""" Cisco_IOS_XR_fib_common_oper 

This module contains a collection of YANG definitions
for Cisco IOS\-XR fib\-common package operational data.

This module contains definitions
for the following management objects\:
  fib\-statistics\: cef interface drops operational data
  fib\: fib
  mpls\-forwarding\: mpls forwarding

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class FibAdjacencyShow(Enum):
    """
    FibAdjacencyShow

    Adjacency types

    .. data:: fib_adjacency_normal = 0

    	Normal adjacency

    .. data:: fib_adjacency_null = 1

    	Null adjacency

    .. data:: fib_adjacency_punt = 2

    	Punt adjacency

    .. data:: fib_adjacency_drop = 3

    	Drop adjacency

    .. data:: fib_adjacency_glean = 4

    	Glean adjacency

    .. data:: fib_adjacency_discard = 5

    	Discard adjacency

    .. data:: fib_adjacency_broadcast = 6

    	Broadcast adjacency

    .. data:: fib_adjacency_external = 7

    	external adjacency

    .. data:: fib_adjacency_lisp = 8

    	LISP adjacency

    .. data:: fib_adjacency_unknown = 9

    	Unknown adjacency

    """

    fib_adjacency_normal = Enum.YLeaf(0, "fib-adjacency-normal")

    fib_adjacency_null = Enum.YLeaf(1, "fib-adjacency-null")

    fib_adjacency_punt = Enum.YLeaf(2, "fib-adjacency-punt")

    fib_adjacency_drop = Enum.YLeaf(3, "fib-adjacency-drop")

    fib_adjacency_glean = Enum.YLeaf(4, "fib-adjacency-glean")

    fib_adjacency_discard = Enum.YLeaf(5, "fib-adjacency-discard")

    fib_adjacency_broadcast = Enum.YLeaf(6, "fib-adjacency-broadcast")

    fib_adjacency_external = Enum.YLeaf(7, "fib-adjacency-external")

    fib_adjacency_lisp = Enum.YLeaf(8, "fib-adjacency-lisp")

    fib_adjacency_unknown = Enum.YLeaf(9, "fib-adjacency-unknown")


class FibFrrProtocolShow(Enum):
    """
    FibFrrProtocolShow

    Fib frr protocol show

    .. data:: frr_protocol_ipv4 = 0

    	frr protocol ipv4

    .. data:: frr_protocol_ipv6 = 1

    	frr protocol ipv6

    .. data:: frr_protocol_mpls = 2

    	frr protocol mpls

    """

    frr_protocol_ipv4 = Enum.YLeaf(0, "frr-protocol-ipv4")

    frr_protocol_ipv6 = Enum.YLeaf(1, "frr-protocol-ipv6")

    frr_protocol_mpls = Enum.YLeaf(2, "frr-protocol-mpls")


class FibLink(Enum):
    """
    FibLink

    Fib link

    .. data:: link_ipv4 = 0

    	IPv4 link protocol

    .. data:: link_ipv6 = 1

    	IPv6 link protocol

    .. data:: link_mpls = 2

    	MPLS link protocol

    """

    link_ipv4 = Enum.YLeaf(0, "link-ipv4")

    link_ipv6 = Enum.YLeaf(1, "link-ipv6")

    link_mpls = Enum.YLeaf(2, "link-mpls")


class FibLoadshareShow(Enum):
    """
    FibLoadshareShow

    Loadsharing type

    .. data:: fib_load_share_none = 0

    	No loadsharing

    .. data:: fib_load_share_per_packet = 1

    	Per packet loadsharing

    .. data:: fib_load_share_dest_sharing = 2

    	Destination loadsharing

    """

    fib_load_share_none = Enum.YLeaf(0, "fib-load-share-none")

    fib_load_share_per_packet = Enum.YLeaf(1, "fib-load-share-per-packet")

    fib_load_share_dest_sharing = Enum.YLeaf(2, "fib-load-share-dest-sharing")


class FibMplsLlcEntryBag(Enum):
    """
    FibMplsLlcEntryBag

    Fib mpls llc entry bag

    .. data:: fib_mpls_llc_bag_type_xc = 1

    	fib mpls llc bag type xc

    .. data:: fib_mpls_llc_bag_type_pfx = 2

    	fib mpls llc bag type pfx

    .. data:: fib_mpls_llc_bag_type_lsm = 3

    	fib mpls llc bag type lsm

    .. data:: fib_mpls_llc_bag_type_max = 4

    	fib mpls llc bag type max

    """

    fib_mpls_llc_bag_type_xc = Enum.YLeaf(1, "fib-mpls-llc-bag-type-xc")

    fib_mpls_llc_bag_type_pfx = Enum.YLeaf(2, "fib-mpls-llc-bag-type-pfx")

    fib_mpls_llc_bag_type_lsm = Enum.YLeaf(3, "fib-mpls-llc-bag-type-lsm")

    fib_mpls_llc_bag_type_max = Enum.YLeaf(4, "fib-mpls-llc-bag-type-max")


class FibNeh(Enum):
    """
    FibNeh

    Fib neh

    .. data:: nh_local = 0

    	nh local

    .. data:: nh_remote = 1

    	nh remote

    .. data:: nh_special = 2

    	nh special

    """

    nh_local = Enum.YLeaf(0, "nh-local")

    nh_remote = Enum.YLeaf(1, "nh-remote")

    nh_special = Enum.YLeaf(2, "nh-special")


class FibNehSpecial(Enum):
    """
    FibNehSpecial

    Fib neh special

    .. data:: nh_not_found = 0

    	nh not found

    .. data:: nh_null0 = 1

    	nh null0

    .. data:: nh_punt = 2

    	nh punt

    .. data:: nh_drop = 3

    	nh drop

    .. data:: nh_glean = 4

    	nh glean

    .. data:: nh_receive = 5

    	nh receive

    .. data:: nh_broadcast = 6

    	nh broadcast

    .. data:: nh_external = 7

    	nh external

    .. data:: nh_lisp = 8

    	nh lisp

    .. data:: nh_lookup = 9

    	nh lookup

    .. data:: nh_max_type = 10

    	nh max type

    """

    nh_not_found = Enum.YLeaf(0, "nh-not-found")

    nh_null0 = Enum.YLeaf(1, "nh-null0")

    nh_punt = Enum.YLeaf(2, "nh-punt")

    nh_drop = Enum.YLeaf(3, "nh-drop")

    nh_glean = Enum.YLeaf(4, "nh-glean")

    nh_receive = Enum.YLeaf(5, "nh-receive")

    nh_broadcast = Enum.YLeaf(6, "nh-broadcast")

    nh_external = Enum.YLeaf(7, "nh-external")

    nh_lisp = Enum.YLeaf(8, "nh-lisp")

    nh_lookup = Enum.YLeaf(9, "nh-lookup")

    nh_max_type = Enum.YLeaf(10, "nh-max-type")


class FibProtocol(Enum):
    """
    FibProtocol

    Fib protocol

    .. data:: ipv4 = 0

    	ipv4 protocol

    .. data:: ipv6 = 1

    	ipv6 protocol

    .. data:: mpls = 2

    	MPLS protocol

    """

    ipv4 = Enum.YLeaf(0, "ipv4")

    ipv6 = Enum.YLeaf(1, "ipv6")

    mpls = Enum.YLeaf(2, "mpls")


class FibRouteSource(Enum):
    """
    FibRouteSource

    Fib route source

    .. data:: lsd = 5

    	LSD

    .. data:: rib = 7

    	RIB

    .. data:: mrib = 13

    	MRIB

    """

    lsd = Enum.YLeaf(5, "lsd")

    rib = Enum.YLeaf(7, "rib")

    mrib = Enum.YLeaf(13, "mrib")


class FibRpfMode(Enum):
    """
    FibRpfMode

    RPF mode types

    .. data:: fib_rpf_mode_strict = 0

    	RPF mode strict

    .. data:: fib_rpf_mode_loose = 1

    	RPF mode loose

    .. data:: fib_rpf_mode_unknown = 2

    	RPF mode unknown

    """

    fib_rpf_mode_strict = Enum.YLeaf(0, "fib-rpf-mode-strict")

    fib_rpf_mode_loose = Enum.YLeaf(1, "fib-rpf-mode-loose")

    fib_rpf_mode_unknown = Enum.YLeaf(2, "fib-rpf-mode-unknown")


class FibShIpencapHdr(Enum):
    """
    FibShIpencapHdr

    IP Encap Header Type

    .. data:: fib_sh_ip_encap_none = 0

    	No Header

    .. data:: fib_sh_ip_encap_ip4 = 1

    	IPv4 Header

    .. data:: fib_sh_ip_encap_ip6 = 2

    	IPv6 Header

    .. data:: fib_sh_ip_encap_udp = 3

    	UDP Header

    .. data:: fib_sh_ip_encap_lisp = 4

    	Lisp Header

    """

    fib_sh_ip_encap_none = Enum.YLeaf(0, "fib-sh-ip-encap-none")

    fib_sh_ip_encap_ip4 = Enum.YLeaf(1, "fib-sh-ip-encap-ip4")

    fib_sh_ip_encap_ip6 = Enum.YLeaf(2, "fib-sh-ip-encap-ip6")

    fib_sh_ip_encap_udp = Enum.YLeaf(3, "fib-sh-ip-encap-udp")

    fib_sh_ip_encap_lisp = Enum.YLeaf(4, "fib-sh-ip-encap-lisp")


class FibShTblFibExtBag(Enum):
    """
    FibShTblFibExtBag

    Fib sh tbl fib ext bag

    .. data:: leaf_extension = 1

    	Leaf Extension

    """

    leaf_extension = Enum.YLeaf(1, "leaf-extension")


class FibUpdatePathLfaProtection(Enum):
    """
    FibUpdatePathLfaProtection

    LFA protection type

    .. data:: not_lfa_protected = 0

    	Not LFA-protected

    .. data:: local_lfa_protected = 1

    	Local-LFA protected

    .. data:: remote_lfa_protected = 2

    	Remote-LFA protected

    .. data:: ti_lfa_protected = 3

    	TI-LFA protected

    """

    not_lfa_protected = Enum.YLeaf(0, "not-lfa-protected")

    local_lfa_protected = Enum.YLeaf(1, "local-lfa-protected")

    remote_lfa_protected = Enum.YLeaf(2, "remote-lfa-protected")

    ti_lfa_protected = Enum.YLeaf(3, "ti-lfa-protected")


class FibafiProto(Enum):
    """
    FibafiProto

    Fibafi proto

    .. data:: ipv4 = 0

    	ipv4 protocol

    .. data:: ipv4_mpls = 1

    	ipv4 mpls protocol

    .. data:: ipv6 = 2

    	ipv6 protocol

    .. data:: ipv6_mpls = 3

    	ipv6 mpls protocol

    """

    ipv4 = Enum.YLeaf(0, "ipv4")

    ipv4_mpls = Enum.YLeaf(1, "ipv4-mpls")

    ipv6 = Enum.YLeaf(2, "ipv6")

    ipv6_mpls = Enum.YLeaf(3, "ipv6-mpls")


class FibidbOper(Enum):
    """
    FibidbOper

    Fibidb oper

    .. data:: fibidb_none = 0

    	fibidb none

    .. data:: fibidb_create = 1

    	fibidb create

    .. data:: fibidb_delete = 2

    	fibidb delete

    .. data:: fibidb_modify = 3

    	fibidb modify

    .. data:: fibidb_max = 4

    	fibidb max

    """

    fibidb_none = Enum.YLeaf(0, "fibidb-none")

    fibidb_create = Enum.YLeaf(1, "fibidb-create")

    fibidb_delete = Enum.YLeaf(2, "fibidb-delete")

    fibidb_modify = Enum.YLeaf(3, "fibidb-modify")

    fibidb_max = Enum.YLeaf(4, "fibidb-max")


class FibllcEntry(Enum):
    """
    FibllcEntry

    Fibllc entry

    .. data:: xc = 1

    	LabelXconnect

    .. data:: pfx = 2

    	IPPrefix

    """

    xc = Enum.YLeaf(1, "xc")

    pfx = Enum.YLeaf(2, "pfx")


class MgmtFibMplsFrrState(Enum):
    """
    MgmtFibMplsFrrState

    MPLS FRR entry state

    .. data:: partial = 0

    	Partial

    .. data:: active = 1

    	Active

    .. data:: ready = 2

    	Ready

    .. data:: complete = 3

    	Complete

    .. data:: any = 4

    	Any

    """

    partial = Enum.YLeaf(0, "partial")

    active = Enum.YLeaf(1, "active")

    ready = Enum.YLeaf(2, "ready")

    complete = Enum.YLeaf(3, "complete")

    any = Enum.YLeaf(4, "any")


class MgmtFibMplsLspRole(Enum):
    """
    MgmtFibMplsLspRole

    MPLS FRR entry role

    .. data:: head = 0

    	Head

    .. data:: midpoint = 1

    	Midpoint

    """

    head = Enum.YLeaf(0, "head")

    midpoint = Enum.YLeaf(1, "midpoint")


class Mplseos(Enum):
    """
    Mplseos

    Mplseos

    .. data:: eos0 = 0

    	EOS Disable

    .. data:: eos1 = 1

    	EOS Enable

    """

    eos0 = Enum.YLeaf(0, "eos0")

    eos1 = Enum.YLeaf(1, "eos1")


class NextHop(Enum):
    """
    NextHop

    MPLS Forwarding Next Hop Type

    .. data:: tx = 0

    	TX

    .. data:: rx = 1

    	RX

    .. data:: special = 2

    	Special

    """

    tx = Enum.YLeaf(0, "tx")

    rx = Enum.YLeaf(1, "rx")

    special = Enum.YLeaf(2, "special")


class Proto(Enum):
    """
    Proto

    MPLS Forwarding Protocol Type

    .. data:: ipv4 = 0

    	IPv4

    .. data:: ipv6 = 1

    	IPv6

    .. data:: mpls = 2

    	MPLS

    """

    ipv4 = Enum.YLeaf(0, "ipv4")

    ipv6 = Enum.YLeaf(1, "ipv6")

    mpls = Enum.YLeaf(2, "mpls")


class SsLbaState(Enum):
    """
    SsLbaState

    Load Balance config

    .. data:: l3 = 0

    	L3 Load Balance config

    .. data:: l4 = 1

    	L4 Load Balance config

    """

    l3 = Enum.YLeaf(0, "l3")

    l4 = Enum.YLeaf(1, "l4")



class FibStatistics(Entity):
    """
    cef interface drops operational data
    
    .. attribute:: nodes
    
    	List of nodes
    	**type**\:   :py:class:`Nodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibStatistics.Nodes>`
    
    

    """

    _prefix = 'fib-common-oper'
    _revision = '2017-01-20'

    def __init__(self):
        super(FibStatistics, self).__init__()
        self._top_entity = None

        self.yang_name = "fib-statistics"
        self.yang_parent_name = "Cisco-IOS-XR-fib-common-oper"

        self.nodes = FibStatistics.Nodes()
        self.nodes.parent = self
        self._children_name_map["nodes"] = "nodes"
        self._children_yang_names.add("nodes")


    class Nodes(Entity):
        """
        List of nodes
        
        .. attribute:: node
        
        	Specific node operational data
        	**type**\: list of    :py:class:`Node <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibStatistics.Nodes.Node>`
        
        

        """

        _prefix = 'fib-common-oper'
        _revision = '2017-01-20'

        def __init__(self):
            super(FibStatistics.Nodes, self).__init__()

            self.yang_name = "nodes"
            self.yang_parent_name = "fib-statistics"

            self.node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(FibStatistics.Nodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(FibStatistics.Nodes, self).__setattr__(name, value)


        class Node(Entity):
            """
            Specific node operational data
            
            .. attribute:: node_name  <key>
            
            	Node name
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: drops
            
            	Specific node drops
            	**type**\:   :py:class:`Drops <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibStatistics.Nodes.Node.Drops>`
            
            

            """

            _prefix = 'fib-common-oper'
            _revision = '2017-01-20'

            def __init__(self):
                super(FibStatistics.Nodes.Node, self).__init__()

                self.yang_name = "node"
                self.yang_parent_name = "nodes"

                self.node_name = YLeaf(YType.str, "node-name")

                self.drops = FibStatistics.Nodes.Node.Drops()
                self.drops.parent = self
                self._children_name_map["drops"] = "drops"
                self._children_yang_names.add("drops")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(FibStatistics.Nodes.Node, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(FibStatistics.Nodes.Node, self).__setattr__(name, value)


            class Drops(Entity):
                """
                Specific node drops
                
                .. attribute:: acl_in_rpf_packets
                
                	ACL in RPF pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: checksum_error_packets
                
                	checksum error pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: df_unreachable_packets
                
                	DF unreachable pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: discard_packets
                
                	discard pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: encapsulation_failure_packets
                
                	encapsulation failure pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: fragmenation_consumed_packets
                
                	frag consumed packet pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: fragmenation_failure_packets
                
                	fragmenation failure pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: gre_error_drop
                
                	GRE processing errors
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: gre_lookup_failed_drop
                
                	GRE tunnel lookup failed drop pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: incomplete_adjacency_packets
                
                	incomplete adjacency pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: lisp_decap_error_drops
                
                	Lisp decap error drops
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: lisp_encap_error_drops
                
                	Lisp encap error drops
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: lisp_punt_drops
                
                	LISP Punt drops
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: mpls_disabled_interface
                
                	mpls disabled in interface
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: multi_label_drops
                
                	Drops for the packets with multi[le labels
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: no_route_packets
                
                	no route pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: null_packets
                
                	null0 pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: punt_unreachable_packets
                
                	Punt generate unreach pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: rp_destination_drop_packets
                
                	rp dest drop pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: rpf_check_failure_packets
                
                	RPF check failures pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: total_number_of_drop_packets
                
                	the total number of drop pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: unresolved_prefix_packets
                
                	unresolved prefix pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: unsupported_feature_packets
                
                	unsupported feature pkt
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                

                """

                _prefix = 'fib-common-oper'
                _revision = '2017-01-20'

                def __init__(self):
                    super(FibStatistics.Nodes.Node.Drops, self).__init__()

                    self.yang_name = "drops"
                    self.yang_parent_name = "node"

                    self.acl_in_rpf_packets = YLeaf(YType.uint64, "acl-in-rpf-packets")

                    self.checksum_error_packets = YLeaf(YType.uint64, "checksum-error-packets")

                    self.df_unreachable_packets = YLeaf(YType.uint64, "df-unreachable-packets")

                    self.discard_packets = YLeaf(YType.uint64, "discard-packets")

                    self.encapsulation_failure_packets = YLeaf(YType.uint64, "encapsulation-failure-packets")

                    self.fragmenation_consumed_packets = YLeaf(YType.uint64, "fragmenation-consumed-packets")

                    self.fragmenation_failure_packets = YLeaf(YType.uint64, "fragmenation-failure-packets")

                    self.gre_error_drop = YLeaf(YType.uint64, "gre-error-drop")

                    self.gre_lookup_failed_drop = YLeaf(YType.uint64, "gre-lookup-failed-drop")

                    self.incomplete_adjacency_packets = YLeaf(YType.uint64, "incomplete-adjacency-packets")

                    self.lisp_decap_error_drops = YLeaf(YType.uint64, "lisp-decap-error-drops")

                    self.lisp_encap_error_drops = YLeaf(YType.uint64, "lisp-encap-error-drops")

                    self.lisp_punt_drops = YLeaf(YType.uint64, "lisp-punt-drops")

                    self.mpls_disabled_interface = YLeaf(YType.uint64, "mpls-disabled-interface")

                    self.multi_label_drops = YLeaf(YType.uint64, "multi-label-drops")

                    self.no_route_packets = YLeaf(YType.uint64, "no-route-packets")

                    self.null_packets = YLeaf(YType.uint64, "null-packets")

                    self.punt_unreachable_packets = YLeaf(YType.uint64, "punt-unreachable-packets")

                    self.rp_destination_drop_packets = YLeaf(YType.uint64, "rp-destination-drop-packets")

                    self.rpf_check_failure_packets = YLeaf(YType.uint64, "rpf-check-failure-packets")

                    self.total_number_of_drop_packets = YLeaf(YType.uint64, "total-number-of-drop-packets")

                    self.unresolved_prefix_packets = YLeaf(YType.uint64, "unresolved-prefix-packets")

                    self.unsupported_feature_packets = YLeaf(YType.uint64, "unsupported-feature-packets")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("acl_in_rpf_packets",
                                    "checksum_error_packets",
                                    "df_unreachable_packets",
                                    "discard_packets",
                                    "encapsulation_failure_packets",
                                    "fragmenation_consumed_packets",
                                    "fragmenation_failure_packets",
                                    "gre_error_drop",
                                    "gre_lookup_failed_drop",
                                    "incomplete_adjacency_packets",
                                    "lisp_decap_error_drops",
                                    "lisp_encap_error_drops",
                                    "lisp_punt_drops",
                                    "mpls_disabled_interface",
                                    "multi_label_drops",
                                    "no_route_packets",
                                    "null_packets",
                                    "punt_unreachable_packets",
                                    "rp_destination_drop_packets",
                                    "rpf_check_failure_packets",
                                    "total_number_of_drop_packets",
                                    "unresolved_prefix_packets",
                                    "unsupported_feature_packets") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(FibStatistics.Nodes.Node.Drops, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(FibStatistics.Nodes.Node.Drops, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.acl_in_rpf_packets.is_set or
                        self.checksum_error_packets.is_set or
                        self.df_unreachable_packets.is_set or
                        self.discard_packets.is_set or
                        self.encapsulation_failure_packets.is_set or
                        self.fragmenation_consumed_packets.is_set or
                        self.fragmenation_failure_packets.is_set or
                        self.gre_error_drop.is_set or
                        self.gre_lookup_failed_drop.is_set or
                        self.incomplete_adjacency_packets.is_set or
                        self.lisp_decap_error_drops.is_set or
                        self.lisp_encap_error_drops.is_set or
                        self.lisp_punt_drops.is_set or
                        self.mpls_disabled_interface.is_set or
                        self.multi_label_drops.is_set or
                        self.no_route_packets.is_set or
                        self.null_packets.is_set or
                        self.punt_unreachable_packets.is_set or
                        self.rp_destination_drop_packets.is_set or
                        self.rpf_check_failure_packets.is_set or
                        self.total_number_of_drop_packets.is_set or
                        self.unresolved_prefix_packets.is_set or
                        self.unsupported_feature_packets.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.acl_in_rpf_packets.yfilter != YFilter.not_set or
                        self.checksum_error_packets.yfilter != YFilter.not_set or
                        self.df_unreachable_packets.yfilter != YFilter.not_set or
                        self.discard_packets.yfilter != YFilter.not_set or
                        self.encapsulation_failure_packets.yfilter != YFilter.not_set or
                        self.fragmenation_consumed_packets.yfilter != YFilter.not_set or
                        self.fragmenation_failure_packets.yfilter != YFilter.not_set or
                        self.gre_error_drop.yfilter != YFilter.not_set or
                        self.gre_lookup_failed_drop.yfilter != YFilter.not_set or
                        self.incomplete_adjacency_packets.yfilter != YFilter.not_set or
                        self.lisp_decap_error_drops.yfilter != YFilter.not_set or
                        self.lisp_encap_error_drops.yfilter != YFilter.not_set or
                        self.lisp_punt_drops.yfilter != YFilter.not_set or
                        self.mpls_disabled_interface.yfilter != YFilter.not_set or
                        self.multi_label_drops.yfilter != YFilter.not_set or
                        self.no_route_packets.yfilter != YFilter.not_set or
                        self.null_packets.yfilter != YFilter.not_set or
                        self.punt_unreachable_packets.yfilter != YFilter.not_set or
                        self.rp_destination_drop_packets.yfilter != YFilter.not_set or
                        self.rpf_check_failure_packets.yfilter != YFilter.not_set or
                        self.total_number_of_drop_packets.yfilter != YFilter.not_set or
                        self.unresolved_prefix_packets.yfilter != YFilter.not_set or
                        self.unsupported_feature_packets.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "drops" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.acl_in_rpf_packets.is_set or self.acl_in_rpf_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.acl_in_rpf_packets.get_name_leafdata())
                    if (self.checksum_error_packets.is_set or self.checksum_error_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.checksum_error_packets.get_name_leafdata())
                    if (self.df_unreachable_packets.is_set or self.df_unreachable_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.df_unreachable_packets.get_name_leafdata())
                    if (self.discard_packets.is_set or self.discard_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.discard_packets.get_name_leafdata())
                    if (self.encapsulation_failure_packets.is_set or self.encapsulation_failure_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.encapsulation_failure_packets.get_name_leafdata())
                    if (self.fragmenation_consumed_packets.is_set or self.fragmenation_consumed_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fragmenation_consumed_packets.get_name_leafdata())
                    if (self.fragmenation_failure_packets.is_set or self.fragmenation_failure_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fragmenation_failure_packets.get_name_leafdata())
                    if (self.gre_error_drop.is_set or self.gre_error_drop.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.gre_error_drop.get_name_leafdata())
                    if (self.gre_lookup_failed_drop.is_set or self.gre_lookup_failed_drop.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.gre_lookup_failed_drop.get_name_leafdata())
                    if (self.incomplete_adjacency_packets.is_set or self.incomplete_adjacency_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.incomplete_adjacency_packets.get_name_leafdata())
                    if (self.lisp_decap_error_drops.is_set or self.lisp_decap_error_drops.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lisp_decap_error_drops.get_name_leafdata())
                    if (self.lisp_encap_error_drops.is_set or self.lisp_encap_error_drops.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lisp_encap_error_drops.get_name_leafdata())
                    if (self.lisp_punt_drops.is_set or self.lisp_punt_drops.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lisp_punt_drops.get_name_leafdata())
                    if (self.mpls_disabled_interface.is_set or self.mpls_disabled_interface.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mpls_disabled_interface.get_name_leafdata())
                    if (self.multi_label_drops.is_set or self.multi_label_drops.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.multi_label_drops.get_name_leafdata())
                    if (self.no_route_packets.is_set or self.no_route_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.no_route_packets.get_name_leafdata())
                    if (self.null_packets.is_set or self.null_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.null_packets.get_name_leafdata())
                    if (self.punt_unreachable_packets.is_set or self.punt_unreachable_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.punt_unreachable_packets.get_name_leafdata())
                    if (self.rp_destination_drop_packets.is_set or self.rp_destination_drop_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rp_destination_drop_packets.get_name_leafdata())
                    if (self.rpf_check_failure_packets.is_set or self.rpf_check_failure_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.rpf_check_failure_packets.get_name_leafdata())
                    if (self.total_number_of_drop_packets.is_set or self.total_number_of_drop_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_number_of_drop_packets.get_name_leafdata())
                    if (self.unresolved_prefix_packets.is_set or self.unresolved_prefix_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unresolved_prefix_packets.get_name_leafdata())
                    if (self.unsupported_feature_packets.is_set or self.unsupported_feature_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unsupported_feature_packets.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "acl-in-rpf-packets" or name == "checksum-error-packets" or name == "df-unreachable-packets" or name == "discard-packets" or name == "encapsulation-failure-packets" or name == "fragmenation-consumed-packets" or name == "fragmenation-failure-packets" or name == "gre-error-drop" or name == "gre-lookup-failed-drop" or name == "incomplete-adjacency-packets" or name == "lisp-decap-error-drops" or name == "lisp-encap-error-drops" or name == "lisp-punt-drops" or name == "mpls-disabled-interface" or name == "multi-label-drops" or name == "no-route-packets" or name == "null-packets" or name == "punt-unreachable-packets" or name == "rp-destination-drop-packets" or name == "rpf-check-failure-packets" or name == "total-number-of-drop-packets" or name == "unresolved-prefix-packets" or name == "unsupported-feature-packets"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "acl-in-rpf-packets"):
                        self.acl_in_rpf_packets = value
                        self.acl_in_rpf_packets.value_namespace = name_space
                        self.acl_in_rpf_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "checksum-error-packets"):
                        self.checksum_error_packets = value
                        self.checksum_error_packets.value_namespace = name_space
                        self.checksum_error_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "df-unreachable-packets"):
                        self.df_unreachable_packets = value
                        self.df_unreachable_packets.value_namespace = name_space
                        self.df_unreachable_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "discard-packets"):
                        self.discard_packets = value
                        self.discard_packets.value_namespace = name_space
                        self.discard_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "encapsulation-failure-packets"):
                        self.encapsulation_failure_packets = value
                        self.encapsulation_failure_packets.value_namespace = name_space
                        self.encapsulation_failure_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "fragmenation-consumed-packets"):
                        self.fragmenation_consumed_packets = value
                        self.fragmenation_consumed_packets.value_namespace = name_space
                        self.fragmenation_consumed_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "fragmenation-failure-packets"):
                        self.fragmenation_failure_packets = value
                        self.fragmenation_failure_packets.value_namespace = name_space
                        self.fragmenation_failure_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "gre-error-drop"):
                        self.gre_error_drop = value
                        self.gre_error_drop.value_namespace = name_space
                        self.gre_error_drop.value_namespace_prefix = name_space_prefix
                    if(value_path == "gre-lookup-failed-drop"):
                        self.gre_lookup_failed_drop = value
                        self.gre_lookup_failed_drop.value_namespace = name_space
                        self.gre_lookup_failed_drop.value_namespace_prefix = name_space_prefix
                    if(value_path == "incomplete-adjacency-packets"):
                        self.incomplete_adjacency_packets = value
                        self.incomplete_adjacency_packets.value_namespace = name_space
                        self.incomplete_adjacency_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "lisp-decap-error-drops"):
                        self.lisp_decap_error_drops = value
                        self.lisp_decap_error_drops.value_namespace = name_space
                        self.lisp_decap_error_drops.value_namespace_prefix = name_space_prefix
                    if(value_path == "lisp-encap-error-drops"):
                        self.lisp_encap_error_drops = value
                        self.lisp_encap_error_drops.value_namespace = name_space
                        self.lisp_encap_error_drops.value_namespace_prefix = name_space_prefix
                    if(value_path == "lisp-punt-drops"):
                        self.lisp_punt_drops = value
                        self.lisp_punt_drops.value_namespace = name_space
                        self.lisp_punt_drops.value_namespace_prefix = name_space_prefix
                    if(value_path == "mpls-disabled-interface"):
                        self.mpls_disabled_interface = value
                        self.mpls_disabled_interface.value_namespace = name_space
                        self.mpls_disabled_interface.value_namespace_prefix = name_space_prefix
                    if(value_path == "multi-label-drops"):
                        self.multi_label_drops = value
                        self.multi_label_drops.value_namespace = name_space
                        self.multi_label_drops.value_namespace_prefix = name_space_prefix
                    if(value_path == "no-route-packets"):
                        self.no_route_packets = value
                        self.no_route_packets.value_namespace = name_space
                        self.no_route_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "null-packets"):
                        self.null_packets = value
                        self.null_packets.value_namespace = name_space
                        self.null_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "punt-unreachable-packets"):
                        self.punt_unreachable_packets = value
                        self.punt_unreachable_packets.value_namespace = name_space
                        self.punt_unreachable_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "rp-destination-drop-packets"):
                        self.rp_destination_drop_packets = value
                        self.rp_destination_drop_packets.value_namespace = name_space
                        self.rp_destination_drop_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "rpf-check-failure-packets"):
                        self.rpf_check_failure_packets = value
                        self.rpf_check_failure_packets.value_namespace = name_space
                        self.rpf_check_failure_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-number-of-drop-packets"):
                        self.total_number_of_drop_packets = value
                        self.total_number_of_drop_packets.value_namespace = name_space
                        self.total_number_of_drop_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "unresolved-prefix-packets"):
                        self.unresolved_prefix_packets = value
                        self.unresolved_prefix_packets.value_namespace = name_space
                        self.unresolved_prefix_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "unsupported-feature-packets"):
                        self.unsupported_feature_packets = value
                        self.unsupported_feature_packets.value_namespace = name_space
                        self.unsupported_feature_packets.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.node_name.is_set or
                    (self.drops is not None and self.drops.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_name.yfilter != YFilter.not_set or
                    (self.drops is not None and self.drops.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node" + "[node-name='" + self.node_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-fib-common-oper:fib-statistics/nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "drops"):
                    if (self.drops is None):
                        self.drops = FibStatistics.Nodes.Node.Drops()
                        self.drops.parent = self
                        self._children_name_map["drops"] = "drops"
                    return self.drops

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "drops" or name == "node-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-name"):
                    self.node_name = value
                    self.node_name.value_namespace = name_space
                    self.node_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-fib-common-oper:fib-statistics/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node"):
                for c in self.node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = FibStatistics.Nodes.Node()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (self.nodes is not None and self.nodes.has_data())

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.nodes is not None and self.nodes.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-fib-common-oper:fib-statistics" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "nodes"):
            if (self.nodes is None):
                self.nodes = FibStatistics.Nodes()
                self.nodes.parent = self
                self._children_name_map["nodes"] = "nodes"
            return self.nodes

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "nodes"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = FibStatistics()
        return self._top_entity

class Fib(Entity):
    """
    fib
    
    .. attribute:: nodes
    
    	Table of nodes
    	**type**\:   :py:class:`Nodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes>`
    
    

    """

    _prefix = 'fib-common-oper'
    _revision = '2017-01-20'

    def __init__(self):
        super(Fib, self).__init__()
        self._top_entity = None

        self.yang_name = "fib"
        self.yang_parent_name = "Cisco-IOS-XR-fib-common-oper"

        self.nodes = Fib.Nodes()
        self.nodes.parent = self
        self._children_name_map["nodes"] = "nodes"
        self._children_yang_names.add("nodes")


    class Nodes(Entity):
        """
        Table of nodes
        
        .. attribute:: node
        
        	Operational data for a specific Node
        	**type**\: list of    :py:class:`Node <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node>`
        
        

        """

        _prefix = 'fib-common-oper'
        _revision = '2017-01-20'

        def __init__(self):
            super(Fib.Nodes, self).__init__()

            self.yang_name = "nodes"
            self.yang_parent_name = "fib"

            self.node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Fib.Nodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Fib.Nodes, self).__setattr__(name, value)


        class Node(Entity):
            """
            Operational data for a specific Node
            
            .. attribute:: node_name  <key>
            
            	Node name
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: global_
            
            	FIB Global info
            	**type**\:   :py:class:`Global_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_>`
            
            .. attribute:: protocols
            
            	Protocol table
            	**type**\:   :py:class:`Protocols <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols>`
            
            

            """

            _prefix = 'fib-common-oper'
            _revision = '2017-01-20'

            def __init__(self):
                super(Fib.Nodes.Node, self).__init__()

                self.yang_name = "node"
                self.yang_parent_name = "nodes"

                self.node_name = YLeaf(YType.str, "node-name")

                self.global_ = Fib.Nodes.Node.Global_()
                self.global_.parent = self
                self._children_name_map["global_"] = "global"
                self._children_yang_names.add("global")

                self.protocols = Fib.Nodes.Node.Protocols()
                self.protocols.parent = self
                self._children_name_map["protocols"] = "protocols"
                self._children_yang_names.add("protocols")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Fib.Nodes.Node, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Fib.Nodes.Node, self).__setattr__(name, value)


            class Global_(Entity):
                """
                FIB Global info
                
                .. attribute:: object_history
                
                	Object History
                	**type**\:   :py:class:`ObjectHistory <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.ObjectHistory>`
                
                .. attribute:: summary
                
                	Global Summary
                	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary>`
                
                

                """

                _prefix = 'fib-common-oper'
                _revision = '2017-01-20'

                def __init__(self):
                    super(Fib.Nodes.Node.Global_, self).__init__()

                    self.yang_name = "global"
                    self.yang_parent_name = "node"

                    self.object_history = Fib.Nodes.Node.Global_.ObjectHistory()
                    self.object_history.parent = self
                    self._children_name_map["object_history"] = "object-history"
                    self._children_yang_names.add("object-history")

                    self.summary = Fib.Nodes.Node.Global_.Summary()
                    self.summary.parent = self
                    self._children_name_map["summary"] = "summary"
                    self._children_yang_names.add("summary")


                class Summary(Entity):
                    """
                    Global Summary
                    
                    .. attribute:: protos
                    
                    	Proto Table
                    	**type**\:   :py:class:`Protos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Protos>`
                    
                    .. attribute:: total
                    
                    	Display total counters and common info
                    	**type**\:   :py:class:`Total <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Total>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(Fib.Nodes.Node.Global_.Summary, self).__init__()

                        self.yang_name = "summary"
                        self.yang_parent_name = "global"

                        self.protos = Fib.Nodes.Node.Global_.Summary.Protos()
                        self.protos.parent = self
                        self._children_name_map["protos"] = "protos"
                        self._children_yang_names.add("protos")

                        self.total = Fib.Nodes.Node.Global_.Summary.Total()
                        self.total.parent = self
                        self._children_name_map["total"] = "total"
                        self._children_yang_names.add("total")


                    class Total(Entity):
                        """
                        Display total counters and common info
                        
                        .. attribute:: common_info
                        
                        	Common info
                        	**type**\:   :py:class:`CommonInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Total.CommonInfo>`
                        
                        .. attribute:: total_counters
                        
                        	Aggregate counters of all protocols
                        	**type**\:   :py:class:`TotalCounters <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Total.TotalCounters>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Global_.Summary.Total, self).__init__()

                            self.yang_name = "total"
                            self.yang_parent_name = "summary"

                            self.common_info = Fib.Nodes.Node.Global_.Summary.Total.CommonInfo()
                            self.common_info.parent = self
                            self._children_name_map["common_info"] = "common-info"
                            self._children_yang_names.add("common-info")

                            self.total_counters = Fib.Nodes.Node.Global_.Summary.Total.TotalCounters()
                            self.total_counters.parent = self
                            self._children_name_map["total_counters"] = "total-counters"
                            self._children_yang_names.add("total-counters")


                        class CommonInfo(Entity):
                            """
                            Common info
                            
                            .. attribute:: count
                            
                            	Placeholder for common info counts
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Global_.Summary.Total.CommonInfo, self).__init__()

                                self.yang_name = "common-info"
                                self.yang_parent_name = "total"

                                self.count = YLeaf(YType.uint32, "count")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Global_.Summary.Total.CommonInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Global_.Summary.Total.CommonInfo, self).__setattr__(name, value)

                            def has_data(self):
                                return self.count.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.count.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "common-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.count.is_set or self.count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "count"):
                                    self.count = value
                                    self.count.value_namespace = name_space
                                    self.count.value_namespace_prefix = name_space_prefix


                        class TotalCounters(Entity):
                            """
                            Aggregate counters of all protocols
                            
                            .. attribute:: array_number_of_object
                            
                            	total number of objects
                            	**type**\: list of    :py:class:`ArrayNumberOfObject <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfObject>`
                            
                            .. attribute:: array_number_of_retry
                            
                            	number of objects in retry db
                            	**type**\: list of    :py:class:`ArrayNumberOfRetry <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfRetry>`
                            
                            .. attribute:: num_retry_ojbects
                            
                            	number of elements in retry db
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: num_retry_timeouts
                            
                            	number of retry timeouts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Global_.Summary.Total.TotalCounters, self).__init__()

                                self.yang_name = "total-counters"
                                self.yang_parent_name = "total"

                                self.num_retry_ojbects = YLeaf(YType.uint32, "num-retry-ojbects")

                                self.num_retry_timeouts = YLeaf(YType.uint64, "num-retry-timeouts")

                                self.array_number_of_object = YList(self)
                                self.array_number_of_retry = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("num_retry_ojbects",
                                                "num_retry_timeouts") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Global_.Summary.Total.TotalCounters, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Global_.Summary.Total.TotalCounters, self).__setattr__(name, value)


                            class ArrayNumberOfRetry(Entity):
                                """
                                number of objects in retry db
                                
                                .. attribute:: num_retries
                                
                                	number of elements for this obj type in retry db
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: retry_object_type
                                
                                	retry object
                                	**type**\:  str
                                
                                	**length:** 0..30
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfRetry, self).__init__()

                                    self.yang_name = "array-number-of-retry"
                                    self.yang_parent_name = "total-counters"

                                    self.num_retries = YLeaf(YType.uint64, "num-retries")

                                    self.retry_object_type = YLeaf(YType.str, "retry-object-type")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("num_retries",
                                                    "retry_object_type") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfRetry, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfRetry, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.num_retries.is_set or
                                        self.retry_object_type.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.num_retries.yfilter != YFilter.not_set or
                                        self.retry_object_type.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "array-number-of-retry" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.num_retries.is_set or self.num_retries.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.num_retries.get_name_leafdata())
                                    if (self.retry_object_type.is_set or self.retry_object_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retry_object_type.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "num-retries" or name == "retry-object-type"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "num-retries"):
                                        self.num_retries = value
                                        self.num_retries.value_namespace = name_space
                                        self.num_retries.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retry-object-type"):
                                        self.retry_object_type = value
                                        self.retry_object_type.value_namespace = name_space
                                        self.retry_object_type.value_namespace_prefix = name_space_prefix


                            class ArrayNumberOfObject(Entity):
                                """
                                total number of objects
                                
                                .. attribute:: num_objects
                                
                                	number of elements for this obj type
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: object_type
                                
                                	object
                                	**type**\:  str
                                
                                	**length:** 0..30
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfObject, self).__init__()

                                    self.yang_name = "array-number-of-object"
                                    self.yang_parent_name = "total-counters"

                                    self.num_objects = YLeaf(YType.uint32, "num-objects")

                                    self.object_type = YLeaf(YType.str, "object-type")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("num_objects",
                                                    "object_type") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfObject, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfObject, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.num_objects.is_set or
                                        self.object_type.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.num_objects.yfilter != YFilter.not_set or
                                        self.object_type.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "array-number-of-object" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.num_objects.is_set or self.num_objects.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.num_objects.get_name_leafdata())
                                    if (self.object_type.is_set or self.object_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.object_type.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "num-objects" or name == "object-type"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "num-objects"):
                                        self.num_objects = value
                                        self.num_objects.value_namespace = name_space
                                        self.num_objects.value_namespace_prefix = name_space_prefix
                                    if(value_path == "object-type"):
                                        self.object_type = value
                                        self.object_type.value_namespace = name_space
                                        self.object_type.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.array_number_of_object:
                                    if (c.has_data()):
                                        return True
                                for c in self.array_number_of_retry:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.num_retry_ojbects.is_set or
                                    self.num_retry_timeouts.is_set)

                            def has_operation(self):
                                for c in self.array_number_of_object:
                                    if (c.has_operation()):
                                        return True
                                for c in self.array_number_of_retry:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.num_retry_ojbects.yfilter != YFilter.not_set or
                                    self.num_retry_timeouts.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "total-counters" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.num_retry_ojbects.is_set or self.num_retry_ojbects.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.num_retry_ojbects.get_name_leafdata())
                                if (self.num_retry_timeouts.is_set or self.num_retry_timeouts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.num_retry_timeouts.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "array-number-of-object"):
                                    for c in self.array_number_of_object:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfObject()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.array_number_of_object.append(c)
                                    return c

                                if (child_yang_name == "array-number-of-retry"):
                                    for c in self.array_number_of_retry:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Global_.Summary.Total.TotalCounters.ArrayNumberOfRetry()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.array_number_of_retry.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "array-number-of-object" or name == "array-number-of-retry" or name == "num-retry-ojbects" or name == "num-retry-timeouts"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "num-retry-ojbects"):
                                    self.num_retry_ojbects = value
                                    self.num_retry_ojbects.value_namespace = name_space
                                    self.num_retry_ojbects.value_namespace_prefix = name_space_prefix
                                if(value_path == "num-retry-timeouts"):
                                    self.num_retry_timeouts = value
                                    self.num_retry_timeouts.value_namespace = name_space
                                    self.num_retry_timeouts.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.common_info is not None and self.common_info.has_data()) or
                                (self.total_counters is not None and self.total_counters.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.common_info is not None and self.common_info.has_operation()) or
                                (self.total_counters is not None and self.total_counters.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "total" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "common-info"):
                                if (self.common_info is None):
                                    self.common_info = Fib.Nodes.Node.Global_.Summary.Total.CommonInfo()
                                    self.common_info.parent = self
                                    self._children_name_map["common_info"] = "common-info"
                                return self.common_info

                            if (child_yang_name == "total-counters"):
                                if (self.total_counters is None):
                                    self.total_counters = Fib.Nodes.Node.Global_.Summary.Total.TotalCounters()
                                    self.total_counters.parent = self
                                    self._children_name_map["total_counters"] = "total-counters"
                                return self.total_counters

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "common-info" or name == "total-counters"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Protos(Entity):
                        """
                        Proto Table
                        
                        .. attribute:: proto
                        
                        	Proto Table entry
                        	**type**\: list of    :py:class:`Proto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Protos.Proto>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Global_.Summary.Protos, self).__init__()

                            self.yang_name = "protos"
                            self.yang_parent_name = "summary"

                            self.proto = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Fib.Nodes.Node.Global_.Summary.Protos, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Fib.Nodes.Node.Global_.Summary.Protos, self).__setattr__(name, value)


                        class Proto(Entity):
                            """
                            Proto Table entry
                            
                            .. attribute:: protocol_name  <key>
                            
                            	Protocol Name
                            	**type**\:   :py:class:`FibafiProto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibafiProto>`
                            
                            .. attribute:: common_info
                            
                            	Common Info
                            	**type**\:   :py:class:`CommonInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Protos.Proto.CommonInfo>`
                            
                            .. attribute:: summary
                            
                            	Global summary
                            	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary>`
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Global_.Summary.Protos.Proto, self).__init__()

                                self.yang_name = "proto"
                                self.yang_parent_name = "protos"

                                self.protocol_name = YLeaf(YType.enumeration, "protocol-name")

                                self.common_info = Fib.Nodes.Node.Global_.Summary.Protos.Proto.CommonInfo()
                                self.common_info.parent = self
                                self._children_name_map["common_info"] = "common-info"
                                self._children_yang_names.add("common-info")

                                self.summary = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary()
                                self.summary.parent = self
                                self._children_name_map["summary"] = "summary"
                                self._children_yang_names.add("summary")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("protocol_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Global_.Summary.Protos.Proto, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Global_.Summary.Protos.Proto, self).__setattr__(name, value)


                            class CommonInfo(Entity):
                                """
                                Common Info
                                
                                .. attribute:: count
                                
                                	Placeholder for common info counts
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.CommonInfo, self).__init__()

                                    self.yang_name = "common-info"
                                    self.yang_parent_name = "proto"

                                    self.count = YLeaf(YType.uint32, "count")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("count") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.CommonInfo, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.CommonInfo, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.count.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.count.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "common-info" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.count.is_set or self.count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.count.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "count"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "count"):
                                        self.count = value
                                        self.count.value_namespace = name_space
                                        self.count.value_namespace_prefix = name_space_prefix


                            class Summary(Entity):
                                """
                                Global summary
                                
                                .. attribute:: base_object
                                
                                	Base object
                                	**type**\:   :py:class:`BaseObject <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.BaseObject>`
                                
                                .. attribute:: health
                                
                                	Global summary health
                                	**type**\:   :py:class:`Health <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.Health>`
                                
                                .. attribute:: summary_counts
                                
                                	Global Summary counts
                                	**type**\:   :py:class:`SummaryCounts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts>`
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary, self).__init__()

                                    self.yang_name = "summary"
                                    self.yang_parent_name = "proto"

                                    self.base_object = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.BaseObject()
                                    self.base_object.parent = self
                                    self._children_name_map["base_object"] = "base-object"
                                    self._children_yang_names.add("base-object")

                                    self.health = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.Health()
                                    self.health.parent = self
                                    self._children_name_map["health"] = "health"
                                    self._children_yang_names.add("health")

                                    self.summary_counts = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts()
                                    self.summary_counts.parent = self
                                    self._children_name_map["summary_counts"] = "summary-counts"
                                    self._children_yang_names.add("summary-counts")


                                class BaseObject(Entity):
                                    """
                                    Base object
                                    
                                    .. attribute:: protocol
                                    
                                    	protocol
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.BaseObject, self).__init__()

                                        self.yang_name = "base-object"
                                        self.yang_parent_name = "summary"

                                        self.protocol = YLeaf(YType.uint32, "protocol")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("protocol") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.BaseObject, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.BaseObject, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.protocol.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.protocol.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "base-object" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.protocol.is_set or self.protocol.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.protocol.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "protocol"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "protocol"):
                                            self.protocol = value
                                            self.protocol.value_namespace = name_space
                                            self.protocol.value_namespace_prefix = name_space_prefix


                                class SummaryCounts(Entity):
                                    """
                                    Global Summary counts
                                    
                                    .. attribute:: array_number_of_object
                                    
                                    	total number of objects
                                    	**type**\: list of    :py:class:`ArrayNumberOfObject <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfObject>`
                                    
                                    .. attribute:: array_number_of_retry
                                    
                                    	number of objects in retry db
                                    	**type**\: list of    :py:class:`ArrayNumberOfRetry <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfRetry>`
                                    
                                    .. attribute:: num_retry_ojbects
                                    
                                    	number of elements in retry db
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: num_retry_timeouts
                                    
                                    	number of retry timeouts
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts, self).__init__()

                                        self.yang_name = "summary-counts"
                                        self.yang_parent_name = "summary"

                                        self.num_retry_ojbects = YLeaf(YType.uint32, "num-retry-ojbects")

                                        self.num_retry_timeouts = YLeaf(YType.uint64, "num-retry-timeouts")

                                        self.array_number_of_object = YList(self)
                                        self.array_number_of_retry = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("num_retry_ojbects",
                                                        "num_retry_timeouts") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts, self).__setattr__(name, value)


                                    class ArrayNumberOfRetry(Entity):
                                        """
                                        number of objects in retry db
                                        
                                        .. attribute:: num_retries
                                        
                                        	number of elements for this obj type in retry db
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: retry_object_type
                                        
                                        	retry object
                                        	**type**\:  str
                                        
                                        	**length:** 0..30
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfRetry, self).__init__()

                                            self.yang_name = "array-number-of-retry"
                                            self.yang_parent_name = "summary-counts"

                                            self.num_retries = YLeaf(YType.uint64, "num-retries")

                                            self.retry_object_type = YLeaf(YType.str, "retry-object-type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("num_retries",
                                                            "retry_object_type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfRetry, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfRetry, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.num_retries.is_set or
                                                self.retry_object_type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.num_retries.yfilter != YFilter.not_set or
                                                self.retry_object_type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "array-number-of-retry" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.num_retries.is_set or self.num_retries.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.num_retries.get_name_leafdata())
                                            if (self.retry_object_type.is_set or self.retry_object_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.retry_object_type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "num-retries" or name == "retry-object-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "num-retries"):
                                                self.num_retries = value
                                                self.num_retries.value_namespace = name_space
                                                self.num_retries.value_namespace_prefix = name_space_prefix
                                            if(value_path == "retry-object-type"):
                                                self.retry_object_type = value
                                                self.retry_object_type.value_namespace = name_space
                                                self.retry_object_type.value_namespace_prefix = name_space_prefix


                                    class ArrayNumberOfObject(Entity):
                                        """
                                        total number of objects
                                        
                                        .. attribute:: num_objects
                                        
                                        	number of elements for this obj type
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: object_type
                                        
                                        	object
                                        	**type**\:  str
                                        
                                        	**length:** 0..30
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfObject, self).__init__()

                                            self.yang_name = "array-number-of-object"
                                            self.yang_parent_name = "summary-counts"

                                            self.num_objects = YLeaf(YType.uint32, "num-objects")

                                            self.object_type = YLeaf(YType.str, "object-type")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("num_objects",
                                                            "object_type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfObject, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfObject, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.num_objects.is_set or
                                                self.object_type.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.num_objects.yfilter != YFilter.not_set or
                                                self.object_type.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "array-number-of-object" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.num_objects.is_set or self.num_objects.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.num_objects.get_name_leafdata())
                                            if (self.object_type.is_set or self.object_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.object_type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "num-objects" or name == "object-type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "num-objects"):
                                                self.num_objects = value
                                                self.num_objects.value_namespace = name_space
                                                self.num_objects.value_namespace_prefix = name_space_prefix
                                            if(value_path == "object-type"):
                                                self.object_type = value
                                                self.object_type.value_namespace = name_space
                                                self.object_type.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.array_number_of_object:
                                            if (c.has_data()):
                                                return True
                                        for c in self.array_number_of_retry:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.num_retry_ojbects.is_set or
                                            self.num_retry_timeouts.is_set)

                                    def has_operation(self):
                                        for c in self.array_number_of_object:
                                            if (c.has_operation()):
                                                return True
                                        for c in self.array_number_of_retry:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.num_retry_ojbects.yfilter != YFilter.not_set or
                                            self.num_retry_timeouts.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "summary-counts" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.num_retry_ojbects.is_set or self.num_retry_ojbects.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.num_retry_ojbects.get_name_leafdata())
                                        if (self.num_retry_timeouts.is_set or self.num_retry_timeouts.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.num_retry_timeouts.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "array-number-of-object"):
                                            for c in self.array_number_of_object:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfObject()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.array_number_of_object.append(c)
                                            return c

                                        if (child_yang_name == "array-number-of-retry"):
                                            for c in self.array_number_of_retry:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts.ArrayNumberOfRetry()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.array_number_of_retry.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "array-number-of-object" or name == "array-number-of-retry" or name == "num-retry-ojbects" or name == "num-retry-timeouts"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "num-retry-ojbects"):
                                            self.num_retry_ojbects = value
                                            self.num_retry_ojbects.value_namespace = name_space
                                            self.num_retry_ojbects.value_namespace_prefix = name_space_prefix
                                        if(value_path == "num-retry-timeouts"):
                                            self.num_retry_timeouts = value
                                            self.num_retry_timeouts.value_namespace = name_space
                                            self.num_retry_timeouts.value_namespace_prefix = name_space_prefix


                                class Health(Entity):
                                    """
                                    Global summary health
                                    
                                    .. attribute:: is_retry_db_empty
                                    
                                    	Is the retry db empty?
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.Health, self).__init__()

                                        self.yang_name = "health"
                                        self.yang_parent_name = "summary"

                                        self.is_retry_db_empty = YLeaf(YType.boolean, "is-retry-db-empty")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("is_retry_db_empty") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.Health, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.Health, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.is_retry_db_empty.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.is_retry_db_empty.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "health" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.is_retry_db_empty.is_set or self.is_retry_db_empty.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.is_retry_db_empty.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "is-retry-db-empty"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "is-retry-db-empty"):
                                            self.is_retry_db_empty = value
                                            self.is_retry_db_empty.value_namespace = name_space
                                            self.is_retry_db_empty.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        (self.base_object is not None and self.base_object.has_data()) or
                                        (self.health is not None and self.health.has_data()) or
                                        (self.summary_counts is not None and self.summary_counts.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.base_object is not None and self.base_object.has_operation()) or
                                        (self.health is not None and self.health.has_operation()) or
                                        (self.summary_counts is not None and self.summary_counts.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "summary" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "base-object"):
                                        if (self.base_object is None):
                                            self.base_object = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.BaseObject()
                                            self.base_object.parent = self
                                            self._children_name_map["base_object"] = "base-object"
                                        return self.base_object

                                    if (child_yang_name == "health"):
                                        if (self.health is None):
                                            self.health = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.Health()
                                            self.health.parent = self
                                            self._children_name_map["health"] = "health"
                                        return self.health

                                    if (child_yang_name == "summary-counts"):
                                        if (self.summary_counts is None):
                                            self.summary_counts = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary.SummaryCounts()
                                            self.summary_counts.parent = self
                                            self._children_name_map["summary_counts"] = "summary-counts"
                                        return self.summary_counts

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "base-object" or name == "health" or name == "summary-counts"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.protocol_name.is_set or
                                    (self.common_info is not None and self.common_info.has_data()) or
                                    (self.summary is not None and self.summary.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.protocol_name.yfilter != YFilter.not_set or
                                    (self.common_info is not None and self.common_info.has_operation()) or
                                    (self.summary is not None and self.summary.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "proto" + "[protocol-name='" + self.protocol_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.protocol_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "common-info"):
                                    if (self.common_info is None):
                                        self.common_info = Fib.Nodes.Node.Global_.Summary.Protos.Proto.CommonInfo()
                                        self.common_info.parent = self
                                        self._children_name_map["common_info"] = "common-info"
                                    return self.common_info

                                if (child_yang_name == "summary"):
                                    if (self.summary is None):
                                        self.summary = Fib.Nodes.Node.Global_.Summary.Protos.Proto.Summary()
                                        self.summary.parent = self
                                        self._children_name_map["summary"] = "summary"
                                    return self.summary

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "common-info" or name == "summary" or name == "protocol-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "protocol-name"):
                                    self.protocol_name = value
                                    self.protocol_name.value_namespace = name_space
                                    self.protocol_name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.proto:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.proto:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "protos" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "proto"):
                                for c in self.proto:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Global_.Summary.Protos.Proto()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.proto.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "proto"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            (self.protos is not None and self.protos.has_data()) or
                            (self.total is not None and self.total.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.protos is not None and self.protos.has_operation()) or
                            (self.total is not None and self.total.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "summary" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "protos"):
                            if (self.protos is None):
                                self.protos = Fib.Nodes.Node.Global_.Summary.Protos()
                                self.protos.parent = self
                                self._children_name_map["protos"] = "protos"
                            return self.protos

                        if (child_yang_name == "total"):
                            if (self.total is None):
                                self.total = Fib.Nodes.Node.Global_.Summary.Total()
                                self.total.parent = self
                                self._children_name_map["total"] = "total"
                            return self.total

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "protos" or name == "total"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class ObjectHistory(Entity):
                    """
                    Object History
                    
                    .. attribute:: obj_history_protos
                    
                    	Proto Table
                    	**type**\:   :py:class:`ObjHistoryProtos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(Fib.Nodes.Node.Global_.ObjectHistory, self).__init__()

                        self.yang_name = "object-history"
                        self.yang_parent_name = "global"

                        self.obj_history_protos = Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos()
                        self.obj_history_protos.parent = self
                        self._children_name_map["obj_history_protos"] = "obj-history-protos"
                        self._children_yang_names.add("obj-history-protos")


                    class ObjHistoryProtos(Entity):
                        """
                        Proto Table
                        
                        .. attribute:: obj_history_proto
                        
                        	Protocol Table entry
                        	**type**\: list of    :py:class:`ObjHistoryProto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos, self).__init__()

                            self.yang_name = "obj-history-protos"
                            self.yang_parent_name = "object-history"

                            self.obj_history_proto = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos, self).__setattr__(name, value)


                        class ObjHistoryProto(Entity):
                            """
                            Protocol Table entry
                            
                            .. attribute:: protocol_name  <key>
                            
                            	Protocol Name
                            	**type**\:   :py:class:`FibafiProto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibafiProto>`
                            
                            .. attribute:: base_object
                            
                            	Base object
                            	**type**\:   :py:class:`BaseObject <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.BaseObject>`
                            
                            .. attribute:: object_history
                            
                            	Obj History
                            	**type**\:   :py:class:`ObjectHistory <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.ObjectHistory>`
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto, self).__init__()

                                self.yang_name = "obj-history-proto"
                                self.yang_parent_name = "obj-history-protos"

                                self.protocol_name = YLeaf(YType.enumeration, "protocol-name")

                                self.base_object = Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.BaseObject()
                                self.base_object.parent = self
                                self._children_name_map["base_object"] = "base-object"
                                self._children_yang_names.add("base-object")

                                self.object_history = Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.ObjectHistory()
                                self.object_history.parent = self
                                self._children_name_map["object_history"] = "object-history"
                                self._children_yang_names.add("object-history")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("protocol_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto, self).__setattr__(name, value)


                            class BaseObject(Entity):
                                """
                                Base object
                                
                                .. attribute:: protocol
                                
                                	protocol
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.BaseObject, self).__init__()

                                    self.yang_name = "base-object"
                                    self.yang_parent_name = "obj-history-proto"

                                    self.protocol = YLeaf(YType.uint32, "protocol")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("protocol") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.BaseObject, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.BaseObject, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.protocol.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.protocol.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "base-object" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.protocol.is_set or self.protocol.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.protocol.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "protocol"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "protocol"):
                                        self.protocol = value
                                        self.protocol.value_namespace = name_space
                                        self.protocol.value_namespace_prefix = name_space_prefix


                            class ObjectHistory(Entity):
                                """
                                Obj History
                                
                                .. attribute:: count
                                
                                	Placeholder for obj history counts
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.ObjectHistory, self).__init__()

                                    self.yang_name = "object-history"
                                    self.yang_parent_name = "obj-history-proto"

                                    self.count = YLeaf(YType.uint32, "count")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("count") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.ObjectHistory, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.ObjectHistory, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.count.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.count.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "object-history" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.count.is_set or self.count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.count.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "count"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "count"):
                                        self.count = value
                                        self.count.value_namespace = name_space
                                        self.count.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.protocol_name.is_set or
                                    (self.base_object is not None and self.base_object.has_data()) or
                                    (self.object_history is not None and self.object_history.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.protocol_name.yfilter != YFilter.not_set or
                                    (self.base_object is not None and self.base_object.has_operation()) or
                                    (self.object_history is not None and self.object_history.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "obj-history-proto" + "[protocol-name='" + self.protocol_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.protocol_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "base-object"):
                                    if (self.base_object is None):
                                        self.base_object = Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.BaseObject()
                                        self.base_object.parent = self
                                        self._children_name_map["base_object"] = "base-object"
                                    return self.base_object

                                if (child_yang_name == "object-history"):
                                    if (self.object_history is None):
                                        self.object_history = Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto.ObjectHistory()
                                        self.object_history.parent = self
                                        self._children_name_map["object_history"] = "object-history"
                                    return self.object_history

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "base-object" or name == "object-history" or name == "protocol-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "protocol-name"):
                                    self.protocol_name = value
                                    self.protocol_name.value_namespace = name_space
                                    self.protocol_name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.obj_history_proto:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.obj_history_proto:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "obj-history-protos" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "obj-history-proto"):
                                for c in self.obj_history_proto:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos.ObjHistoryProto()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.obj_history_proto.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "obj-history-proto"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (self.obj_history_protos is not None and self.obj_history_protos.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.obj_history_protos is not None and self.obj_history_protos.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "object-history" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "obj-history-protos"):
                            if (self.obj_history_protos is None):
                                self.obj_history_protos = Fib.Nodes.Node.Global_.ObjectHistory.ObjHistoryProtos()
                                self.obj_history_protos.parent = self
                                self._children_name_map["obj_history_protos"] = "obj-history-protos"
                            return self.obj_history_protos

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "obj-history-protos"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.object_history is not None and self.object_history.has_data()) or
                        (self.summary is not None and self.summary.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.object_history is not None and self.object_history.has_operation()) or
                        (self.summary is not None and self.summary.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "global" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "object-history"):
                        if (self.object_history is None):
                            self.object_history = Fib.Nodes.Node.Global_.ObjectHistory()
                            self.object_history.parent = self
                            self._children_name_map["object_history"] = "object-history"
                        return self.object_history

                    if (child_yang_name == "summary"):
                        if (self.summary is None):
                            self.summary = Fib.Nodes.Node.Global_.Summary()
                            self.summary.parent = self
                            self._children_name_map["summary"] = "summary"
                        return self.summary

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "object-history" or name == "summary"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Protocols(Entity):
                """
                Protocol table
                
                .. attribute:: protocol
                
                	Protocol table entry
                	**type**\: list of    :py:class:`Protocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol>`
                
                

                """

                _prefix = 'fib-common-oper'
                _revision = '2017-01-20'

                def __init__(self):
                    super(Fib.Nodes.Node.Protocols, self).__init__()

                    self.yang_name = "protocols"
                    self.yang_parent_name = "node"

                    self.protocol = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Fib.Nodes.Node.Protocols, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Fib.Nodes.Node.Protocols, self).__setattr__(name, value)


                class Protocol(Entity):
                    """
                    Protocol table entry
                    
                    .. attribute:: protocol_name  <key>
                    
                    	Protocol Name 
                    	**type**\:   :py:class:`FibProtocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibProtocol>`
                    
                    .. attribute:: external_client_summaries
                    
                    	External Client Summary Table
                    	**type**\:   :py:class:`ExternalClientSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries>`
                    
                    .. attribute:: external_summary_all
                    
                    	Summary for all external clients
                    	**type**\:   :py:class:`ExternalSummaryAll <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll>`
                    
                    .. attribute:: fib_summaries
                    
                    	Summary for FIB tables
                    	**type**\:   :py:class:`FibSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FibSummaries>`
                    
                    .. attribute:: frr_log
                    
                    	Table of Fast Reroute activation logs
                    	**type**\:   :py:class:`FrrLog <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FrrLog>`
                    
                    .. attribute:: issu_state
                    
                    	CEF ISSU State
                    	**type**\:   :py:class:`IssuState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.IssuState>`
                    
                    .. attribute:: local_label
                    
                    	Local label
                    	**type**\:   :py:class:`LocalLabel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.LocalLabel>`
                    
                    .. attribute:: misc
                    
                    	CEF misc hidden data
                    	**type**\:   :py:class:`Misc <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc>`
                    
                    .. attribute:: nh_ids
                    
                    	NHIdTable is accessed by two keys; {NHIdValue} and/or {NHInterface,NHAddress
                    	**type**\:   :py:class:`NhIds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.NhIds>`
                    
                    .. attribute:: resource
                    
                    	Resource information
                    	**type**\:   :py:class:`Resource <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource>`
                    
                    .. attribute:: vrfs
                    
                    	VRF table
                    	**type**\:   :py:class:`Vrfs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(Fib.Nodes.Node.Protocols.Protocol, self).__init__()

                        self.yang_name = "protocol"
                        self.yang_parent_name = "protocols"

                        self.protocol_name = YLeaf(YType.enumeration, "protocol-name")

                        self.external_client_summaries = Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries()
                        self.external_client_summaries.parent = self
                        self._children_name_map["external_client_summaries"] = "external-client-summaries"
                        self._children_yang_names.add("external-client-summaries")

                        self.external_summary_all = Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll()
                        self.external_summary_all.parent = self
                        self._children_name_map["external_summary_all"] = "external-summary-all"
                        self._children_yang_names.add("external-summary-all")

                        self.fib_summaries = Fib.Nodes.Node.Protocols.Protocol.FibSummaries()
                        self.fib_summaries.parent = self
                        self._children_name_map["fib_summaries"] = "fib-summaries"
                        self._children_yang_names.add("fib-summaries")

                        self.frr_log = Fib.Nodes.Node.Protocols.Protocol.FrrLog()
                        self.frr_log.parent = self
                        self._children_name_map["frr_log"] = "frr-log"
                        self._children_yang_names.add("frr-log")

                        self.issu_state = Fib.Nodes.Node.Protocols.Protocol.IssuState()
                        self.issu_state.parent = self
                        self._children_name_map["issu_state"] = "issu-state"
                        self._children_yang_names.add("issu-state")

                        self.local_label = Fib.Nodes.Node.Protocols.Protocol.LocalLabel()
                        self.local_label.parent = self
                        self._children_name_map["local_label"] = "local-label"
                        self._children_yang_names.add("local-label")

                        self.misc = Fib.Nodes.Node.Protocols.Protocol.Misc()
                        self.misc.parent = self
                        self._children_name_map["misc"] = "misc"
                        self._children_yang_names.add("misc")

                        self.nh_ids = Fib.Nodes.Node.Protocols.Protocol.NhIds()
                        self.nh_ids.parent = self
                        self._children_name_map["nh_ids"] = "nh-ids"
                        self._children_yang_names.add("nh-ids")

                        self.resource = Fib.Nodes.Node.Protocols.Protocol.Resource()
                        self.resource.parent = self
                        self._children_name_map["resource"] = "resource"
                        self._children_yang_names.add("resource")

                        self.vrfs = Fib.Nodes.Node.Protocols.Protocol.Vrfs()
                        self.vrfs.parent = self
                        self._children_name_map["vrfs"] = "vrfs"
                        self._children_yang_names.add("vrfs")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("protocol_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Fib.Nodes.Node.Protocols.Protocol, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Fib.Nodes.Node.Protocols.Protocol, self).__setattr__(name, value)


                    class IssuState(Entity):
                        """
                        CEF ISSU State
                        
                        .. attribute:: eoc_received_imdr_time_stamp
                        
                        	End\-of\-config received from IMDR timestamp
                        	**type**\:  str
                        
                        	**length:** 0..33
                        
                        .. attribute:: eoc_received_slc_time_stamp
                        
                        	End\-of\-config received from SLC timestamp
                        	**type**\:  str
                        
                        	**length:** 0..33
                        
                        .. attribute:: eod_received_im_time_stamp
                        
                        	End\-of\-download received from IM timestamp
                        	**type**\:  str
                        
                        	**length:** 0..33
                        
                        .. attribute:: eod_sent_imdr_time_stamp
                        
                        	End\-of\-download send to IMDR timestamp
                        	**type**\:  str
                        
                        	**length:** 0..33
                        
                        .. attribute:: eod_sent_slc_time_stamp
                        
                        	End\-of\-download send to SLC timestamp
                        	**type**\:  str
                        
                        	**length:** 0..33
                        
                        .. attribute:: fis_issu_error_ts
                        
                        	ISSU error sent to ISSUMGR timetstamp
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: fis_issu_restart
                        
                        	ISSU restart
                        	**type**\:  bool
                        
                        .. attribute:: fis_proto_state
                        
                        	IMDR state for the protocols
                        	**type**\: list of    :py:class:`FisProtoState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.IssuState.FisProtoState>`
                        
                        .. attribute:: imdr_eoc_implicit
                        
                        	IMDR End\-of\-config implicit
                        	**type**\:  bool
                        
                        .. attribute:: imdr_support
                        
                        	IMDR supported
                        	**type**\:  bool
                        
                        .. attribute:: slc_eoc_implicit
                        
                        	SLC End\-of\-config implicit
                        	**type**\:  bool
                        
                        .. attribute:: slc_support
                        
                        	SLC supported
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.IssuState, self).__init__()

                            self.yang_name = "issu-state"
                            self.yang_parent_name = "protocol"

                            self.eoc_received_imdr_time_stamp = YLeaf(YType.str, "eoc-received-imdr-time-stamp")

                            self.eoc_received_slc_time_stamp = YLeaf(YType.str, "eoc-received-slc-time-stamp")

                            self.eod_received_im_time_stamp = YLeaf(YType.str, "eod-received-im-time-stamp")

                            self.eod_sent_imdr_time_stamp = YLeaf(YType.str, "eod-sent-imdr-time-stamp")

                            self.eod_sent_slc_time_stamp = YLeaf(YType.str, "eod-sent-slc-time-stamp")

                            self.fis_issu_error_ts = YLeaf(YType.uint64, "fis-issu-error-ts")

                            self.fis_issu_restart = YLeaf(YType.boolean, "fis-issu-restart")

                            self.imdr_eoc_implicit = YLeaf(YType.boolean, "imdr-eoc-implicit")

                            self.imdr_support = YLeaf(YType.boolean, "imdr-support")

                            self.slc_eoc_implicit = YLeaf(YType.boolean, "slc-eoc-implicit")

                            self.slc_support = YLeaf(YType.boolean, "slc-support")

                            self.fis_proto_state = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("eoc_received_imdr_time_stamp",
                                            "eoc_received_slc_time_stamp",
                                            "eod_received_im_time_stamp",
                                            "eod_sent_imdr_time_stamp",
                                            "eod_sent_slc_time_stamp",
                                            "fis_issu_error_ts",
                                            "fis_issu_restart",
                                            "imdr_eoc_implicit",
                                            "imdr_support",
                                            "slc_eoc_implicit",
                                            "slc_support") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Fib.Nodes.Node.Protocols.Protocol.IssuState, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Fib.Nodes.Node.Protocols.Protocol.IssuState, self).__setattr__(name, value)


                        class FisProtoState(Entity):
                            """
                            IMDR state for the protocols
                            
                            .. attribute:: aib_eod_time_stamp
                            
                            	AIB EODTimeStamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: bcdl_tables
                            
                            	Number of BCDL tables
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: converged_tables
                            
                            	Number of tables converged
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lmrib_eod_time_stamp
                            
                            	LMRIB EOD received timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: lmrib_eod_valid
                            
                            	LMRIB EOD expected/valid
                            	**type**\:  bool
                            
                            .. attribute:: lsd_eod_time_stamp
                            
                            	LSD EOD received timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: lsd_eod_valid
                            
                            	LSD EOD expected/valid
                            	**type**\:  bool
                            
                            .. attribute:: protocol_eod_time_stamp
                            
                            	Protocol EOD sent timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: protocol_eod_valid
                            
                            	Protocol EOD expected/valid
                            	**type**\:  bool
                            
                            .. attribute:: protocol_name
                            
                            	Protocol name
                            	**type**\:  str
                            
                            	**length:** 0..6
                            
                            .. attribute:: rib_info_valid
                            
                            	RIB table info valid
                            	**type**\:  bool
                            
                            .. attribute:: rib_tables_converged_time_stamp
                            
                            	All RIB tables converged timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: rsi_eod_time_stamp
                            
                            	RSI EOD received timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: rsi_eod_valid
                            
                            	RSI EOD expected/valid
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.IssuState.FisProtoState, self).__init__()

                                self.yang_name = "fis-proto-state"
                                self.yang_parent_name = "issu-state"

                                self.aib_eod_time_stamp = YLeaf(YType.str, "aib-eod-time-stamp")

                                self.bcdl_tables = YLeaf(YType.uint32, "bcdl-tables")

                                self.converged_tables = YLeaf(YType.uint32, "converged-tables")

                                self.lmrib_eod_time_stamp = YLeaf(YType.str, "lmrib-eod-time-stamp")

                                self.lmrib_eod_valid = YLeaf(YType.boolean, "lmrib-eod-valid")

                                self.lsd_eod_time_stamp = YLeaf(YType.str, "lsd-eod-time-stamp")

                                self.lsd_eod_valid = YLeaf(YType.boolean, "lsd-eod-valid")

                                self.protocol_eod_time_stamp = YLeaf(YType.str, "protocol-eod-time-stamp")

                                self.protocol_eod_valid = YLeaf(YType.boolean, "protocol-eod-valid")

                                self.protocol_name = YLeaf(YType.str, "protocol-name")

                                self.rib_info_valid = YLeaf(YType.boolean, "rib-info-valid")

                                self.rib_tables_converged_time_stamp = YLeaf(YType.str, "rib-tables-converged-time-stamp")

                                self.rsi_eod_time_stamp = YLeaf(YType.str, "rsi-eod-time-stamp")

                                self.rsi_eod_valid = YLeaf(YType.boolean, "rsi-eod-valid")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("aib_eod_time_stamp",
                                                "bcdl_tables",
                                                "converged_tables",
                                                "lmrib_eod_time_stamp",
                                                "lmrib_eod_valid",
                                                "lsd_eod_time_stamp",
                                                "lsd_eod_valid",
                                                "protocol_eod_time_stamp",
                                                "protocol_eod_valid",
                                                "protocol_name",
                                                "rib_info_valid",
                                                "rib_tables_converged_time_stamp",
                                                "rsi_eod_time_stamp",
                                                "rsi_eod_valid") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.IssuState.FisProtoState, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.IssuState.FisProtoState, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.aib_eod_time_stamp.is_set or
                                    self.bcdl_tables.is_set or
                                    self.converged_tables.is_set or
                                    self.lmrib_eod_time_stamp.is_set or
                                    self.lmrib_eod_valid.is_set or
                                    self.lsd_eod_time_stamp.is_set or
                                    self.lsd_eod_valid.is_set or
                                    self.protocol_eod_time_stamp.is_set or
                                    self.protocol_eod_valid.is_set or
                                    self.protocol_name.is_set or
                                    self.rib_info_valid.is_set or
                                    self.rib_tables_converged_time_stamp.is_set or
                                    self.rsi_eod_time_stamp.is_set or
                                    self.rsi_eod_valid.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.aib_eod_time_stamp.yfilter != YFilter.not_set or
                                    self.bcdl_tables.yfilter != YFilter.not_set or
                                    self.converged_tables.yfilter != YFilter.not_set or
                                    self.lmrib_eod_time_stamp.yfilter != YFilter.not_set or
                                    self.lmrib_eod_valid.yfilter != YFilter.not_set or
                                    self.lsd_eod_time_stamp.yfilter != YFilter.not_set or
                                    self.lsd_eod_valid.yfilter != YFilter.not_set or
                                    self.protocol_eod_time_stamp.yfilter != YFilter.not_set or
                                    self.protocol_eod_valid.yfilter != YFilter.not_set or
                                    self.protocol_name.yfilter != YFilter.not_set or
                                    self.rib_info_valid.yfilter != YFilter.not_set or
                                    self.rib_tables_converged_time_stamp.yfilter != YFilter.not_set or
                                    self.rsi_eod_time_stamp.yfilter != YFilter.not_set or
                                    self.rsi_eod_valid.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "fis-proto-state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.aib_eod_time_stamp.is_set or self.aib_eod_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.aib_eod_time_stamp.get_name_leafdata())
                                if (self.bcdl_tables.is_set or self.bcdl_tables.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bcdl_tables.get_name_leafdata())
                                if (self.converged_tables.is_set or self.converged_tables.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.converged_tables.get_name_leafdata())
                                if (self.lmrib_eod_time_stamp.is_set or self.lmrib_eod_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lmrib_eod_time_stamp.get_name_leafdata())
                                if (self.lmrib_eod_valid.is_set or self.lmrib_eod_valid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lmrib_eod_valid.get_name_leafdata())
                                if (self.lsd_eod_time_stamp.is_set or self.lsd_eod_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_eod_time_stamp.get_name_leafdata())
                                if (self.lsd_eod_valid.is_set or self.lsd_eod_valid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_eod_valid.get_name_leafdata())
                                if (self.protocol_eod_time_stamp.is_set or self.protocol_eod_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.protocol_eod_time_stamp.get_name_leafdata())
                                if (self.protocol_eod_valid.is_set or self.protocol_eod_valid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.protocol_eod_valid.get_name_leafdata())
                                if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.protocol_name.get_name_leafdata())
                                if (self.rib_info_valid.is_set or self.rib_info_valid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rib_info_valid.get_name_leafdata())
                                if (self.rib_tables_converged_time_stamp.is_set or self.rib_tables_converged_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rib_tables_converged_time_stamp.get_name_leafdata())
                                if (self.rsi_eod_time_stamp.is_set or self.rsi_eod_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rsi_eod_time_stamp.get_name_leafdata())
                                if (self.rsi_eod_valid.is_set or self.rsi_eod_valid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rsi_eod_valid.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "aib-eod-time-stamp" or name == "bcdl-tables" or name == "converged-tables" or name == "lmrib-eod-time-stamp" or name == "lmrib-eod-valid" or name == "lsd-eod-time-stamp" or name == "lsd-eod-valid" or name == "protocol-eod-time-stamp" or name == "protocol-eod-valid" or name == "protocol-name" or name == "rib-info-valid" or name == "rib-tables-converged-time-stamp" or name == "rsi-eod-time-stamp" or name == "rsi-eod-valid"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "aib-eod-time-stamp"):
                                    self.aib_eod_time_stamp = value
                                    self.aib_eod_time_stamp.value_namespace = name_space
                                    self.aib_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "bcdl-tables"):
                                    self.bcdl_tables = value
                                    self.bcdl_tables.value_namespace = name_space
                                    self.bcdl_tables.value_namespace_prefix = name_space_prefix
                                if(value_path == "converged-tables"):
                                    self.converged_tables = value
                                    self.converged_tables.value_namespace = name_space
                                    self.converged_tables.value_namespace_prefix = name_space_prefix
                                if(value_path == "lmrib-eod-time-stamp"):
                                    self.lmrib_eod_time_stamp = value
                                    self.lmrib_eod_time_stamp.value_namespace = name_space
                                    self.lmrib_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "lmrib-eod-valid"):
                                    self.lmrib_eod_valid = value
                                    self.lmrib_eod_valid.value_namespace = name_space
                                    self.lmrib_eod_valid.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-eod-time-stamp"):
                                    self.lsd_eod_time_stamp = value
                                    self.lsd_eod_time_stamp.value_namespace = name_space
                                    self.lsd_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-eod-valid"):
                                    self.lsd_eod_valid = value
                                    self.lsd_eod_valid.value_namespace = name_space
                                    self.lsd_eod_valid.value_namespace_prefix = name_space_prefix
                                if(value_path == "protocol-eod-time-stamp"):
                                    self.protocol_eod_time_stamp = value
                                    self.protocol_eod_time_stamp.value_namespace = name_space
                                    self.protocol_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "protocol-eod-valid"):
                                    self.protocol_eod_valid = value
                                    self.protocol_eod_valid.value_namespace = name_space
                                    self.protocol_eod_valid.value_namespace_prefix = name_space_prefix
                                if(value_path == "protocol-name"):
                                    self.protocol_name = value
                                    self.protocol_name.value_namespace = name_space
                                    self.protocol_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "rib-info-valid"):
                                    self.rib_info_valid = value
                                    self.rib_info_valid.value_namespace = name_space
                                    self.rib_info_valid.value_namespace_prefix = name_space_prefix
                                if(value_path == "rib-tables-converged-time-stamp"):
                                    self.rib_tables_converged_time_stamp = value
                                    self.rib_tables_converged_time_stamp.value_namespace = name_space
                                    self.rib_tables_converged_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "rsi-eod-time-stamp"):
                                    self.rsi_eod_time_stamp = value
                                    self.rsi_eod_time_stamp.value_namespace = name_space
                                    self.rsi_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "rsi-eod-valid"):
                                    self.rsi_eod_valid = value
                                    self.rsi_eod_valid.value_namespace = name_space
                                    self.rsi_eod_valid.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.fis_proto_state:
                                if (c.has_data()):
                                    return True
                            return (
                                self.eoc_received_imdr_time_stamp.is_set or
                                self.eoc_received_slc_time_stamp.is_set or
                                self.eod_received_im_time_stamp.is_set or
                                self.eod_sent_imdr_time_stamp.is_set or
                                self.eod_sent_slc_time_stamp.is_set or
                                self.fis_issu_error_ts.is_set or
                                self.fis_issu_restart.is_set or
                                self.imdr_eoc_implicit.is_set or
                                self.imdr_support.is_set or
                                self.slc_eoc_implicit.is_set or
                                self.slc_support.is_set)

                        def has_operation(self):
                            for c in self.fis_proto_state:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.eoc_received_imdr_time_stamp.yfilter != YFilter.not_set or
                                self.eoc_received_slc_time_stamp.yfilter != YFilter.not_set or
                                self.eod_received_im_time_stamp.yfilter != YFilter.not_set or
                                self.eod_sent_imdr_time_stamp.yfilter != YFilter.not_set or
                                self.eod_sent_slc_time_stamp.yfilter != YFilter.not_set or
                                self.fis_issu_error_ts.yfilter != YFilter.not_set or
                                self.fis_issu_restart.yfilter != YFilter.not_set or
                                self.imdr_eoc_implicit.yfilter != YFilter.not_set or
                                self.imdr_support.yfilter != YFilter.not_set or
                                self.slc_eoc_implicit.yfilter != YFilter.not_set or
                                self.slc_support.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "issu-state" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.eoc_received_imdr_time_stamp.is_set or self.eoc_received_imdr_time_stamp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.eoc_received_imdr_time_stamp.get_name_leafdata())
                            if (self.eoc_received_slc_time_stamp.is_set or self.eoc_received_slc_time_stamp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.eoc_received_slc_time_stamp.get_name_leafdata())
                            if (self.eod_received_im_time_stamp.is_set or self.eod_received_im_time_stamp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.eod_received_im_time_stamp.get_name_leafdata())
                            if (self.eod_sent_imdr_time_stamp.is_set or self.eod_sent_imdr_time_stamp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.eod_sent_imdr_time_stamp.get_name_leafdata())
                            if (self.eod_sent_slc_time_stamp.is_set or self.eod_sent_slc_time_stamp.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.eod_sent_slc_time_stamp.get_name_leafdata())
                            if (self.fis_issu_error_ts.is_set or self.fis_issu_error_ts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fis_issu_error_ts.get_name_leafdata())
                            if (self.fis_issu_restart.is_set or self.fis_issu_restart.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fis_issu_restart.get_name_leafdata())
                            if (self.imdr_eoc_implicit.is_set or self.imdr_eoc_implicit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.imdr_eoc_implicit.get_name_leafdata())
                            if (self.imdr_support.is_set or self.imdr_support.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.imdr_support.get_name_leafdata())
                            if (self.slc_eoc_implicit.is_set or self.slc_eoc_implicit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.slc_eoc_implicit.get_name_leafdata())
                            if (self.slc_support.is_set or self.slc_support.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.slc_support.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "fis-proto-state"):
                                for c in self.fis_proto_state:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.IssuState.FisProtoState()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.fis_proto_state.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "fis-proto-state" or name == "eoc-received-imdr-time-stamp" or name == "eoc-received-slc-time-stamp" or name == "eod-received-im-time-stamp" or name == "eod-sent-imdr-time-stamp" or name == "eod-sent-slc-time-stamp" or name == "fis-issu-error-ts" or name == "fis-issu-restart" or name == "imdr-eoc-implicit" or name == "imdr-support" or name == "slc-eoc-implicit" or name == "slc-support"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "eoc-received-imdr-time-stamp"):
                                self.eoc_received_imdr_time_stamp = value
                                self.eoc_received_imdr_time_stamp.value_namespace = name_space
                                self.eoc_received_imdr_time_stamp.value_namespace_prefix = name_space_prefix
                            if(value_path == "eoc-received-slc-time-stamp"):
                                self.eoc_received_slc_time_stamp = value
                                self.eoc_received_slc_time_stamp.value_namespace = name_space
                                self.eoc_received_slc_time_stamp.value_namespace_prefix = name_space_prefix
                            if(value_path == "eod-received-im-time-stamp"):
                                self.eod_received_im_time_stamp = value
                                self.eod_received_im_time_stamp.value_namespace = name_space
                                self.eod_received_im_time_stamp.value_namespace_prefix = name_space_prefix
                            if(value_path == "eod-sent-imdr-time-stamp"):
                                self.eod_sent_imdr_time_stamp = value
                                self.eod_sent_imdr_time_stamp.value_namespace = name_space
                                self.eod_sent_imdr_time_stamp.value_namespace_prefix = name_space_prefix
                            if(value_path == "eod-sent-slc-time-stamp"):
                                self.eod_sent_slc_time_stamp = value
                                self.eod_sent_slc_time_stamp.value_namespace = name_space
                                self.eod_sent_slc_time_stamp.value_namespace_prefix = name_space_prefix
                            if(value_path == "fis-issu-error-ts"):
                                self.fis_issu_error_ts = value
                                self.fis_issu_error_ts.value_namespace = name_space
                                self.fis_issu_error_ts.value_namespace_prefix = name_space_prefix
                            if(value_path == "fis-issu-restart"):
                                self.fis_issu_restart = value
                                self.fis_issu_restart.value_namespace = name_space
                                self.fis_issu_restart.value_namespace_prefix = name_space_prefix
                            if(value_path == "imdr-eoc-implicit"):
                                self.imdr_eoc_implicit = value
                                self.imdr_eoc_implicit.value_namespace = name_space
                                self.imdr_eoc_implicit.value_namespace_prefix = name_space_prefix
                            if(value_path == "imdr-support"):
                                self.imdr_support = value
                                self.imdr_support.value_namespace = name_space
                                self.imdr_support.value_namespace_prefix = name_space_prefix
                            if(value_path == "slc-eoc-implicit"):
                                self.slc_eoc_implicit = value
                                self.slc_eoc_implicit.value_namespace = name_space
                                self.slc_eoc_implicit.value_namespace_prefix = name_space_prefix
                            if(value_path == "slc-support"):
                                self.slc_support = value
                                self.slc_support.value_namespace = name_space
                                self.slc_support.value_namespace_prefix = name_space_prefix


                    class Resource(Entity):
                        """
                        Resource information
                        
                        .. attribute:: resource_detail_info
                        
                        	Detailed info
                        	**type**\:   :py:class:`ResourceDetailInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo>`
                        
                        .. attribute:: resource_hardware_egress_info
                        
                        	Detailed info with egress hardware info
                        	**type**\:   :py:class:`ResourceHardwareEgressInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo>`
                        
                        .. attribute:: resource_hardware_ingress_info
                        
                        	Detailed info with ingress hardware info
                        	**type**\:   :py:class:`ResourceHardwareIngressInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo>`
                        
                        .. attribute:: resource_summary_info
                        
                        	Summary info
                        	**type**\:   :py:class:`ResourceSummaryInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.Resource, self).__init__()

                            self.yang_name = "resource"
                            self.yang_parent_name = "protocol"

                            self.resource_detail_info = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo()
                            self.resource_detail_info.parent = self
                            self._children_name_map["resource_detail_info"] = "resource-detail-info"
                            self._children_yang_names.add("resource-detail-info")

                            self.resource_hardware_egress_info = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo()
                            self.resource_hardware_egress_info.parent = self
                            self._children_name_map["resource_hardware_egress_info"] = "resource-hardware-egress-info"
                            self._children_yang_names.add("resource-hardware-egress-info")

                            self.resource_hardware_ingress_info = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo()
                            self.resource_hardware_ingress_info.parent = self
                            self._children_name_map["resource_hardware_ingress_info"] = "resource-hardware-ingress-info"
                            self._children_yang_names.add("resource-hardware-ingress-info")

                            self.resource_summary_info = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo()
                            self.resource_summary_info.parent = self
                            self._children_name_map["resource_summary_info"] = "resource-summary-info"
                            self._children_yang_names.add("resource-summary-info")


                        class ResourceDetailInfo(Entity):
                            """
                            Detailed info
                            
                            .. attribute:: sr_curr_mode
                            
                            	Current overall oor mode
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sr_hw_oor_count
                            
                            	sr hw oor count
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: sr_hwrsrc_info
                            
                            	Opaque hardware rsrc state info
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: sr_hwrsrc_mode
                            
                            	Hardware resource mode
                            	**type**\: list of    :py:class:`SrHwrsrcMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrHwrsrcMode>`
                            
                            .. attribute:: sr_in_oor_ts
                            
                            	sr in oor ts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: sr_out_oor_ts
                            
                            	sr out oor ts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: sr_shm_state
                            
                            	Current status of shared memories
                            	**type**\: list of    :py:class:`SrShmState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrShmState>`
                            
                            .. attribute:: sr_shmwin_oor_count
                            
                            	sr shmwin oor count
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo, self).__init__()

                                self.yang_name = "resource-detail-info"
                                self.yang_parent_name = "resource"

                                self.sr_curr_mode = YLeaf(YType.uint32, "sr-curr-mode")

                                self.sr_hw_oor_count = YLeaf(YType.uint8, "sr-hw-oor-count")

                                self.sr_hwrsrc_info = YLeaf(YType.str, "sr-hwrsrc-info")

                                self.sr_in_oor_ts = YLeaf(YType.uint64, "sr-in-oor-ts")

                                self.sr_out_oor_ts = YLeaf(YType.uint64, "sr-out-oor-ts")

                                self.sr_shmwin_oor_count = YLeaf(YType.uint8, "sr-shmwin-oor-count")

                                self.sr_hwrsrc_mode = YList(self)
                                self.sr_shm_state = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("sr_curr_mode",
                                                "sr_hw_oor_count",
                                                "sr_hwrsrc_info",
                                                "sr_in_oor_ts",
                                                "sr_out_oor_ts",
                                                "sr_shmwin_oor_count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo, self).__setattr__(name, value)


                            class SrHwrsrcMode(Entity):
                                """
                                Hardware resource mode
                                
                                .. attribute:: entry
                                
                                	
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrHwrsrcMode, self).__init__()

                                    self.yang_name = "sr-hwrsrc-mode"
                                    self.yang_parent_name = "resource-detail-info"

                                    self.entry = YLeaf(YType.uint32, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrHwrsrcMode, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrHwrsrcMode, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sr-hwrsrc-mode" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix


                            class SrShmState(Entity):
                                """
                                Current status of shared memories
                                
                                .. attribute:: srs_avg_avail
                                
                                	Average number of bytes available
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                .. attribute:: srs_curr_mode
                                
                                	OOR mode for this shared memory window
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: srs_max_avail
                                
                                	Maximum bytes available
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrShmState, self).__init__()

                                    self.yang_name = "sr-shm-state"
                                    self.yang_parent_name = "resource-detail-info"

                                    self.srs_avg_avail = YLeaf(YType.uint64, "srs-avg-avail")

                                    self.srs_curr_mode = YLeaf(YType.uint32, "srs-curr-mode")

                                    self.srs_max_avail = YLeaf(YType.uint64, "srs-max-avail")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("srs_avg_avail",
                                                    "srs_curr_mode",
                                                    "srs_max_avail") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrShmState, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrShmState, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.srs_avg_avail.is_set or
                                        self.srs_curr_mode.is_set or
                                        self.srs_max_avail.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.srs_avg_avail.yfilter != YFilter.not_set or
                                        self.srs_curr_mode.yfilter != YFilter.not_set or
                                        self.srs_max_avail.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sr-shm-state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.srs_avg_avail.is_set or self.srs_avg_avail.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_avg_avail.get_name_leafdata())
                                    if (self.srs_curr_mode.is_set or self.srs_curr_mode.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_curr_mode.get_name_leafdata())
                                    if (self.srs_max_avail.is_set or self.srs_max_avail.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_max_avail.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "srs-avg-avail" or name == "srs-curr-mode" or name == "srs-max-avail"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "srs-avg-avail"):
                                        self.srs_avg_avail = value
                                        self.srs_avg_avail.value_namespace = name_space
                                        self.srs_avg_avail.value_namespace_prefix = name_space_prefix
                                    if(value_path == "srs-curr-mode"):
                                        self.srs_curr_mode = value
                                        self.srs_curr_mode.value_namespace = name_space
                                        self.srs_curr_mode.value_namespace_prefix = name_space_prefix
                                    if(value_path == "srs-max-avail"):
                                        self.srs_max_avail = value
                                        self.srs_max_avail.value_namespace = name_space
                                        self.srs_max_avail.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.sr_hwrsrc_mode:
                                    if (c.has_data()):
                                        return True
                                for c in self.sr_shm_state:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.sr_curr_mode.is_set or
                                    self.sr_hw_oor_count.is_set or
                                    self.sr_hwrsrc_info.is_set or
                                    self.sr_in_oor_ts.is_set or
                                    self.sr_out_oor_ts.is_set or
                                    self.sr_shmwin_oor_count.is_set)

                            def has_operation(self):
                                for c in self.sr_hwrsrc_mode:
                                    if (c.has_operation()):
                                        return True
                                for c in self.sr_shm_state:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.sr_curr_mode.yfilter != YFilter.not_set or
                                    self.sr_hw_oor_count.yfilter != YFilter.not_set or
                                    self.sr_hwrsrc_info.yfilter != YFilter.not_set or
                                    self.sr_in_oor_ts.yfilter != YFilter.not_set or
                                    self.sr_out_oor_ts.yfilter != YFilter.not_set or
                                    self.sr_shmwin_oor_count.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "resource-detail-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.sr_curr_mode.is_set or self.sr_curr_mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_curr_mode.get_name_leafdata())
                                if (self.sr_hw_oor_count.is_set or self.sr_hw_oor_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_hw_oor_count.get_name_leafdata())
                                if (self.sr_hwrsrc_info.is_set or self.sr_hwrsrc_info.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_hwrsrc_info.get_name_leafdata())
                                if (self.sr_in_oor_ts.is_set or self.sr_in_oor_ts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_in_oor_ts.get_name_leafdata())
                                if (self.sr_out_oor_ts.is_set or self.sr_out_oor_ts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_out_oor_ts.get_name_leafdata())
                                if (self.sr_shmwin_oor_count.is_set or self.sr_shmwin_oor_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_shmwin_oor_count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "sr-hwrsrc-mode"):
                                    for c in self.sr_hwrsrc_mode:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrHwrsrcMode()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sr_hwrsrc_mode.append(c)
                                    return c

                                if (child_yang_name == "sr-shm-state"):
                                    for c in self.sr_shm_state:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo.SrShmState()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sr_shm_state.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "sr-hwrsrc-mode" or name == "sr-shm-state" or name == "sr-curr-mode" or name == "sr-hw-oor-count" or name == "sr-hwrsrc-info" or name == "sr-in-oor-ts" or name == "sr-out-oor-ts" or name == "sr-shmwin-oor-count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "sr-curr-mode"):
                                    self.sr_curr_mode = value
                                    self.sr_curr_mode.value_namespace = name_space
                                    self.sr_curr_mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-hw-oor-count"):
                                    self.sr_hw_oor_count = value
                                    self.sr_hw_oor_count.value_namespace = name_space
                                    self.sr_hw_oor_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-hwrsrc-info"):
                                    self.sr_hwrsrc_info = value
                                    self.sr_hwrsrc_info.value_namespace = name_space
                                    self.sr_hwrsrc_info.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-in-oor-ts"):
                                    self.sr_in_oor_ts = value
                                    self.sr_in_oor_ts.value_namespace = name_space
                                    self.sr_in_oor_ts.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-out-oor-ts"):
                                    self.sr_out_oor_ts = value
                                    self.sr_out_oor_ts.value_namespace = name_space
                                    self.sr_out_oor_ts.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-shmwin-oor-count"):
                                    self.sr_shmwin_oor_count = value
                                    self.sr_shmwin_oor_count.value_namespace = name_space
                                    self.sr_shmwin_oor_count.value_namespace_prefix = name_space_prefix


                        class ResourceHardwareIngressInfo(Entity):
                            """
                            Detailed info with ingress hardware info
                            
                            .. attribute:: sr_curr_mode
                            
                            	Current overall oor mode
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sr_hw_oor_count
                            
                            	sr hw oor count
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: sr_hwrsrc_info
                            
                            	Opaque hardware rsrc state info
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: sr_hwrsrc_mode
                            
                            	Hardware resource mode
                            	**type**\: list of    :py:class:`SrHwrsrcMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrHwrsrcMode>`
                            
                            .. attribute:: sr_in_oor_ts
                            
                            	sr in oor ts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: sr_out_oor_ts
                            
                            	sr out oor ts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: sr_shm_state
                            
                            	Current status of shared memories
                            	**type**\: list of    :py:class:`SrShmState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrShmState>`
                            
                            .. attribute:: sr_shmwin_oor_count
                            
                            	sr shmwin oor count
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo, self).__init__()

                                self.yang_name = "resource-hardware-ingress-info"
                                self.yang_parent_name = "resource"

                                self.sr_curr_mode = YLeaf(YType.uint32, "sr-curr-mode")

                                self.sr_hw_oor_count = YLeaf(YType.uint8, "sr-hw-oor-count")

                                self.sr_hwrsrc_info = YLeaf(YType.str, "sr-hwrsrc-info")

                                self.sr_in_oor_ts = YLeaf(YType.uint64, "sr-in-oor-ts")

                                self.sr_out_oor_ts = YLeaf(YType.uint64, "sr-out-oor-ts")

                                self.sr_shmwin_oor_count = YLeaf(YType.uint8, "sr-shmwin-oor-count")

                                self.sr_hwrsrc_mode = YList(self)
                                self.sr_shm_state = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("sr_curr_mode",
                                                "sr_hw_oor_count",
                                                "sr_hwrsrc_info",
                                                "sr_in_oor_ts",
                                                "sr_out_oor_ts",
                                                "sr_shmwin_oor_count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo, self).__setattr__(name, value)


                            class SrHwrsrcMode(Entity):
                                """
                                Hardware resource mode
                                
                                .. attribute:: entry
                                
                                	
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrHwrsrcMode, self).__init__()

                                    self.yang_name = "sr-hwrsrc-mode"
                                    self.yang_parent_name = "resource-hardware-ingress-info"

                                    self.entry = YLeaf(YType.uint32, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrHwrsrcMode, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrHwrsrcMode, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sr-hwrsrc-mode" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix


                            class SrShmState(Entity):
                                """
                                Current status of shared memories
                                
                                .. attribute:: srs_avg_avail
                                
                                	Average number of bytes available
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                .. attribute:: srs_curr_mode
                                
                                	OOR mode for this shared memory window
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: srs_max_avail
                                
                                	Maximum bytes available
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrShmState, self).__init__()

                                    self.yang_name = "sr-shm-state"
                                    self.yang_parent_name = "resource-hardware-ingress-info"

                                    self.srs_avg_avail = YLeaf(YType.uint64, "srs-avg-avail")

                                    self.srs_curr_mode = YLeaf(YType.uint32, "srs-curr-mode")

                                    self.srs_max_avail = YLeaf(YType.uint64, "srs-max-avail")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("srs_avg_avail",
                                                    "srs_curr_mode",
                                                    "srs_max_avail") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrShmState, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrShmState, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.srs_avg_avail.is_set or
                                        self.srs_curr_mode.is_set or
                                        self.srs_max_avail.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.srs_avg_avail.yfilter != YFilter.not_set or
                                        self.srs_curr_mode.yfilter != YFilter.not_set or
                                        self.srs_max_avail.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sr-shm-state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.srs_avg_avail.is_set or self.srs_avg_avail.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_avg_avail.get_name_leafdata())
                                    if (self.srs_curr_mode.is_set or self.srs_curr_mode.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_curr_mode.get_name_leafdata())
                                    if (self.srs_max_avail.is_set or self.srs_max_avail.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_max_avail.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "srs-avg-avail" or name == "srs-curr-mode" or name == "srs-max-avail"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "srs-avg-avail"):
                                        self.srs_avg_avail = value
                                        self.srs_avg_avail.value_namespace = name_space
                                        self.srs_avg_avail.value_namespace_prefix = name_space_prefix
                                    if(value_path == "srs-curr-mode"):
                                        self.srs_curr_mode = value
                                        self.srs_curr_mode.value_namespace = name_space
                                        self.srs_curr_mode.value_namespace_prefix = name_space_prefix
                                    if(value_path == "srs-max-avail"):
                                        self.srs_max_avail = value
                                        self.srs_max_avail.value_namespace = name_space
                                        self.srs_max_avail.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.sr_hwrsrc_mode:
                                    if (c.has_data()):
                                        return True
                                for c in self.sr_shm_state:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.sr_curr_mode.is_set or
                                    self.sr_hw_oor_count.is_set or
                                    self.sr_hwrsrc_info.is_set or
                                    self.sr_in_oor_ts.is_set or
                                    self.sr_out_oor_ts.is_set or
                                    self.sr_shmwin_oor_count.is_set)

                            def has_operation(self):
                                for c in self.sr_hwrsrc_mode:
                                    if (c.has_operation()):
                                        return True
                                for c in self.sr_shm_state:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.sr_curr_mode.yfilter != YFilter.not_set or
                                    self.sr_hw_oor_count.yfilter != YFilter.not_set or
                                    self.sr_hwrsrc_info.yfilter != YFilter.not_set or
                                    self.sr_in_oor_ts.yfilter != YFilter.not_set or
                                    self.sr_out_oor_ts.yfilter != YFilter.not_set or
                                    self.sr_shmwin_oor_count.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "resource-hardware-ingress-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.sr_curr_mode.is_set or self.sr_curr_mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_curr_mode.get_name_leafdata())
                                if (self.sr_hw_oor_count.is_set or self.sr_hw_oor_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_hw_oor_count.get_name_leafdata())
                                if (self.sr_hwrsrc_info.is_set or self.sr_hwrsrc_info.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_hwrsrc_info.get_name_leafdata())
                                if (self.sr_in_oor_ts.is_set or self.sr_in_oor_ts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_in_oor_ts.get_name_leafdata())
                                if (self.sr_out_oor_ts.is_set or self.sr_out_oor_ts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_out_oor_ts.get_name_leafdata())
                                if (self.sr_shmwin_oor_count.is_set or self.sr_shmwin_oor_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_shmwin_oor_count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "sr-hwrsrc-mode"):
                                    for c in self.sr_hwrsrc_mode:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrHwrsrcMode()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sr_hwrsrc_mode.append(c)
                                    return c

                                if (child_yang_name == "sr-shm-state"):
                                    for c in self.sr_shm_state:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo.SrShmState()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sr_shm_state.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "sr-hwrsrc-mode" or name == "sr-shm-state" or name == "sr-curr-mode" or name == "sr-hw-oor-count" or name == "sr-hwrsrc-info" or name == "sr-in-oor-ts" or name == "sr-out-oor-ts" or name == "sr-shmwin-oor-count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "sr-curr-mode"):
                                    self.sr_curr_mode = value
                                    self.sr_curr_mode.value_namespace = name_space
                                    self.sr_curr_mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-hw-oor-count"):
                                    self.sr_hw_oor_count = value
                                    self.sr_hw_oor_count.value_namespace = name_space
                                    self.sr_hw_oor_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-hwrsrc-info"):
                                    self.sr_hwrsrc_info = value
                                    self.sr_hwrsrc_info.value_namespace = name_space
                                    self.sr_hwrsrc_info.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-in-oor-ts"):
                                    self.sr_in_oor_ts = value
                                    self.sr_in_oor_ts.value_namespace = name_space
                                    self.sr_in_oor_ts.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-out-oor-ts"):
                                    self.sr_out_oor_ts = value
                                    self.sr_out_oor_ts.value_namespace = name_space
                                    self.sr_out_oor_ts.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-shmwin-oor-count"):
                                    self.sr_shmwin_oor_count = value
                                    self.sr_shmwin_oor_count.value_namespace = name_space
                                    self.sr_shmwin_oor_count.value_namespace_prefix = name_space_prefix


                        class ResourceHardwareEgressInfo(Entity):
                            """
                            Detailed info with egress hardware info
                            
                            .. attribute:: sr_curr_mode
                            
                            	Current overall oor mode
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sr_hw_oor_count
                            
                            	sr hw oor count
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: sr_hwrsrc_info
                            
                            	Opaque hardware rsrc state info
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: sr_hwrsrc_mode
                            
                            	Hardware resource mode
                            	**type**\: list of    :py:class:`SrHwrsrcMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrHwrsrcMode>`
                            
                            .. attribute:: sr_in_oor_ts
                            
                            	sr in oor ts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: sr_out_oor_ts
                            
                            	sr out oor ts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: sr_shm_state
                            
                            	Current status of shared memories
                            	**type**\: list of    :py:class:`SrShmState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrShmState>`
                            
                            .. attribute:: sr_shmwin_oor_count
                            
                            	sr shmwin oor count
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo, self).__init__()

                                self.yang_name = "resource-hardware-egress-info"
                                self.yang_parent_name = "resource"

                                self.sr_curr_mode = YLeaf(YType.uint32, "sr-curr-mode")

                                self.sr_hw_oor_count = YLeaf(YType.uint8, "sr-hw-oor-count")

                                self.sr_hwrsrc_info = YLeaf(YType.str, "sr-hwrsrc-info")

                                self.sr_in_oor_ts = YLeaf(YType.uint64, "sr-in-oor-ts")

                                self.sr_out_oor_ts = YLeaf(YType.uint64, "sr-out-oor-ts")

                                self.sr_shmwin_oor_count = YLeaf(YType.uint8, "sr-shmwin-oor-count")

                                self.sr_hwrsrc_mode = YList(self)
                                self.sr_shm_state = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("sr_curr_mode",
                                                "sr_hw_oor_count",
                                                "sr_hwrsrc_info",
                                                "sr_in_oor_ts",
                                                "sr_out_oor_ts",
                                                "sr_shmwin_oor_count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo, self).__setattr__(name, value)


                            class SrHwrsrcMode(Entity):
                                """
                                Hardware resource mode
                                
                                .. attribute:: entry
                                
                                	
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrHwrsrcMode, self).__init__()

                                    self.yang_name = "sr-hwrsrc-mode"
                                    self.yang_parent_name = "resource-hardware-egress-info"

                                    self.entry = YLeaf(YType.uint32, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrHwrsrcMode, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrHwrsrcMode, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sr-hwrsrc-mode" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix


                            class SrShmState(Entity):
                                """
                                Current status of shared memories
                                
                                .. attribute:: srs_avg_avail
                                
                                	Average number of bytes available
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                .. attribute:: srs_curr_mode
                                
                                	OOR mode for this shared memory window
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: srs_max_avail
                                
                                	Maximum bytes available
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrShmState, self).__init__()

                                    self.yang_name = "sr-shm-state"
                                    self.yang_parent_name = "resource-hardware-egress-info"

                                    self.srs_avg_avail = YLeaf(YType.uint64, "srs-avg-avail")

                                    self.srs_curr_mode = YLeaf(YType.uint32, "srs-curr-mode")

                                    self.srs_max_avail = YLeaf(YType.uint64, "srs-max-avail")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("srs_avg_avail",
                                                    "srs_curr_mode",
                                                    "srs_max_avail") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrShmState, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrShmState, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.srs_avg_avail.is_set or
                                        self.srs_curr_mode.is_set or
                                        self.srs_max_avail.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.srs_avg_avail.yfilter != YFilter.not_set or
                                        self.srs_curr_mode.yfilter != YFilter.not_set or
                                        self.srs_max_avail.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sr-shm-state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.srs_avg_avail.is_set or self.srs_avg_avail.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_avg_avail.get_name_leafdata())
                                    if (self.srs_curr_mode.is_set or self.srs_curr_mode.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_curr_mode.get_name_leafdata())
                                    if (self.srs_max_avail.is_set or self.srs_max_avail.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_max_avail.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "srs-avg-avail" or name == "srs-curr-mode" or name == "srs-max-avail"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "srs-avg-avail"):
                                        self.srs_avg_avail = value
                                        self.srs_avg_avail.value_namespace = name_space
                                        self.srs_avg_avail.value_namespace_prefix = name_space_prefix
                                    if(value_path == "srs-curr-mode"):
                                        self.srs_curr_mode = value
                                        self.srs_curr_mode.value_namespace = name_space
                                        self.srs_curr_mode.value_namespace_prefix = name_space_prefix
                                    if(value_path == "srs-max-avail"):
                                        self.srs_max_avail = value
                                        self.srs_max_avail.value_namespace = name_space
                                        self.srs_max_avail.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.sr_hwrsrc_mode:
                                    if (c.has_data()):
                                        return True
                                for c in self.sr_shm_state:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.sr_curr_mode.is_set or
                                    self.sr_hw_oor_count.is_set or
                                    self.sr_hwrsrc_info.is_set or
                                    self.sr_in_oor_ts.is_set or
                                    self.sr_out_oor_ts.is_set or
                                    self.sr_shmwin_oor_count.is_set)

                            def has_operation(self):
                                for c in self.sr_hwrsrc_mode:
                                    if (c.has_operation()):
                                        return True
                                for c in self.sr_shm_state:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.sr_curr_mode.yfilter != YFilter.not_set or
                                    self.sr_hw_oor_count.yfilter != YFilter.not_set or
                                    self.sr_hwrsrc_info.yfilter != YFilter.not_set or
                                    self.sr_in_oor_ts.yfilter != YFilter.not_set or
                                    self.sr_out_oor_ts.yfilter != YFilter.not_set or
                                    self.sr_shmwin_oor_count.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "resource-hardware-egress-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.sr_curr_mode.is_set or self.sr_curr_mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_curr_mode.get_name_leafdata())
                                if (self.sr_hw_oor_count.is_set or self.sr_hw_oor_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_hw_oor_count.get_name_leafdata())
                                if (self.sr_hwrsrc_info.is_set or self.sr_hwrsrc_info.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_hwrsrc_info.get_name_leafdata())
                                if (self.sr_in_oor_ts.is_set or self.sr_in_oor_ts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_in_oor_ts.get_name_leafdata())
                                if (self.sr_out_oor_ts.is_set or self.sr_out_oor_ts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_out_oor_ts.get_name_leafdata())
                                if (self.sr_shmwin_oor_count.is_set or self.sr_shmwin_oor_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_shmwin_oor_count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "sr-hwrsrc-mode"):
                                    for c in self.sr_hwrsrc_mode:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrHwrsrcMode()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sr_hwrsrc_mode.append(c)
                                    return c

                                if (child_yang_name == "sr-shm-state"):
                                    for c in self.sr_shm_state:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo.SrShmState()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sr_shm_state.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "sr-hwrsrc-mode" or name == "sr-shm-state" or name == "sr-curr-mode" or name == "sr-hw-oor-count" or name == "sr-hwrsrc-info" or name == "sr-in-oor-ts" or name == "sr-out-oor-ts" or name == "sr-shmwin-oor-count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "sr-curr-mode"):
                                    self.sr_curr_mode = value
                                    self.sr_curr_mode.value_namespace = name_space
                                    self.sr_curr_mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-hw-oor-count"):
                                    self.sr_hw_oor_count = value
                                    self.sr_hw_oor_count.value_namespace = name_space
                                    self.sr_hw_oor_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-hwrsrc-info"):
                                    self.sr_hwrsrc_info = value
                                    self.sr_hwrsrc_info.value_namespace = name_space
                                    self.sr_hwrsrc_info.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-in-oor-ts"):
                                    self.sr_in_oor_ts = value
                                    self.sr_in_oor_ts.value_namespace = name_space
                                    self.sr_in_oor_ts.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-out-oor-ts"):
                                    self.sr_out_oor_ts = value
                                    self.sr_out_oor_ts.value_namespace = name_space
                                    self.sr_out_oor_ts.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-shmwin-oor-count"):
                                    self.sr_shmwin_oor_count = value
                                    self.sr_shmwin_oor_count.value_namespace = name_space
                                    self.sr_shmwin_oor_count.value_namespace_prefix = name_space_prefix


                        class ResourceSummaryInfo(Entity):
                            """
                            Summary info
                            
                            .. attribute:: sr_curr_mode
                            
                            	Current overall oor mode
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sr_hw_oor_count
                            
                            	sr hw oor count
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: sr_hwrsrc_info
                            
                            	Opaque hardware rsrc state info
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: sr_hwrsrc_mode
                            
                            	Hardware resource mode
                            	**type**\: list of    :py:class:`SrHwrsrcMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrHwrsrcMode>`
                            
                            .. attribute:: sr_in_oor_ts
                            
                            	sr in oor ts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: sr_out_oor_ts
                            
                            	sr out oor ts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: sr_shm_state
                            
                            	Current status of shared memories
                            	**type**\: list of    :py:class:`SrShmState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrShmState>`
                            
                            .. attribute:: sr_shmwin_oor_count
                            
                            	sr shmwin oor count
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo, self).__init__()

                                self.yang_name = "resource-summary-info"
                                self.yang_parent_name = "resource"

                                self.sr_curr_mode = YLeaf(YType.uint32, "sr-curr-mode")

                                self.sr_hw_oor_count = YLeaf(YType.uint8, "sr-hw-oor-count")

                                self.sr_hwrsrc_info = YLeaf(YType.str, "sr-hwrsrc-info")

                                self.sr_in_oor_ts = YLeaf(YType.uint64, "sr-in-oor-ts")

                                self.sr_out_oor_ts = YLeaf(YType.uint64, "sr-out-oor-ts")

                                self.sr_shmwin_oor_count = YLeaf(YType.uint8, "sr-shmwin-oor-count")

                                self.sr_hwrsrc_mode = YList(self)
                                self.sr_shm_state = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("sr_curr_mode",
                                                "sr_hw_oor_count",
                                                "sr_hwrsrc_info",
                                                "sr_in_oor_ts",
                                                "sr_out_oor_ts",
                                                "sr_shmwin_oor_count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo, self).__setattr__(name, value)


                            class SrHwrsrcMode(Entity):
                                """
                                Hardware resource mode
                                
                                .. attribute:: entry
                                
                                	
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrHwrsrcMode, self).__init__()

                                    self.yang_name = "sr-hwrsrc-mode"
                                    self.yang_parent_name = "resource-summary-info"

                                    self.entry = YLeaf(YType.uint32, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrHwrsrcMode, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrHwrsrcMode, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sr-hwrsrc-mode" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix


                            class SrShmState(Entity):
                                """
                                Current status of shared memories
                                
                                .. attribute:: srs_avg_avail
                                
                                	Average number of bytes available
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                .. attribute:: srs_curr_mode
                                
                                	OOR mode for this shared memory window
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: srs_max_avail
                                
                                	Maximum bytes available
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrShmState, self).__init__()

                                    self.yang_name = "sr-shm-state"
                                    self.yang_parent_name = "resource-summary-info"

                                    self.srs_avg_avail = YLeaf(YType.uint64, "srs-avg-avail")

                                    self.srs_curr_mode = YLeaf(YType.uint32, "srs-curr-mode")

                                    self.srs_max_avail = YLeaf(YType.uint64, "srs-max-avail")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("srs_avg_avail",
                                                    "srs_curr_mode",
                                                    "srs_max_avail") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrShmState, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrShmState, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.srs_avg_avail.is_set or
                                        self.srs_curr_mode.is_set or
                                        self.srs_max_avail.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.srs_avg_avail.yfilter != YFilter.not_set or
                                        self.srs_curr_mode.yfilter != YFilter.not_set or
                                        self.srs_max_avail.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sr-shm-state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.srs_avg_avail.is_set or self.srs_avg_avail.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_avg_avail.get_name_leafdata())
                                    if (self.srs_curr_mode.is_set or self.srs_curr_mode.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_curr_mode.get_name_leafdata())
                                    if (self.srs_max_avail.is_set or self.srs_max_avail.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srs_max_avail.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "srs-avg-avail" or name == "srs-curr-mode" or name == "srs-max-avail"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "srs-avg-avail"):
                                        self.srs_avg_avail = value
                                        self.srs_avg_avail.value_namespace = name_space
                                        self.srs_avg_avail.value_namespace_prefix = name_space_prefix
                                    if(value_path == "srs-curr-mode"):
                                        self.srs_curr_mode = value
                                        self.srs_curr_mode.value_namespace = name_space
                                        self.srs_curr_mode.value_namespace_prefix = name_space_prefix
                                    if(value_path == "srs-max-avail"):
                                        self.srs_max_avail = value
                                        self.srs_max_avail.value_namespace = name_space
                                        self.srs_max_avail.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.sr_hwrsrc_mode:
                                    if (c.has_data()):
                                        return True
                                for c in self.sr_shm_state:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.sr_curr_mode.is_set or
                                    self.sr_hw_oor_count.is_set or
                                    self.sr_hwrsrc_info.is_set or
                                    self.sr_in_oor_ts.is_set or
                                    self.sr_out_oor_ts.is_set or
                                    self.sr_shmwin_oor_count.is_set)

                            def has_operation(self):
                                for c in self.sr_hwrsrc_mode:
                                    if (c.has_operation()):
                                        return True
                                for c in self.sr_shm_state:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.sr_curr_mode.yfilter != YFilter.not_set or
                                    self.sr_hw_oor_count.yfilter != YFilter.not_set or
                                    self.sr_hwrsrc_info.yfilter != YFilter.not_set or
                                    self.sr_in_oor_ts.yfilter != YFilter.not_set or
                                    self.sr_out_oor_ts.yfilter != YFilter.not_set or
                                    self.sr_shmwin_oor_count.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "resource-summary-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.sr_curr_mode.is_set or self.sr_curr_mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_curr_mode.get_name_leafdata())
                                if (self.sr_hw_oor_count.is_set or self.sr_hw_oor_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_hw_oor_count.get_name_leafdata())
                                if (self.sr_hwrsrc_info.is_set or self.sr_hwrsrc_info.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_hwrsrc_info.get_name_leafdata())
                                if (self.sr_in_oor_ts.is_set or self.sr_in_oor_ts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_in_oor_ts.get_name_leafdata())
                                if (self.sr_out_oor_ts.is_set or self.sr_out_oor_ts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_out_oor_ts.get_name_leafdata())
                                if (self.sr_shmwin_oor_count.is_set or self.sr_shmwin_oor_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sr_shmwin_oor_count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "sr-hwrsrc-mode"):
                                    for c in self.sr_hwrsrc_mode:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrHwrsrcMode()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sr_hwrsrc_mode.append(c)
                                    return c

                                if (child_yang_name == "sr-shm-state"):
                                    for c in self.sr_shm_state:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo.SrShmState()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sr_shm_state.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "sr-hwrsrc-mode" or name == "sr-shm-state" or name == "sr-curr-mode" or name == "sr-hw-oor-count" or name == "sr-hwrsrc-info" or name == "sr-in-oor-ts" or name == "sr-out-oor-ts" or name == "sr-shmwin-oor-count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "sr-curr-mode"):
                                    self.sr_curr_mode = value
                                    self.sr_curr_mode.value_namespace = name_space
                                    self.sr_curr_mode.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-hw-oor-count"):
                                    self.sr_hw_oor_count = value
                                    self.sr_hw_oor_count.value_namespace = name_space
                                    self.sr_hw_oor_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-hwrsrc-info"):
                                    self.sr_hwrsrc_info = value
                                    self.sr_hwrsrc_info.value_namespace = name_space
                                    self.sr_hwrsrc_info.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-in-oor-ts"):
                                    self.sr_in_oor_ts = value
                                    self.sr_in_oor_ts.value_namespace = name_space
                                    self.sr_in_oor_ts.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-out-oor-ts"):
                                    self.sr_out_oor_ts = value
                                    self.sr_out_oor_ts.value_namespace = name_space
                                    self.sr_out_oor_ts.value_namespace_prefix = name_space_prefix
                                if(value_path == "sr-shmwin-oor-count"):
                                    self.sr_shmwin_oor_count = value
                                    self.sr_shmwin_oor_count.value_namespace = name_space
                                    self.sr_shmwin_oor_count.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                (self.resource_detail_info is not None and self.resource_detail_info.has_data()) or
                                (self.resource_hardware_egress_info is not None and self.resource_hardware_egress_info.has_data()) or
                                (self.resource_hardware_ingress_info is not None and self.resource_hardware_ingress_info.has_data()) or
                                (self.resource_summary_info is not None and self.resource_summary_info.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.resource_detail_info is not None and self.resource_detail_info.has_operation()) or
                                (self.resource_hardware_egress_info is not None and self.resource_hardware_egress_info.has_operation()) or
                                (self.resource_hardware_ingress_info is not None and self.resource_hardware_ingress_info.has_operation()) or
                                (self.resource_summary_info is not None and self.resource_summary_info.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "resource" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "resource-detail-info"):
                                if (self.resource_detail_info is None):
                                    self.resource_detail_info = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceDetailInfo()
                                    self.resource_detail_info.parent = self
                                    self._children_name_map["resource_detail_info"] = "resource-detail-info"
                                return self.resource_detail_info

                            if (child_yang_name == "resource-hardware-egress-info"):
                                if (self.resource_hardware_egress_info is None):
                                    self.resource_hardware_egress_info = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareEgressInfo()
                                    self.resource_hardware_egress_info.parent = self
                                    self._children_name_map["resource_hardware_egress_info"] = "resource-hardware-egress-info"
                                return self.resource_hardware_egress_info

                            if (child_yang_name == "resource-hardware-ingress-info"):
                                if (self.resource_hardware_ingress_info is None):
                                    self.resource_hardware_ingress_info = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceHardwareIngressInfo()
                                    self.resource_hardware_ingress_info.parent = self
                                    self._children_name_map["resource_hardware_ingress_info"] = "resource-hardware-ingress-info"
                                return self.resource_hardware_ingress_info

                            if (child_yang_name == "resource-summary-info"):
                                if (self.resource_summary_info is None):
                                    self.resource_summary_info = Fib.Nodes.Node.Protocols.Protocol.Resource.ResourceSummaryInfo()
                                    self.resource_summary_info.parent = self
                                    self._children_name_map["resource_summary_info"] = "resource-summary-info"
                                return self.resource_summary_info

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "resource-detail-info" or name == "resource-hardware-egress-info" or name == "resource-hardware-ingress-info" or name == "resource-summary-info"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class FibSummaries(Entity):
                        """
                        Summary for FIB tables
                        
                        .. attribute:: fib_summary
                        
                        	Summary for the requested fib table
                        	**type**\: list of    :py:class:`FibSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries, self).__init__()

                            self.yang_name = "fib-summaries"
                            self.yang_parent_name = "protocol"

                            self.fib_summary = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries, self).__setattr__(name, value)


                        class FibSummary(Entity):
                            """
                            Summary for the requested fib table
                            
                            .. attribute:: cef_route_drops
                            
                            	Number of routes dropped by CEF
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cef_version_mismatch_route_drops
                            
                            	the number of routes dropped due to version mismatch
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: cefl_bl_recycled_routes
                            
                            	Number of routes updates with recycled label handled
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: cross_shared_load_sharing_element
                            
                            	Cross\-table shared load sharing element
                            	**type**\:   :py:class:`CrossSharedLoadSharingElement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.CrossSharedLoadSharingElement>`
                            
                            .. attribute:: delete_cache_num_entries
                            
                            	Number of entries in the route delete cache
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: exclusive_load_sharing_element
                            
                            	Exclusive load sharing element
                            	**type**\:   :py:class:`ExclusiveLoadSharingElement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.ExclusiveLoadSharingElement>`
                            
                            .. attribute:: existing_leaves_revisions
                            
                            	Number of entries present on addition
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: extended_prefixes
                            
                            	Number of prefixes with extended path\-list
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: fib_default_prefix
                            
                            	Default prefix
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: fib_default_prefix_mask_length
                            
                            	Default prefix mask length
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: forwarding_elements
                            
                            	Number of forwarding elements linked to the table
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: imposition_prefixes
                            
                            	Number of prefixes with imposition LDI
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: incomplete_next_hops
                            
                            	Number of incomplete NHINFOS
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: label_shared_load_sharing_element
                            
                            	Label\-shared load sharing element
                            	**type**\:   :py:class:`LabelSharedLoadSharingElement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.LabelSharedLoadSharingElement>`
                            
                            .. attribute:: ldi_backwalks
                            
                            	pd backwalks on LDI modify with backup path
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: leaves_used_bytes
                            
                            	Total memory used by leaves
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lisp_eid_prefixes
                            
                            	Number of lisp eid prefixes associated with table
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lisp_eid_valid_prefixes
                            
                            	Number of lisp eid prefixes eligible for forwarding
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lisp_rloc_objects
                            
                            	Number of lisp rloc objects associated with table
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: load_balancing
                            
                            	LBA configuration state
                            	**type**\:   :py:class:`SsLbaState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.SsLbaState>`
                            
                            .. attribute:: load_sharing_elements
                            
                            	Count of load sharing elements
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: load_sharing_references
                            
                            	Count of load sharing references
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: max_resolution_timer
                            
                            	IP CEF max resolution time in seconds
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**units**\: second
                            
                            .. attribute:: new_unresolve_entries
                            
                            	Number of new unresolved entries
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: next_hops
                            
                            	Number of NHINFOS
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: old_unresolve_entries
                            
                            	Number of old unresolved entries
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: prefix
                            
                            	The router\-id
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: prefix_in_place_modifications
                            
                            	Number of inplace modifications
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: reresolve_entries
                            
                            	Number of reresolved entries
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: resolution_timer
                            
                            	IP CEF resolution timer in seconds
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**units**\: second
                            
                            .. attribute:: routes
                            
                            	Number of routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: shared_load_sharing_element
                            
                            	Shared load sharing element
                            	**type**\:   :py:class:`SharedLoadSharingElement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.SharedLoadSharingElement>`
                            
                            .. attribute:: slow_process_timer
                            
                            	IP CEF slow processing time in seconds
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**units**\: second
                            
                            .. attribute:: ss_drop_pl_count
                            
                            	Number of dropped pathlists
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ss_prot_route_count
                            
                            	Number of routes with FRR protection
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ss_tbl_id
                            
                            	Table Id
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ss_tbl_id_ptr
                            
                            	Table Id Ptr
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ss_vr_id
                            
                            	Virtual router instance Id
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ss_vrf_id
                            
                            	Virtual routing forwarding instance Id
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ss_vxlan_ltep_ifh
                            
                            	VXLAN local Interface handle
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: stale_prefix_deletes
                            
                            	Number of deleted stale leafs
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: table_id
                            
                            	FIB table id
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: total_load_share_element_bytes
                            
                            	Total memory used by load sharing elements
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unresolve_entries
                            
                            	Number of total unresolved entries
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: vrf_name
                            
                            	VRF Name
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary, self).__init__()

                                self.yang_name = "fib-summary"
                                self.yang_parent_name = "fib-summaries"

                                self.cef_route_drops = YLeaf(YType.uint32, "cef-route-drops")

                                self.cef_version_mismatch_route_drops = YLeaf(YType.uint64, "cef-version-mismatch-route-drops")

                                self.cefl_bl_recycled_routes = YLeaf(YType.uint32, "cefl-bl-recycled-routes")

                                self.delete_cache_num_entries = YLeaf(YType.uint32, "delete-cache-num-entries")

                                self.existing_leaves_revisions = YLeaf(YType.uint32, "existing-leaves-revisions")

                                self.extended_prefixes = YLeaf(YType.uint32, "extended-prefixes")

                                self.fib_default_prefix = YLeaf(YType.uint32, "fib-default-prefix")

                                self.fib_default_prefix_mask_length = YLeaf(YType.uint32, "fib-default-prefix-mask-length")

                                self.forwarding_elements = YLeaf(YType.uint32, "forwarding-elements")

                                self.imposition_prefixes = YLeaf(YType.uint32, "imposition-prefixes")

                                self.incomplete_next_hops = YLeaf(YType.uint32, "incomplete-next-hops")

                                self.ldi_backwalks = YLeaf(YType.uint32, "ldi-backwalks")

                                self.leaves_used_bytes = YLeaf(YType.uint32, "leaves-used-bytes")

                                self.lisp_eid_prefixes = YLeaf(YType.uint32, "lisp-eid-prefixes")

                                self.lisp_eid_valid_prefixes = YLeaf(YType.uint32, "lisp-eid-valid-prefixes")

                                self.lisp_rloc_objects = YLeaf(YType.uint32, "lisp-rloc-objects")

                                self.load_balancing = YLeaf(YType.enumeration, "load-balancing")

                                self.load_sharing_elements = YLeaf(YType.uint32, "load-sharing-elements")

                                self.load_sharing_references = YLeaf(YType.uint64, "load-sharing-references")

                                self.max_resolution_timer = YLeaf(YType.uint32, "max-resolution-timer")

                                self.new_unresolve_entries = YLeaf(YType.uint32, "new-unresolve-entries")

                                self.next_hops = YLeaf(YType.uint32, "next-hops")

                                self.old_unresolve_entries = YLeaf(YType.uint32, "old-unresolve-entries")

                                self.prefix = YLeaf(YType.str, "prefix")

                                self.prefix_in_place_modifications = YLeaf(YType.uint32, "prefix-in-place-modifications")

                                self.reresolve_entries = YLeaf(YType.uint32, "reresolve-entries")

                                self.resolution_timer = YLeaf(YType.uint32, "resolution-timer")

                                self.routes = YLeaf(YType.uint32, "routes")

                                self.slow_process_timer = YLeaf(YType.uint32, "slow-process-timer")

                                self.ss_drop_pl_count = YLeaf(YType.uint32, "ss-drop-pl-count")

                                self.ss_prot_route_count = YLeaf(YType.uint32, "ss-prot-route-count")

                                self.ss_tbl_id = YLeaf(YType.uint32, "ss-tbl-id")

                                self.ss_tbl_id_ptr = YLeaf(YType.uint32, "ss-tbl-id-ptr")

                                self.ss_vr_id = YLeaf(YType.uint32, "ss-vr-id")

                                self.ss_vrf_id = YLeaf(YType.uint32, "ss-vrf-id")

                                self.ss_vxlan_ltep_ifh = YLeaf(YType.str, "ss-vxlan-ltep-ifh")

                                self.stale_prefix_deletes = YLeaf(YType.uint32, "stale-prefix-deletes")

                                self.table_id = YLeaf(YType.int32, "table-id")

                                self.total_load_share_element_bytes = YLeaf(YType.uint32, "total-load-share-element-bytes")

                                self.unresolve_entries = YLeaf(YType.uint32, "unresolve-entries")

                                self.vrf_name = YLeaf(YType.str, "vrf-name")

                                self.cross_shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.CrossSharedLoadSharingElement()
                                self.cross_shared_load_sharing_element.parent = self
                                self._children_name_map["cross_shared_load_sharing_element"] = "cross-shared-load-sharing-element"
                                self._children_yang_names.add("cross-shared-load-sharing-element")

                                self.exclusive_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.ExclusiveLoadSharingElement()
                                self.exclusive_load_sharing_element.parent = self
                                self._children_name_map["exclusive_load_sharing_element"] = "exclusive-load-sharing-element"
                                self._children_yang_names.add("exclusive-load-sharing-element")

                                self.label_shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.LabelSharedLoadSharingElement()
                                self.label_shared_load_sharing_element.parent = self
                                self._children_name_map["label_shared_load_sharing_element"] = "label-shared-load-sharing-element"
                                self._children_yang_names.add("label-shared-load-sharing-element")

                                self.shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.SharedLoadSharingElement()
                                self.shared_load_sharing_element.parent = self
                                self._children_name_map["shared_load_sharing_element"] = "shared-load-sharing-element"
                                self._children_yang_names.add("shared-load-sharing-element")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("cef_route_drops",
                                                "cef_version_mismatch_route_drops",
                                                "cefl_bl_recycled_routes",
                                                "delete_cache_num_entries",
                                                "existing_leaves_revisions",
                                                "extended_prefixes",
                                                "fib_default_prefix",
                                                "fib_default_prefix_mask_length",
                                                "forwarding_elements",
                                                "imposition_prefixes",
                                                "incomplete_next_hops",
                                                "ldi_backwalks",
                                                "leaves_used_bytes",
                                                "lisp_eid_prefixes",
                                                "lisp_eid_valid_prefixes",
                                                "lisp_rloc_objects",
                                                "load_balancing",
                                                "load_sharing_elements",
                                                "load_sharing_references",
                                                "max_resolution_timer",
                                                "new_unresolve_entries",
                                                "next_hops",
                                                "old_unresolve_entries",
                                                "prefix",
                                                "prefix_in_place_modifications",
                                                "reresolve_entries",
                                                "resolution_timer",
                                                "routes",
                                                "slow_process_timer",
                                                "ss_drop_pl_count",
                                                "ss_prot_route_count",
                                                "ss_tbl_id",
                                                "ss_tbl_id_ptr",
                                                "ss_vr_id",
                                                "ss_vrf_id",
                                                "ss_vxlan_ltep_ifh",
                                                "stale_prefix_deletes",
                                                "table_id",
                                                "total_load_share_element_bytes",
                                                "unresolve_entries",
                                                "vrf_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary, self).__setattr__(name, value)


                            class ExclusiveLoadSharingElement(Entity):
                                """
                                Exclusive load sharing element
                                
                                .. attribute:: platform_shared_load_info_elements
                                
                                	Count of platform shared Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: platform_shared_path_list_elements
                                
                                	Count of platform shared Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: recursive_load_info_elements
                                
                                	Count of recursive Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: recursive_path_list_elements
                                
                                	Count of recursive Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: retry_path_list_elements
                                
                                	Count of Pathlist elements in retry
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: total_load_info_elements
                                
                                	Total count of Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: total_load_sharing_element_bytes
                                
                                	Total memory used by load sharing elements in bytes
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: byte
                                
                                .. attribute:: total_load_sharing_element_references
                                
                                	Total count of references to load sharing elements
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: total_path_list_elements
                                
                                	Total count of Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: xpl_load_info_elements
                                
                                	Count of XPL Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.ExclusiveLoadSharingElement, self).__init__()

                                    self.yang_name = "exclusive-load-sharing-element"
                                    self.yang_parent_name = "fib-summary"

                                    self.platform_shared_load_info_elements = YLeaf(YType.uint32, "platform-shared-load-info-elements")

                                    self.platform_shared_path_list_elements = YLeaf(YType.uint32, "platform-shared-path-list-elements")

                                    self.recursive_load_info_elements = YLeaf(YType.uint32, "recursive-load-info-elements")

                                    self.recursive_path_list_elements = YLeaf(YType.uint32, "recursive-path-list-elements")

                                    self.retry_path_list_elements = YLeaf(YType.uint32, "retry-path-list-elements")

                                    self.total_load_info_elements = YLeaf(YType.uint32, "total-load-info-elements")

                                    self.total_load_sharing_element_bytes = YLeaf(YType.uint32, "total-load-sharing-element-bytes")

                                    self.total_load_sharing_element_references = YLeaf(YType.uint64, "total-load-sharing-element-references")

                                    self.total_path_list_elements = YLeaf(YType.uint32, "total-path-list-elements")

                                    self.xpl_load_info_elements = YLeaf(YType.uint32, "xpl-load-info-elements")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("platform_shared_load_info_elements",
                                                    "platform_shared_path_list_elements",
                                                    "recursive_load_info_elements",
                                                    "recursive_path_list_elements",
                                                    "retry_path_list_elements",
                                                    "total_load_info_elements",
                                                    "total_load_sharing_element_bytes",
                                                    "total_load_sharing_element_references",
                                                    "total_path_list_elements",
                                                    "xpl_load_info_elements") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.ExclusiveLoadSharingElement, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.ExclusiveLoadSharingElement, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.platform_shared_load_info_elements.is_set or
                                        self.platform_shared_path_list_elements.is_set or
                                        self.recursive_load_info_elements.is_set or
                                        self.recursive_path_list_elements.is_set or
                                        self.retry_path_list_elements.is_set or
                                        self.total_load_info_elements.is_set or
                                        self.total_load_sharing_element_bytes.is_set or
                                        self.total_load_sharing_element_references.is_set or
                                        self.total_path_list_elements.is_set or
                                        self.xpl_load_info_elements.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.platform_shared_load_info_elements.yfilter != YFilter.not_set or
                                        self.platform_shared_path_list_elements.yfilter != YFilter.not_set or
                                        self.recursive_load_info_elements.yfilter != YFilter.not_set or
                                        self.recursive_path_list_elements.yfilter != YFilter.not_set or
                                        self.retry_path_list_elements.yfilter != YFilter.not_set or
                                        self.total_load_info_elements.yfilter != YFilter.not_set or
                                        self.total_load_sharing_element_bytes.yfilter != YFilter.not_set or
                                        self.total_load_sharing_element_references.yfilter != YFilter.not_set or
                                        self.total_path_list_elements.yfilter != YFilter.not_set or
                                        self.xpl_load_info_elements.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "exclusive-load-sharing-element" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.platform_shared_load_info_elements.is_set or self.platform_shared_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.platform_shared_load_info_elements.get_name_leafdata())
                                    if (self.platform_shared_path_list_elements.is_set or self.platform_shared_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.platform_shared_path_list_elements.get_name_leafdata())
                                    if (self.recursive_load_info_elements.is_set or self.recursive_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.recursive_load_info_elements.get_name_leafdata())
                                    if (self.recursive_path_list_elements.is_set or self.recursive_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.recursive_path_list_elements.get_name_leafdata())
                                    if (self.retry_path_list_elements.is_set or self.retry_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retry_path_list_elements.get_name_leafdata())
                                    if (self.total_load_info_elements.is_set or self.total_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_info_elements.get_name_leafdata())
                                    if (self.total_load_sharing_element_bytes.is_set or self.total_load_sharing_element_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_sharing_element_bytes.get_name_leafdata())
                                    if (self.total_load_sharing_element_references.is_set or self.total_load_sharing_element_references.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_sharing_element_references.get_name_leafdata())
                                    if (self.total_path_list_elements.is_set or self.total_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_path_list_elements.get_name_leafdata())
                                    if (self.xpl_load_info_elements.is_set or self.xpl_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.xpl_load_info_elements.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "platform-shared-load-info-elements" or name == "platform-shared-path-list-elements" or name == "recursive-load-info-elements" or name == "recursive-path-list-elements" or name == "retry-path-list-elements" or name == "total-load-info-elements" or name == "total-load-sharing-element-bytes" or name == "total-load-sharing-element-references" or name == "total-path-list-elements" or name == "xpl-load-info-elements"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "platform-shared-load-info-elements"):
                                        self.platform_shared_load_info_elements = value
                                        self.platform_shared_load_info_elements.value_namespace = name_space
                                        self.platform_shared_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "platform-shared-path-list-elements"):
                                        self.platform_shared_path_list_elements = value
                                        self.platform_shared_path_list_elements.value_namespace = name_space
                                        self.platform_shared_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "recursive-load-info-elements"):
                                        self.recursive_load_info_elements = value
                                        self.recursive_load_info_elements.value_namespace = name_space
                                        self.recursive_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "recursive-path-list-elements"):
                                        self.recursive_path_list_elements = value
                                        self.recursive_path_list_elements.value_namespace = name_space
                                        self.recursive_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retry-path-list-elements"):
                                        self.retry_path_list_elements = value
                                        self.retry_path_list_elements.value_namespace = name_space
                                        self.retry_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-info-elements"):
                                        self.total_load_info_elements = value
                                        self.total_load_info_elements.value_namespace = name_space
                                        self.total_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-sharing-element-bytes"):
                                        self.total_load_sharing_element_bytes = value
                                        self.total_load_sharing_element_bytes.value_namespace = name_space
                                        self.total_load_sharing_element_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-sharing-element-references"):
                                        self.total_load_sharing_element_references = value
                                        self.total_load_sharing_element_references.value_namespace = name_space
                                        self.total_load_sharing_element_references.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-path-list-elements"):
                                        self.total_path_list_elements = value
                                        self.total_path_list_elements.value_namespace = name_space
                                        self.total_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "xpl-load-info-elements"):
                                        self.xpl_load_info_elements = value
                                        self.xpl_load_info_elements.value_namespace = name_space
                                        self.xpl_load_info_elements.value_namespace_prefix = name_space_prefix


                            class SharedLoadSharingElement(Entity):
                                """
                                Shared load sharing element
                                
                                .. attribute:: platform_shared_load_info_elements
                                
                                	Count of platform shared Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: platform_shared_path_list_elements
                                
                                	Count of platform shared Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: recursive_load_info_elements
                                
                                	Count of recursive Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: recursive_path_list_elements
                                
                                	Count of recursive Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: retry_path_list_elements
                                
                                	Count of Pathlist elements in retry
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: total_load_info_elements
                                
                                	Total count of Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: total_load_sharing_element_bytes
                                
                                	Total memory used by load sharing elements in bytes
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: byte
                                
                                .. attribute:: total_load_sharing_element_references
                                
                                	Total count of references to load sharing elements
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: total_path_list_elements
                                
                                	Total count of Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: xpl_load_info_elements
                                
                                	Count of XPL Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.SharedLoadSharingElement, self).__init__()

                                    self.yang_name = "shared-load-sharing-element"
                                    self.yang_parent_name = "fib-summary"

                                    self.platform_shared_load_info_elements = YLeaf(YType.uint32, "platform-shared-load-info-elements")

                                    self.platform_shared_path_list_elements = YLeaf(YType.uint32, "platform-shared-path-list-elements")

                                    self.recursive_load_info_elements = YLeaf(YType.uint32, "recursive-load-info-elements")

                                    self.recursive_path_list_elements = YLeaf(YType.uint32, "recursive-path-list-elements")

                                    self.retry_path_list_elements = YLeaf(YType.uint32, "retry-path-list-elements")

                                    self.total_load_info_elements = YLeaf(YType.uint32, "total-load-info-elements")

                                    self.total_load_sharing_element_bytes = YLeaf(YType.uint32, "total-load-sharing-element-bytes")

                                    self.total_load_sharing_element_references = YLeaf(YType.uint64, "total-load-sharing-element-references")

                                    self.total_path_list_elements = YLeaf(YType.uint32, "total-path-list-elements")

                                    self.xpl_load_info_elements = YLeaf(YType.uint32, "xpl-load-info-elements")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("platform_shared_load_info_elements",
                                                    "platform_shared_path_list_elements",
                                                    "recursive_load_info_elements",
                                                    "recursive_path_list_elements",
                                                    "retry_path_list_elements",
                                                    "total_load_info_elements",
                                                    "total_load_sharing_element_bytes",
                                                    "total_load_sharing_element_references",
                                                    "total_path_list_elements",
                                                    "xpl_load_info_elements") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.SharedLoadSharingElement, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.SharedLoadSharingElement, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.platform_shared_load_info_elements.is_set or
                                        self.platform_shared_path_list_elements.is_set or
                                        self.recursive_load_info_elements.is_set or
                                        self.recursive_path_list_elements.is_set or
                                        self.retry_path_list_elements.is_set or
                                        self.total_load_info_elements.is_set or
                                        self.total_load_sharing_element_bytes.is_set or
                                        self.total_load_sharing_element_references.is_set or
                                        self.total_path_list_elements.is_set or
                                        self.xpl_load_info_elements.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.platform_shared_load_info_elements.yfilter != YFilter.not_set or
                                        self.platform_shared_path_list_elements.yfilter != YFilter.not_set or
                                        self.recursive_load_info_elements.yfilter != YFilter.not_set or
                                        self.recursive_path_list_elements.yfilter != YFilter.not_set or
                                        self.retry_path_list_elements.yfilter != YFilter.not_set or
                                        self.total_load_info_elements.yfilter != YFilter.not_set or
                                        self.total_load_sharing_element_bytes.yfilter != YFilter.not_set or
                                        self.total_load_sharing_element_references.yfilter != YFilter.not_set or
                                        self.total_path_list_elements.yfilter != YFilter.not_set or
                                        self.xpl_load_info_elements.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "shared-load-sharing-element" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.platform_shared_load_info_elements.is_set or self.platform_shared_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.platform_shared_load_info_elements.get_name_leafdata())
                                    if (self.platform_shared_path_list_elements.is_set or self.platform_shared_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.platform_shared_path_list_elements.get_name_leafdata())
                                    if (self.recursive_load_info_elements.is_set or self.recursive_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.recursive_load_info_elements.get_name_leafdata())
                                    if (self.recursive_path_list_elements.is_set or self.recursive_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.recursive_path_list_elements.get_name_leafdata())
                                    if (self.retry_path_list_elements.is_set or self.retry_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retry_path_list_elements.get_name_leafdata())
                                    if (self.total_load_info_elements.is_set or self.total_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_info_elements.get_name_leafdata())
                                    if (self.total_load_sharing_element_bytes.is_set or self.total_load_sharing_element_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_sharing_element_bytes.get_name_leafdata())
                                    if (self.total_load_sharing_element_references.is_set or self.total_load_sharing_element_references.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_sharing_element_references.get_name_leafdata())
                                    if (self.total_path_list_elements.is_set or self.total_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_path_list_elements.get_name_leafdata())
                                    if (self.xpl_load_info_elements.is_set or self.xpl_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.xpl_load_info_elements.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "platform-shared-load-info-elements" or name == "platform-shared-path-list-elements" or name == "recursive-load-info-elements" or name == "recursive-path-list-elements" or name == "retry-path-list-elements" or name == "total-load-info-elements" or name == "total-load-sharing-element-bytes" or name == "total-load-sharing-element-references" or name == "total-path-list-elements" or name == "xpl-load-info-elements"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "platform-shared-load-info-elements"):
                                        self.platform_shared_load_info_elements = value
                                        self.platform_shared_load_info_elements.value_namespace = name_space
                                        self.platform_shared_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "platform-shared-path-list-elements"):
                                        self.platform_shared_path_list_elements = value
                                        self.platform_shared_path_list_elements.value_namespace = name_space
                                        self.platform_shared_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "recursive-load-info-elements"):
                                        self.recursive_load_info_elements = value
                                        self.recursive_load_info_elements.value_namespace = name_space
                                        self.recursive_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "recursive-path-list-elements"):
                                        self.recursive_path_list_elements = value
                                        self.recursive_path_list_elements.value_namespace = name_space
                                        self.recursive_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retry-path-list-elements"):
                                        self.retry_path_list_elements = value
                                        self.retry_path_list_elements.value_namespace = name_space
                                        self.retry_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-info-elements"):
                                        self.total_load_info_elements = value
                                        self.total_load_info_elements.value_namespace = name_space
                                        self.total_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-sharing-element-bytes"):
                                        self.total_load_sharing_element_bytes = value
                                        self.total_load_sharing_element_bytes.value_namespace = name_space
                                        self.total_load_sharing_element_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-sharing-element-references"):
                                        self.total_load_sharing_element_references = value
                                        self.total_load_sharing_element_references.value_namespace = name_space
                                        self.total_load_sharing_element_references.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-path-list-elements"):
                                        self.total_path_list_elements = value
                                        self.total_path_list_elements.value_namespace = name_space
                                        self.total_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "xpl-load-info-elements"):
                                        self.xpl_load_info_elements = value
                                        self.xpl_load_info_elements.value_namespace = name_space
                                        self.xpl_load_info_elements.value_namespace_prefix = name_space_prefix


                            class CrossSharedLoadSharingElement(Entity):
                                """
                                Cross\-table shared load sharing element
                                
                                .. attribute:: platform_shared_load_info_elements
                                
                                	Count of platform shared Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: platform_shared_path_list_elements
                                
                                	Count of platform shared Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: recursive_load_info_elements
                                
                                	Count of recursive Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: recursive_path_list_elements
                                
                                	Count of recursive Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: retry_path_list_elements
                                
                                	Count of Pathlist elements in retry
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: total_load_info_elements
                                
                                	Total count of Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: total_load_sharing_element_bytes
                                
                                	Total memory used by load sharing elements in bytes
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: byte
                                
                                .. attribute:: total_load_sharing_element_references
                                
                                	Total count of references to load sharing elements
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: total_path_list_elements
                                
                                	Total count of Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: xpl_load_info_elements
                                
                                	Count of XPL Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.CrossSharedLoadSharingElement, self).__init__()

                                    self.yang_name = "cross-shared-load-sharing-element"
                                    self.yang_parent_name = "fib-summary"

                                    self.platform_shared_load_info_elements = YLeaf(YType.uint32, "platform-shared-load-info-elements")

                                    self.platform_shared_path_list_elements = YLeaf(YType.uint32, "platform-shared-path-list-elements")

                                    self.recursive_load_info_elements = YLeaf(YType.uint32, "recursive-load-info-elements")

                                    self.recursive_path_list_elements = YLeaf(YType.uint32, "recursive-path-list-elements")

                                    self.retry_path_list_elements = YLeaf(YType.uint32, "retry-path-list-elements")

                                    self.total_load_info_elements = YLeaf(YType.uint32, "total-load-info-elements")

                                    self.total_load_sharing_element_bytes = YLeaf(YType.uint32, "total-load-sharing-element-bytes")

                                    self.total_load_sharing_element_references = YLeaf(YType.uint64, "total-load-sharing-element-references")

                                    self.total_path_list_elements = YLeaf(YType.uint32, "total-path-list-elements")

                                    self.xpl_load_info_elements = YLeaf(YType.uint32, "xpl-load-info-elements")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("platform_shared_load_info_elements",
                                                    "platform_shared_path_list_elements",
                                                    "recursive_load_info_elements",
                                                    "recursive_path_list_elements",
                                                    "retry_path_list_elements",
                                                    "total_load_info_elements",
                                                    "total_load_sharing_element_bytes",
                                                    "total_load_sharing_element_references",
                                                    "total_path_list_elements",
                                                    "xpl_load_info_elements") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.CrossSharedLoadSharingElement, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.CrossSharedLoadSharingElement, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.platform_shared_load_info_elements.is_set or
                                        self.platform_shared_path_list_elements.is_set or
                                        self.recursive_load_info_elements.is_set or
                                        self.recursive_path_list_elements.is_set or
                                        self.retry_path_list_elements.is_set or
                                        self.total_load_info_elements.is_set or
                                        self.total_load_sharing_element_bytes.is_set or
                                        self.total_load_sharing_element_references.is_set or
                                        self.total_path_list_elements.is_set or
                                        self.xpl_load_info_elements.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.platform_shared_load_info_elements.yfilter != YFilter.not_set or
                                        self.platform_shared_path_list_elements.yfilter != YFilter.not_set or
                                        self.recursive_load_info_elements.yfilter != YFilter.not_set or
                                        self.recursive_path_list_elements.yfilter != YFilter.not_set or
                                        self.retry_path_list_elements.yfilter != YFilter.not_set or
                                        self.total_load_info_elements.yfilter != YFilter.not_set or
                                        self.total_load_sharing_element_bytes.yfilter != YFilter.not_set or
                                        self.total_load_sharing_element_references.yfilter != YFilter.not_set or
                                        self.total_path_list_elements.yfilter != YFilter.not_set or
                                        self.xpl_load_info_elements.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "cross-shared-load-sharing-element" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.platform_shared_load_info_elements.is_set or self.platform_shared_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.platform_shared_load_info_elements.get_name_leafdata())
                                    if (self.platform_shared_path_list_elements.is_set or self.platform_shared_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.platform_shared_path_list_elements.get_name_leafdata())
                                    if (self.recursive_load_info_elements.is_set or self.recursive_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.recursive_load_info_elements.get_name_leafdata())
                                    if (self.recursive_path_list_elements.is_set or self.recursive_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.recursive_path_list_elements.get_name_leafdata())
                                    if (self.retry_path_list_elements.is_set or self.retry_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retry_path_list_elements.get_name_leafdata())
                                    if (self.total_load_info_elements.is_set or self.total_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_info_elements.get_name_leafdata())
                                    if (self.total_load_sharing_element_bytes.is_set or self.total_load_sharing_element_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_sharing_element_bytes.get_name_leafdata())
                                    if (self.total_load_sharing_element_references.is_set or self.total_load_sharing_element_references.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_sharing_element_references.get_name_leafdata())
                                    if (self.total_path_list_elements.is_set or self.total_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_path_list_elements.get_name_leafdata())
                                    if (self.xpl_load_info_elements.is_set or self.xpl_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.xpl_load_info_elements.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "platform-shared-load-info-elements" or name == "platform-shared-path-list-elements" or name == "recursive-load-info-elements" or name == "recursive-path-list-elements" or name == "retry-path-list-elements" or name == "total-load-info-elements" or name == "total-load-sharing-element-bytes" or name == "total-load-sharing-element-references" or name == "total-path-list-elements" or name == "xpl-load-info-elements"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "platform-shared-load-info-elements"):
                                        self.platform_shared_load_info_elements = value
                                        self.platform_shared_load_info_elements.value_namespace = name_space
                                        self.platform_shared_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "platform-shared-path-list-elements"):
                                        self.platform_shared_path_list_elements = value
                                        self.platform_shared_path_list_elements.value_namespace = name_space
                                        self.platform_shared_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "recursive-load-info-elements"):
                                        self.recursive_load_info_elements = value
                                        self.recursive_load_info_elements.value_namespace = name_space
                                        self.recursive_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "recursive-path-list-elements"):
                                        self.recursive_path_list_elements = value
                                        self.recursive_path_list_elements.value_namespace = name_space
                                        self.recursive_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retry-path-list-elements"):
                                        self.retry_path_list_elements = value
                                        self.retry_path_list_elements.value_namespace = name_space
                                        self.retry_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-info-elements"):
                                        self.total_load_info_elements = value
                                        self.total_load_info_elements.value_namespace = name_space
                                        self.total_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-sharing-element-bytes"):
                                        self.total_load_sharing_element_bytes = value
                                        self.total_load_sharing_element_bytes.value_namespace = name_space
                                        self.total_load_sharing_element_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-sharing-element-references"):
                                        self.total_load_sharing_element_references = value
                                        self.total_load_sharing_element_references.value_namespace = name_space
                                        self.total_load_sharing_element_references.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-path-list-elements"):
                                        self.total_path_list_elements = value
                                        self.total_path_list_elements.value_namespace = name_space
                                        self.total_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "xpl-load-info-elements"):
                                        self.xpl_load_info_elements = value
                                        self.xpl_load_info_elements.value_namespace = name_space
                                        self.xpl_load_info_elements.value_namespace_prefix = name_space_prefix


                            class LabelSharedLoadSharingElement(Entity):
                                """
                                Label\-shared load sharing element
                                
                                .. attribute:: platform_shared_load_info_elements
                                
                                	Count of platform shared Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: platform_shared_path_list_elements
                                
                                	Count of platform shared Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: recursive_load_info_elements
                                
                                	Count of recursive Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: recursive_path_list_elements
                                
                                	Count of recursive Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: retry_path_list_elements
                                
                                	Count of Pathlist elements in retry
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: total_load_info_elements
                                
                                	Total count of Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: total_load_sharing_element_bytes
                                
                                	Total memory used by load sharing elements in bytes
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: byte
                                
                                .. attribute:: total_load_sharing_element_references
                                
                                	Total count of references to load sharing elements
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: total_path_list_elements
                                
                                	Total count of Pathlist elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: xpl_load_info_elements
                                
                                	Count of XPL Loadinfo elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.LabelSharedLoadSharingElement, self).__init__()

                                    self.yang_name = "label-shared-load-sharing-element"
                                    self.yang_parent_name = "fib-summary"

                                    self.platform_shared_load_info_elements = YLeaf(YType.uint32, "platform-shared-load-info-elements")

                                    self.platform_shared_path_list_elements = YLeaf(YType.uint32, "platform-shared-path-list-elements")

                                    self.recursive_load_info_elements = YLeaf(YType.uint32, "recursive-load-info-elements")

                                    self.recursive_path_list_elements = YLeaf(YType.uint32, "recursive-path-list-elements")

                                    self.retry_path_list_elements = YLeaf(YType.uint32, "retry-path-list-elements")

                                    self.total_load_info_elements = YLeaf(YType.uint32, "total-load-info-elements")

                                    self.total_load_sharing_element_bytes = YLeaf(YType.uint32, "total-load-sharing-element-bytes")

                                    self.total_load_sharing_element_references = YLeaf(YType.uint64, "total-load-sharing-element-references")

                                    self.total_path_list_elements = YLeaf(YType.uint32, "total-path-list-elements")

                                    self.xpl_load_info_elements = YLeaf(YType.uint32, "xpl-load-info-elements")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("platform_shared_load_info_elements",
                                                    "platform_shared_path_list_elements",
                                                    "recursive_load_info_elements",
                                                    "recursive_path_list_elements",
                                                    "retry_path_list_elements",
                                                    "total_load_info_elements",
                                                    "total_load_sharing_element_bytes",
                                                    "total_load_sharing_element_references",
                                                    "total_path_list_elements",
                                                    "xpl_load_info_elements") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.LabelSharedLoadSharingElement, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.LabelSharedLoadSharingElement, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.platform_shared_load_info_elements.is_set or
                                        self.platform_shared_path_list_elements.is_set or
                                        self.recursive_load_info_elements.is_set or
                                        self.recursive_path_list_elements.is_set or
                                        self.retry_path_list_elements.is_set or
                                        self.total_load_info_elements.is_set or
                                        self.total_load_sharing_element_bytes.is_set or
                                        self.total_load_sharing_element_references.is_set or
                                        self.total_path_list_elements.is_set or
                                        self.xpl_load_info_elements.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.platform_shared_load_info_elements.yfilter != YFilter.not_set or
                                        self.platform_shared_path_list_elements.yfilter != YFilter.not_set or
                                        self.recursive_load_info_elements.yfilter != YFilter.not_set or
                                        self.recursive_path_list_elements.yfilter != YFilter.not_set or
                                        self.retry_path_list_elements.yfilter != YFilter.not_set or
                                        self.total_load_info_elements.yfilter != YFilter.not_set or
                                        self.total_load_sharing_element_bytes.yfilter != YFilter.not_set or
                                        self.total_load_sharing_element_references.yfilter != YFilter.not_set or
                                        self.total_path_list_elements.yfilter != YFilter.not_set or
                                        self.xpl_load_info_elements.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "label-shared-load-sharing-element" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.platform_shared_load_info_elements.is_set or self.platform_shared_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.platform_shared_load_info_elements.get_name_leafdata())
                                    if (self.platform_shared_path_list_elements.is_set or self.platform_shared_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.platform_shared_path_list_elements.get_name_leafdata())
                                    if (self.recursive_load_info_elements.is_set or self.recursive_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.recursive_load_info_elements.get_name_leafdata())
                                    if (self.recursive_path_list_elements.is_set or self.recursive_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.recursive_path_list_elements.get_name_leafdata())
                                    if (self.retry_path_list_elements.is_set or self.retry_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retry_path_list_elements.get_name_leafdata())
                                    if (self.total_load_info_elements.is_set or self.total_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_info_elements.get_name_leafdata())
                                    if (self.total_load_sharing_element_bytes.is_set or self.total_load_sharing_element_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_sharing_element_bytes.get_name_leafdata())
                                    if (self.total_load_sharing_element_references.is_set or self.total_load_sharing_element_references.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_sharing_element_references.get_name_leafdata())
                                    if (self.total_path_list_elements.is_set or self.total_path_list_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_path_list_elements.get_name_leafdata())
                                    if (self.xpl_load_info_elements.is_set or self.xpl_load_info_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.xpl_load_info_elements.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "platform-shared-load-info-elements" or name == "platform-shared-path-list-elements" or name == "recursive-load-info-elements" or name == "recursive-path-list-elements" or name == "retry-path-list-elements" or name == "total-load-info-elements" or name == "total-load-sharing-element-bytes" or name == "total-load-sharing-element-references" or name == "total-path-list-elements" or name == "xpl-load-info-elements"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "platform-shared-load-info-elements"):
                                        self.platform_shared_load_info_elements = value
                                        self.platform_shared_load_info_elements.value_namespace = name_space
                                        self.platform_shared_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "platform-shared-path-list-elements"):
                                        self.platform_shared_path_list_elements = value
                                        self.platform_shared_path_list_elements.value_namespace = name_space
                                        self.platform_shared_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "recursive-load-info-elements"):
                                        self.recursive_load_info_elements = value
                                        self.recursive_load_info_elements.value_namespace = name_space
                                        self.recursive_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "recursive-path-list-elements"):
                                        self.recursive_path_list_elements = value
                                        self.recursive_path_list_elements.value_namespace = name_space
                                        self.recursive_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retry-path-list-elements"):
                                        self.retry_path_list_elements = value
                                        self.retry_path_list_elements.value_namespace = name_space
                                        self.retry_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-info-elements"):
                                        self.total_load_info_elements = value
                                        self.total_load_info_elements.value_namespace = name_space
                                        self.total_load_info_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-sharing-element-bytes"):
                                        self.total_load_sharing_element_bytes = value
                                        self.total_load_sharing_element_bytes.value_namespace = name_space
                                        self.total_load_sharing_element_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-sharing-element-references"):
                                        self.total_load_sharing_element_references = value
                                        self.total_load_sharing_element_references.value_namespace = name_space
                                        self.total_load_sharing_element_references.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-path-list-elements"):
                                        self.total_path_list_elements = value
                                        self.total_path_list_elements.value_namespace = name_space
                                        self.total_path_list_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "xpl-load-info-elements"):
                                        self.xpl_load_info_elements = value
                                        self.xpl_load_info_elements.value_namespace = name_space
                                        self.xpl_load_info_elements.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.cef_route_drops.is_set or
                                    self.cef_version_mismatch_route_drops.is_set or
                                    self.cefl_bl_recycled_routes.is_set or
                                    self.delete_cache_num_entries.is_set or
                                    self.existing_leaves_revisions.is_set or
                                    self.extended_prefixes.is_set or
                                    self.fib_default_prefix.is_set or
                                    self.fib_default_prefix_mask_length.is_set or
                                    self.forwarding_elements.is_set or
                                    self.imposition_prefixes.is_set or
                                    self.incomplete_next_hops.is_set or
                                    self.ldi_backwalks.is_set or
                                    self.leaves_used_bytes.is_set or
                                    self.lisp_eid_prefixes.is_set or
                                    self.lisp_eid_valid_prefixes.is_set or
                                    self.lisp_rloc_objects.is_set or
                                    self.load_balancing.is_set or
                                    self.load_sharing_elements.is_set or
                                    self.load_sharing_references.is_set or
                                    self.max_resolution_timer.is_set or
                                    self.new_unresolve_entries.is_set or
                                    self.next_hops.is_set or
                                    self.old_unresolve_entries.is_set or
                                    self.prefix.is_set or
                                    self.prefix_in_place_modifications.is_set or
                                    self.reresolve_entries.is_set or
                                    self.resolution_timer.is_set or
                                    self.routes.is_set or
                                    self.slow_process_timer.is_set or
                                    self.ss_drop_pl_count.is_set or
                                    self.ss_prot_route_count.is_set or
                                    self.ss_tbl_id.is_set or
                                    self.ss_tbl_id_ptr.is_set or
                                    self.ss_vr_id.is_set or
                                    self.ss_vrf_id.is_set or
                                    self.ss_vxlan_ltep_ifh.is_set or
                                    self.stale_prefix_deletes.is_set or
                                    self.table_id.is_set or
                                    self.total_load_share_element_bytes.is_set or
                                    self.unresolve_entries.is_set or
                                    self.vrf_name.is_set or
                                    (self.cross_shared_load_sharing_element is not None and self.cross_shared_load_sharing_element.has_data()) or
                                    (self.exclusive_load_sharing_element is not None and self.exclusive_load_sharing_element.has_data()) or
                                    (self.label_shared_load_sharing_element is not None and self.label_shared_load_sharing_element.has_data()) or
                                    (self.shared_load_sharing_element is not None and self.shared_load_sharing_element.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.cef_route_drops.yfilter != YFilter.not_set or
                                    self.cef_version_mismatch_route_drops.yfilter != YFilter.not_set or
                                    self.cefl_bl_recycled_routes.yfilter != YFilter.not_set or
                                    self.delete_cache_num_entries.yfilter != YFilter.not_set or
                                    self.existing_leaves_revisions.yfilter != YFilter.not_set or
                                    self.extended_prefixes.yfilter != YFilter.not_set or
                                    self.fib_default_prefix.yfilter != YFilter.not_set or
                                    self.fib_default_prefix_mask_length.yfilter != YFilter.not_set or
                                    self.forwarding_elements.yfilter != YFilter.not_set or
                                    self.imposition_prefixes.yfilter != YFilter.not_set or
                                    self.incomplete_next_hops.yfilter != YFilter.not_set or
                                    self.ldi_backwalks.yfilter != YFilter.not_set or
                                    self.leaves_used_bytes.yfilter != YFilter.not_set or
                                    self.lisp_eid_prefixes.yfilter != YFilter.not_set or
                                    self.lisp_eid_valid_prefixes.yfilter != YFilter.not_set or
                                    self.lisp_rloc_objects.yfilter != YFilter.not_set or
                                    self.load_balancing.yfilter != YFilter.not_set or
                                    self.load_sharing_elements.yfilter != YFilter.not_set or
                                    self.load_sharing_references.yfilter != YFilter.not_set or
                                    self.max_resolution_timer.yfilter != YFilter.not_set or
                                    self.new_unresolve_entries.yfilter != YFilter.not_set or
                                    self.next_hops.yfilter != YFilter.not_set or
                                    self.old_unresolve_entries.yfilter != YFilter.not_set or
                                    self.prefix.yfilter != YFilter.not_set or
                                    self.prefix_in_place_modifications.yfilter != YFilter.not_set or
                                    self.reresolve_entries.yfilter != YFilter.not_set or
                                    self.resolution_timer.yfilter != YFilter.not_set or
                                    self.routes.yfilter != YFilter.not_set or
                                    self.slow_process_timer.yfilter != YFilter.not_set or
                                    self.ss_drop_pl_count.yfilter != YFilter.not_set or
                                    self.ss_prot_route_count.yfilter != YFilter.not_set or
                                    self.ss_tbl_id.yfilter != YFilter.not_set or
                                    self.ss_tbl_id_ptr.yfilter != YFilter.not_set or
                                    self.ss_vr_id.yfilter != YFilter.not_set or
                                    self.ss_vrf_id.yfilter != YFilter.not_set or
                                    self.ss_vxlan_ltep_ifh.yfilter != YFilter.not_set or
                                    self.stale_prefix_deletes.yfilter != YFilter.not_set or
                                    self.table_id.yfilter != YFilter.not_set or
                                    self.total_load_share_element_bytes.yfilter != YFilter.not_set or
                                    self.unresolve_entries.yfilter != YFilter.not_set or
                                    self.vrf_name.yfilter != YFilter.not_set or
                                    (self.cross_shared_load_sharing_element is not None and self.cross_shared_load_sharing_element.has_operation()) or
                                    (self.exclusive_load_sharing_element is not None and self.exclusive_load_sharing_element.has_operation()) or
                                    (self.label_shared_load_sharing_element is not None and self.label_shared_load_sharing_element.has_operation()) or
                                    (self.shared_load_sharing_element is not None and self.shared_load_sharing_element.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "fib-summary" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.cef_route_drops.is_set or self.cef_route_drops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cef_route_drops.get_name_leafdata())
                                if (self.cef_version_mismatch_route_drops.is_set or self.cef_version_mismatch_route_drops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cef_version_mismatch_route_drops.get_name_leafdata())
                                if (self.cefl_bl_recycled_routes.is_set or self.cefl_bl_recycled_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.cefl_bl_recycled_routes.get_name_leafdata())
                                if (self.delete_cache_num_entries.is_set or self.delete_cache_num_entries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delete_cache_num_entries.get_name_leafdata())
                                if (self.existing_leaves_revisions.is_set or self.existing_leaves_revisions.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.existing_leaves_revisions.get_name_leafdata())
                                if (self.extended_prefixes.is_set or self.extended_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.extended_prefixes.get_name_leafdata())
                                if (self.fib_default_prefix.is_set or self.fib_default_prefix.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fib_default_prefix.get_name_leafdata())
                                if (self.fib_default_prefix_mask_length.is_set or self.fib_default_prefix_mask_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fib_default_prefix_mask_length.get_name_leafdata())
                                if (self.forwarding_elements.is_set or self.forwarding_elements.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.forwarding_elements.get_name_leafdata())
                                if (self.imposition_prefixes.is_set or self.imposition_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.imposition_prefixes.get_name_leafdata())
                                if (self.incomplete_next_hops.is_set or self.incomplete_next_hops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.incomplete_next_hops.get_name_leafdata())
                                if (self.ldi_backwalks.is_set or self.ldi_backwalks.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldi_backwalks.get_name_leafdata())
                                if (self.leaves_used_bytes.is_set or self.leaves_used_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.leaves_used_bytes.get_name_leafdata())
                                if (self.lisp_eid_prefixes.is_set or self.lisp_eid_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lisp_eid_prefixes.get_name_leafdata())
                                if (self.lisp_eid_valid_prefixes.is_set or self.lisp_eid_valid_prefixes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lisp_eid_valid_prefixes.get_name_leafdata())
                                if (self.lisp_rloc_objects.is_set or self.lisp_rloc_objects.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lisp_rloc_objects.get_name_leafdata())
                                if (self.load_balancing.is_set or self.load_balancing.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.load_balancing.get_name_leafdata())
                                if (self.load_sharing_elements.is_set or self.load_sharing_elements.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.load_sharing_elements.get_name_leafdata())
                                if (self.load_sharing_references.is_set or self.load_sharing_references.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.load_sharing_references.get_name_leafdata())
                                if (self.max_resolution_timer.is_set or self.max_resolution_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.max_resolution_timer.get_name_leafdata())
                                if (self.new_unresolve_entries.is_set or self.new_unresolve_entries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.new_unresolve_entries.get_name_leafdata())
                                if (self.next_hops.is_set or self.next_hops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.next_hops.get_name_leafdata())
                                if (self.old_unresolve_entries.is_set or self.old_unresolve_entries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.old_unresolve_entries.get_name_leafdata())
                                if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix.get_name_leafdata())
                                if (self.prefix_in_place_modifications.is_set or self.prefix_in_place_modifications.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_in_place_modifications.get_name_leafdata())
                                if (self.reresolve_entries.is_set or self.reresolve_entries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reresolve_entries.get_name_leafdata())
                                if (self.resolution_timer.is_set or self.resolution_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.resolution_timer.get_name_leafdata())
                                if (self.routes.is_set or self.routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.routes.get_name_leafdata())
                                if (self.slow_process_timer.is_set or self.slow_process_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slow_process_timer.get_name_leafdata())
                                if (self.ss_drop_pl_count.is_set or self.ss_drop_pl_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ss_drop_pl_count.get_name_leafdata())
                                if (self.ss_prot_route_count.is_set or self.ss_prot_route_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ss_prot_route_count.get_name_leafdata())
                                if (self.ss_tbl_id.is_set or self.ss_tbl_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ss_tbl_id.get_name_leafdata())
                                if (self.ss_tbl_id_ptr.is_set or self.ss_tbl_id_ptr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ss_tbl_id_ptr.get_name_leafdata())
                                if (self.ss_vr_id.is_set or self.ss_vr_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ss_vr_id.get_name_leafdata())
                                if (self.ss_vrf_id.is_set or self.ss_vrf_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ss_vrf_id.get_name_leafdata())
                                if (self.ss_vxlan_ltep_ifh.is_set or self.ss_vxlan_ltep_ifh.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ss_vxlan_ltep_ifh.get_name_leafdata())
                                if (self.stale_prefix_deletes.is_set or self.stale_prefix_deletes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.stale_prefix_deletes.get_name_leafdata())
                                if (self.table_id.is_set or self.table_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.table_id.get_name_leafdata())
                                if (self.total_load_share_element_bytes.is_set or self.total_load_share_element_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_load_share_element_bytes.get_name_leafdata())
                                if (self.unresolve_entries.is_set or self.unresolve_entries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unresolve_entries.get_name_leafdata())
                                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "cross-shared-load-sharing-element"):
                                    if (self.cross_shared_load_sharing_element is None):
                                        self.cross_shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.CrossSharedLoadSharingElement()
                                        self.cross_shared_load_sharing_element.parent = self
                                        self._children_name_map["cross_shared_load_sharing_element"] = "cross-shared-load-sharing-element"
                                    return self.cross_shared_load_sharing_element

                                if (child_yang_name == "exclusive-load-sharing-element"):
                                    if (self.exclusive_load_sharing_element is None):
                                        self.exclusive_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.ExclusiveLoadSharingElement()
                                        self.exclusive_load_sharing_element.parent = self
                                        self._children_name_map["exclusive_load_sharing_element"] = "exclusive-load-sharing-element"
                                    return self.exclusive_load_sharing_element

                                if (child_yang_name == "label-shared-load-sharing-element"):
                                    if (self.label_shared_load_sharing_element is None):
                                        self.label_shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.LabelSharedLoadSharingElement()
                                        self.label_shared_load_sharing_element.parent = self
                                        self._children_name_map["label_shared_load_sharing_element"] = "label-shared-load-sharing-element"
                                    return self.label_shared_load_sharing_element

                                if (child_yang_name == "shared-load-sharing-element"):
                                    if (self.shared_load_sharing_element is None):
                                        self.shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary.SharedLoadSharingElement()
                                        self.shared_load_sharing_element.parent = self
                                        self._children_name_map["shared_load_sharing_element"] = "shared-load-sharing-element"
                                    return self.shared_load_sharing_element

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "cross-shared-load-sharing-element" or name == "exclusive-load-sharing-element" or name == "label-shared-load-sharing-element" or name == "shared-load-sharing-element" or name == "cef-route-drops" or name == "cef-version-mismatch-route-drops" or name == "cefl-bl-recycled-routes" or name == "delete-cache-num-entries" or name == "existing-leaves-revisions" or name == "extended-prefixes" or name == "fib-default-prefix" or name == "fib-default-prefix-mask-length" or name == "forwarding-elements" or name == "imposition-prefixes" or name == "incomplete-next-hops" or name == "ldi-backwalks" or name == "leaves-used-bytes" or name == "lisp-eid-prefixes" or name == "lisp-eid-valid-prefixes" or name == "lisp-rloc-objects" or name == "load-balancing" or name == "load-sharing-elements" or name == "load-sharing-references" or name == "max-resolution-timer" or name == "new-unresolve-entries" or name == "next-hops" or name == "old-unresolve-entries" or name == "prefix" or name == "prefix-in-place-modifications" or name == "reresolve-entries" or name == "resolution-timer" or name == "routes" or name == "slow-process-timer" or name == "ss-drop-pl-count" or name == "ss-prot-route-count" or name == "ss-tbl-id" or name == "ss-tbl-id-ptr" or name == "ss-vr-id" or name == "ss-vrf-id" or name == "ss-vxlan-ltep-ifh" or name == "stale-prefix-deletes" or name == "table-id" or name == "total-load-share-element-bytes" or name == "unresolve-entries" or name == "vrf-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "cef-route-drops"):
                                    self.cef_route_drops = value
                                    self.cef_route_drops.value_namespace = name_space
                                    self.cef_route_drops.value_namespace_prefix = name_space_prefix
                                if(value_path == "cef-version-mismatch-route-drops"):
                                    self.cef_version_mismatch_route_drops = value
                                    self.cef_version_mismatch_route_drops.value_namespace = name_space
                                    self.cef_version_mismatch_route_drops.value_namespace_prefix = name_space_prefix
                                if(value_path == "cefl-bl-recycled-routes"):
                                    self.cefl_bl_recycled_routes = value
                                    self.cefl_bl_recycled_routes.value_namespace = name_space
                                    self.cefl_bl_recycled_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "delete-cache-num-entries"):
                                    self.delete_cache_num_entries = value
                                    self.delete_cache_num_entries.value_namespace = name_space
                                    self.delete_cache_num_entries.value_namespace_prefix = name_space_prefix
                                if(value_path == "existing-leaves-revisions"):
                                    self.existing_leaves_revisions = value
                                    self.existing_leaves_revisions.value_namespace = name_space
                                    self.existing_leaves_revisions.value_namespace_prefix = name_space_prefix
                                if(value_path == "extended-prefixes"):
                                    self.extended_prefixes = value
                                    self.extended_prefixes.value_namespace = name_space
                                    self.extended_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "fib-default-prefix"):
                                    self.fib_default_prefix = value
                                    self.fib_default_prefix.value_namespace = name_space
                                    self.fib_default_prefix.value_namespace_prefix = name_space_prefix
                                if(value_path == "fib-default-prefix-mask-length"):
                                    self.fib_default_prefix_mask_length = value
                                    self.fib_default_prefix_mask_length.value_namespace = name_space
                                    self.fib_default_prefix_mask_length.value_namespace_prefix = name_space_prefix
                                if(value_path == "forwarding-elements"):
                                    self.forwarding_elements = value
                                    self.forwarding_elements.value_namespace = name_space
                                    self.forwarding_elements.value_namespace_prefix = name_space_prefix
                                if(value_path == "imposition-prefixes"):
                                    self.imposition_prefixes = value
                                    self.imposition_prefixes.value_namespace = name_space
                                    self.imposition_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "incomplete-next-hops"):
                                    self.incomplete_next_hops = value
                                    self.incomplete_next_hops.value_namespace = name_space
                                    self.incomplete_next_hops.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldi-backwalks"):
                                    self.ldi_backwalks = value
                                    self.ldi_backwalks.value_namespace = name_space
                                    self.ldi_backwalks.value_namespace_prefix = name_space_prefix
                                if(value_path == "leaves-used-bytes"):
                                    self.leaves_used_bytes = value
                                    self.leaves_used_bytes.value_namespace = name_space
                                    self.leaves_used_bytes.value_namespace_prefix = name_space_prefix
                                if(value_path == "lisp-eid-prefixes"):
                                    self.lisp_eid_prefixes = value
                                    self.lisp_eid_prefixes.value_namespace = name_space
                                    self.lisp_eid_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "lisp-eid-valid-prefixes"):
                                    self.lisp_eid_valid_prefixes = value
                                    self.lisp_eid_valid_prefixes.value_namespace = name_space
                                    self.lisp_eid_valid_prefixes.value_namespace_prefix = name_space_prefix
                                if(value_path == "lisp-rloc-objects"):
                                    self.lisp_rloc_objects = value
                                    self.lisp_rloc_objects.value_namespace = name_space
                                    self.lisp_rloc_objects.value_namespace_prefix = name_space_prefix
                                if(value_path == "load-balancing"):
                                    self.load_balancing = value
                                    self.load_balancing.value_namespace = name_space
                                    self.load_balancing.value_namespace_prefix = name_space_prefix
                                if(value_path == "load-sharing-elements"):
                                    self.load_sharing_elements = value
                                    self.load_sharing_elements.value_namespace = name_space
                                    self.load_sharing_elements.value_namespace_prefix = name_space_prefix
                                if(value_path == "load-sharing-references"):
                                    self.load_sharing_references = value
                                    self.load_sharing_references.value_namespace = name_space
                                    self.load_sharing_references.value_namespace_prefix = name_space_prefix
                                if(value_path == "max-resolution-timer"):
                                    self.max_resolution_timer = value
                                    self.max_resolution_timer.value_namespace = name_space
                                    self.max_resolution_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "new-unresolve-entries"):
                                    self.new_unresolve_entries = value
                                    self.new_unresolve_entries.value_namespace = name_space
                                    self.new_unresolve_entries.value_namespace_prefix = name_space_prefix
                                if(value_path == "next-hops"):
                                    self.next_hops = value
                                    self.next_hops.value_namespace = name_space
                                    self.next_hops.value_namespace_prefix = name_space_prefix
                                if(value_path == "old-unresolve-entries"):
                                    self.old_unresolve_entries = value
                                    self.old_unresolve_entries.value_namespace = name_space
                                    self.old_unresolve_entries.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix"):
                                    self.prefix = value
                                    self.prefix.value_namespace = name_space
                                    self.prefix.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-in-place-modifications"):
                                    self.prefix_in_place_modifications = value
                                    self.prefix_in_place_modifications.value_namespace = name_space
                                    self.prefix_in_place_modifications.value_namespace_prefix = name_space_prefix
                                if(value_path == "reresolve-entries"):
                                    self.reresolve_entries = value
                                    self.reresolve_entries.value_namespace = name_space
                                    self.reresolve_entries.value_namespace_prefix = name_space_prefix
                                if(value_path == "resolution-timer"):
                                    self.resolution_timer = value
                                    self.resolution_timer.value_namespace = name_space
                                    self.resolution_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "routes"):
                                    self.routes = value
                                    self.routes.value_namespace = name_space
                                    self.routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "slow-process-timer"):
                                    self.slow_process_timer = value
                                    self.slow_process_timer.value_namespace = name_space
                                    self.slow_process_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "ss-drop-pl-count"):
                                    self.ss_drop_pl_count = value
                                    self.ss_drop_pl_count.value_namespace = name_space
                                    self.ss_drop_pl_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "ss-prot-route-count"):
                                    self.ss_prot_route_count = value
                                    self.ss_prot_route_count.value_namespace = name_space
                                    self.ss_prot_route_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "ss-tbl-id"):
                                    self.ss_tbl_id = value
                                    self.ss_tbl_id.value_namespace = name_space
                                    self.ss_tbl_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "ss-tbl-id-ptr"):
                                    self.ss_tbl_id_ptr = value
                                    self.ss_tbl_id_ptr.value_namespace = name_space
                                    self.ss_tbl_id_ptr.value_namespace_prefix = name_space_prefix
                                if(value_path == "ss-vr-id"):
                                    self.ss_vr_id = value
                                    self.ss_vr_id.value_namespace = name_space
                                    self.ss_vr_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "ss-vrf-id"):
                                    self.ss_vrf_id = value
                                    self.ss_vrf_id.value_namespace = name_space
                                    self.ss_vrf_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "ss-vxlan-ltep-ifh"):
                                    self.ss_vxlan_ltep_ifh = value
                                    self.ss_vxlan_ltep_ifh.value_namespace = name_space
                                    self.ss_vxlan_ltep_ifh.value_namespace_prefix = name_space_prefix
                                if(value_path == "stale-prefix-deletes"):
                                    self.stale_prefix_deletes = value
                                    self.stale_prefix_deletes.value_namespace = name_space
                                    self.stale_prefix_deletes.value_namespace_prefix = name_space_prefix
                                if(value_path == "table-id"):
                                    self.table_id = value
                                    self.table_id.value_namespace = name_space
                                    self.table_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-load-share-element-bytes"):
                                    self.total_load_share_element_bytes = value
                                    self.total_load_share_element_bytes.value_namespace = name_space
                                    self.total_load_share_element_bytes.value_namespace_prefix = name_space_prefix
                                if(value_path == "unresolve-entries"):
                                    self.unresolve_entries = value
                                    self.unresolve_entries.value_namespace = name_space
                                    self.unresolve_entries.value_namespace_prefix = name_space_prefix
                                if(value_path == "vrf-name"):
                                    self.vrf_name = value
                                    self.vrf_name.value_namespace = name_space
                                    self.vrf_name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.fib_summary:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.fib_summary:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "fib-summaries" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "fib-summary"):
                                for c in self.fib_summary:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.FibSummaries.FibSummary()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.fib_summary.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "fib-summary"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class ExternalSummaryAll(Entity):
                        """
                        Summary for all external clients
                        
                        .. attribute:: sesa_num_client
                        
                        	Client information
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: sesa_pl_sum
                        
                        	External pathlist summary
                        	**type**\:   :py:class:`SesaPlSum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll, self).__init__()

                            self.yang_name = "external-summary-all"
                            self.yang_parent_name = "protocol"

                            self.sesa_num_client = YLeaf(YType.uint32, "sesa-num-client")

                            self.sesa_pl_sum = Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum()
                            self.sesa_pl_sum.parent = self
                            self._children_name_map["sesa_pl_sum"] = "sesa-pl-sum"
                            self._children_yang_names.add("sesa-pl-sum")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("sesa_num_client") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll, self).__setattr__(name, value)


                        class SesaPlSum(Entity):
                            """
                            External pathlist summary
                            
                            .. attribute:: sep_num_ecd_pathlist
                            
                            	Number of ECD pathlists
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: sep_num_ecd_pl_per_interest
                            
                            	Number of ECD pathlists per interest
                            	**type**\: list of    :py:class:`SepNumEcdPlPerInterest <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum.SepNumEcdPlPerInterest>`
                            
                            .. attribute:: sep_num_ecd_pl_unresolved
                            
                            	Number of ECD pathlists unresolved
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum, self).__init__()

                                self.yang_name = "sesa-pl-sum"
                                self.yang_parent_name = "external-summary-all"

                                self.sep_num_ecd_pathlist = YLeaf(YType.uint32, "sep-num-ecd-pathlist")

                                self.sep_num_ecd_pl_unresolved = YLeaf(YType.uint32, "sep-num-ecd-pl-unresolved")

                                self.sep_num_ecd_pl_per_interest = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("sep_num_ecd_pathlist",
                                                "sep_num_ecd_pl_unresolved") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum, self).__setattr__(name, value)


                            class SepNumEcdPlPerInterest(Entity):
                                """
                                Number of ECD pathlists per interest
                                
                                .. attribute:: entry
                                
                                	
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum.SepNumEcdPlPerInterest, self).__init__()

                                    self.yang_name = "sep-num-ecd-pl-per-interest"
                                    self.yang_parent_name = "sesa-pl-sum"

                                    self.entry = YLeaf(YType.uint32, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum.SepNumEcdPlPerInterest, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum.SepNumEcdPlPerInterest, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "sep-num-ecd-pl-per-interest" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.sep_num_ecd_pl_per_interest:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.sep_num_ecd_pathlist.is_set or
                                    self.sep_num_ecd_pl_unresolved.is_set)

                            def has_operation(self):
                                for c in self.sep_num_ecd_pl_per_interest:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.sep_num_ecd_pathlist.yfilter != YFilter.not_set or
                                    self.sep_num_ecd_pl_unresolved.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "sesa-pl-sum" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.sep_num_ecd_pathlist.is_set or self.sep_num_ecd_pathlist.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sep_num_ecd_pathlist.get_name_leafdata())
                                if (self.sep_num_ecd_pl_unresolved.is_set or self.sep_num_ecd_pl_unresolved.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sep_num_ecd_pl_unresolved.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "sep-num-ecd-pl-per-interest"):
                                    for c in self.sep_num_ecd_pl_per_interest:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum.SepNumEcdPlPerInterest()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.sep_num_ecd_pl_per_interest.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "sep-num-ecd-pl-per-interest" or name == "sep-num-ecd-pathlist" or name == "sep-num-ecd-pl-unresolved"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "sep-num-ecd-pathlist"):
                                    self.sep_num_ecd_pathlist = value
                                    self.sep_num_ecd_pathlist.value_namespace = name_space
                                    self.sep_num_ecd_pathlist.value_namespace_prefix = name_space_prefix
                                if(value_path == "sep-num-ecd-pl-unresolved"):
                                    self.sep_num_ecd_pl_unresolved = value
                                    self.sep_num_ecd_pl_unresolved.value_namespace = name_space
                                    self.sep_num_ecd_pl_unresolved.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.sesa_num_client.is_set or
                                (self.sesa_pl_sum is not None and self.sesa_pl_sum.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.sesa_num_client.yfilter != YFilter.not_set or
                                (self.sesa_pl_sum is not None and self.sesa_pl_sum.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "external-summary-all" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.sesa_num_client.is_set or self.sesa_num_client.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sesa_num_client.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "sesa-pl-sum"):
                                if (self.sesa_pl_sum is None):
                                    self.sesa_pl_sum = Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll.SesaPlSum()
                                    self.sesa_pl_sum.parent = self
                                    self._children_name_map["sesa_pl_sum"] = "sesa-pl-sum"
                                return self.sesa_pl_sum

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "sesa-pl-sum" or name == "sesa-num-client"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "sesa-num-client"):
                                self.sesa_num_client = value
                                self.sesa_num_client.value_namespace = name_space
                                self.sesa_num_client.value_namespace_prefix = name_space_prefix


                    class FrrLog(Entity):
                        """
                        Table of Fast Reroute activation logs
                        
                        .. attribute:: frr_interfaces
                        
                        	FRR Interface Table
                        	**type**\:   :py:class:`FrrInterfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.FrrLog, self).__init__()

                            self.yang_name = "frr-log"
                            self.yang_parent_name = "protocol"

                            self.frr_interfaces = Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces()
                            self.frr_interfaces.parent = self
                            self._children_name_map["frr_interfaces"] = "frr-interfaces"
                            self._children_yang_names.add("frr-interfaces")


                        class FrrInterfaces(Entity):
                            """
                            FRR Interface Table
                            
                            .. attribute:: frr_interface
                            
                            	Specify FRR Interface Name
                            	**type**\: list of    :py:class:`FrrInterface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface>`
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces, self).__init__()

                                self.yang_name = "frr-interfaces"
                                self.yang_parent_name = "frr-log"

                                self.frr_interface = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces, self).__setattr__(name, value)


                            class FrrInterface(Entity):
                                """
                                Specify FRR Interface Name
                                
                                .. attribute:: frr_interface_name  <key>
                                
                                	Interface Name
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: logs
                                
                                	FRR log table
                                	**type**\:   :py:class:`Logs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs>`
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface, self).__init__()

                                    self.yang_name = "frr-interface"
                                    self.yang_parent_name = "frr-interfaces"

                                    self.frr_interface_name = YLeaf(YType.str, "frr-interface-name")

                                    self.logs = Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs()
                                    self.logs.parent = self
                                    self._children_name_map["logs"] = "logs"
                                    self._children_yang_names.add("logs")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("frr_interface_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface, self).__setattr__(name, value)


                                class Logs(Entity):
                                    """
                                    FRR log table
                                    
                                    .. attribute:: log
                                    
                                    	Specify index into frr log table
                                    	**type**\: list of    :py:class:`Log <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log>`
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs, self).__init__()

                                        self.yang_name = "logs"
                                        self.yang_parent_name = "frr-interface"

                                        self.log = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs, self).__setattr__(name, value)


                                    class Log(Entity):
                                        """
                                        Specify index into frr log table
                                        
                                        .. attribute:: log_index  <key>
                                        
                                        	FRR Log Index
                                        	**type**\:  int
                                        
                                        	**range:** \-2147483648..2147483647
                                        
                                        .. attribute:: bundle_member_interface_name
                                        
                                        	bundle member
                                        	**type**\:  str
                                        
                                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                        
                                        .. attribute:: frr_interface_name
                                        
                                        	Interface assoc w frr nh
                                        	**type**\:  str
                                        
                                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                        
                                        .. attribute:: frr_prefix
                                        
                                        	nh prefix
                                        	**type**\:  str
                                        
                                        	**length:** 0..52
                                        
                                        .. attribute:: frr_protocol_type
                                        
                                        	FIB Protocol Type
                                        	**type**\:   :py:class:`FibFrrProtocolShow <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibFrrProtocolShow>`
                                        
                                        .. attribute:: frr_switching_time
                                        
                                        	frr switching time
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: frr_timestamp
                                        
                                        	frr timestamp
                                        	**type**\:   :py:class:`FrrTimestamp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log.FrrTimestamp>`
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log, self).__init__()

                                            self.yang_name = "log"
                                            self.yang_parent_name = "logs"

                                            self.log_index = YLeaf(YType.int32, "log-index")

                                            self.bundle_member_interface_name = YLeaf(YType.str, "bundle-member-interface-name")

                                            self.frr_interface_name = YLeaf(YType.str, "frr-interface-name")

                                            self.frr_prefix = YLeaf(YType.str, "frr-prefix")

                                            self.frr_protocol_type = YLeaf(YType.enumeration, "frr-protocol-type")

                                            self.frr_switching_time = YLeaf(YType.uint32, "frr-switching-time")

                                            self.frr_timestamp = Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log.FrrTimestamp()
                                            self.frr_timestamp.parent = self
                                            self._children_name_map["frr_timestamp"] = "frr-timestamp"
                                            self._children_yang_names.add("frr-timestamp")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("log_index",
                                                            "bundle_member_interface_name",
                                                            "frr_interface_name",
                                                            "frr_prefix",
                                                            "frr_protocol_type",
                                                            "frr_switching_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log, self).__setattr__(name, value)


                                        class FrrTimestamp(Entity):
                                            """
                                            frr timestamp
                                            
                                            .. attribute:: nano_seconds
                                            
                                            	NanoSeconds
                                            	**type**\:  int
                                            
                                            	**range:** \-2147483648..2147483647
                                            
                                            .. attribute:: seconds
                                            
                                            	Seconds
                                            	**type**\:  int
                                            
                                            	**range:** \-2147483648..2147483647
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log.FrrTimestamp, self).__init__()

                                                self.yang_name = "frr-timestamp"
                                                self.yang_parent_name = "log"

                                                self.nano_seconds = YLeaf(YType.int32, "nano-seconds")

                                                self.seconds = YLeaf(YType.int32, "seconds")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("nano_seconds",
                                                                "seconds") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log.FrrTimestamp, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log.FrrTimestamp, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.nano_seconds.is_set or
                                                    self.seconds.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.nano_seconds.yfilter != YFilter.not_set or
                                                    self.seconds.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "frr-timestamp" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.nano_seconds.is_set or self.nano_seconds.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.nano_seconds.get_name_leafdata())
                                                if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.seconds.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "nano-seconds" or name == "seconds"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "nano-seconds"):
                                                    self.nano_seconds = value
                                                    self.nano_seconds.value_namespace = name_space
                                                    self.nano_seconds.value_namespace_prefix = name_space_prefix
                                                if(value_path == "seconds"):
                                                    self.seconds = value
                                                    self.seconds.value_namespace = name_space
                                                    self.seconds.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.log_index.is_set or
                                                self.bundle_member_interface_name.is_set or
                                                self.frr_interface_name.is_set or
                                                self.frr_prefix.is_set or
                                                self.frr_protocol_type.is_set or
                                                self.frr_switching_time.is_set or
                                                (self.frr_timestamp is not None and self.frr_timestamp.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.log_index.yfilter != YFilter.not_set or
                                                self.bundle_member_interface_name.yfilter != YFilter.not_set or
                                                self.frr_interface_name.yfilter != YFilter.not_set or
                                                self.frr_prefix.yfilter != YFilter.not_set or
                                                self.frr_protocol_type.yfilter != YFilter.not_set or
                                                self.frr_switching_time.yfilter != YFilter.not_set or
                                                (self.frr_timestamp is not None and self.frr_timestamp.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "log" + "[log-index='" + self.log_index.get() + "']" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.log_index.is_set or self.log_index.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.log_index.get_name_leafdata())
                                            if (self.bundle_member_interface_name.is_set or self.bundle_member_interface_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bundle_member_interface_name.get_name_leafdata())
                                            if (self.frr_interface_name.is_set or self.frr_interface_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.frr_interface_name.get_name_leafdata())
                                            if (self.frr_prefix.is_set or self.frr_prefix.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.frr_prefix.get_name_leafdata())
                                            if (self.frr_protocol_type.is_set or self.frr_protocol_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.frr_protocol_type.get_name_leafdata())
                                            if (self.frr_switching_time.is_set or self.frr_switching_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.frr_switching_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "frr-timestamp"):
                                                if (self.frr_timestamp is None):
                                                    self.frr_timestamp = Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log.FrrTimestamp()
                                                    self.frr_timestamp.parent = self
                                                    self._children_name_map["frr_timestamp"] = "frr-timestamp"
                                                return self.frr_timestamp

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "frr-timestamp" or name == "log-index" or name == "bundle-member-interface-name" or name == "frr-interface-name" or name == "frr-prefix" or name == "frr-protocol-type" or name == "frr-switching-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "log-index"):
                                                self.log_index = value
                                                self.log_index.value_namespace = name_space
                                                self.log_index.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bundle-member-interface-name"):
                                                self.bundle_member_interface_name = value
                                                self.bundle_member_interface_name.value_namespace = name_space
                                                self.bundle_member_interface_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "frr-interface-name"):
                                                self.frr_interface_name = value
                                                self.frr_interface_name.value_namespace = name_space
                                                self.frr_interface_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "frr-prefix"):
                                                self.frr_prefix = value
                                                self.frr_prefix.value_namespace = name_space
                                                self.frr_prefix.value_namespace_prefix = name_space_prefix
                                            if(value_path == "frr-protocol-type"):
                                                self.frr_protocol_type = value
                                                self.frr_protocol_type.value_namespace = name_space
                                                self.frr_protocol_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "frr-switching-time"):
                                                self.frr_switching_time = value
                                                self.frr_switching_time.value_namespace = name_space
                                                self.frr_switching_time.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.log:
                                            if (c.has_data()):
                                                return True
                                        return False

                                    def has_operation(self):
                                        for c in self.log:
                                            if (c.has_operation()):
                                                return True
                                        return self.yfilter != YFilter.not_set

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "logs" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "log"):
                                            for c in self.log:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs.Log()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.log.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "log"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass

                                def has_data(self):
                                    return (
                                        self.frr_interface_name.is_set or
                                        (self.logs is not None and self.logs.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.frr_interface_name.yfilter != YFilter.not_set or
                                        (self.logs is not None and self.logs.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-interface" + "[frr-interface-name='" + self.frr_interface_name.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.frr_interface_name.is_set or self.frr_interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.frr_interface_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "logs"):
                                        if (self.logs is None):
                                            self.logs = Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface.Logs()
                                            self.logs.parent = self
                                            self._children_name_map["logs"] = "logs"
                                        return self.logs

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "logs" or name == "frr-interface-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "frr-interface-name"):
                                        self.frr_interface_name = value
                                        self.frr_interface_name.value_namespace = name_space
                                        self.frr_interface_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.frr_interface:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.frr_interface:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "frr-interfaces" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "frr-interface"):
                                    for c in self.frr_interface:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces.FrrInterface()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.frr_interface.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "frr-interface"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.frr_interfaces is not None and self.frr_interfaces.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.frr_interfaces is not None and self.frr_interfaces.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "frr-log" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "frr-interfaces"):
                                if (self.frr_interfaces is None):
                                    self.frr_interfaces = Fib.Nodes.Node.Protocols.Protocol.FrrLog.FrrInterfaces()
                                    self.frr_interfaces.parent = self
                                    self._children_name_map["frr_interfaces"] = "frr-interfaces"
                                return self.frr_interfaces

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "frr-interfaces"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Vrfs(Entity):
                        """
                        VRF table
                        
                        .. attribute:: vrf
                        
                        	VRF table entry
                        	**type**\: list of    :py:class:`Vrf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs, self).__init__()

                            self.yang_name = "vrfs"
                            self.yang_parent_name = "protocol"

                            self.vrf = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs, self).__setattr__(name, value)


                        class Vrf(Entity):
                            """
                            VRF table entry
                            
                            .. attribute:: vrf_name  <key>
                            
                            	VRF Name
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: interface_infos
                            
                            	Table of InterfaceInfo
                            	**type**\:   :py:class:`InterfaceInfos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos>`
                            
                            .. attribute:: ip_prefix_briefs
                            
                            	IP FIB prefix brief table
                            	**type**\:   :py:class:`IpPrefixBriefs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs>`
                            
                            .. attribute:: ip_prefix_details
                            
                            	IP FIB prefix detail table
                            	**type**\:   :py:class:`IpPrefixDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails>`
                            
                            .. attribute:: summary
                            
                            	Operational data for FIB Tablee
                            	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary>`
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf, self).__init__()

                                self.yang_name = "vrf"
                                self.yang_parent_name = "vrfs"

                                self.vrf_name = YLeaf(YType.str, "vrf-name")

                                self.interface_infos = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos()
                                self.interface_infos.parent = self
                                self._children_name_map["interface_infos"] = "interface-infos"
                                self._children_yang_names.add("interface-infos")

                                self.ip_prefix_briefs = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs()
                                self.ip_prefix_briefs.parent = self
                                self._children_name_map["ip_prefix_briefs"] = "ip-prefix-briefs"
                                self._children_yang_names.add("ip-prefix-briefs")

                                self.ip_prefix_details = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails()
                                self.ip_prefix_details.parent = self
                                self._children_name_map["ip_prefix_details"] = "ip-prefix-details"
                                self._children_yang_names.add("ip-prefix-details")

                                self.summary = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary()
                                self.summary.parent = self
                                self._children_name_map["summary"] = "summary"
                                self._children_yang_names.add("summary")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("vrf_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf, self).__setattr__(name, value)


                            class IpPrefixDetails(Entity):
                                """
                                IP FIB prefix detail table
                                
                                .. attribute:: ip_prefix_detail
                                
                                	IP FIB prefix detail table entry
                                	**type**\: list of    :py:class:`IpPrefixDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail>`
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails, self).__init__()

                                    self.yang_name = "ip-prefix-details"
                                    self.yang_parent_name = "vrf"

                                    self.ip_prefix_detail = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails, self).__setattr__(name, value)


                                class IpPrefixDetail(Entity):
                                    """
                                    IP FIB prefix detail table entry
                                    
                                    .. attribute:: broadcast_forward_flag
                                    
                                    	Broadcast forward flag
                                    	**type**\:  bool
                                    
                                    .. attribute:: broadcast_recive_flag
                                    
                                    	Broadcast receive flag
                                    	**type**\:  bool
                                    
                                    .. attribute:: detail_fib_entry_information
                                    
                                    	Detailed FIB entry information
                                    	**type**\:   :py:class:`DetailFibEntryInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation>`
                                    
                                    .. attribute:: dummy_real_zero_route
                                    
                                    	Dummy real zero route
                                    	**type**\:  bool
                                    
                                    .. attribute:: exact_route_result
                                    
                                    	exact\-route result
                                    	**type**\:  bool
                                    
                                    .. attribute:: extension_object
                                    
                                    	Leaf Extension Object List
                                    	**type**\: list of    :py:class:`ExtensionObject <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject>`
                                    
                                    .. attribute:: external_switch_triggered
                                    
                                    	External switch function triggered
                                    	**type**\:  bool
                                    
                                    .. attribute:: fib_entry_path
                                    
                                    	FIB entry path details
                                    	**type**\:   :py:class:`FibEntryPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath>`
                                    
                                    .. attribute:: fib_route_download_priority
                                    
                                    	Priority at which the route was downloaded
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: flags_external_ldi
                                    
                                    	The flags of ext assocaited with LDI 
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: l2_subscriber_ip_protocol
                                    
                                    	IP protocol associated with L2 subscriber
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: l2_subscriber_route
                                    
                                    	Is L2 Subscriber route
                                    	**type**\:  bool
                                    
                                    .. attribute:: l2_subscriber_xconnect_id
                                    
                                    	XConnect\-id associated with L2 subscriber
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: l2tpv3_cookie_length_bits
                                    
                                    	L2TPv3 cookie length for L2 subscriber
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: ldi_flags
                                    
                                    	The LDI flags
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: ldi_lw_flag
                                    
                                    	The LDI LW flags
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: lspa_flags
                                    
                                    	The LSPA flags
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: number_of_referances_to_ldi
                                    
                                    	Number of references to the LDI
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: number_of_referances_to_path_list
                                    
                                    	Number of references to the pathlist
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: packet_should_recieve
                                    
                                    	Packet should always be received
                                    	**type**\:  bool
                                    
                                    .. attribute:: path_list_flags
                                    
                                    	The pathlist flags
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: path_list_source
                                    
                                    	The pathlist source
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: platform_hardware
                                    
                                    	Platform Hardware info
                                    	**type**\:  str
                                    
                                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                    
                                    .. attribute:: prefix
                                    
                                    	Destination IP address
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: prefix_connected
                                    
                                    	Prefix is connected
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_for_adjancency
                                    
                                    	Prefix is for an adjacency
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_for_pic_next_hop
                                    
                                    	Prefix is for a PIC nexthop
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_is_static_or_connected
                                    
                                    	Prefix is static or connected
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_length
                                    
                                    	IP prefix length
                                    	**type**\:  int
                                    
                                    	**range:** 0..128
                                    
                                    .. attribute:: protocol_type_fib_entry
                                    
                                    	Proto type for this entry
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: purgable_after_purge_interval
                                    
                                    	Purgable after the purge interval
                                    	**type**\:  bool
                                    
                                    .. attribute:: ref_counter_of_ldi_lw_ldi
                                    
                                    	The refcounter of LDI LW LDI
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: route_attribute_flag
                                    
                                    	Route attributes summary flag
                                    	**type**\:  bool
                                    
                                    .. attribute:: route_for_external_reach_linecard_flag
                                    
                                    	Route destined for Line Card that support External Reach only
                                    	**type**\:  bool
                                    
                                    .. attribute:: route_is_sr_flag
                                    
                                    	Route is a MPLS Segment\-Routing prefix
                                    	**type**\:  bool
                                    
                                    .. attribute:: srv6_information
                                    
                                    	Information about IPv6 SR prefix
                                    	**type**\:   :py:class:`Srv6Information <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information>`
                                    
                                    .. attribute:: time_of_last_update_in_msec
                                    
                                    	The time of last update in msec
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: type_of_ldi_lw_ldi
                                    
                                    	The type of LDI LW LDI
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: version_of_route
                                    
                                    	The version of the route
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: zero_by_zero_route_as_default
                                    
                                    	0/0 route added as default route
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail, self).__init__()

                                        self.yang_name = "ip-prefix-detail"
                                        self.yang_parent_name = "ip-prefix-details"

                                        self.broadcast_forward_flag = YLeaf(YType.boolean, "broadcast-forward-flag")

                                        self.broadcast_recive_flag = YLeaf(YType.boolean, "broadcast-recive-flag")

                                        self.dummy_real_zero_route = YLeaf(YType.boolean, "dummy-real-zero-route")

                                        self.exact_route_result = YLeaf(YType.boolean, "exact-route-result")

                                        self.external_switch_triggered = YLeaf(YType.boolean, "external-switch-triggered")

                                        self.fib_route_download_priority = YLeaf(YType.uint32, "fib-route-download-priority")

                                        self.flags_external_ldi = YLeaf(YType.uint32, "flags-external-ldi")

                                        self.l2_subscriber_ip_protocol = YLeaf(YType.uint32, "l2-subscriber-ip-protocol")

                                        self.l2_subscriber_route = YLeaf(YType.boolean, "l2-subscriber-route")

                                        self.l2_subscriber_xconnect_id = YLeaf(YType.uint32, "l2-subscriber-xconnect-id")

                                        self.l2tpv3_cookie_length_bits = YLeaf(YType.uint32, "l2tpv3-cookie-length-bits")

                                        self.ldi_flags = YLeaf(YType.uint32, "ldi-flags")

                                        self.ldi_lw_flag = YLeaf(YType.uint32, "ldi-lw-flag")

                                        self.lspa_flags = YLeaf(YType.uint32, "lspa-flags")

                                        self.number_of_referances_to_ldi = YLeaf(YType.uint32, "number-of-referances-to-ldi")

                                        self.number_of_referances_to_path_list = YLeaf(YType.uint32, "number-of-referances-to-path-list")

                                        self.packet_should_recieve = YLeaf(YType.boolean, "packet-should-recieve")

                                        self.path_list_flags = YLeaf(YType.uint32, "path-list-flags")

                                        self.path_list_source = YLeaf(YType.uint32, "path-list-source")

                                        self.platform_hardware = YLeaf(YType.str, "platform-hardware")

                                        self.prefix = YLeaf(YType.str, "prefix")

                                        self.prefix_connected = YLeaf(YType.boolean, "prefix-connected")

                                        self.prefix_for_adjancency = YLeaf(YType.boolean, "prefix-for-adjancency")

                                        self.prefix_for_pic_next_hop = YLeaf(YType.boolean, "prefix-for-pic-next-hop")

                                        self.prefix_is_static_or_connected = YLeaf(YType.boolean, "prefix-is-static-or-connected")

                                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                        self.protocol_type_fib_entry = YLeaf(YType.uint32, "protocol-type-fib-entry")

                                        self.purgable_after_purge_interval = YLeaf(YType.boolean, "purgable-after-purge-interval")

                                        self.ref_counter_of_ldi_lw_ldi = YLeaf(YType.uint32, "ref-counter-of-ldi-lw-ldi")

                                        self.route_attribute_flag = YLeaf(YType.boolean, "route-attribute-flag")

                                        self.route_for_external_reach_linecard_flag = YLeaf(YType.boolean, "route-for-external-reach-linecard-flag")

                                        self.route_is_sr_flag = YLeaf(YType.boolean, "route-is-sr-flag")

                                        self.time_of_last_update_in_msec = YLeaf(YType.uint64, "time-of-last-update-in-msec")

                                        self.type_of_ldi_lw_ldi = YLeaf(YType.uint32, "type-of-ldi-lw-ldi")

                                        self.version_of_route = YLeaf(YType.uint64, "version-of-route")

                                        self.zero_by_zero_route_as_default = YLeaf(YType.boolean, "zero-by-zero-route-as-default")

                                        self.detail_fib_entry_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation()
                                        self.detail_fib_entry_information.parent = self
                                        self._children_name_map["detail_fib_entry_information"] = "detail-fib-entry-information"
                                        self._children_yang_names.add("detail-fib-entry-information")

                                        self.fib_entry_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath()
                                        self.fib_entry_path.parent = self
                                        self._children_name_map["fib_entry_path"] = "fib-entry-path"
                                        self._children_yang_names.add("fib-entry-path")

                                        self.srv6_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information()
                                        self.srv6_information.parent = self
                                        self._children_name_map["srv6_information"] = "srv6-information"
                                        self._children_yang_names.add("srv6-information")

                                        self.extension_object = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("broadcast_forward_flag",
                                                        "broadcast_recive_flag",
                                                        "dummy_real_zero_route",
                                                        "exact_route_result",
                                                        "external_switch_triggered",
                                                        "fib_route_download_priority",
                                                        "flags_external_ldi",
                                                        "l2_subscriber_ip_protocol",
                                                        "l2_subscriber_route",
                                                        "l2_subscriber_xconnect_id",
                                                        "l2tpv3_cookie_length_bits",
                                                        "ldi_flags",
                                                        "ldi_lw_flag",
                                                        "lspa_flags",
                                                        "number_of_referances_to_ldi",
                                                        "number_of_referances_to_path_list",
                                                        "packet_should_recieve",
                                                        "path_list_flags",
                                                        "path_list_source",
                                                        "platform_hardware",
                                                        "prefix",
                                                        "prefix_connected",
                                                        "prefix_for_adjancency",
                                                        "prefix_for_pic_next_hop",
                                                        "prefix_is_static_or_connected",
                                                        "prefix_length",
                                                        "protocol_type_fib_entry",
                                                        "purgable_after_purge_interval",
                                                        "ref_counter_of_ldi_lw_ldi",
                                                        "route_attribute_flag",
                                                        "route_for_external_reach_linecard_flag",
                                                        "route_is_sr_flag",
                                                        "time_of_last_update_in_msec",
                                                        "type_of_ldi_lw_ldi",
                                                        "version_of_route",
                                                        "zero_by_zero_route_as_default") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail, self).__setattr__(name, value)


                                    class DetailFibEntryInformation(Entity):
                                        """
                                        Detailed FIB entry information
                                        
                                        .. attribute:: adjacency_address_length
                                        
                                        	ADJ ADDR LEN
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: adjacency_interface
                                        
                                        	ADJ IFH
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: afi_fib_protocol_type
                                        
                                        	AFI FIB protocol type
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: aib_l3_address
                                        
                                        	AIB L3 Address
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: bgp_attribute_id
                                        
                                        	BGP attribute id
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: bgp_attribute_next_hop_as
                                        
                                        	BGP attribute next hop as
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: bgp_attribute_origin_as
                                        
                                        	BGP attribute origin as
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: bgp_local_attribute_id
                                        
                                        	BGP local attribute id
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: bytes_through_fib_entry
                                        
                                        	Bytes through this FIB entry
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        	**units**\: byte
                                        
                                        .. attribute:: com_string
                                        
                                        	com st
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: detailed_prefix_length
                                        
                                        	Prefix length
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: extcom_string
                                        
                                        	extcom st
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: extended_community
                                        
                                        	extended community
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: fast_adjacency_flag
                                        
                                        	Fast adjacency flag
                                        	**type**\:  bool
                                        
                                        .. attribute:: fib_entry_adjacency_address
                                        
                                        	FIB entry adj address
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: fib_entry_adjacency_interface
                                        
                                        	FIB entry adjacency interface
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: fib_entry_adjacency_type
                                        
                                        	FIB entry adjacency type
                                        	**type**\:   :py:class:`FibAdjacencyShow <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibAdjacencyShow>`
                                        
                                        .. attribute:: fib_entry_version
                                        
                                        	FIB entry version number
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: fib_protocol_type
                                        
                                        	FIB Protocol type
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: fib_special_nh_information_type
                                        
                                        	FIB Special NHINFO Type
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: flow_tag
                                        
                                        	PBR flow\-tag
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: forward_class
                                        
                                        	SPP forwarding class ID
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: illegal_fast_adjacency_flag
                                        
                                        	Illegal fast adjacency flag
                                        	**type**\:  bool
                                        
                                        .. attribute:: ldi_time_of_last_update_in_msec
                                        
                                        	The time of last update for LDI in msec
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: load_sharing_type
                                        
                                        	Load sharing type
                                        	**type**\:   :py:class:`FibLoadshareShow <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibLoadshareShow>`
                                        
                                        .. attribute:: loadshare_information
                                        
                                        	Detailed Loadshare info
                                        	**type**\:   :py:class:`LoadshareInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation>`
                                        
                                        .. attribute:: lwldi_time_of_last_update_in_msec
                                        
                                        	The time of last update for LW\-LDI in msec
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: mpls_fec
                                        
                                        	mpls fec
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: packets_through_fib_entry
                                        
                                        	Packets through this FIB entry
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: path_string
                                        
                                        	As path string
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: per_prefix_accounting
                                        
                                        	Per Prefix Accounting
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: pl_time_of_last_update_in_msec
                                        
                                        	The time of last update for PL in msec
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: pl_time_stamp_type
                                        
                                        	The type of time\-stamp on PL
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: precedence_forpackets
                                        
                                        	Precedence for packets to this entry
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: prefix_protocol
                                        
                                        	Prefix protocol
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: qos_group
                                        
                                        	qos group
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: qppb_qos_group_and_ip_precedence
                                        
                                        	qppb QOS group and IP precedence
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: remote_adjacency_flag
                                        
                                        	Remote adjacency flag
                                        	**type**\:  bool
                                        
                                        .. attribute:: switch_compontent_id
                                        
                                        	Switch function compontent ID
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: traffic_index_for_packets
                                        
                                        	Traffic index for packets to this entry
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation, self).__init__()

                                            self.yang_name = "detail-fib-entry-information"
                                            self.yang_parent_name = "ip-prefix-detail"

                                            self.adjacency_address_length = YLeaf(YType.uint32, "adjacency-address-length")

                                            self.adjacency_interface = YLeaf(YType.uint32, "adjacency-interface")

                                            self.afi_fib_protocol_type = YLeaf(YType.uint32, "afi-fib-protocol-type")

                                            self.aib_l3_address = YLeaf(YType.str, "aib-l3-address")

                                            self.bgp_attribute_id = YLeaf(YType.uint32, "bgp-attribute-id")

                                            self.bgp_attribute_next_hop_as = YLeaf(YType.uint32, "bgp-attribute-next-hop-as")

                                            self.bgp_attribute_origin_as = YLeaf(YType.uint32, "bgp-attribute-origin-as")

                                            self.bgp_local_attribute_id = YLeaf(YType.uint32, "bgp-local-attribute-id")

                                            self.bytes_through_fib_entry = YLeaf(YType.uint64, "bytes-through-fib-entry")

                                            self.com_string = YLeaf(YType.str, "com-string")

                                            self.detailed_prefix_length = YLeaf(YType.uint32, "detailed-prefix-length")

                                            self.extcom_string = YLeaf(YType.str, "extcom-string")

                                            self.extended_community = YLeaf(YType.uint32, "extended-community")

                                            self.fast_adjacency_flag = YLeaf(YType.boolean, "fast-adjacency-flag")

                                            self.fib_entry_adjacency_address = YLeaf(YType.str, "fib-entry-adjacency-address")

                                            self.fib_entry_adjacency_interface = YLeaf(YType.uint32, "fib-entry-adjacency-interface")

                                            self.fib_entry_adjacency_type = YLeaf(YType.enumeration, "fib-entry-adjacency-type")

                                            self.fib_entry_version = YLeaf(YType.uint32, "fib-entry-version")

                                            self.fib_protocol_type = YLeaf(YType.uint32, "fib-protocol-type")

                                            self.fib_special_nh_information_type = YLeaf(YType.uint32, "fib-special-nh-information-type")

                                            self.flow_tag = YLeaf(YType.uint8, "flow-tag")

                                            self.forward_class = YLeaf(YType.uint8, "forward-class")

                                            self.illegal_fast_adjacency_flag = YLeaf(YType.boolean, "illegal-fast-adjacency-flag")

                                            self.ldi_time_of_last_update_in_msec = YLeaf(YType.uint64, "ldi-time-of-last-update-in-msec")

                                            self.load_sharing_type = YLeaf(YType.enumeration, "load-sharing-type")

                                            self.lwldi_time_of_last_update_in_msec = YLeaf(YType.uint64, "lwldi-time-of-last-update-in-msec")

                                            self.mpls_fec = YLeaf(YType.uint32, "mpls-fec")

                                            self.packets_through_fib_entry = YLeaf(YType.uint64, "packets-through-fib-entry")

                                            self.path_string = YLeaf(YType.str, "path-string")

                                            self.per_prefix_accounting = YLeaf(YType.uint8, "per-prefix-accounting")

                                            self.pl_time_of_last_update_in_msec = YLeaf(YType.uint64, "pl-time-of-last-update-in-msec")

                                            self.pl_time_stamp_type = YLeaf(YType.uint32, "pl-time-stamp-type")

                                            self.precedence_forpackets = YLeaf(YType.uint8, "precedence-forpackets")

                                            self.prefix_protocol = YLeaf(YType.uint32, "prefix-protocol")

                                            self.qos_group = YLeaf(YType.uint32, "qos-group")

                                            self.qppb_qos_group_and_ip_precedence = YLeaf(YType.uint32, "qppb-qos-group-and-ip-precedence")

                                            self.remote_adjacency_flag = YLeaf(YType.boolean, "remote-adjacency-flag")

                                            self.switch_compontent_id = YLeaf(YType.uint32, "switch-compontent-id")

                                            self.traffic_index_for_packets = YLeaf(YType.uint8, "traffic-index-for-packets")

                                            self.loadshare_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation()
                                            self.loadshare_information.parent = self
                                            self._children_name_map["loadshare_information"] = "loadshare-information"
                                            self._children_yang_names.add("loadshare-information")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("adjacency_address_length",
                                                            "adjacency_interface",
                                                            "afi_fib_protocol_type",
                                                            "aib_l3_address",
                                                            "bgp_attribute_id",
                                                            "bgp_attribute_next_hop_as",
                                                            "bgp_attribute_origin_as",
                                                            "bgp_local_attribute_id",
                                                            "bytes_through_fib_entry",
                                                            "com_string",
                                                            "detailed_prefix_length",
                                                            "extcom_string",
                                                            "extended_community",
                                                            "fast_adjacency_flag",
                                                            "fib_entry_adjacency_address",
                                                            "fib_entry_adjacency_interface",
                                                            "fib_entry_adjacency_type",
                                                            "fib_entry_version",
                                                            "fib_protocol_type",
                                                            "fib_special_nh_information_type",
                                                            "flow_tag",
                                                            "forward_class",
                                                            "illegal_fast_adjacency_flag",
                                                            "ldi_time_of_last_update_in_msec",
                                                            "load_sharing_type",
                                                            "lwldi_time_of_last_update_in_msec",
                                                            "mpls_fec",
                                                            "packets_through_fib_entry",
                                                            "path_string",
                                                            "per_prefix_accounting",
                                                            "pl_time_of_last_update_in_msec",
                                                            "pl_time_stamp_type",
                                                            "precedence_forpackets",
                                                            "prefix_protocol",
                                                            "qos_group",
                                                            "qppb_qos_group_and_ip_precedence",
                                                            "remote_adjacency_flag",
                                                            "switch_compontent_id",
                                                            "traffic_index_for_packets") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation, self).__setattr__(name, value)


                                        class LoadshareInformation(Entity):
                                            """
                                            Detailed Loadshare info
                                            
                                            .. attribute:: bytes_through_load_information
                                            
                                            	Bytes through this loadinfo
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            	**units**\: byte
                                            
                                            .. attribute:: is_owner
                                            
                                            	Owner flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: load_information_owner_deleted_flag
                                            
                                            	Loadinfo owner deleted flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: load_information_reference_count
                                            
                                            	Loadinfo reference count
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            .. attribute:: load_informtion_internal_data
                                            
                                            	Loadinfo internal data
                                            	**type**\:   :py:class:`LoadInformtionInternalData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData>`
                                            
                                            .. attribute:: loadinfo_sanity_flag
                                            
                                            	Loadinfo sanity flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: mask_length_of_owner
                                            
                                            	Mask length of the owner
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: packets_through_load_information
                                            
                                            	Packets through this loadinfo
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            .. attribute:: per_dest_load_sharing_flag
                                            
                                            	Per destination load sharing flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: prefix_of_owner
                                            
                                            	Prefix of the owner
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: total_bytes_through_load_information
                                            
                                            	Total bytes through this loadinfo
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            	**units**\: byte
                                            
                                            .. attribute:: total_packets_through_load_information
                                            
                                            	Total packets through this loadinfo
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation, self).__init__()

                                                self.yang_name = "loadshare-information"
                                                self.yang_parent_name = "detail-fib-entry-information"

                                                self.bytes_through_load_information = YLeaf(YType.uint64, "bytes-through-load-information")

                                                self.is_owner = YLeaf(YType.boolean, "is-owner")

                                                self.load_information_owner_deleted_flag = YLeaf(YType.boolean, "load-information-owner-deleted-flag")

                                                self.load_information_reference_count = YLeaf(YType.uint16, "load-information-reference-count")

                                                self.loadinfo_sanity_flag = YLeaf(YType.boolean, "loadinfo-sanity-flag")

                                                self.mask_length_of_owner = YLeaf(YType.uint32, "mask-length-of-owner")

                                                self.packets_through_load_information = YLeaf(YType.uint64, "packets-through-load-information")

                                                self.per_dest_load_sharing_flag = YLeaf(YType.boolean, "per-dest-load-sharing-flag")

                                                self.prefix_of_owner = YLeaf(YType.uint32, "prefix-of-owner")

                                                self.total_bytes_through_load_information = YLeaf(YType.uint64, "total-bytes-through-load-information")

                                                self.total_packets_through_load_information = YLeaf(YType.uint64, "total-packets-through-load-information")

                                                self.load_informtion_internal_data = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData()
                                                self.load_informtion_internal_data.parent = self
                                                self._children_name_map["load_informtion_internal_data"] = "load-informtion-internal-data"
                                                self._children_yang_names.add("load-informtion-internal-data")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("bytes_through_load_information",
                                                                "is_owner",
                                                                "load_information_owner_deleted_flag",
                                                                "load_information_reference_count",
                                                                "loadinfo_sanity_flag",
                                                                "mask_length_of_owner",
                                                                "packets_through_load_information",
                                                                "per_dest_load_sharing_flag",
                                                                "prefix_of_owner",
                                                                "total_bytes_through_load_information",
                                                                "total_packets_through_load_information") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation, self).__setattr__(name, value)


                                            class LoadInformtionInternalData(Entity):
                                                """
                                                Loadinfo internal data
                                                
                                                .. attribute:: adjacency_address
                                                
                                                	Adjacency address
                                                	**type**\: list of    :py:class:`AdjacencyAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress>`
                                                
                                                .. attribute:: interface_handle
                                                
                                                	Interface handle
                                                	**type**\: list of    :py:class:`InterfaceHandle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle>`
                                                
                                                .. attribute:: is_pbts_info_valid
                                                
                                                	PBTS info valid flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: ldi_next_hop_buckets
                                                
                                                	Number of LDI next hop buckets
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: level_ofldis
                                                
                                                	level of ldis
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: maximum_index_arrays
                                                
                                                	Maximum index of the arrays
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: maximum_slots
                                                
                                                	Maximum slots
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: normalized_weights
                                                
                                                	Normalized weights
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: number_of_ldis
                                                
                                                	no. of ldis
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: path_indices
                                                
                                                	Path indices
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: path_ldi_numbers
                                                
                                                	Path indices
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: pbts_class_is_fallback_mapped
                                                
                                                	Does PBTS class fall back to drop or any class
                                                	**type**\: list of    :py:class:`PbtsClassIsFallbackMapped <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped>`
                                                
                                                .. attribute:: pbts_class_num_paths
                                                
                                                	PBTS class num paths
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: pbts_class_offset
                                                
                                                	PBTS class offset
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: pbts_fallback_mapped_class
                                                
                                                	PBTS class falls back to class
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: pbts_fallback_to_drop
                                                
                                                	PBTS class falls back to drop
                                                	**type**\: list of    :py:class:`PbtsFallbackToDrop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop>`
                                                
                                                .. attribute:: platform_hardware_information
                                                
                                                	Platform Hardware info
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: round_robin_disable
                                                
                                                	Round Robin Disable
                                                	**type**\:  bool
                                                
                                                .. attribute:: sanity_flag
                                                
                                                	Sanity flag
                                                	**type**\: list of    :py:class:`SanityFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag>`
                                                
                                                .. attribute:: tunnel_class_value
                                                
                                                	Tunnel class value
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: tunnel_is_forward_class
                                                
                                                	Tunnel is forward class
                                                	**type**\: list of    :py:class:`TunnelIsForwardClass <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass>`
                                                
                                                .. attribute:: weights_of_path
                                                
                                                	Weights of paths
                                                	**type**\: list of    :py:class:`WeightsOfPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath>`
                                                
                                                

                                                """

                                                _prefix = 'fib-common-oper'
                                                _revision = '2017-01-20'

                                                def __init__(self):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData, self).__init__()

                                                    self.yang_name = "load-informtion-internal-data"
                                                    self.yang_parent_name = "loadshare-information"

                                                    self.is_pbts_info_valid = YLeaf(YType.boolean, "is-pbts-info-valid")

                                                    self.ldi_next_hop_buckets = YLeaf(YType.uint8, "ldi-next-hop-buckets")

                                                    self.level_ofldis = YLeaf(YType.uint8, "level-ofldis")

                                                    self.maximum_index_arrays = YLeaf(YType.uint32, "maximum-index-arrays")

                                                    self.maximum_slots = YLeaf(YType.uint32, "maximum-slots")

                                                    self.normalized_weights = YLeaf(YType.str, "normalized-weights")

                                                    self.number_of_ldis = YLeaf(YType.uint8, "number-of-ldis")

                                                    self.path_indices = YLeaf(YType.str, "path-indices")

                                                    self.path_ldi_numbers = YLeaf(YType.str, "path-ldi-numbers")

                                                    self.pbts_class_num_paths = YLeaf(YType.str, "pbts-class-num-paths")

                                                    self.pbts_class_offset = YLeaf(YType.str, "pbts-class-offset")

                                                    self.pbts_fallback_mapped_class = YLeaf(YType.str, "pbts-fallback-mapped-class")

                                                    self.platform_hardware_information = YLeaf(YType.str, "platform-hardware-information")

                                                    self.round_robin_disable = YLeaf(YType.boolean, "round-robin-disable")

                                                    self.tunnel_class_value = YLeaf(YType.str, "tunnel-class-value")

                                                    self.adjacency_address = YList(self)
                                                    self.interface_handle = YList(self)
                                                    self.pbts_class_is_fallback_mapped = YList(self)
                                                    self.pbts_fallback_to_drop = YList(self)
                                                    self.sanity_flag = YList(self)
                                                    self.tunnel_is_forward_class = YList(self)
                                                    self.weights_of_path = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("is_pbts_info_valid",
                                                                    "ldi_next_hop_buckets",
                                                                    "level_ofldis",
                                                                    "maximum_index_arrays",
                                                                    "maximum_slots",
                                                                    "normalized_weights",
                                                                    "number_of_ldis",
                                                                    "path_indices",
                                                                    "path_ldi_numbers",
                                                                    "pbts_class_num_paths",
                                                                    "pbts_class_offset",
                                                                    "pbts_fallback_mapped_class",
                                                                    "platform_hardware_information",
                                                                    "round_robin_disable",
                                                                    "tunnel_class_value") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData, self).__setattr__(name, value)


                                                class SanityFlag(Entity):
                                                    """
                                                    Sanity flag
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	
                                                    	**type**\:  bool
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag, self).__init__()

                                                        self.yang_name = "sanity-flag"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.boolean, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "sanity-flag" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class InterfaceHandle(Entity):
                                                    """
                                                    Interface handle
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle, self).__init__()

                                                        self.yang_name = "interface-handle"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.str, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "interface-handle" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class WeightsOfPath(Entity):
                                                    """
                                                    Weights of paths
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath, self).__init__()

                                                        self.yang_name = "weights-of-path"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.uint32, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "weights-of-path" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class AdjacencyAddress(Entity):
                                                    """
                                                    Adjacency address
                                                    
                                                    .. attribute:: address
                                                    
                                                    	address
                                                    	**type**\:  str
                                                    
                                                    	**length:** 0..60
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress, self).__init__()

                                                        self.yang_name = "adjacency-address"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.address = YLeaf(YType.str, "address")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("address") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.address.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.address.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "adjacency-address" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.address.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "address"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "address"):
                                                            self.address = value
                                                            self.address.value_namespace = name_space
                                                            self.address.value_namespace_prefix = name_space_prefix


                                                class PbtsClassIsFallbackMapped(Entity):
                                                    """
                                                    Does PBTS class fall back to drop or any class
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	Array entry
                                                    	**type**\:  bool
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped, self).__init__()

                                                        self.yang_name = "pbts-class-is-fallback-mapped"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.boolean, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "pbts-class-is-fallback-mapped" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class PbtsFallbackToDrop(Entity):
                                                    """
                                                    PBTS class falls back to drop
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	Array entry
                                                    	**type**\:  bool
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop, self).__init__()

                                                        self.yang_name = "pbts-fallback-to-drop"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.boolean, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "pbts-fallback-to-drop" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class TunnelIsForwardClass(Entity):
                                                    """
                                                    Tunnel is forward class
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	Array entry
                                                    	**type**\:  bool
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass, self).__init__()

                                                        self.yang_name = "tunnel-is-forward-class"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.boolean, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "tunnel-is-forward-class" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.adjacency_address:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.interface_handle:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.pbts_class_is_fallback_mapped:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.pbts_fallback_to_drop:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.sanity_flag:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.tunnel_is_forward_class:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.weights_of_path:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.is_pbts_info_valid.is_set or
                                                        self.ldi_next_hop_buckets.is_set or
                                                        self.level_ofldis.is_set or
                                                        self.maximum_index_arrays.is_set or
                                                        self.maximum_slots.is_set or
                                                        self.normalized_weights.is_set or
                                                        self.number_of_ldis.is_set or
                                                        self.path_indices.is_set or
                                                        self.path_ldi_numbers.is_set or
                                                        self.pbts_class_num_paths.is_set or
                                                        self.pbts_class_offset.is_set or
                                                        self.pbts_fallback_mapped_class.is_set or
                                                        self.platform_hardware_information.is_set or
                                                        self.round_robin_disable.is_set or
                                                        self.tunnel_class_value.is_set)

                                                def has_operation(self):
                                                    for c in self.adjacency_address:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.interface_handle:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.pbts_class_is_fallback_mapped:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.pbts_fallback_to_drop:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.sanity_flag:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.tunnel_is_forward_class:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.weights_of_path:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.is_pbts_info_valid.yfilter != YFilter.not_set or
                                                        self.ldi_next_hop_buckets.yfilter != YFilter.not_set or
                                                        self.level_ofldis.yfilter != YFilter.not_set or
                                                        self.maximum_index_arrays.yfilter != YFilter.not_set or
                                                        self.maximum_slots.yfilter != YFilter.not_set or
                                                        self.normalized_weights.yfilter != YFilter.not_set or
                                                        self.number_of_ldis.yfilter != YFilter.not_set or
                                                        self.path_indices.yfilter != YFilter.not_set or
                                                        self.path_ldi_numbers.yfilter != YFilter.not_set or
                                                        self.pbts_class_num_paths.yfilter != YFilter.not_set or
                                                        self.pbts_class_offset.yfilter != YFilter.not_set or
                                                        self.pbts_fallback_mapped_class.yfilter != YFilter.not_set or
                                                        self.platform_hardware_information.yfilter != YFilter.not_set or
                                                        self.round_robin_disable.yfilter != YFilter.not_set or
                                                        self.tunnel_class_value.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "load-informtion-internal-data" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.is_pbts_info_valid.is_set or self.is_pbts_info_valid.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.is_pbts_info_valid.get_name_leafdata())
                                                    if (self.ldi_next_hop_buckets.is_set or self.ldi_next_hop_buckets.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.ldi_next_hop_buckets.get_name_leafdata())
                                                    if (self.level_ofldis.is_set or self.level_ofldis.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.level_ofldis.get_name_leafdata())
                                                    if (self.maximum_index_arrays.is_set or self.maximum_index_arrays.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.maximum_index_arrays.get_name_leafdata())
                                                    if (self.maximum_slots.is_set or self.maximum_slots.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.maximum_slots.get_name_leafdata())
                                                    if (self.normalized_weights.is_set or self.normalized_weights.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.normalized_weights.get_name_leafdata())
                                                    if (self.number_of_ldis.is_set or self.number_of_ldis.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.number_of_ldis.get_name_leafdata())
                                                    if (self.path_indices.is_set or self.path_indices.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.path_indices.get_name_leafdata())
                                                    if (self.path_ldi_numbers.is_set or self.path_ldi_numbers.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.path_ldi_numbers.get_name_leafdata())
                                                    if (self.pbts_class_num_paths.is_set or self.pbts_class_num_paths.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.pbts_class_num_paths.get_name_leafdata())
                                                    if (self.pbts_class_offset.is_set or self.pbts_class_offset.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.pbts_class_offset.get_name_leafdata())
                                                    if (self.pbts_fallback_mapped_class.is_set or self.pbts_fallback_mapped_class.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.pbts_fallback_mapped_class.get_name_leafdata())
                                                    if (self.platform_hardware_information.is_set or self.platform_hardware_information.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.platform_hardware_information.get_name_leafdata())
                                                    if (self.round_robin_disable.is_set or self.round_robin_disable.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.round_robin_disable.get_name_leafdata())
                                                    if (self.tunnel_class_value.is_set or self.tunnel_class_value.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.tunnel_class_value.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "adjacency-address"):
                                                        for c in self.adjacency_address:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.adjacency_address.append(c)
                                                        return c

                                                    if (child_yang_name == "interface-handle"):
                                                        for c in self.interface_handle:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.interface_handle.append(c)
                                                        return c

                                                    if (child_yang_name == "pbts-class-is-fallback-mapped"):
                                                        for c in self.pbts_class_is_fallback_mapped:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.pbts_class_is_fallback_mapped.append(c)
                                                        return c

                                                    if (child_yang_name == "pbts-fallback-to-drop"):
                                                        for c in self.pbts_fallback_to_drop:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.pbts_fallback_to_drop.append(c)
                                                        return c

                                                    if (child_yang_name == "sanity-flag"):
                                                        for c in self.sanity_flag:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.sanity_flag.append(c)
                                                        return c

                                                    if (child_yang_name == "tunnel-is-forward-class"):
                                                        for c in self.tunnel_is_forward_class:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.tunnel_is_forward_class.append(c)
                                                        return c

                                                    if (child_yang_name == "weights-of-path"):
                                                        for c in self.weights_of_path:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.weights_of_path.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "adjacency-address" or name == "interface-handle" or name == "pbts-class-is-fallback-mapped" or name == "pbts-fallback-to-drop" or name == "sanity-flag" or name == "tunnel-is-forward-class" or name == "weights-of-path" or name == "is-pbts-info-valid" or name == "ldi-next-hop-buckets" or name == "level-ofldis" or name == "maximum-index-arrays" or name == "maximum-slots" or name == "normalized-weights" or name == "number-of-ldis" or name == "path-indices" or name == "path-ldi-numbers" or name == "pbts-class-num-paths" or name == "pbts-class-offset" or name == "pbts-fallback-mapped-class" or name == "platform-hardware-information" or name == "round-robin-disable" or name == "tunnel-class-value"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "is-pbts-info-valid"):
                                                        self.is_pbts_info_valid = value
                                                        self.is_pbts_info_valid.value_namespace = name_space
                                                        self.is_pbts_info_valid.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "ldi-next-hop-buckets"):
                                                        self.ldi_next_hop_buckets = value
                                                        self.ldi_next_hop_buckets.value_namespace = name_space
                                                        self.ldi_next_hop_buckets.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "level-ofldis"):
                                                        self.level_ofldis = value
                                                        self.level_ofldis.value_namespace = name_space
                                                        self.level_ofldis.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "maximum-index-arrays"):
                                                        self.maximum_index_arrays = value
                                                        self.maximum_index_arrays.value_namespace = name_space
                                                        self.maximum_index_arrays.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "maximum-slots"):
                                                        self.maximum_slots = value
                                                        self.maximum_slots.value_namespace = name_space
                                                        self.maximum_slots.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "normalized-weights"):
                                                        self.normalized_weights = value
                                                        self.normalized_weights.value_namespace = name_space
                                                        self.normalized_weights.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "number-of-ldis"):
                                                        self.number_of_ldis = value
                                                        self.number_of_ldis.value_namespace = name_space
                                                        self.number_of_ldis.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "path-indices"):
                                                        self.path_indices = value
                                                        self.path_indices.value_namespace = name_space
                                                        self.path_indices.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "path-ldi-numbers"):
                                                        self.path_ldi_numbers = value
                                                        self.path_ldi_numbers.value_namespace = name_space
                                                        self.path_ldi_numbers.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "pbts-class-num-paths"):
                                                        self.pbts_class_num_paths = value
                                                        self.pbts_class_num_paths.value_namespace = name_space
                                                        self.pbts_class_num_paths.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "pbts-class-offset"):
                                                        self.pbts_class_offset = value
                                                        self.pbts_class_offset.value_namespace = name_space
                                                        self.pbts_class_offset.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "pbts-fallback-mapped-class"):
                                                        self.pbts_fallback_mapped_class = value
                                                        self.pbts_fallback_mapped_class.value_namespace = name_space
                                                        self.pbts_fallback_mapped_class.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "platform-hardware-information"):
                                                        self.platform_hardware_information = value
                                                        self.platform_hardware_information.value_namespace = name_space
                                                        self.platform_hardware_information.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "round-robin-disable"):
                                                        self.round_robin_disable = value
                                                        self.round_robin_disable.value_namespace = name_space
                                                        self.round_robin_disable.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "tunnel-class-value"):
                                                        self.tunnel_class_value = value
                                                        self.tunnel_class_value.value_namespace = name_space
                                                        self.tunnel_class_value.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                return (
                                                    self.bytes_through_load_information.is_set or
                                                    self.is_owner.is_set or
                                                    self.load_information_owner_deleted_flag.is_set or
                                                    self.load_information_reference_count.is_set or
                                                    self.loadinfo_sanity_flag.is_set or
                                                    self.mask_length_of_owner.is_set or
                                                    self.packets_through_load_information.is_set or
                                                    self.per_dest_load_sharing_flag.is_set or
                                                    self.prefix_of_owner.is_set or
                                                    self.total_bytes_through_load_information.is_set or
                                                    self.total_packets_through_load_information.is_set or
                                                    (self.load_informtion_internal_data is not None and self.load_informtion_internal_data.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.bytes_through_load_information.yfilter != YFilter.not_set or
                                                    self.is_owner.yfilter != YFilter.not_set or
                                                    self.load_information_owner_deleted_flag.yfilter != YFilter.not_set or
                                                    self.load_information_reference_count.yfilter != YFilter.not_set or
                                                    self.loadinfo_sanity_flag.yfilter != YFilter.not_set or
                                                    self.mask_length_of_owner.yfilter != YFilter.not_set or
                                                    self.packets_through_load_information.yfilter != YFilter.not_set or
                                                    self.per_dest_load_sharing_flag.yfilter != YFilter.not_set or
                                                    self.prefix_of_owner.yfilter != YFilter.not_set or
                                                    self.total_bytes_through_load_information.yfilter != YFilter.not_set or
                                                    self.total_packets_through_load_information.yfilter != YFilter.not_set or
                                                    (self.load_informtion_internal_data is not None and self.load_informtion_internal_data.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "loadshare-information" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.bytes_through_load_information.is_set or self.bytes_through_load_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.bytes_through_load_information.get_name_leafdata())
                                                if (self.is_owner.is_set or self.is_owner.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.is_owner.get_name_leafdata())
                                                if (self.load_information_owner_deleted_flag.is_set or self.load_information_owner_deleted_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.load_information_owner_deleted_flag.get_name_leafdata())
                                                if (self.load_information_reference_count.is_set or self.load_information_reference_count.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.load_information_reference_count.get_name_leafdata())
                                                if (self.loadinfo_sanity_flag.is_set or self.loadinfo_sanity_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.loadinfo_sanity_flag.get_name_leafdata())
                                                if (self.mask_length_of_owner.is_set or self.mask_length_of_owner.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.mask_length_of_owner.get_name_leafdata())
                                                if (self.packets_through_load_information.is_set or self.packets_through_load_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.packets_through_load_information.get_name_leafdata())
                                                if (self.per_dest_load_sharing_flag.is_set or self.per_dest_load_sharing_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.per_dest_load_sharing_flag.get_name_leafdata())
                                                if (self.prefix_of_owner.is_set or self.prefix_of_owner.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix_of_owner.get_name_leafdata())
                                                if (self.total_bytes_through_load_information.is_set or self.total_bytes_through_load_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.total_bytes_through_load_information.get_name_leafdata())
                                                if (self.total_packets_through_load_information.is_set or self.total_packets_through_load_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.total_packets_through_load_information.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "load-informtion-internal-data"):
                                                    if (self.load_informtion_internal_data is None):
                                                        self.load_informtion_internal_data = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData()
                                                        self.load_informtion_internal_data.parent = self
                                                        self._children_name_map["load_informtion_internal_data"] = "load-informtion-internal-data"
                                                    return self.load_informtion_internal_data

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "load-informtion-internal-data" or name == "bytes-through-load-information" or name == "is-owner" or name == "load-information-owner-deleted-flag" or name == "load-information-reference-count" or name == "loadinfo-sanity-flag" or name == "mask-length-of-owner" or name == "packets-through-load-information" or name == "per-dest-load-sharing-flag" or name == "prefix-of-owner" or name == "total-bytes-through-load-information" or name == "total-packets-through-load-information"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "bytes-through-load-information"):
                                                    self.bytes_through_load_information = value
                                                    self.bytes_through_load_information.value_namespace = name_space
                                                    self.bytes_through_load_information.value_namespace_prefix = name_space_prefix
                                                if(value_path == "is-owner"):
                                                    self.is_owner = value
                                                    self.is_owner.value_namespace = name_space
                                                    self.is_owner.value_namespace_prefix = name_space_prefix
                                                if(value_path == "load-information-owner-deleted-flag"):
                                                    self.load_information_owner_deleted_flag = value
                                                    self.load_information_owner_deleted_flag.value_namespace = name_space
                                                    self.load_information_owner_deleted_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "load-information-reference-count"):
                                                    self.load_information_reference_count = value
                                                    self.load_information_reference_count.value_namespace = name_space
                                                    self.load_information_reference_count.value_namespace_prefix = name_space_prefix
                                                if(value_path == "loadinfo-sanity-flag"):
                                                    self.loadinfo_sanity_flag = value
                                                    self.loadinfo_sanity_flag.value_namespace = name_space
                                                    self.loadinfo_sanity_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "mask-length-of-owner"):
                                                    self.mask_length_of_owner = value
                                                    self.mask_length_of_owner.value_namespace = name_space
                                                    self.mask_length_of_owner.value_namespace_prefix = name_space_prefix
                                                if(value_path == "packets-through-load-information"):
                                                    self.packets_through_load_information = value
                                                    self.packets_through_load_information.value_namespace = name_space
                                                    self.packets_through_load_information.value_namespace_prefix = name_space_prefix
                                                if(value_path == "per-dest-load-sharing-flag"):
                                                    self.per_dest_load_sharing_flag = value
                                                    self.per_dest_load_sharing_flag.value_namespace = name_space
                                                    self.per_dest_load_sharing_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "prefix-of-owner"):
                                                    self.prefix_of_owner = value
                                                    self.prefix_of_owner.value_namespace = name_space
                                                    self.prefix_of_owner.value_namespace_prefix = name_space_prefix
                                                if(value_path == "total-bytes-through-load-information"):
                                                    self.total_bytes_through_load_information = value
                                                    self.total_bytes_through_load_information.value_namespace = name_space
                                                    self.total_bytes_through_load_information.value_namespace_prefix = name_space_prefix
                                                if(value_path == "total-packets-through-load-information"):
                                                    self.total_packets_through_load_information = value
                                                    self.total_packets_through_load_information.value_namespace = name_space
                                                    self.total_packets_through_load_information.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.adjacency_address_length.is_set or
                                                self.adjacency_interface.is_set or
                                                self.afi_fib_protocol_type.is_set or
                                                self.aib_l3_address.is_set or
                                                self.bgp_attribute_id.is_set or
                                                self.bgp_attribute_next_hop_as.is_set or
                                                self.bgp_attribute_origin_as.is_set or
                                                self.bgp_local_attribute_id.is_set or
                                                self.bytes_through_fib_entry.is_set or
                                                self.com_string.is_set or
                                                self.detailed_prefix_length.is_set or
                                                self.extcom_string.is_set or
                                                self.extended_community.is_set or
                                                self.fast_adjacency_flag.is_set or
                                                self.fib_entry_adjacency_address.is_set or
                                                self.fib_entry_adjacency_interface.is_set or
                                                self.fib_entry_adjacency_type.is_set or
                                                self.fib_entry_version.is_set or
                                                self.fib_protocol_type.is_set or
                                                self.fib_special_nh_information_type.is_set or
                                                self.flow_tag.is_set or
                                                self.forward_class.is_set or
                                                self.illegal_fast_adjacency_flag.is_set or
                                                self.ldi_time_of_last_update_in_msec.is_set or
                                                self.load_sharing_type.is_set or
                                                self.lwldi_time_of_last_update_in_msec.is_set or
                                                self.mpls_fec.is_set or
                                                self.packets_through_fib_entry.is_set or
                                                self.path_string.is_set or
                                                self.per_prefix_accounting.is_set or
                                                self.pl_time_of_last_update_in_msec.is_set or
                                                self.pl_time_stamp_type.is_set or
                                                self.precedence_forpackets.is_set or
                                                self.prefix_protocol.is_set or
                                                self.qos_group.is_set or
                                                self.qppb_qos_group_and_ip_precedence.is_set or
                                                self.remote_adjacency_flag.is_set or
                                                self.switch_compontent_id.is_set or
                                                self.traffic_index_for_packets.is_set or
                                                (self.loadshare_information is not None and self.loadshare_information.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.adjacency_address_length.yfilter != YFilter.not_set or
                                                self.adjacency_interface.yfilter != YFilter.not_set or
                                                self.afi_fib_protocol_type.yfilter != YFilter.not_set or
                                                self.aib_l3_address.yfilter != YFilter.not_set or
                                                self.bgp_attribute_id.yfilter != YFilter.not_set or
                                                self.bgp_attribute_next_hop_as.yfilter != YFilter.not_set or
                                                self.bgp_attribute_origin_as.yfilter != YFilter.not_set or
                                                self.bgp_local_attribute_id.yfilter != YFilter.not_set or
                                                self.bytes_through_fib_entry.yfilter != YFilter.not_set or
                                                self.com_string.yfilter != YFilter.not_set or
                                                self.detailed_prefix_length.yfilter != YFilter.not_set or
                                                self.extcom_string.yfilter != YFilter.not_set or
                                                self.extended_community.yfilter != YFilter.not_set or
                                                self.fast_adjacency_flag.yfilter != YFilter.not_set or
                                                self.fib_entry_adjacency_address.yfilter != YFilter.not_set or
                                                self.fib_entry_adjacency_interface.yfilter != YFilter.not_set or
                                                self.fib_entry_adjacency_type.yfilter != YFilter.not_set or
                                                self.fib_entry_version.yfilter != YFilter.not_set or
                                                self.fib_protocol_type.yfilter != YFilter.not_set or
                                                self.fib_special_nh_information_type.yfilter != YFilter.not_set or
                                                self.flow_tag.yfilter != YFilter.not_set or
                                                self.forward_class.yfilter != YFilter.not_set or
                                                self.illegal_fast_adjacency_flag.yfilter != YFilter.not_set or
                                                self.ldi_time_of_last_update_in_msec.yfilter != YFilter.not_set or
                                                self.load_sharing_type.yfilter != YFilter.not_set or
                                                self.lwldi_time_of_last_update_in_msec.yfilter != YFilter.not_set or
                                                self.mpls_fec.yfilter != YFilter.not_set or
                                                self.packets_through_fib_entry.yfilter != YFilter.not_set or
                                                self.path_string.yfilter != YFilter.not_set or
                                                self.per_prefix_accounting.yfilter != YFilter.not_set or
                                                self.pl_time_of_last_update_in_msec.yfilter != YFilter.not_set or
                                                self.pl_time_stamp_type.yfilter != YFilter.not_set or
                                                self.precedence_forpackets.yfilter != YFilter.not_set or
                                                self.prefix_protocol.yfilter != YFilter.not_set or
                                                self.qos_group.yfilter != YFilter.not_set or
                                                self.qppb_qos_group_and_ip_precedence.yfilter != YFilter.not_set or
                                                self.remote_adjacency_flag.yfilter != YFilter.not_set or
                                                self.switch_compontent_id.yfilter != YFilter.not_set or
                                                self.traffic_index_for_packets.yfilter != YFilter.not_set or
                                                (self.loadshare_information is not None and self.loadshare_information.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "detail-fib-entry-information" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.adjacency_address_length.is_set or self.adjacency_address_length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adjacency_address_length.get_name_leafdata())
                                            if (self.adjacency_interface.is_set or self.adjacency_interface.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adjacency_interface.get_name_leafdata())
                                            if (self.afi_fib_protocol_type.is_set or self.afi_fib_protocol_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.afi_fib_protocol_type.get_name_leafdata())
                                            if (self.aib_l3_address.is_set or self.aib_l3_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.aib_l3_address.get_name_leafdata())
                                            if (self.bgp_attribute_id.is_set or self.bgp_attribute_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bgp_attribute_id.get_name_leafdata())
                                            if (self.bgp_attribute_next_hop_as.is_set or self.bgp_attribute_next_hop_as.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bgp_attribute_next_hop_as.get_name_leafdata())
                                            if (self.bgp_attribute_origin_as.is_set or self.bgp_attribute_origin_as.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bgp_attribute_origin_as.get_name_leafdata())
                                            if (self.bgp_local_attribute_id.is_set or self.bgp_local_attribute_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bgp_local_attribute_id.get_name_leafdata())
                                            if (self.bytes_through_fib_entry.is_set or self.bytes_through_fib_entry.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bytes_through_fib_entry.get_name_leafdata())
                                            if (self.com_string.is_set or self.com_string.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.com_string.get_name_leafdata())
                                            if (self.detailed_prefix_length.is_set or self.detailed_prefix_length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.detailed_prefix_length.get_name_leafdata())
                                            if (self.extcom_string.is_set or self.extcom_string.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.extcom_string.get_name_leafdata())
                                            if (self.extended_community.is_set or self.extended_community.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.extended_community.get_name_leafdata())
                                            if (self.fast_adjacency_flag.is_set or self.fast_adjacency_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_adjacency_flag.get_name_leafdata())
                                            if (self.fib_entry_adjacency_address.is_set or self.fib_entry_adjacency_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_entry_adjacency_address.get_name_leafdata())
                                            if (self.fib_entry_adjacency_interface.is_set or self.fib_entry_adjacency_interface.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_entry_adjacency_interface.get_name_leafdata())
                                            if (self.fib_entry_adjacency_type.is_set or self.fib_entry_adjacency_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_entry_adjacency_type.get_name_leafdata())
                                            if (self.fib_entry_version.is_set or self.fib_entry_version.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_entry_version.get_name_leafdata())
                                            if (self.fib_protocol_type.is_set or self.fib_protocol_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_protocol_type.get_name_leafdata())
                                            if (self.fib_special_nh_information_type.is_set or self.fib_special_nh_information_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_special_nh_information_type.get_name_leafdata())
                                            if (self.flow_tag.is_set or self.flow_tag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.flow_tag.get_name_leafdata())
                                            if (self.forward_class.is_set or self.forward_class.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.forward_class.get_name_leafdata())
                                            if (self.illegal_fast_adjacency_flag.is_set or self.illegal_fast_adjacency_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.illegal_fast_adjacency_flag.get_name_leafdata())
                                            if (self.ldi_time_of_last_update_in_msec.is_set or self.ldi_time_of_last_update_in_msec.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.ldi_time_of_last_update_in_msec.get_name_leafdata())
                                            if (self.load_sharing_type.is_set or self.load_sharing_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.load_sharing_type.get_name_leafdata())
                                            if (self.lwldi_time_of_last_update_in_msec.is_set or self.lwldi_time_of_last_update_in_msec.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.lwldi_time_of_last_update_in_msec.get_name_leafdata())
                                            if (self.mpls_fec.is_set or self.mpls_fec.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.mpls_fec.get_name_leafdata())
                                            if (self.packets_through_fib_entry.is_set or self.packets_through_fib_entry.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.packets_through_fib_entry.get_name_leafdata())
                                            if (self.path_string.is_set or self.path_string.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.path_string.get_name_leafdata())
                                            if (self.per_prefix_accounting.is_set or self.per_prefix_accounting.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.per_prefix_accounting.get_name_leafdata())
                                            if (self.pl_time_of_last_update_in_msec.is_set or self.pl_time_of_last_update_in_msec.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pl_time_of_last_update_in_msec.get_name_leafdata())
                                            if (self.pl_time_stamp_type.is_set or self.pl_time_stamp_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pl_time_stamp_type.get_name_leafdata())
                                            if (self.precedence_forpackets.is_set or self.precedence_forpackets.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.precedence_forpackets.get_name_leafdata())
                                            if (self.prefix_protocol.is_set or self.prefix_protocol.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.prefix_protocol.get_name_leafdata())
                                            if (self.qos_group.is_set or self.qos_group.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.qos_group.get_name_leafdata())
                                            if (self.qppb_qos_group_and_ip_precedence.is_set or self.qppb_qos_group_and_ip_precedence.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.qppb_qos_group_and_ip_precedence.get_name_leafdata())
                                            if (self.remote_adjacency_flag.is_set or self.remote_adjacency_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.remote_adjacency_flag.get_name_leafdata())
                                            if (self.switch_compontent_id.is_set or self.switch_compontent_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.switch_compontent_id.get_name_leafdata())
                                            if (self.traffic_index_for_packets.is_set or self.traffic_index_for_packets.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.traffic_index_for_packets.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "loadshare-information"):
                                                if (self.loadshare_information is None):
                                                    self.loadshare_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation.LoadshareInformation()
                                                    self.loadshare_information.parent = self
                                                    self._children_name_map["loadshare_information"] = "loadshare-information"
                                                return self.loadshare_information

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "loadshare-information" or name == "adjacency-address-length" or name == "adjacency-interface" or name == "afi-fib-protocol-type" or name == "aib-l3-address" or name == "bgp-attribute-id" or name == "bgp-attribute-next-hop-as" or name == "bgp-attribute-origin-as" or name == "bgp-local-attribute-id" or name == "bytes-through-fib-entry" or name == "com-string" or name == "detailed-prefix-length" or name == "extcom-string" or name == "extended-community" or name == "fast-adjacency-flag" or name == "fib-entry-adjacency-address" or name == "fib-entry-adjacency-interface" or name == "fib-entry-adjacency-type" or name == "fib-entry-version" or name == "fib-protocol-type" or name == "fib-special-nh-information-type" or name == "flow-tag" or name == "forward-class" or name == "illegal-fast-adjacency-flag" or name == "ldi-time-of-last-update-in-msec" or name == "load-sharing-type" or name == "lwldi-time-of-last-update-in-msec" or name == "mpls-fec" or name == "packets-through-fib-entry" or name == "path-string" or name == "per-prefix-accounting" or name == "pl-time-of-last-update-in-msec" or name == "pl-time-stamp-type" or name == "precedence-forpackets" or name == "prefix-protocol" or name == "qos-group" or name == "qppb-qos-group-and-ip-precedence" or name == "remote-adjacency-flag" or name == "switch-compontent-id" or name == "traffic-index-for-packets"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "adjacency-address-length"):
                                                self.adjacency_address_length = value
                                                self.adjacency_address_length.value_namespace = name_space
                                                self.adjacency_address_length.value_namespace_prefix = name_space_prefix
                                            if(value_path == "adjacency-interface"):
                                                self.adjacency_interface = value
                                                self.adjacency_interface.value_namespace = name_space
                                                self.adjacency_interface.value_namespace_prefix = name_space_prefix
                                            if(value_path == "afi-fib-protocol-type"):
                                                self.afi_fib_protocol_type = value
                                                self.afi_fib_protocol_type.value_namespace = name_space
                                                self.afi_fib_protocol_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "aib-l3-address"):
                                                self.aib_l3_address = value
                                                self.aib_l3_address.value_namespace = name_space
                                                self.aib_l3_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bgp-attribute-id"):
                                                self.bgp_attribute_id = value
                                                self.bgp_attribute_id.value_namespace = name_space
                                                self.bgp_attribute_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bgp-attribute-next-hop-as"):
                                                self.bgp_attribute_next_hop_as = value
                                                self.bgp_attribute_next_hop_as.value_namespace = name_space
                                                self.bgp_attribute_next_hop_as.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bgp-attribute-origin-as"):
                                                self.bgp_attribute_origin_as = value
                                                self.bgp_attribute_origin_as.value_namespace = name_space
                                                self.bgp_attribute_origin_as.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bgp-local-attribute-id"):
                                                self.bgp_local_attribute_id = value
                                                self.bgp_local_attribute_id.value_namespace = name_space
                                                self.bgp_local_attribute_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bytes-through-fib-entry"):
                                                self.bytes_through_fib_entry = value
                                                self.bytes_through_fib_entry.value_namespace = name_space
                                                self.bytes_through_fib_entry.value_namespace_prefix = name_space_prefix
                                            if(value_path == "com-string"):
                                                self.com_string = value
                                                self.com_string.value_namespace = name_space
                                                self.com_string.value_namespace_prefix = name_space_prefix
                                            if(value_path == "detailed-prefix-length"):
                                                self.detailed_prefix_length = value
                                                self.detailed_prefix_length.value_namespace = name_space
                                                self.detailed_prefix_length.value_namespace_prefix = name_space_prefix
                                            if(value_path == "extcom-string"):
                                                self.extcom_string = value
                                                self.extcom_string.value_namespace = name_space
                                                self.extcom_string.value_namespace_prefix = name_space_prefix
                                            if(value_path == "extended-community"):
                                                self.extended_community = value
                                                self.extended_community.value_namespace = name_space
                                                self.extended_community.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fast-adjacency-flag"):
                                                self.fast_adjacency_flag = value
                                                self.fast_adjacency_flag.value_namespace = name_space
                                                self.fast_adjacency_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-entry-adjacency-address"):
                                                self.fib_entry_adjacency_address = value
                                                self.fib_entry_adjacency_address.value_namespace = name_space
                                                self.fib_entry_adjacency_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-entry-adjacency-interface"):
                                                self.fib_entry_adjacency_interface = value
                                                self.fib_entry_adjacency_interface.value_namespace = name_space
                                                self.fib_entry_adjacency_interface.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-entry-adjacency-type"):
                                                self.fib_entry_adjacency_type = value
                                                self.fib_entry_adjacency_type.value_namespace = name_space
                                                self.fib_entry_adjacency_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-entry-version"):
                                                self.fib_entry_version = value
                                                self.fib_entry_version.value_namespace = name_space
                                                self.fib_entry_version.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-protocol-type"):
                                                self.fib_protocol_type = value
                                                self.fib_protocol_type.value_namespace = name_space
                                                self.fib_protocol_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-special-nh-information-type"):
                                                self.fib_special_nh_information_type = value
                                                self.fib_special_nh_information_type.value_namespace = name_space
                                                self.fib_special_nh_information_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "flow-tag"):
                                                self.flow_tag = value
                                                self.flow_tag.value_namespace = name_space
                                                self.flow_tag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "forward-class"):
                                                self.forward_class = value
                                                self.forward_class.value_namespace = name_space
                                                self.forward_class.value_namespace_prefix = name_space_prefix
                                            if(value_path == "illegal-fast-adjacency-flag"):
                                                self.illegal_fast_adjacency_flag = value
                                                self.illegal_fast_adjacency_flag.value_namespace = name_space
                                                self.illegal_fast_adjacency_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "ldi-time-of-last-update-in-msec"):
                                                self.ldi_time_of_last_update_in_msec = value
                                                self.ldi_time_of_last_update_in_msec.value_namespace = name_space
                                                self.ldi_time_of_last_update_in_msec.value_namespace_prefix = name_space_prefix
                                            if(value_path == "load-sharing-type"):
                                                self.load_sharing_type = value
                                                self.load_sharing_type.value_namespace = name_space
                                                self.load_sharing_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "lwldi-time-of-last-update-in-msec"):
                                                self.lwldi_time_of_last_update_in_msec = value
                                                self.lwldi_time_of_last_update_in_msec.value_namespace = name_space
                                                self.lwldi_time_of_last_update_in_msec.value_namespace_prefix = name_space_prefix
                                            if(value_path == "mpls-fec"):
                                                self.mpls_fec = value
                                                self.mpls_fec.value_namespace = name_space
                                                self.mpls_fec.value_namespace_prefix = name_space_prefix
                                            if(value_path == "packets-through-fib-entry"):
                                                self.packets_through_fib_entry = value
                                                self.packets_through_fib_entry.value_namespace = name_space
                                                self.packets_through_fib_entry.value_namespace_prefix = name_space_prefix
                                            if(value_path == "path-string"):
                                                self.path_string = value
                                                self.path_string.value_namespace = name_space
                                                self.path_string.value_namespace_prefix = name_space_prefix
                                            if(value_path == "per-prefix-accounting"):
                                                self.per_prefix_accounting = value
                                                self.per_prefix_accounting.value_namespace = name_space
                                                self.per_prefix_accounting.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pl-time-of-last-update-in-msec"):
                                                self.pl_time_of_last_update_in_msec = value
                                                self.pl_time_of_last_update_in_msec.value_namespace = name_space
                                                self.pl_time_of_last_update_in_msec.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pl-time-stamp-type"):
                                                self.pl_time_stamp_type = value
                                                self.pl_time_stamp_type.value_namespace = name_space
                                                self.pl_time_stamp_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "precedence-forpackets"):
                                                self.precedence_forpackets = value
                                                self.precedence_forpackets.value_namespace = name_space
                                                self.precedence_forpackets.value_namespace_prefix = name_space_prefix
                                            if(value_path == "prefix-protocol"):
                                                self.prefix_protocol = value
                                                self.prefix_protocol.value_namespace = name_space
                                                self.prefix_protocol.value_namespace_prefix = name_space_prefix
                                            if(value_path == "qos-group"):
                                                self.qos_group = value
                                                self.qos_group.value_namespace = name_space
                                                self.qos_group.value_namespace_prefix = name_space_prefix
                                            if(value_path == "qppb-qos-group-and-ip-precedence"):
                                                self.qppb_qos_group_and_ip_precedence = value
                                                self.qppb_qos_group_and_ip_precedence.value_namespace = name_space
                                                self.qppb_qos_group_and_ip_precedence.value_namespace_prefix = name_space_prefix
                                            if(value_path == "remote-adjacency-flag"):
                                                self.remote_adjacency_flag = value
                                                self.remote_adjacency_flag.value_namespace = name_space
                                                self.remote_adjacency_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "switch-compontent-id"):
                                                self.switch_compontent_id = value
                                                self.switch_compontent_id.value_namespace = name_space
                                                self.switch_compontent_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "traffic-index-for-packets"):
                                                self.traffic_index_for_packets = value
                                                self.traffic_index_for_packets.value_namespace = name_space
                                                self.traffic_index_for_packets.value_namespace_prefix = name_space_prefix


                                    class FibEntryPath(Entity):
                                        """
                                        FIB entry path details
                                        
                                        .. attribute:: fib_sh_tbl_path
                                        
                                        	fib sh tbl path
                                        	**type**\: list of    :py:class:`FibShTblPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath>`
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath, self).__init__()

                                            self.yang_name = "fib-entry-path"
                                            self.yang_parent_name = "ip-prefix-detail"

                                            self.fib_sh_tbl_path = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath, self).__setattr__(name, value)


                                        class FibShTblPath(Entity):
                                            """
                                            fib sh tbl path
                                            
                                            .. attribute:: attached_path
                                            
                                            	Attached path
                                            	**type**\:  bool
                                            
                                            .. attribute:: backup_index
                                            
                                            	Backup path index
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            .. attribute:: backup_path
                                            
                                            	Backup path
                                            	**type**\:  bool
                                            
                                            .. attribute:: best_external_path
                                            
                                            	Best external path
                                            	**type**\:  bool
                                            
                                            .. attribute:: brief_interface_handle
                                            
                                            	Interface handle
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: brief_lfa_protection_type
                                            
                                            	LFA protection type
                                            	**type**\:   :py:class:`FibUpdatePathLfaProtection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibUpdatePathLfaProtection>`
                                            
                                            .. attribute:: brief_next_hop_prefix
                                            
                                            	Next hop prefix
                                            	**type**\:  str
                                            
                                            	**length:** 0..52
                                            
                                            .. attribute:: brief_pnode_address
                                            
                                            	P\-node address
                                            	**type**\:  str
                                            
                                            	**length:** 0..52
                                            
                                            .. attribute:: brief_qnode_address
                                            
                                            	Q\-node address
                                            	**type**\:  str
                                            
                                            	**length:** 0..52
                                            
                                            .. attribute:: hardware_information
                                            
                                            	Hardware info
                                            	**type**\:  str
                                            
                                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                            
                                            .. attribute:: more_detail_about_path
                                            
                                            	More detail about this path entry
                                            	**type**\:   :py:class:`MoreDetailAboutPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath>`
                                            
                                            .. attribute:: mpls_information_for_path
                                            
                                            	mpls info for this path entry
                                            	**type**\:   :py:class:`MplsInformationForPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath>`
                                            
                                            .. attribute:: next_hop_index
                                            
                                            	Next Hop Index
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: packets_received_path
                                            
                                            	Packets received on this path
                                            	**type**\:  bool
                                            
                                            .. attribute:: parent_interface_handle
                                            
                                            	Parent Interface Handle
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: path_dlb
                                            
                                            	Is this the path used for DLB
                                            	**type**\:  bool
                                            
                                            .. attribute:: path_flags
                                            
                                            	Path flags
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: path_index
                                            
                                            	Path index
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            .. attribute:: path_info_flags
                                            
                                            	Path Info flags
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            .. attribute:: protect_ignore
                                            
                                            	Is protection ignored
                                            	**type**\:  bool
                                            
                                            .. attribute:: recursionvia_len
                                            
                                            	recursion via /N constraint
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            .. attribute:: recursive_path
                                            
                                            	Recursive path
                                            	**type**\:  bool
                                            
                                            .. attribute:: resolved_path
                                            
                                            	Resolved path
                                            	**type**\:  bool
                                            
                                            .. attribute:: via_label_to_recurse
                                            
                                            	Local label to recurse over
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath, self).__init__()

                                                self.yang_name = "fib-sh-tbl-path"
                                                self.yang_parent_name = "fib-entry-path"

                                                self.attached_path = YLeaf(YType.boolean, "attached-path")

                                                self.backup_index = YLeaf(YType.uint8, "backup-index")

                                                self.backup_path = YLeaf(YType.boolean, "backup-path")

                                                self.best_external_path = YLeaf(YType.boolean, "best-external-path")

                                                self.brief_interface_handle = YLeaf(YType.str, "brief-interface-handle")

                                                self.brief_lfa_protection_type = YLeaf(YType.enumeration, "brief-lfa-protection-type")

                                                self.brief_next_hop_prefix = YLeaf(YType.str, "brief-next-hop-prefix")

                                                self.brief_pnode_address = YLeaf(YType.str, "brief-pnode-address")

                                                self.brief_qnode_address = YLeaf(YType.str, "brief-qnode-address")

                                                self.hardware_information = YLeaf(YType.str, "hardware-information")

                                                self.next_hop_index = YLeaf(YType.uint32, "next-hop-index")

                                                self.packets_received_path = YLeaf(YType.boolean, "packets-received-path")

                                                self.parent_interface_handle = YLeaf(YType.str, "parent-interface-handle")

                                                self.path_dlb = YLeaf(YType.boolean, "path-dlb")

                                                self.path_flags = YLeaf(YType.uint32, "path-flags")

                                                self.path_index = YLeaf(YType.uint8, "path-index")

                                                self.path_info_flags = YLeaf(YType.uint16, "path-info-flags")

                                                self.protect_ignore = YLeaf(YType.boolean, "protect-ignore")

                                                self.recursionvia_len = YLeaf(YType.uint8, "recursionvia-len")

                                                self.recursive_path = YLeaf(YType.boolean, "recursive-path")

                                                self.resolved_path = YLeaf(YType.boolean, "resolved-path")

                                                self.via_label_to_recurse = YLeaf(YType.uint32, "via-label-to-recurse")

                                                self.more_detail_about_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath()
                                                self.more_detail_about_path.parent = self
                                                self._children_name_map["more_detail_about_path"] = "more-detail-about-path"
                                                self._children_yang_names.add("more-detail-about-path")

                                                self.mpls_information_for_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath()
                                                self.mpls_information_for_path.parent = self
                                                self._children_name_map["mpls_information_for_path"] = "mpls-information-for-path"
                                                self._children_yang_names.add("mpls-information-for-path")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("attached_path",
                                                                "backup_index",
                                                                "backup_path",
                                                                "best_external_path",
                                                                "brief_interface_handle",
                                                                "brief_lfa_protection_type",
                                                                "brief_next_hop_prefix",
                                                                "brief_pnode_address",
                                                                "brief_qnode_address",
                                                                "hardware_information",
                                                                "next_hop_index",
                                                                "packets_received_path",
                                                                "parent_interface_handle",
                                                                "path_dlb",
                                                                "path_flags",
                                                                "path_index",
                                                                "path_info_flags",
                                                                "protect_ignore",
                                                                "recursionvia_len",
                                                                "recursive_path",
                                                                "resolved_path",
                                                                "via_label_to_recurse") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath, self).__setattr__(name, value)


                                            class MoreDetailAboutPath(Entity):
                                                """
                                                More detail about this path entry
                                                
                                                .. attribute:: current_path_flag
                                                
                                                	Current path flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: detail_fib_adjacency_type
                                                
                                                	FIB entry adjacency type
                                                	**type**\:   :py:class:`FibAdjacencyShow <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibAdjacencyShow>`
                                                
                                                .. attribute:: detail_next_hop_prefix
                                                
                                                	Next hop prefix
                                                	**type**\:  str
                                                
                                                	**length:** 0..52
                                                
                                                .. attribute:: external_adjacency
                                                
                                                	Path is an external adjacency
                                                	**type**\:  bool
                                                
                                                .. attribute:: fib_path_nh_information_type
                                                
                                                	FIB Nhinfo type
                                                	**type**\:   :py:class:`FibNeh <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibNeh>`
                                                
                                                .. attribute:: fib_path_nh_information_type_special
                                                
                                                	FIB Nhinfo type special
                                                	**type**\:   :py:class:`FibNehSpecial <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibNehSpecial>`
                                                
                                                .. attribute:: interface_associated_path
                                                
                                                	Interface associated with this path
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                .. attribute:: ip_address_to_recurse
                                                
                                                	IP address to recurse to
                                                	**type**\:  str
                                                
                                                	**length:** 0..52
                                                
                                                .. attribute:: label_to_recurse
                                                
                                                	Local label to recurse over
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: lisprlocid
                                                
                                                	LISP RLOC ID
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: next_hop_interface
                                                
                                                	Next hop interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                .. attribute:: next_hop_mask_length
                                                
                                                	Next hop mask length
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: next_hop_vrf
                                                
                                                	Next hop VRF
                                                	**type**\:  str
                                                
                                                	**length:** 0..33
                                                
                                                .. attribute:: next_prefix_length
                                                
                                                	Next prefix length
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: next_prefix_length2
                                                
                                                	Next prefix2 length
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: next_prefix_recursion
                                                
                                                	Next prefix recursion in the path
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: next_prefix_recursion2
                                                
                                                	Next prefix2 recursion in the path
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: number_of_dependencies_this_path
                                                
                                                	No. of dependents for this path
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: recurse_prefix_object
                                                
                                                	Is recursion object a leaf?
                                                	**type**\:  bool
                                                
                                                .. attribute:: recurse_prefix_object2
                                                
                                                	Recursion has two leaves (e.g. implicit\-null path)
                                                	**type**\:  bool
                                                
                                                .. attribute:: recursive_path_information
                                                
                                                	Recursive path information is available
                                                	**type**\:  bool
                                                
                                                .. attribute:: robin_reset_value
                                                
                                                	Round robin reset value
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: spd_ipencap
                                                
                                                	IP Encap
                                                	**type**\: list of    :py:class:`SpdIpencap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap>`
                                                
                                                .. attribute:: tunnel_class
                                                
                                                	Tunnel class of the path
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: tunnel_is_forward_class
                                                
                                                	Tunnel is forward class
                                                	**type**\:  bool
                                                
                                                .. attribute:: tunnle_endpoint_id
                                                
                                                	Tunnel endpoint id
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: weight_of_path
                                                
                                                	Weight of the path
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                

                                                """

                                                _prefix = 'fib-common-oper'
                                                _revision = '2017-01-20'

                                                def __init__(self):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath, self).__init__()

                                                    self.yang_name = "more-detail-about-path"
                                                    self.yang_parent_name = "fib-sh-tbl-path"

                                                    self.current_path_flag = YLeaf(YType.boolean, "current-path-flag")

                                                    self.detail_fib_adjacency_type = YLeaf(YType.enumeration, "detail-fib-adjacency-type")

                                                    self.detail_next_hop_prefix = YLeaf(YType.str, "detail-next-hop-prefix")

                                                    self.external_adjacency = YLeaf(YType.boolean, "external-adjacency")

                                                    self.fib_path_nh_information_type = YLeaf(YType.enumeration, "fib-path-nh-information-type")

                                                    self.fib_path_nh_information_type_special = YLeaf(YType.enumeration, "fib-path-nh-information-type-special")

                                                    self.interface_associated_path = YLeaf(YType.str, "interface-associated-path")

                                                    self.ip_address_to_recurse = YLeaf(YType.str, "ip-address-to-recurse")

                                                    self.label_to_recurse = YLeaf(YType.uint32, "label-to-recurse")

                                                    self.lisprlocid = YLeaf(YType.uint32, "lisprlocid")

                                                    self.next_hop_interface = YLeaf(YType.str, "next-hop-interface")

                                                    self.next_hop_mask_length = YLeaf(YType.uint8, "next-hop-mask-length")

                                                    self.next_hop_vrf = YLeaf(YType.str, "next-hop-vrf")

                                                    self.next_prefix_length = YLeaf(YType.uint8, "next-prefix-length")

                                                    self.next_prefix_length2 = YLeaf(YType.uint8, "next-prefix-length2")

                                                    self.next_prefix_recursion = YLeaf(YType.str, "next-prefix-recursion")

                                                    self.next_prefix_recursion2 = YLeaf(YType.str, "next-prefix-recursion2")

                                                    self.number_of_dependencies_this_path = YLeaf(YType.uint32, "number-of-dependencies-this-path")

                                                    self.recurse_prefix_object = YLeaf(YType.boolean, "recurse-prefix-object")

                                                    self.recurse_prefix_object2 = YLeaf(YType.boolean, "recurse-prefix-object2")

                                                    self.recursive_path_information = YLeaf(YType.boolean, "recursive-path-information")

                                                    self.robin_reset_value = YLeaf(YType.uint8, "robin-reset-value")

                                                    self.tunnel_class = YLeaf(YType.uint8, "tunnel-class")

                                                    self.tunnel_is_forward_class = YLeaf(YType.boolean, "tunnel-is-forward-class")

                                                    self.tunnle_endpoint_id = YLeaf(YType.uint32, "tunnle-endpoint-id")

                                                    self.weight_of_path = YLeaf(YType.uint32, "weight-of-path")

                                                    self.spd_ipencap = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("current_path_flag",
                                                                    "detail_fib_adjacency_type",
                                                                    "detail_next_hop_prefix",
                                                                    "external_adjacency",
                                                                    "fib_path_nh_information_type",
                                                                    "fib_path_nh_information_type_special",
                                                                    "interface_associated_path",
                                                                    "ip_address_to_recurse",
                                                                    "label_to_recurse",
                                                                    "lisprlocid",
                                                                    "next_hop_interface",
                                                                    "next_hop_mask_length",
                                                                    "next_hop_vrf",
                                                                    "next_prefix_length",
                                                                    "next_prefix_length2",
                                                                    "next_prefix_recursion",
                                                                    "next_prefix_recursion2",
                                                                    "number_of_dependencies_this_path",
                                                                    "recurse_prefix_object",
                                                                    "recurse_prefix_object2",
                                                                    "recursive_path_information",
                                                                    "robin_reset_value",
                                                                    "tunnel_class",
                                                                    "tunnel_is_forward_class",
                                                                    "tunnle_endpoint_id",
                                                                    "weight_of_path") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath, self).__setattr__(name, value)


                                                class SpdIpencap(Entity):
                                                    """
                                                    IP Encap
                                                    
                                                    .. attribute:: ip_encap_hdr
                                                    
                                                    	Headers
                                                    	**type**\: list of    :py:class:`IpEncapHdr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr>`
                                                    
                                                    .. attribute:: ip_encap_hdr_count
                                                    
                                                    	Header Count
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..255
                                                    
                                                    .. attribute:: ip_encap_locks
                                                    
                                                    	IPEncap Object Locks
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_parent
                                                    
                                                    	Pointer to parent
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_parent_type
                                                    
                                                    	Parent type enumeration
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_payload_af
                                                    
                                                    	Payload AF
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_payload_mtu
                                                    
                                                    	Payload MTU
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    .. attribute:: ip_encap_transport_af
                                                    
                                                    	Transport AF
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_transport_tbl
                                                    
                                                    	Transport Table
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ipe_transport_vrf_name
                                                    
                                                    	Transport VRF name
                                                    	**type**\:  str
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap, self).__init__()

                                                        self.yang_name = "spd-ipencap"
                                                        self.yang_parent_name = "more-detail-about-path"

                                                        self.ip_encap_hdr_count = YLeaf(YType.uint8, "ip-encap-hdr-count")

                                                        self.ip_encap_locks = YLeaf(YType.uint32, "ip-encap-locks")

                                                        self.ip_encap_parent = YLeaf(YType.uint32, "ip-encap-parent")

                                                        self.ip_encap_parent_type = YLeaf(YType.uint32, "ip-encap-parent-type")

                                                        self.ip_encap_payload_af = YLeaf(YType.uint32, "ip-encap-payload-af")

                                                        self.ip_encap_payload_mtu = YLeaf(YType.uint16, "ip-encap-payload-mtu")

                                                        self.ip_encap_transport_af = YLeaf(YType.uint32, "ip-encap-transport-af")

                                                        self.ip_encap_transport_tbl = YLeaf(YType.uint32, "ip-encap-transport-tbl")

                                                        self.ipe_transport_vrf_name = YLeaf(YType.str, "ipe-transport-vrf-name")

                                                        self.ip_encap_hdr = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("ip_encap_hdr_count",
                                                                        "ip_encap_locks",
                                                                        "ip_encap_parent",
                                                                        "ip_encap_parent_type",
                                                                        "ip_encap_payload_af",
                                                                        "ip_encap_payload_mtu",
                                                                        "ip_encap_transport_af",
                                                                        "ip_encap_transport_tbl",
                                                                        "ipe_transport_vrf_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap, self).__setattr__(name, value)


                                                    class IpEncapHdr(Entity):
                                                        """
                                                        Headers
                                                        
                                                        .. attribute:: ip_encap_hdr_dyn
                                                        
                                                        	Dynamic Header Fields
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        .. attribute:: ip_encap_hdr_type
                                                        
                                                        	Header Type
                                                        	**type**\:   :py:class:`FibShIpencapHdr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibShIpencapHdr>`
                                                        
                                                        .. attribute:: ip_encap_hdrp
                                                        
                                                        	Static Header
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                        
                                                        

                                                        """

                                                        _prefix = 'fib-common-oper'
                                                        _revision = '2017-01-20'

                                                        def __init__(self):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr, self).__init__()

                                                            self.yang_name = "ip-encap-hdr"
                                                            self.yang_parent_name = "spd-ipencap"

                                                            self.ip_encap_hdr_dyn = YLeaf(YType.uint32, "ip-encap-hdr-dyn")

                                                            self.ip_encap_hdr_type = YLeaf(YType.enumeration, "ip-encap-hdr-type")

                                                            self.ip_encap_hdrp = YLeaf(YType.str, "ip-encap-hdrp")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("ip_encap_hdr_dyn",
                                                                            "ip_encap_hdr_type",
                                                                            "ip_encap_hdrp") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.ip_encap_hdr_dyn.is_set or
                                                                self.ip_encap_hdr_type.is_set or
                                                                self.ip_encap_hdrp.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.ip_encap_hdr_dyn.yfilter != YFilter.not_set or
                                                                self.ip_encap_hdr_type.yfilter != YFilter.not_set or
                                                                self.ip_encap_hdrp.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "ip-encap-hdr" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.ip_encap_hdr_dyn.is_set or self.ip_encap_hdr_dyn.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.ip_encap_hdr_dyn.get_name_leafdata())
                                                            if (self.ip_encap_hdr_type.is_set or self.ip_encap_hdr_type.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.ip_encap_hdr_type.get_name_leafdata())
                                                            if (self.ip_encap_hdrp.is_set or self.ip_encap_hdrp.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.ip_encap_hdrp.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "ip-encap-hdr-dyn" or name == "ip-encap-hdr-type" or name == "ip-encap-hdrp"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "ip-encap-hdr-dyn"):
                                                                self.ip_encap_hdr_dyn = value
                                                                self.ip_encap_hdr_dyn.value_namespace = name_space
                                                                self.ip_encap_hdr_dyn.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "ip-encap-hdr-type"):
                                                                self.ip_encap_hdr_type = value
                                                                self.ip_encap_hdr_type.value_namespace = name_space
                                                                self.ip_encap_hdr_type.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "ip-encap-hdrp"):
                                                                self.ip_encap_hdrp = value
                                                                self.ip_encap_hdrp.value_namespace = name_space
                                                                self.ip_encap_hdrp.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.ip_encap_hdr:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            self.ip_encap_hdr_count.is_set or
                                                            self.ip_encap_locks.is_set or
                                                            self.ip_encap_parent.is_set or
                                                            self.ip_encap_parent_type.is_set or
                                                            self.ip_encap_payload_af.is_set or
                                                            self.ip_encap_payload_mtu.is_set or
                                                            self.ip_encap_transport_af.is_set or
                                                            self.ip_encap_transport_tbl.is_set or
                                                            self.ipe_transport_vrf_name.is_set)

                                                    def has_operation(self):
                                                        for c in self.ip_encap_hdr:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.ip_encap_hdr_count.yfilter != YFilter.not_set or
                                                            self.ip_encap_locks.yfilter != YFilter.not_set or
                                                            self.ip_encap_parent.yfilter != YFilter.not_set or
                                                            self.ip_encap_parent_type.yfilter != YFilter.not_set or
                                                            self.ip_encap_payload_af.yfilter != YFilter.not_set or
                                                            self.ip_encap_payload_mtu.yfilter != YFilter.not_set or
                                                            self.ip_encap_transport_af.yfilter != YFilter.not_set or
                                                            self.ip_encap_transport_tbl.yfilter != YFilter.not_set or
                                                            self.ipe_transport_vrf_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "spd-ipencap" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.ip_encap_hdr_count.is_set or self.ip_encap_hdr_count.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_hdr_count.get_name_leafdata())
                                                        if (self.ip_encap_locks.is_set or self.ip_encap_locks.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_locks.get_name_leafdata())
                                                        if (self.ip_encap_parent.is_set or self.ip_encap_parent.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_parent.get_name_leafdata())
                                                        if (self.ip_encap_parent_type.is_set or self.ip_encap_parent_type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_parent_type.get_name_leafdata())
                                                        if (self.ip_encap_payload_af.is_set or self.ip_encap_payload_af.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_payload_af.get_name_leafdata())
                                                        if (self.ip_encap_payload_mtu.is_set or self.ip_encap_payload_mtu.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_payload_mtu.get_name_leafdata())
                                                        if (self.ip_encap_transport_af.is_set or self.ip_encap_transport_af.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_transport_af.get_name_leafdata())
                                                        if (self.ip_encap_transport_tbl.is_set or self.ip_encap_transport_tbl.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_transport_tbl.get_name_leafdata())
                                                        if (self.ipe_transport_vrf_name.is_set or self.ipe_transport_vrf_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ipe_transport_vrf_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "ip-encap-hdr"):
                                                            for c in self.ip_encap_hdr:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.ip_encap_hdr.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "ip-encap-hdr" or name == "ip-encap-hdr-count" or name == "ip-encap-locks" or name == "ip-encap-parent" or name == "ip-encap-parent-type" or name == "ip-encap-payload-af" or name == "ip-encap-payload-mtu" or name == "ip-encap-transport-af" or name == "ip-encap-transport-tbl" or name == "ipe-transport-vrf-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "ip-encap-hdr-count"):
                                                            self.ip_encap_hdr_count = value
                                                            self.ip_encap_hdr_count.value_namespace = name_space
                                                            self.ip_encap_hdr_count.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-locks"):
                                                            self.ip_encap_locks = value
                                                            self.ip_encap_locks.value_namespace = name_space
                                                            self.ip_encap_locks.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-parent"):
                                                            self.ip_encap_parent = value
                                                            self.ip_encap_parent.value_namespace = name_space
                                                            self.ip_encap_parent.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-parent-type"):
                                                            self.ip_encap_parent_type = value
                                                            self.ip_encap_parent_type.value_namespace = name_space
                                                            self.ip_encap_parent_type.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-payload-af"):
                                                            self.ip_encap_payload_af = value
                                                            self.ip_encap_payload_af.value_namespace = name_space
                                                            self.ip_encap_payload_af.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-payload-mtu"):
                                                            self.ip_encap_payload_mtu = value
                                                            self.ip_encap_payload_mtu.value_namespace = name_space
                                                            self.ip_encap_payload_mtu.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-transport-af"):
                                                            self.ip_encap_transport_af = value
                                                            self.ip_encap_transport_af.value_namespace = name_space
                                                            self.ip_encap_transport_af.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-transport-tbl"):
                                                            self.ip_encap_transport_tbl = value
                                                            self.ip_encap_transport_tbl.value_namespace = name_space
                                                            self.ip_encap_transport_tbl.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ipe-transport-vrf-name"):
                                                            self.ipe_transport_vrf_name = value
                                                            self.ipe_transport_vrf_name.value_namespace = name_space
                                                            self.ipe_transport_vrf_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.spd_ipencap:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.current_path_flag.is_set or
                                                        self.detail_fib_adjacency_type.is_set or
                                                        self.detail_next_hop_prefix.is_set or
                                                        self.external_adjacency.is_set or
                                                        self.fib_path_nh_information_type.is_set or
                                                        self.fib_path_nh_information_type_special.is_set or
                                                        self.interface_associated_path.is_set or
                                                        self.ip_address_to_recurse.is_set or
                                                        self.label_to_recurse.is_set or
                                                        self.lisprlocid.is_set or
                                                        self.next_hop_interface.is_set or
                                                        self.next_hop_mask_length.is_set or
                                                        self.next_hop_vrf.is_set or
                                                        self.next_prefix_length.is_set or
                                                        self.next_prefix_length2.is_set or
                                                        self.next_prefix_recursion.is_set or
                                                        self.next_prefix_recursion2.is_set or
                                                        self.number_of_dependencies_this_path.is_set or
                                                        self.recurse_prefix_object.is_set or
                                                        self.recurse_prefix_object2.is_set or
                                                        self.recursive_path_information.is_set or
                                                        self.robin_reset_value.is_set or
                                                        self.tunnel_class.is_set or
                                                        self.tunnel_is_forward_class.is_set or
                                                        self.tunnle_endpoint_id.is_set or
                                                        self.weight_of_path.is_set)

                                                def has_operation(self):
                                                    for c in self.spd_ipencap:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.current_path_flag.yfilter != YFilter.not_set or
                                                        self.detail_fib_adjacency_type.yfilter != YFilter.not_set or
                                                        self.detail_next_hop_prefix.yfilter != YFilter.not_set or
                                                        self.external_adjacency.yfilter != YFilter.not_set or
                                                        self.fib_path_nh_information_type.yfilter != YFilter.not_set or
                                                        self.fib_path_nh_information_type_special.yfilter != YFilter.not_set or
                                                        self.interface_associated_path.yfilter != YFilter.not_set or
                                                        self.ip_address_to_recurse.yfilter != YFilter.not_set or
                                                        self.label_to_recurse.yfilter != YFilter.not_set or
                                                        self.lisprlocid.yfilter != YFilter.not_set or
                                                        self.next_hop_interface.yfilter != YFilter.not_set or
                                                        self.next_hop_mask_length.yfilter != YFilter.not_set or
                                                        self.next_hop_vrf.yfilter != YFilter.not_set or
                                                        self.next_prefix_length.yfilter != YFilter.not_set or
                                                        self.next_prefix_length2.yfilter != YFilter.not_set or
                                                        self.next_prefix_recursion.yfilter != YFilter.not_set or
                                                        self.next_prefix_recursion2.yfilter != YFilter.not_set or
                                                        self.number_of_dependencies_this_path.yfilter != YFilter.not_set or
                                                        self.recurse_prefix_object.yfilter != YFilter.not_set or
                                                        self.recurse_prefix_object2.yfilter != YFilter.not_set or
                                                        self.recursive_path_information.yfilter != YFilter.not_set or
                                                        self.robin_reset_value.yfilter != YFilter.not_set or
                                                        self.tunnel_class.yfilter != YFilter.not_set or
                                                        self.tunnel_is_forward_class.yfilter != YFilter.not_set or
                                                        self.tunnle_endpoint_id.yfilter != YFilter.not_set or
                                                        self.weight_of_path.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "more-detail-about-path" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.current_path_flag.is_set or self.current_path_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.current_path_flag.get_name_leafdata())
                                                    if (self.detail_fib_adjacency_type.is_set or self.detail_fib_adjacency_type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.detail_fib_adjacency_type.get_name_leafdata())
                                                    if (self.detail_next_hop_prefix.is_set or self.detail_next_hop_prefix.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.detail_next_hop_prefix.get_name_leafdata())
                                                    if (self.external_adjacency.is_set or self.external_adjacency.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.external_adjacency.get_name_leafdata())
                                                    if (self.fib_path_nh_information_type.is_set or self.fib_path_nh_information_type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.fib_path_nh_information_type.get_name_leafdata())
                                                    if (self.fib_path_nh_information_type_special.is_set or self.fib_path_nh_information_type_special.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.fib_path_nh_information_type_special.get_name_leafdata())
                                                    if (self.interface_associated_path.is_set or self.interface_associated_path.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_associated_path.get_name_leafdata())
                                                    if (self.ip_address_to_recurse.is_set or self.ip_address_to_recurse.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.ip_address_to_recurse.get_name_leafdata())
                                                    if (self.label_to_recurse.is_set or self.label_to_recurse.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.label_to_recurse.get_name_leafdata())
                                                    if (self.lisprlocid.is_set or self.lisprlocid.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.lisprlocid.get_name_leafdata())
                                                    if (self.next_hop_interface.is_set or self.next_hop_interface.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_hop_interface.get_name_leafdata())
                                                    if (self.next_hop_mask_length.is_set or self.next_hop_mask_length.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_hop_mask_length.get_name_leafdata())
                                                    if (self.next_hop_vrf.is_set or self.next_hop_vrf.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_hop_vrf.get_name_leafdata())
                                                    if (self.next_prefix_length.is_set or self.next_prefix_length.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_prefix_length.get_name_leafdata())
                                                    if (self.next_prefix_length2.is_set or self.next_prefix_length2.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_prefix_length2.get_name_leafdata())
                                                    if (self.next_prefix_recursion.is_set or self.next_prefix_recursion.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_prefix_recursion.get_name_leafdata())
                                                    if (self.next_prefix_recursion2.is_set or self.next_prefix_recursion2.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_prefix_recursion2.get_name_leafdata())
                                                    if (self.number_of_dependencies_this_path.is_set or self.number_of_dependencies_this_path.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.number_of_dependencies_this_path.get_name_leafdata())
                                                    if (self.recurse_prefix_object.is_set or self.recurse_prefix_object.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recurse_prefix_object.get_name_leafdata())
                                                    if (self.recurse_prefix_object2.is_set or self.recurse_prefix_object2.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recurse_prefix_object2.get_name_leafdata())
                                                    if (self.recursive_path_information.is_set or self.recursive_path_information.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recursive_path_information.get_name_leafdata())
                                                    if (self.robin_reset_value.is_set or self.robin_reset_value.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.robin_reset_value.get_name_leafdata())
                                                    if (self.tunnel_class.is_set or self.tunnel_class.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.tunnel_class.get_name_leafdata())
                                                    if (self.tunnel_is_forward_class.is_set or self.tunnel_is_forward_class.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.tunnel_is_forward_class.get_name_leafdata())
                                                    if (self.tunnle_endpoint_id.is_set or self.tunnle_endpoint_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.tunnle_endpoint_id.get_name_leafdata())
                                                    if (self.weight_of_path.is_set or self.weight_of_path.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.weight_of_path.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "spd-ipencap"):
                                                        for c in self.spd_ipencap:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.spd_ipencap.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "spd-ipencap" or name == "current-path-flag" or name == "detail-fib-adjacency-type" or name == "detail-next-hop-prefix" or name == "external-adjacency" or name == "fib-path-nh-information-type" or name == "fib-path-nh-information-type-special" or name == "interface-associated-path" or name == "ip-address-to-recurse" or name == "label-to-recurse" or name == "lisprlocid" or name == "next-hop-interface" or name == "next-hop-mask-length" or name == "next-hop-vrf" or name == "next-prefix-length" or name == "next-prefix-length2" or name == "next-prefix-recursion" or name == "next-prefix-recursion2" or name == "number-of-dependencies-this-path" or name == "recurse-prefix-object" or name == "recurse-prefix-object2" or name == "recursive-path-information" or name == "robin-reset-value" or name == "tunnel-class" or name == "tunnel-is-forward-class" or name == "tunnle-endpoint-id" or name == "weight-of-path"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "current-path-flag"):
                                                        self.current_path_flag = value
                                                        self.current_path_flag.value_namespace = name_space
                                                        self.current_path_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "detail-fib-adjacency-type"):
                                                        self.detail_fib_adjacency_type = value
                                                        self.detail_fib_adjacency_type.value_namespace = name_space
                                                        self.detail_fib_adjacency_type.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "detail-next-hop-prefix"):
                                                        self.detail_next_hop_prefix = value
                                                        self.detail_next_hop_prefix.value_namespace = name_space
                                                        self.detail_next_hop_prefix.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "external-adjacency"):
                                                        self.external_adjacency = value
                                                        self.external_adjacency.value_namespace = name_space
                                                        self.external_adjacency.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "fib-path-nh-information-type"):
                                                        self.fib_path_nh_information_type = value
                                                        self.fib_path_nh_information_type.value_namespace = name_space
                                                        self.fib_path_nh_information_type.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "fib-path-nh-information-type-special"):
                                                        self.fib_path_nh_information_type_special = value
                                                        self.fib_path_nh_information_type_special.value_namespace = name_space
                                                        self.fib_path_nh_information_type_special.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "interface-associated-path"):
                                                        self.interface_associated_path = value
                                                        self.interface_associated_path.value_namespace = name_space
                                                        self.interface_associated_path.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "ip-address-to-recurse"):
                                                        self.ip_address_to_recurse = value
                                                        self.ip_address_to_recurse.value_namespace = name_space
                                                        self.ip_address_to_recurse.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "label-to-recurse"):
                                                        self.label_to_recurse = value
                                                        self.label_to_recurse.value_namespace = name_space
                                                        self.label_to_recurse.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "lisprlocid"):
                                                        self.lisprlocid = value
                                                        self.lisprlocid.value_namespace = name_space
                                                        self.lisprlocid.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-hop-interface"):
                                                        self.next_hop_interface = value
                                                        self.next_hop_interface.value_namespace = name_space
                                                        self.next_hop_interface.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-hop-mask-length"):
                                                        self.next_hop_mask_length = value
                                                        self.next_hop_mask_length.value_namespace = name_space
                                                        self.next_hop_mask_length.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-hop-vrf"):
                                                        self.next_hop_vrf = value
                                                        self.next_hop_vrf.value_namespace = name_space
                                                        self.next_hop_vrf.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-prefix-length"):
                                                        self.next_prefix_length = value
                                                        self.next_prefix_length.value_namespace = name_space
                                                        self.next_prefix_length.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-prefix-length2"):
                                                        self.next_prefix_length2 = value
                                                        self.next_prefix_length2.value_namespace = name_space
                                                        self.next_prefix_length2.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-prefix-recursion"):
                                                        self.next_prefix_recursion = value
                                                        self.next_prefix_recursion.value_namespace = name_space
                                                        self.next_prefix_recursion.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-prefix-recursion2"):
                                                        self.next_prefix_recursion2 = value
                                                        self.next_prefix_recursion2.value_namespace = name_space
                                                        self.next_prefix_recursion2.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "number-of-dependencies-this-path"):
                                                        self.number_of_dependencies_this_path = value
                                                        self.number_of_dependencies_this_path.value_namespace = name_space
                                                        self.number_of_dependencies_this_path.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recurse-prefix-object"):
                                                        self.recurse_prefix_object = value
                                                        self.recurse_prefix_object.value_namespace = name_space
                                                        self.recurse_prefix_object.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recurse-prefix-object2"):
                                                        self.recurse_prefix_object2 = value
                                                        self.recurse_prefix_object2.value_namespace = name_space
                                                        self.recurse_prefix_object2.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recursive-path-information"):
                                                        self.recursive_path_information = value
                                                        self.recursive_path_information.value_namespace = name_space
                                                        self.recursive_path_information.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "robin-reset-value"):
                                                        self.robin_reset_value = value
                                                        self.robin_reset_value.value_namespace = name_space
                                                        self.robin_reset_value.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "tunnel-class"):
                                                        self.tunnel_class = value
                                                        self.tunnel_class.value_namespace = name_space
                                                        self.tunnel_class.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "tunnel-is-forward-class"):
                                                        self.tunnel_is_forward_class = value
                                                        self.tunnel_is_forward_class.value_namespace = name_space
                                                        self.tunnel_is_forward_class.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "tunnle-endpoint-id"):
                                                        self.tunnle_endpoint_id = value
                                                        self.tunnle_endpoint_id.value_namespace = name_space
                                                        self.tunnle_endpoint_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "weight-of-path"):
                                                        self.weight_of_path = value
                                                        self.weight_of_path.value_namespace = name_space
                                                        self.weight_of_path.value_namespace_prefix = name_space_prefix


                                            class MplsInformationForPath(Entity):
                                                """
                                                mpls info for this path entry
                                                
                                                .. attribute:: igp_label_stack_array
                                                
                                                	igp label stack array
                                                	**type**\: list of    :py:class:`IgpLabelStackArray <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray>`
                                                
                                                .. attribute:: local_lable
                                                
                                                	LocalLable
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: number_of_igp_paths
                                                
                                                	NumberOfIGPPaths
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: recursive_fwd_chain
                                                
                                                	RecursiveFwdChain
                                                	**type**\:  bool
                                                
                                                .. attribute:: recursive_out_label_valid
                                                
                                                	RecursiveOutLabelValid
                                                	**type**\:  bool
                                                
                                                .. attribute:: recursive_out_lable
                                                
                                                	RecursiveOutLable
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: remote_backup
                                                
                                                	RemoteBackupPath
                                                	**type**\:  bool
                                                
                                                

                                                """

                                                _prefix = 'fib-common-oper'
                                                _revision = '2017-01-20'

                                                def __init__(self):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath, self).__init__()

                                                    self.yang_name = "mpls-information-for-path"
                                                    self.yang_parent_name = "fib-sh-tbl-path"

                                                    self.local_lable = YLeaf(YType.uint32, "local-lable")

                                                    self.number_of_igp_paths = YLeaf(YType.uint32, "number-of-igp-paths")

                                                    self.recursive_fwd_chain = YLeaf(YType.boolean, "recursive-fwd-chain")

                                                    self.recursive_out_label_valid = YLeaf(YType.boolean, "recursive-out-label-valid")

                                                    self.recursive_out_lable = YLeaf(YType.uint32, "recursive-out-lable")

                                                    self.remote_backup = YLeaf(YType.boolean, "remote-backup")

                                                    self.igp_label_stack_array = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("local_lable",
                                                                    "number_of_igp_paths",
                                                                    "recursive_fwd_chain",
                                                                    "recursive_out_label_valid",
                                                                    "recursive_out_lable",
                                                                    "remote_backup") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath, self).__setattr__(name, value)


                                                class IgpLabelStackArray(Entity):
                                                    """
                                                    igp label stack array
                                                    
                                                    .. attribute:: lstack
                                                    
                                                    	lstack
                                                    	**type**\: list of    :py:class:`Lstack <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack>`
                                                    
                                                    .. attribute:: nh_address
                                                    
                                                    	NHAddress
                                                    	**type**\:  str
                                                    
                                                    	**length:** 0..52
                                                    
                                                    .. attribute:: number_of_labels
                                                    
                                                    	NumberOfLabels
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: out_interface
                                                    
                                                    	OutInterface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray, self).__init__()

                                                        self.yang_name = "igp-label-stack-array"
                                                        self.yang_parent_name = "mpls-information-for-path"

                                                        self.nh_address = YLeaf(YType.str, "nh-address")

                                                        self.number_of_labels = YLeaf(YType.uint32, "number-of-labels")

                                                        self.out_interface = YLeaf(YType.str, "out-interface")

                                                        self.lstack = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("nh_address",
                                                                        "number_of_labels",
                                                                        "out_interface") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray, self).__setattr__(name, value)


                                                    class Lstack(Entity):
                                                        """
                                                        lstack
                                                        
                                                        .. attribute:: entry
                                                        
                                                        	
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        

                                                        """

                                                        _prefix = 'fib-common-oper'
                                                        _revision = '2017-01-20'

                                                        def __init__(self):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack, self).__init__()

                                                            self.yang_name = "lstack"
                                                            self.yang_parent_name = "igp-label-stack-array"

                                                            self.entry = YLeaf(YType.uint32, "entry")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("entry") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return self.entry.is_set

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.entry.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "lstack" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.entry.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "entry"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "entry"):
                                                                self.entry = value
                                                                self.entry.value_namespace = name_space
                                                                self.entry.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.lstack:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            self.nh_address.is_set or
                                                            self.number_of_labels.is_set or
                                                            self.out_interface.is_set)

                                                    def has_operation(self):
                                                        for c in self.lstack:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.nh_address.yfilter != YFilter.not_set or
                                                            self.number_of_labels.yfilter != YFilter.not_set or
                                                            self.out_interface.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "igp-label-stack-array" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.nh_address.is_set or self.nh_address.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.nh_address.get_name_leafdata())
                                                        if (self.number_of_labels.is_set or self.number_of_labels.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.number_of_labels.get_name_leafdata())
                                                        if (self.out_interface.is_set or self.out_interface.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.out_interface.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "lstack"):
                                                            for c in self.lstack:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.lstack.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "lstack" or name == "nh-address" or name == "number-of-labels" or name == "out-interface"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "nh-address"):
                                                            self.nh_address = value
                                                            self.nh_address.value_namespace = name_space
                                                            self.nh_address.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "number-of-labels"):
                                                            self.number_of_labels = value
                                                            self.number_of_labels.value_namespace = name_space
                                                            self.number_of_labels.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "out-interface"):
                                                            self.out_interface = value
                                                            self.out_interface.value_namespace = name_space
                                                            self.out_interface.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.igp_label_stack_array:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.local_lable.is_set or
                                                        self.number_of_igp_paths.is_set or
                                                        self.recursive_fwd_chain.is_set or
                                                        self.recursive_out_label_valid.is_set or
                                                        self.recursive_out_lable.is_set or
                                                        self.remote_backup.is_set)

                                                def has_operation(self):
                                                    for c in self.igp_label_stack_array:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.local_lable.yfilter != YFilter.not_set or
                                                        self.number_of_igp_paths.yfilter != YFilter.not_set or
                                                        self.recursive_fwd_chain.yfilter != YFilter.not_set or
                                                        self.recursive_out_label_valid.yfilter != YFilter.not_set or
                                                        self.recursive_out_lable.yfilter != YFilter.not_set or
                                                        self.remote_backup.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "mpls-information-for-path" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.local_lable.is_set or self.local_lable.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.local_lable.get_name_leafdata())
                                                    if (self.number_of_igp_paths.is_set or self.number_of_igp_paths.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.number_of_igp_paths.get_name_leafdata())
                                                    if (self.recursive_fwd_chain.is_set or self.recursive_fwd_chain.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recursive_fwd_chain.get_name_leafdata())
                                                    if (self.recursive_out_label_valid.is_set or self.recursive_out_label_valid.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recursive_out_label_valid.get_name_leafdata())
                                                    if (self.recursive_out_lable.is_set or self.recursive_out_lable.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recursive_out_lable.get_name_leafdata())
                                                    if (self.remote_backup.is_set or self.remote_backup.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.remote_backup.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "igp-label-stack-array"):
                                                        for c in self.igp_label_stack_array:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.igp_label_stack_array.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "igp-label-stack-array" or name == "local-lable" or name == "number-of-igp-paths" or name == "recursive-fwd-chain" or name == "recursive-out-label-valid" or name == "recursive-out-lable" or name == "remote-backup"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "local-lable"):
                                                        self.local_lable = value
                                                        self.local_lable.value_namespace = name_space
                                                        self.local_lable.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "number-of-igp-paths"):
                                                        self.number_of_igp_paths = value
                                                        self.number_of_igp_paths.value_namespace = name_space
                                                        self.number_of_igp_paths.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recursive-fwd-chain"):
                                                        self.recursive_fwd_chain = value
                                                        self.recursive_fwd_chain.value_namespace = name_space
                                                        self.recursive_fwd_chain.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recursive-out-label-valid"):
                                                        self.recursive_out_label_valid = value
                                                        self.recursive_out_label_valid.value_namespace = name_space
                                                        self.recursive_out_label_valid.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recursive-out-lable"):
                                                        self.recursive_out_lable = value
                                                        self.recursive_out_lable.value_namespace = name_space
                                                        self.recursive_out_lable.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "remote-backup"):
                                                        self.remote_backup = value
                                                        self.remote_backup.value_namespace = name_space
                                                        self.remote_backup.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                return (
                                                    self.attached_path.is_set or
                                                    self.backup_index.is_set or
                                                    self.backup_path.is_set or
                                                    self.best_external_path.is_set or
                                                    self.brief_interface_handle.is_set or
                                                    self.brief_lfa_protection_type.is_set or
                                                    self.brief_next_hop_prefix.is_set or
                                                    self.brief_pnode_address.is_set or
                                                    self.brief_qnode_address.is_set or
                                                    self.hardware_information.is_set or
                                                    self.next_hop_index.is_set or
                                                    self.packets_received_path.is_set or
                                                    self.parent_interface_handle.is_set or
                                                    self.path_dlb.is_set or
                                                    self.path_flags.is_set or
                                                    self.path_index.is_set or
                                                    self.path_info_flags.is_set or
                                                    self.protect_ignore.is_set or
                                                    self.recursionvia_len.is_set or
                                                    self.recursive_path.is_set or
                                                    self.resolved_path.is_set or
                                                    self.via_label_to_recurse.is_set or
                                                    (self.more_detail_about_path is not None and self.more_detail_about_path.has_data()) or
                                                    (self.mpls_information_for_path is not None and self.mpls_information_for_path.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.attached_path.yfilter != YFilter.not_set or
                                                    self.backup_index.yfilter != YFilter.not_set or
                                                    self.backup_path.yfilter != YFilter.not_set or
                                                    self.best_external_path.yfilter != YFilter.not_set or
                                                    self.brief_interface_handle.yfilter != YFilter.not_set or
                                                    self.brief_lfa_protection_type.yfilter != YFilter.not_set or
                                                    self.brief_next_hop_prefix.yfilter != YFilter.not_set or
                                                    self.brief_pnode_address.yfilter != YFilter.not_set or
                                                    self.brief_qnode_address.yfilter != YFilter.not_set or
                                                    self.hardware_information.yfilter != YFilter.not_set or
                                                    self.next_hop_index.yfilter != YFilter.not_set or
                                                    self.packets_received_path.yfilter != YFilter.not_set or
                                                    self.parent_interface_handle.yfilter != YFilter.not_set or
                                                    self.path_dlb.yfilter != YFilter.not_set or
                                                    self.path_flags.yfilter != YFilter.not_set or
                                                    self.path_index.yfilter != YFilter.not_set or
                                                    self.path_info_flags.yfilter != YFilter.not_set or
                                                    self.protect_ignore.yfilter != YFilter.not_set or
                                                    self.recursionvia_len.yfilter != YFilter.not_set or
                                                    self.recursive_path.yfilter != YFilter.not_set or
                                                    self.resolved_path.yfilter != YFilter.not_set or
                                                    self.via_label_to_recurse.yfilter != YFilter.not_set or
                                                    (self.more_detail_about_path is not None and self.more_detail_about_path.has_operation()) or
                                                    (self.mpls_information_for_path is not None and self.mpls_information_for_path.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-sh-tbl-path" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.attached_path.is_set or self.attached_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.attached_path.get_name_leafdata())
                                                if (self.backup_index.is_set or self.backup_index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.backup_index.get_name_leafdata())
                                                if (self.backup_path.is_set or self.backup_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.backup_path.get_name_leafdata())
                                                if (self.best_external_path.is_set or self.best_external_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.best_external_path.get_name_leafdata())
                                                if (self.brief_interface_handle.is_set or self.brief_interface_handle.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_interface_handle.get_name_leafdata())
                                                if (self.brief_lfa_protection_type.is_set or self.brief_lfa_protection_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_lfa_protection_type.get_name_leafdata())
                                                if (self.brief_next_hop_prefix.is_set or self.brief_next_hop_prefix.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_next_hop_prefix.get_name_leafdata())
                                                if (self.brief_pnode_address.is_set or self.brief_pnode_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_pnode_address.get_name_leafdata())
                                                if (self.brief_qnode_address.is_set or self.brief_qnode_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_qnode_address.get_name_leafdata())
                                                if (self.hardware_information.is_set or self.hardware_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.hardware_information.get_name_leafdata())
                                                if (self.next_hop_index.is_set or self.next_hop_index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.next_hop_index.get_name_leafdata())
                                                if (self.packets_received_path.is_set or self.packets_received_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.packets_received_path.get_name_leafdata())
                                                if (self.parent_interface_handle.is_set or self.parent_interface_handle.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.parent_interface_handle.get_name_leafdata())
                                                if (self.path_dlb.is_set or self.path_dlb.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.path_dlb.get_name_leafdata())
                                                if (self.path_flags.is_set or self.path_flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.path_flags.get_name_leafdata())
                                                if (self.path_index.is_set or self.path_index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.path_index.get_name_leafdata())
                                                if (self.path_info_flags.is_set or self.path_info_flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.path_info_flags.get_name_leafdata())
                                                if (self.protect_ignore.is_set or self.protect_ignore.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.protect_ignore.get_name_leafdata())
                                                if (self.recursionvia_len.is_set or self.recursionvia_len.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.recursionvia_len.get_name_leafdata())
                                                if (self.recursive_path.is_set or self.recursive_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.recursive_path.get_name_leafdata())
                                                if (self.resolved_path.is_set or self.resolved_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.resolved_path.get_name_leafdata())
                                                if (self.via_label_to_recurse.is_set or self.via_label_to_recurse.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.via_label_to_recurse.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "more-detail-about-path"):
                                                    if (self.more_detail_about_path is None):
                                                        self.more_detail_about_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MoreDetailAboutPath()
                                                        self.more_detail_about_path.parent = self
                                                        self._children_name_map["more_detail_about_path"] = "more-detail-about-path"
                                                    return self.more_detail_about_path

                                                if (child_yang_name == "mpls-information-for-path"):
                                                    if (self.mpls_information_for_path is None):
                                                        self.mpls_information_for_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath.MplsInformationForPath()
                                                        self.mpls_information_for_path.parent = self
                                                        self._children_name_map["mpls_information_for_path"] = "mpls-information-for-path"
                                                    return self.mpls_information_for_path

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "more-detail-about-path" or name == "mpls-information-for-path" or name == "attached-path" or name == "backup-index" or name == "backup-path" or name == "best-external-path" or name == "brief-interface-handle" or name == "brief-lfa-protection-type" or name == "brief-next-hop-prefix" or name == "brief-pnode-address" or name == "brief-qnode-address" or name == "hardware-information" or name == "next-hop-index" or name == "packets-received-path" or name == "parent-interface-handle" or name == "path-dlb" or name == "path-flags" or name == "path-index" or name == "path-info-flags" or name == "protect-ignore" or name == "recursionvia-len" or name == "recursive-path" or name == "resolved-path" or name == "via-label-to-recurse"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "attached-path"):
                                                    self.attached_path = value
                                                    self.attached_path.value_namespace = name_space
                                                    self.attached_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "backup-index"):
                                                    self.backup_index = value
                                                    self.backup_index.value_namespace = name_space
                                                    self.backup_index.value_namespace_prefix = name_space_prefix
                                                if(value_path == "backup-path"):
                                                    self.backup_path = value
                                                    self.backup_path.value_namespace = name_space
                                                    self.backup_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "best-external-path"):
                                                    self.best_external_path = value
                                                    self.best_external_path.value_namespace = name_space
                                                    self.best_external_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-interface-handle"):
                                                    self.brief_interface_handle = value
                                                    self.brief_interface_handle.value_namespace = name_space
                                                    self.brief_interface_handle.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-lfa-protection-type"):
                                                    self.brief_lfa_protection_type = value
                                                    self.brief_lfa_protection_type.value_namespace = name_space
                                                    self.brief_lfa_protection_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-next-hop-prefix"):
                                                    self.brief_next_hop_prefix = value
                                                    self.brief_next_hop_prefix.value_namespace = name_space
                                                    self.brief_next_hop_prefix.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-pnode-address"):
                                                    self.brief_pnode_address = value
                                                    self.brief_pnode_address.value_namespace = name_space
                                                    self.brief_pnode_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-qnode-address"):
                                                    self.brief_qnode_address = value
                                                    self.brief_qnode_address.value_namespace = name_space
                                                    self.brief_qnode_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "hardware-information"):
                                                    self.hardware_information = value
                                                    self.hardware_information.value_namespace = name_space
                                                    self.hardware_information.value_namespace_prefix = name_space_prefix
                                                if(value_path == "next-hop-index"):
                                                    self.next_hop_index = value
                                                    self.next_hop_index.value_namespace = name_space
                                                    self.next_hop_index.value_namespace_prefix = name_space_prefix
                                                if(value_path == "packets-received-path"):
                                                    self.packets_received_path = value
                                                    self.packets_received_path.value_namespace = name_space
                                                    self.packets_received_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "parent-interface-handle"):
                                                    self.parent_interface_handle = value
                                                    self.parent_interface_handle.value_namespace = name_space
                                                    self.parent_interface_handle.value_namespace_prefix = name_space_prefix
                                                if(value_path == "path-dlb"):
                                                    self.path_dlb = value
                                                    self.path_dlb.value_namespace = name_space
                                                    self.path_dlb.value_namespace_prefix = name_space_prefix
                                                if(value_path == "path-flags"):
                                                    self.path_flags = value
                                                    self.path_flags.value_namespace = name_space
                                                    self.path_flags.value_namespace_prefix = name_space_prefix
                                                if(value_path == "path-index"):
                                                    self.path_index = value
                                                    self.path_index.value_namespace = name_space
                                                    self.path_index.value_namespace_prefix = name_space_prefix
                                                if(value_path == "path-info-flags"):
                                                    self.path_info_flags = value
                                                    self.path_info_flags.value_namespace = name_space
                                                    self.path_info_flags.value_namespace_prefix = name_space_prefix
                                                if(value_path == "protect-ignore"):
                                                    self.protect_ignore = value
                                                    self.protect_ignore.value_namespace = name_space
                                                    self.protect_ignore.value_namespace_prefix = name_space_prefix
                                                if(value_path == "recursionvia-len"):
                                                    self.recursionvia_len = value
                                                    self.recursionvia_len.value_namespace = name_space
                                                    self.recursionvia_len.value_namespace_prefix = name_space_prefix
                                                if(value_path == "recursive-path"):
                                                    self.recursive_path = value
                                                    self.recursive_path.value_namespace = name_space
                                                    self.recursive_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "resolved-path"):
                                                    self.resolved_path = value
                                                    self.resolved_path.value_namespace = name_space
                                                    self.resolved_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "via-label-to-recurse"):
                                                    self.via_label_to_recurse = value
                                                    self.via_label_to_recurse.value_namespace = name_space
                                                    self.via_label_to_recurse.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.fib_sh_tbl_path:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.fib_sh_tbl_path:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "fib-entry-path" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-sh-tbl-path"):
                                                for c in self.fib_sh_tbl_path:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath.FibShTblPath()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.fib_sh_tbl_path.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-sh-tbl-path"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class Srv6Information(Entity):
                                        """
                                        Information about IPv6 SR prefix
                                        
                                        .. attribute:: route_is_sripv6_flag
                                        
                                        	Route is an IPv6 Segment\-Routing prefix
                                        	**type**\:  bool
                                        
                                        .. attribute:: sripv6_stats_valid_flag
                                        
                                        	Statistics are valid for this prefix
                                        	**type**\:  bool
                                        
                                        .. attribute:: srv6_pfx_resolved_via_policy_label
                                        
                                        	Route is a SRv6 prefix resolved via Policy label
                                        	**type**\:  bool
                                        
                                        .. attribute:: srv6_statistics
                                        
                                        	Statistics for a IPv6 SR prefix
                                        	**type**\:   :py:class:`Srv6Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information.Srv6Statistics>`
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information, self).__init__()

                                            self.yang_name = "srv6-information"
                                            self.yang_parent_name = "ip-prefix-detail"

                                            self.route_is_sripv6_flag = YLeaf(YType.boolean, "route-is-sripv6-flag")

                                            self.sripv6_stats_valid_flag = YLeaf(YType.boolean, "sripv6-stats-valid-flag")

                                            self.srv6_pfx_resolved_via_policy_label = YLeaf(YType.boolean, "srv6-pfx-resolved-via-policy-label")

                                            self.srv6_statistics = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information.Srv6Statistics()
                                            self.srv6_statistics.parent = self
                                            self._children_name_map["srv6_statistics"] = "srv6-statistics"
                                            self._children_yang_names.add("srv6-statistics")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("route_is_sripv6_flag",
                                                            "sripv6_stats_valid_flag",
                                                            "srv6_pfx_resolved_via_policy_label") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information, self).__setattr__(name, value)


                                        class Srv6Statistics(Entity):
                                            """
                                            Statistics for a IPv6 SR prefix
                                            
                                            .. attribute:: srv6_packets_dropped
                                            
                                            	SRv6 Packets dropped for a prefix
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            .. attribute:: srv6_packets_forwarded
                                            
                                            	SRv6 packets forwarded for a prefix
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information.Srv6Statistics, self).__init__()

                                                self.yang_name = "srv6-statistics"
                                                self.yang_parent_name = "srv6-information"

                                                self.srv6_packets_dropped = YLeaf(YType.uint64, "srv6-packets-dropped")

                                                self.srv6_packets_forwarded = YLeaf(YType.uint64, "srv6-packets-forwarded")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("srv6_packets_dropped",
                                                                "srv6_packets_forwarded") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information.Srv6Statistics, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information.Srv6Statistics, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.srv6_packets_dropped.is_set or
                                                    self.srv6_packets_forwarded.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.srv6_packets_dropped.yfilter != YFilter.not_set or
                                                    self.srv6_packets_forwarded.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "srv6-statistics" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.srv6_packets_dropped.is_set or self.srv6_packets_dropped.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.srv6_packets_dropped.get_name_leafdata())
                                                if (self.srv6_packets_forwarded.is_set or self.srv6_packets_forwarded.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.srv6_packets_forwarded.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "srv6-packets-dropped" or name == "srv6-packets-forwarded"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "srv6-packets-dropped"):
                                                    self.srv6_packets_dropped = value
                                                    self.srv6_packets_dropped.value_namespace = name_space
                                                    self.srv6_packets_dropped.value_namespace_prefix = name_space_prefix
                                                if(value_path == "srv6-packets-forwarded"):
                                                    self.srv6_packets_forwarded = value
                                                    self.srv6_packets_forwarded.value_namespace = name_space
                                                    self.srv6_packets_forwarded.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.route_is_sripv6_flag.is_set or
                                                self.sripv6_stats_valid_flag.is_set or
                                                self.srv6_pfx_resolved_via_policy_label.is_set or
                                                (self.srv6_statistics is not None and self.srv6_statistics.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.route_is_sripv6_flag.yfilter != YFilter.not_set or
                                                self.sripv6_stats_valid_flag.yfilter != YFilter.not_set or
                                                self.srv6_pfx_resolved_via_policy_label.yfilter != YFilter.not_set or
                                                (self.srv6_statistics is not None and self.srv6_statistics.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "srv6-information" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.route_is_sripv6_flag.is_set or self.route_is_sripv6_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.route_is_sripv6_flag.get_name_leafdata())
                                            if (self.sripv6_stats_valid_flag.is_set or self.sripv6_stats_valid_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.sripv6_stats_valid_flag.get_name_leafdata())
                                            if (self.srv6_pfx_resolved_via_policy_label.is_set or self.srv6_pfx_resolved_via_policy_label.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.srv6_pfx_resolved_via_policy_label.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "srv6-statistics"):
                                                if (self.srv6_statistics is None):
                                                    self.srv6_statistics = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information.Srv6Statistics()
                                                    self.srv6_statistics.parent = self
                                                    self._children_name_map["srv6_statistics"] = "srv6-statistics"
                                                return self.srv6_statistics

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "srv6-statistics" or name == "route-is-sripv6-flag" or name == "sripv6-stats-valid-flag" or name == "srv6-pfx-resolved-via-policy-label"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "route-is-sripv6-flag"):
                                                self.route_is_sripv6_flag = value
                                                self.route_is_sripv6_flag.value_namespace = name_space
                                                self.route_is_sripv6_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "sripv6-stats-valid-flag"):
                                                self.sripv6_stats_valid_flag = value
                                                self.sripv6_stats_valid_flag.value_namespace = name_space
                                                self.sripv6_stats_valid_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "srv6-pfx-resolved-via-policy-label"):
                                                self.srv6_pfx_resolved_via_policy_label = value
                                                self.srv6_pfx_resolved_via_policy_label.value_namespace = name_space
                                                self.srv6_pfx_resolved_via_policy_label.value_namespace_prefix = name_space_prefix


                                    class ExtensionObject(Entity):
                                        """
                                        Leaf Extension Object List
                                        
                                        .. attribute:: sfecd_le
                                        
                                        	sfecd le
                                        	**type**\:   :py:class:`SfecdLe <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject.SfecdLe>`
                                        
                                        .. attribute:: type
                                        
                                        	type
                                        	**type**\:   :py:class:`FibShTblFibExtBag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibShTblFibExtBag>`
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject, self).__init__()

                                            self.yang_name = "extension-object"
                                            self.yang_parent_name = "ip-prefix-detail"

                                            self.type = YLeaf(YType.enumeration, "type")

                                            self.sfecd_le = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject.SfecdLe()
                                            self.sfecd_le.parent = self
                                            self._children_name_map["sfecd_le"] = "sfecd-le"
                                            self._children_yang_names.add("sfecd-le")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject, self).__setattr__(name, value)


                                        class SfecdLe(Entity):
                                            """
                                            sfecd le
                                            
                                            .. attribute:: context_label
                                            
                                            	Context Label
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: context_label_flag
                                            
                                            	Context Label Exist
                                            	**type**\:  bool
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject.SfecdLe, self).__init__()

                                                self.yang_name = "sfecd-le"
                                                self.yang_parent_name = "extension-object"

                                                self.context_label = YLeaf(YType.uint32, "context-label")

                                                self.context_label_flag = YLeaf(YType.boolean, "context-label-flag")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("context_label",
                                                                "context_label_flag") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject.SfecdLe, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject.SfecdLe, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.context_label.is_set or
                                                    self.context_label_flag.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.context_label.yfilter != YFilter.not_set or
                                                    self.context_label_flag.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "sfecd-le" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.context_label.is_set or self.context_label.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.context_label.get_name_leafdata())
                                                if (self.context_label_flag.is_set or self.context_label_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.context_label_flag.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "context-label" or name == "context-label-flag"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "context-label"):
                                                    self.context_label = value
                                                    self.context_label.value_namespace = name_space
                                                    self.context_label.value_namespace_prefix = name_space_prefix
                                                if(value_path == "context-label-flag"):
                                                    self.context_label_flag = value
                                                    self.context_label_flag.value_namespace = name_space
                                                    self.context_label_flag.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.type.is_set or
                                                (self.sfecd_le is not None and self.sfecd_le.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.type.yfilter != YFilter.not_set or
                                                (self.sfecd_le is not None and self.sfecd_le.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "extension-object" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "sfecd-le"):
                                                if (self.sfecd_le is None):
                                                    self.sfecd_le = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject.SfecdLe()
                                                    self.sfecd_le.parent = self
                                                    self._children_name_map["sfecd_le"] = "sfecd-le"
                                                return self.sfecd_le

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "sfecd-le" or name == "type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "type"):
                                                self.type = value
                                                self.type.value_namespace = name_space
                                                self.type.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.extension_object:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.broadcast_forward_flag.is_set or
                                            self.broadcast_recive_flag.is_set or
                                            self.dummy_real_zero_route.is_set or
                                            self.exact_route_result.is_set or
                                            self.external_switch_triggered.is_set or
                                            self.fib_route_download_priority.is_set or
                                            self.flags_external_ldi.is_set or
                                            self.l2_subscriber_ip_protocol.is_set or
                                            self.l2_subscriber_route.is_set or
                                            self.l2_subscriber_xconnect_id.is_set or
                                            self.l2tpv3_cookie_length_bits.is_set or
                                            self.ldi_flags.is_set or
                                            self.ldi_lw_flag.is_set or
                                            self.lspa_flags.is_set or
                                            self.number_of_referances_to_ldi.is_set or
                                            self.number_of_referances_to_path_list.is_set or
                                            self.packet_should_recieve.is_set or
                                            self.path_list_flags.is_set or
                                            self.path_list_source.is_set or
                                            self.platform_hardware.is_set or
                                            self.prefix.is_set or
                                            self.prefix_connected.is_set or
                                            self.prefix_for_adjancency.is_set or
                                            self.prefix_for_pic_next_hop.is_set or
                                            self.prefix_is_static_or_connected.is_set or
                                            self.prefix_length.is_set or
                                            self.protocol_type_fib_entry.is_set or
                                            self.purgable_after_purge_interval.is_set or
                                            self.ref_counter_of_ldi_lw_ldi.is_set or
                                            self.route_attribute_flag.is_set or
                                            self.route_for_external_reach_linecard_flag.is_set or
                                            self.route_is_sr_flag.is_set or
                                            self.time_of_last_update_in_msec.is_set or
                                            self.type_of_ldi_lw_ldi.is_set or
                                            self.version_of_route.is_set or
                                            self.zero_by_zero_route_as_default.is_set or
                                            (self.detail_fib_entry_information is not None and self.detail_fib_entry_information.has_data()) or
                                            (self.fib_entry_path is not None and self.fib_entry_path.has_data()) or
                                            (self.srv6_information is not None and self.srv6_information.has_data()))

                                    def has_operation(self):
                                        for c in self.extension_object:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.broadcast_forward_flag.yfilter != YFilter.not_set or
                                            self.broadcast_recive_flag.yfilter != YFilter.not_set or
                                            self.dummy_real_zero_route.yfilter != YFilter.not_set or
                                            self.exact_route_result.yfilter != YFilter.not_set or
                                            self.external_switch_triggered.yfilter != YFilter.not_set or
                                            self.fib_route_download_priority.yfilter != YFilter.not_set or
                                            self.flags_external_ldi.yfilter != YFilter.not_set or
                                            self.l2_subscriber_ip_protocol.yfilter != YFilter.not_set or
                                            self.l2_subscriber_route.yfilter != YFilter.not_set or
                                            self.l2_subscriber_xconnect_id.yfilter != YFilter.not_set or
                                            self.l2tpv3_cookie_length_bits.yfilter != YFilter.not_set or
                                            self.ldi_flags.yfilter != YFilter.not_set or
                                            self.ldi_lw_flag.yfilter != YFilter.not_set or
                                            self.lspa_flags.yfilter != YFilter.not_set or
                                            self.number_of_referances_to_ldi.yfilter != YFilter.not_set or
                                            self.number_of_referances_to_path_list.yfilter != YFilter.not_set or
                                            self.packet_should_recieve.yfilter != YFilter.not_set or
                                            self.path_list_flags.yfilter != YFilter.not_set or
                                            self.path_list_source.yfilter != YFilter.not_set or
                                            self.platform_hardware.yfilter != YFilter.not_set or
                                            self.prefix.yfilter != YFilter.not_set or
                                            self.prefix_connected.yfilter != YFilter.not_set or
                                            self.prefix_for_adjancency.yfilter != YFilter.not_set or
                                            self.prefix_for_pic_next_hop.yfilter != YFilter.not_set or
                                            self.prefix_is_static_or_connected.yfilter != YFilter.not_set or
                                            self.prefix_length.yfilter != YFilter.not_set or
                                            self.protocol_type_fib_entry.yfilter != YFilter.not_set or
                                            self.purgable_after_purge_interval.yfilter != YFilter.not_set or
                                            self.ref_counter_of_ldi_lw_ldi.yfilter != YFilter.not_set or
                                            self.route_attribute_flag.yfilter != YFilter.not_set or
                                            self.route_for_external_reach_linecard_flag.yfilter != YFilter.not_set or
                                            self.route_is_sr_flag.yfilter != YFilter.not_set or
                                            self.time_of_last_update_in_msec.yfilter != YFilter.not_set or
                                            self.type_of_ldi_lw_ldi.yfilter != YFilter.not_set or
                                            self.version_of_route.yfilter != YFilter.not_set or
                                            self.zero_by_zero_route_as_default.yfilter != YFilter.not_set or
                                            (self.detail_fib_entry_information is not None and self.detail_fib_entry_information.has_operation()) or
                                            (self.fib_entry_path is not None and self.fib_entry_path.has_operation()) or
                                            (self.srv6_information is not None and self.srv6_information.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ip-prefix-detail" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.broadcast_forward_flag.is_set or self.broadcast_forward_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.broadcast_forward_flag.get_name_leafdata())
                                        if (self.broadcast_recive_flag.is_set or self.broadcast_recive_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.broadcast_recive_flag.get_name_leafdata())
                                        if (self.dummy_real_zero_route.is_set or self.dummy_real_zero_route.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dummy_real_zero_route.get_name_leafdata())
                                        if (self.exact_route_result.is_set or self.exact_route_result.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.exact_route_result.get_name_leafdata())
                                        if (self.external_switch_triggered.is_set or self.external_switch_triggered.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.external_switch_triggered.get_name_leafdata())
                                        if (self.fib_route_download_priority.is_set or self.fib_route_download_priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fib_route_download_priority.get_name_leafdata())
                                        if (self.flags_external_ldi.is_set or self.flags_external_ldi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.flags_external_ldi.get_name_leafdata())
                                        if (self.l2_subscriber_ip_protocol.is_set or self.l2_subscriber_ip_protocol.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.l2_subscriber_ip_protocol.get_name_leafdata())
                                        if (self.l2_subscriber_route.is_set or self.l2_subscriber_route.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.l2_subscriber_route.get_name_leafdata())
                                        if (self.l2_subscriber_xconnect_id.is_set or self.l2_subscriber_xconnect_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.l2_subscriber_xconnect_id.get_name_leafdata())
                                        if (self.l2tpv3_cookie_length_bits.is_set or self.l2tpv3_cookie_length_bits.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.l2tpv3_cookie_length_bits.get_name_leafdata())
                                        if (self.ldi_flags.is_set or self.ldi_flags.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ldi_flags.get_name_leafdata())
                                        if (self.ldi_lw_flag.is_set or self.ldi_lw_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ldi_lw_flag.get_name_leafdata())
                                        if (self.lspa_flags.is_set or self.lspa_flags.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.lspa_flags.get_name_leafdata())
                                        if (self.number_of_referances_to_ldi.is_set or self.number_of_referances_to_ldi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.number_of_referances_to_ldi.get_name_leafdata())
                                        if (self.number_of_referances_to_path_list.is_set or self.number_of_referances_to_path_list.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.number_of_referances_to_path_list.get_name_leafdata())
                                        if (self.packet_should_recieve.is_set or self.packet_should_recieve.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.packet_should_recieve.get_name_leafdata())
                                        if (self.path_list_flags.is_set or self.path_list_flags.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.path_list_flags.get_name_leafdata())
                                        if (self.path_list_source.is_set or self.path_list_source.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.path_list_source.get_name_leafdata())
                                        if (self.platform_hardware.is_set or self.platform_hardware.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_hardware.get_name_leafdata())
                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                        if (self.prefix_connected.is_set or self.prefix_connected.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_connected.get_name_leafdata())
                                        if (self.prefix_for_adjancency.is_set or self.prefix_for_adjancency.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_for_adjancency.get_name_leafdata())
                                        if (self.prefix_for_pic_next_hop.is_set or self.prefix_for_pic_next_hop.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_for_pic_next_hop.get_name_leafdata())
                                        if (self.prefix_is_static_or_connected.is_set or self.prefix_is_static_or_connected.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_is_static_or_connected.get_name_leafdata())
                                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_length.get_name_leafdata())
                                        if (self.protocol_type_fib_entry.is_set or self.protocol_type_fib_entry.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.protocol_type_fib_entry.get_name_leafdata())
                                        if (self.purgable_after_purge_interval.is_set or self.purgable_after_purge_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.purgable_after_purge_interval.get_name_leafdata())
                                        if (self.ref_counter_of_ldi_lw_ldi.is_set or self.ref_counter_of_ldi_lw_ldi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ref_counter_of_ldi_lw_ldi.get_name_leafdata())
                                        if (self.route_attribute_flag.is_set or self.route_attribute_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_attribute_flag.get_name_leafdata())
                                        if (self.route_for_external_reach_linecard_flag.is_set or self.route_for_external_reach_linecard_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_for_external_reach_linecard_flag.get_name_leafdata())
                                        if (self.route_is_sr_flag.is_set or self.route_is_sr_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_is_sr_flag.get_name_leafdata())
                                        if (self.time_of_last_update_in_msec.is_set or self.time_of_last_update_in_msec.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.time_of_last_update_in_msec.get_name_leafdata())
                                        if (self.type_of_ldi_lw_ldi.is_set or self.type_of_ldi_lw_ldi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type_of_ldi_lw_ldi.get_name_leafdata())
                                        if (self.version_of_route.is_set or self.version_of_route.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.version_of_route.get_name_leafdata())
                                        if (self.zero_by_zero_route_as_default.is_set or self.zero_by_zero_route_as_default.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.zero_by_zero_route_as_default.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "detail-fib-entry-information"):
                                            if (self.detail_fib_entry_information is None):
                                                self.detail_fib_entry_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.DetailFibEntryInformation()
                                                self.detail_fib_entry_information.parent = self
                                                self._children_name_map["detail_fib_entry_information"] = "detail-fib-entry-information"
                                            return self.detail_fib_entry_information

                                        if (child_yang_name == "extension-object"):
                                            for c in self.extension_object:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.ExtensionObject()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.extension_object.append(c)
                                            return c

                                        if (child_yang_name == "fib-entry-path"):
                                            if (self.fib_entry_path is None):
                                                self.fib_entry_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.FibEntryPath()
                                                self.fib_entry_path.parent = self
                                                self._children_name_map["fib_entry_path"] = "fib-entry-path"
                                            return self.fib_entry_path

                                        if (child_yang_name == "srv6-information"):
                                            if (self.srv6_information is None):
                                                self.srv6_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail.Srv6Information()
                                                self.srv6_information.parent = self
                                                self._children_name_map["srv6_information"] = "srv6-information"
                                            return self.srv6_information

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "detail-fib-entry-information" or name == "extension-object" or name == "fib-entry-path" or name == "srv6-information" or name == "broadcast-forward-flag" or name == "broadcast-recive-flag" or name == "dummy-real-zero-route" or name == "exact-route-result" or name == "external-switch-triggered" or name == "fib-route-download-priority" or name == "flags-external-ldi" or name == "l2-subscriber-ip-protocol" or name == "l2-subscriber-route" or name == "l2-subscriber-xconnect-id" or name == "l2tpv3-cookie-length-bits" or name == "ldi-flags" or name == "ldi-lw-flag" or name == "lspa-flags" or name == "number-of-referances-to-ldi" or name == "number-of-referances-to-path-list" or name == "packet-should-recieve" or name == "path-list-flags" or name == "path-list-source" or name == "platform-hardware" or name == "prefix" or name == "prefix-connected" or name == "prefix-for-adjancency" or name == "prefix-for-pic-next-hop" or name == "prefix-is-static-or-connected" or name == "prefix-length" or name == "protocol-type-fib-entry" or name == "purgable-after-purge-interval" or name == "ref-counter-of-ldi-lw-ldi" or name == "route-attribute-flag" or name == "route-for-external-reach-linecard-flag" or name == "route-is-sr-flag" or name == "time-of-last-update-in-msec" or name == "type-of-ldi-lw-ldi" or name == "version-of-route" or name == "zero-by-zero-route-as-default"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "broadcast-forward-flag"):
                                            self.broadcast_forward_flag = value
                                            self.broadcast_forward_flag.value_namespace = name_space
                                            self.broadcast_forward_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "broadcast-recive-flag"):
                                            self.broadcast_recive_flag = value
                                            self.broadcast_recive_flag.value_namespace = name_space
                                            self.broadcast_recive_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "dummy-real-zero-route"):
                                            self.dummy_real_zero_route = value
                                            self.dummy_real_zero_route.value_namespace = name_space
                                            self.dummy_real_zero_route.value_namespace_prefix = name_space_prefix
                                        if(value_path == "exact-route-result"):
                                            self.exact_route_result = value
                                            self.exact_route_result.value_namespace = name_space
                                            self.exact_route_result.value_namespace_prefix = name_space_prefix
                                        if(value_path == "external-switch-triggered"):
                                            self.external_switch_triggered = value
                                            self.external_switch_triggered.value_namespace = name_space
                                            self.external_switch_triggered.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fib-route-download-priority"):
                                            self.fib_route_download_priority = value
                                            self.fib_route_download_priority.value_namespace = name_space
                                            self.fib_route_download_priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "flags-external-ldi"):
                                            self.flags_external_ldi = value
                                            self.flags_external_ldi.value_namespace = name_space
                                            self.flags_external_ldi.value_namespace_prefix = name_space_prefix
                                        if(value_path == "l2-subscriber-ip-protocol"):
                                            self.l2_subscriber_ip_protocol = value
                                            self.l2_subscriber_ip_protocol.value_namespace = name_space
                                            self.l2_subscriber_ip_protocol.value_namespace_prefix = name_space_prefix
                                        if(value_path == "l2-subscriber-route"):
                                            self.l2_subscriber_route = value
                                            self.l2_subscriber_route.value_namespace = name_space
                                            self.l2_subscriber_route.value_namespace_prefix = name_space_prefix
                                        if(value_path == "l2-subscriber-xconnect-id"):
                                            self.l2_subscriber_xconnect_id = value
                                            self.l2_subscriber_xconnect_id.value_namespace = name_space
                                            self.l2_subscriber_xconnect_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "l2tpv3-cookie-length-bits"):
                                            self.l2tpv3_cookie_length_bits = value
                                            self.l2tpv3_cookie_length_bits.value_namespace = name_space
                                            self.l2tpv3_cookie_length_bits.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ldi-flags"):
                                            self.ldi_flags = value
                                            self.ldi_flags.value_namespace = name_space
                                            self.ldi_flags.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ldi-lw-flag"):
                                            self.ldi_lw_flag = value
                                            self.ldi_lw_flag.value_namespace = name_space
                                            self.ldi_lw_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "lspa-flags"):
                                            self.lspa_flags = value
                                            self.lspa_flags.value_namespace = name_space
                                            self.lspa_flags.value_namespace_prefix = name_space_prefix
                                        if(value_path == "number-of-referances-to-ldi"):
                                            self.number_of_referances_to_ldi = value
                                            self.number_of_referances_to_ldi.value_namespace = name_space
                                            self.number_of_referances_to_ldi.value_namespace_prefix = name_space_prefix
                                        if(value_path == "number-of-referances-to-path-list"):
                                            self.number_of_referances_to_path_list = value
                                            self.number_of_referances_to_path_list.value_namespace = name_space
                                            self.number_of_referances_to_path_list.value_namespace_prefix = name_space_prefix
                                        if(value_path == "packet-should-recieve"):
                                            self.packet_should_recieve = value
                                            self.packet_should_recieve.value_namespace = name_space
                                            self.packet_should_recieve.value_namespace_prefix = name_space_prefix
                                        if(value_path == "path-list-flags"):
                                            self.path_list_flags = value
                                            self.path_list_flags.value_namespace = name_space
                                            self.path_list_flags.value_namespace_prefix = name_space_prefix
                                        if(value_path == "path-list-source"):
                                            self.path_list_source = value
                                            self.path_list_source.value_namespace = name_space
                                            self.path_list_source.value_namespace_prefix = name_space_prefix
                                        if(value_path == "platform-hardware"):
                                            self.platform_hardware = value
                                            self.platform_hardware.value_namespace = name_space
                                            self.platform_hardware.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix"):
                                            self.prefix = value
                                            self.prefix.value_namespace = name_space
                                            self.prefix.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-connected"):
                                            self.prefix_connected = value
                                            self.prefix_connected.value_namespace = name_space
                                            self.prefix_connected.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-for-adjancency"):
                                            self.prefix_for_adjancency = value
                                            self.prefix_for_adjancency.value_namespace = name_space
                                            self.prefix_for_adjancency.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-for-pic-next-hop"):
                                            self.prefix_for_pic_next_hop = value
                                            self.prefix_for_pic_next_hop.value_namespace = name_space
                                            self.prefix_for_pic_next_hop.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-is-static-or-connected"):
                                            self.prefix_is_static_or_connected = value
                                            self.prefix_is_static_or_connected.value_namespace = name_space
                                            self.prefix_is_static_or_connected.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-length"):
                                            self.prefix_length = value
                                            self.prefix_length.value_namespace = name_space
                                            self.prefix_length.value_namespace_prefix = name_space_prefix
                                        if(value_path == "protocol-type-fib-entry"):
                                            self.protocol_type_fib_entry = value
                                            self.protocol_type_fib_entry.value_namespace = name_space
                                            self.protocol_type_fib_entry.value_namespace_prefix = name_space_prefix
                                        if(value_path == "purgable-after-purge-interval"):
                                            self.purgable_after_purge_interval = value
                                            self.purgable_after_purge_interval.value_namespace = name_space
                                            self.purgable_after_purge_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ref-counter-of-ldi-lw-ldi"):
                                            self.ref_counter_of_ldi_lw_ldi = value
                                            self.ref_counter_of_ldi_lw_ldi.value_namespace = name_space
                                            self.ref_counter_of_ldi_lw_ldi.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-attribute-flag"):
                                            self.route_attribute_flag = value
                                            self.route_attribute_flag.value_namespace = name_space
                                            self.route_attribute_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-for-external-reach-linecard-flag"):
                                            self.route_for_external_reach_linecard_flag = value
                                            self.route_for_external_reach_linecard_flag.value_namespace = name_space
                                            self.route_for_external_reach_linecard_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-is-sr-flag"):
                                            self.route_is_sr_flag = value
                                            self.route_is_sr_flag.value_namespace = name_space
                                            self.route_is_sr_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "time-of-last-update-in-msec"):
                                            self.time_of_last_update_in_msec = value
                                            self.time_of_last_update_in_msec.value_namespace = name_space
                                            self.time_of_last_update_in_msec.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type-of-ldi-lw-ldi"):
                                            self.type_of_ldi_lw_ldi = value
                                            self.type_of_ldi_lw_ldi.value_namespace = name_space
                                            self.type_of_ldi_lw_ldi.value_namespace_prefix = name_space_prefix
                                        if(value_path == "version-of-route"):
                                            self.version_of_route = value
                                            self.version_of_route.value_namespace = name_space
                                            self.version_of_route.value_namespace_prefix = name_space_prefix
                                        if(value_path == "zero-by-zero-route-as-default"):
                                            self.zero_by_zero_route_as_default = value
                                            self.zero_by_zero_route_as_default.value_namespace = name_space
                                            self.zero_by_zero_route_as_default.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.ip_prefix_detail:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.ip_prefix_detail:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ip-prefix-details" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "ip-prefix-detail"):
                                        for c in self.ip_prefix_detail:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails.IpPrefixDetail()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.ip_prefix_detail.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip-prefix-detail"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class Summary(Entity):
                                """
                                Operational data for FIB Tablee
                                
                                .. attribute:: cef_route_drops
                                
                                	Number of routes dropped by CEF
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: cef_version_mismatch_route_drops
                                
                                	the number of routes dropped due to version mismatch
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: cefl_bl_recycled_routes
                                
                                	Number of routes updates with recycled label handled
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: cross_shared_load_sharing_element
                                
                                	Cross\-table shared load sharing element
                                	**type**\:   :py:class:`CrossSharedLoadSharingElement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.CrossSharedLoadSharingElement>`
                                
                                .. attribute:: delete_cache_num_entries
                                
                                	Number of entries in the route delete cache
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: exclusive_load_sharing_element
                                
                                	Exclusive load sharing element
                                	**type**\:   :py:class:`ExclusiveLoadSharingElement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.ExclusiveLoadSharingElement>`
                                
                                .. attribute:: existing_leaves_revisions
                                
                                	Number of entries present on addition
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: extended_prefixes
                                
                                	Number of prefixes with extended path\-list
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: fib_default_prefix
                                
                                	Default prefix
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: fib_default_prefix_mask_length
                                
                                	Default prefix mask length
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: forwarding_elements
                                
                                	Number of forwarding elements linked to the table
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: imposition_prefixes
                                
                                	Number of prefixes with imposition LDI
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: incomplete_next_hops
                                
                                	Number of incomplete NHINFOS
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: label_shared_load_sharing_element
                                
                                	Label\-shared load sharing element
                                	**type**\:   :py:class:`LabelSharedLoadSharingElement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.LabelSharedLoadSharingElement>`
                                
                                .. attribute:: ldi_backwalks
                                
                                	pd backwalks on LDI modify with backup path
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: leaves_used_bytes
                                
                                	Total memory used by leaves
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: lisp_eid_prefixes
                                
                                	Number of lisp eid prefixes associated with table
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: lisp_eid_valid_prefixes
                                
                                	Number of lisp eid prefixes eligible for forwarding
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: lisp_rloc_objects
                                
                                	Number of lisp rloc objects associated with table
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: load_balancing
                                
                                	LBA configuration state
                                	**type**\:   :py:class:`SsLbaState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.SsLbaState>`
                                
                                .. attribute:: load_sharing_elements
                                
                                	Count of load sharing elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: load_sharing_references
                                
                                	Count of load sharing references
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: max_resolution_timer
                                
                                	IP CEF max resolution time in seconds
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: second
                                
                                .. attribute:: new_unresolve_entries
                                
                                	Number of new unresolved entries
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: next_hops
                                
                                	Number of NHINFOS
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: old_unresolve_entries
                                
                                	Number of old unresolved entries
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: prefix
                                
                                	The router\-id
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: prefix_in_place_modifications
                                
                                	Number of inplace modifications
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: reresolve_entries
                                
                                	Number of reresolved entries
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: resolution_timer
                                
                                	IP CEF resolution timer in seconds
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: second
                                
                                .. attribute:: routes
                                
                                	Number of routes
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: shared_load_sharing_element
                                
                                	Shared load sharing element
                                	**type**\:   :py:class:`SharedLoadSharingElement <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.SharedLoadSharingElement>`
                                
                                .. attribute:: slow_process_timer
                                
                                	IP CEF slow processing time in seconds
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                	**units**\: second
                                
                                .. attribute:: ss_drop_pl_count
                                
                                	Number of dropped pathlists
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: ss_prot_route_count
                                
                                	Number of routes with FRR protection
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: ss_tbl_id
                                
                                	Table Id
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: ss_tbl_id_ptr
                                
                                	Table Id Ptr
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: ss_vr_id
                                
                                	Virtual router instance Id
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: ss_vrf_id
                                
                                	Virtual routing forwarding instance Id
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: ss_vxlan_ltep_ifh
                                
                                	VXLAN local Interface handle
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: stale_prefix_deletes
                                
                                	Number of deleted stale leafs
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: total_load_share_element_bytes
                                
                                	Total memory used by load sharing elements
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: unresolve_entries
                                
                                	Number of total unresolved entries
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary, self).__init__()

                                    self.yang_name = "summary"
                                    self.yang_parent_name = "vrf"

                                    self.cef_route_drops = YLeaf(YType.uint32, "cef-route-drops")

                                    self.cef_version_mismatch_route_drops = YLeaf(YType.uint64, "cef-version-mismatch-route-drops")

                                    self.cefl_bl_recycled_routes = YLeaf(YType.uint32, "cefl-bl-recycled-routes")

                                    self.delete_cache_num_entries = YLeaf(YType.uint32, "delete-cache-num-entries")

                                    self.existing_leaves_revisions = YLeaf(YType.uint32, "existing-leaves-revisions")

                                    self.extended_prefixes = YLeaf(YType.uint32, "extended-prefixes")

                                    self.fib_default_prefix = YLeaf(YType.uint32, "fib-default-prefix")

                                    self.fib_default_prefix_mask_length = YLeaf(YType.uint32, "fib-default-prefix-mask-length")

                                    self.forwarding_elements = YLeaf(YType.uint32, "forwarding-elements")

                                    self.imposition_prefixes = YLeaf(YType.uint32, "imposition-prefixes")

                                    self.incomplete_next_hops = YLeaf(YType.uint32, "incomplete-next-hops")

                                    self.ldi_backwalks = YLeaf(YType.uint32, "ldi-backwalks")

                                    self.leaves_used_bytes = YLeaf(YType.uint32, "leaves-used-bytes")

                                    self.lisp_eid_prefixes = YLeaf(YType.uint32, "lisp-eid-prefixes")

                                    self.lisp_eid_valid_prefixes = YLeaf(YType.uint32, "lisp-eid-valid-prefixes")

                                    self.lisp_rloc_objects = YLeaf(YType.uint32, "lisp-rloc-objects")

                                    self.load_balancing = YLeaf(YType.enumeration, "load-balancing")

                                    self.load_sharing_elements = YLeaf(YType.uint32, "load-sharing-elements")

                                    self.load_sharing_references = YLeaf(YType.uint64, "load-sharing-references")

                                    self.max_resolution_timer = YLeaf(YType.uint32, "max-resolution-timer")

                                    self.new_unresolve_entries = YLeaf(YType.uint32, "new-unresolve-entries")

                                    self.next_hops = YLeaf(YType.uint32, "next-hops")

                                    self.old_unresolve_entries = YLeaf(YType.uint32, "old-unresolve-entries")

                                    self.prefix = YLeaf(YType.str, "prefix")

                                    self.prefix_in_place_modifications = YLeaf(YType.uint32, "prefix-in-place-modifications")

                                    self.reresolve_entries = YLeaf(YType.uint32, "reresolve-entries")

                                    self.resolution_timer = YLeaf(YType.uint32, "resolution-timer")

                                    self.routes = YLeaf(YType.uint32, "routes")

                                    self.slow_process_timer = YLeaf(YType.uint32, "slow-process-timer")

                                    self.ss_drop_pl_count = YLeaf(YType.uint32, "ss-drop-pl-count")

                                    self.ss_prot_route_count = YLeaf(YType.uint32, "ss-prot-route-count")

                                    self.ss_tbl_id = YLeaf(YType.uint32, "ss-tbl-id")

                                    self.ss_tbl_id_ptr = YLeaf(YType.uint32, "ss-tbl-id-ptr")

                                    self.ss_vr_id = YLeaf(YType.uint32, "ss-vr-id")

                                    self.ss_vrf_id = YLeaf(YType.uint32, "ss-vrf-id")

                                    self.ss_vxlan_ltep_ifh = YLeaf(YType.str, "ss-vxlan-ltep-ifh")

                                    self.stale_prefix_deletes = YLeaf(YType.uint32, "stale-prefix-deletes")

                                    self.total_load_share_element_bytes = YLeaf(YType.uint32, "total-load-share-element-bytes")

                                    self.unresolve_entries = YLeaf(YType.uint32, "unresolve-entries")

                                    self.cross_shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.CrossSharedLoadSharingElement()
                                    self.cross_shared_load_sharing_element.parent = self
                                    self._children_name_map["cross_shared_load_sharing_element"] = "cross-shared-load-sharing-element"
                                    self._children_yang_names.add("cross-shared-load-sharing-element")

                                    self.exclusive_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.ExclusiveLoadSharingElement()
                                    self.exclusive_load_sharing_element.parent = self
                                    self._children_name_map["exclusive_load_sharing_element"] = "exclusive-load-sharing-element"
                                    self._children_yang_names.add("exclusive-load-sharing-element")

                                    self.label_shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.LabelSharedLoadSharingElement()
                                    self.label_shared_load_sharing_element.parent = self
                                    self._children_name_map["label_shared_load_sharing_element"] = "label-shared-load-sharing-element"
                                    self._children_yang_names.add("label-shared-load-sharing-element")

                                    self.shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.SharedLoadSharingElement()
                                    self.shared_load_sharing_element.parent = self
                                    self._children_name_map["shared_load_sharing_element"] = "shared-load-sharing-element"
                                    self._children_yang_names.add("shared-load-sharing-element")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("cef_route_drops",
                                                    "cef_version_mismatch_route_drops",
                                                    "cefl_bl_recycled_routes",
                                                    "delete_cache_num_entries",
                                                    "existing_leaves_revisions",
                                                    "extended_prefixes",
                                                    "fib_default_prefix",
                                                    "fib_default_prefix_mask_length",
                                                    "forwarding_elements",
                                                    "imposition_prefixes",
                                                    "incomplete_next_hops",
                                                    "ldi_backwalks",
                                                    "leaves_used_bytes",
                                                    "lisp_eid_prefixes",
                                                    "lisp_eid_valid_prefixes",
                                                    "lisp_rloc_objects",
                                                    "load_balancing",
                                                    "load_sharing_elements",
                                                    "load_sharing_references",
                                                    "max_resolution_timer",
                                                    "new_unresolve_entries",
                                                    "next_hops",
                                                    "old_unresolve_entries",
                                                    "prefix",
                                                    "prefix_in_place_modifications",
                                                    "reresolve_entries",
                                                    "resolution_timer",
                                                    "routes",
                                                    "slow_process_timer",
                                                    "ss_drop_pl_count",
                                                    "ss_prot_route_count",
                                                    "ss_tbl_id",
                                                    "ss_tbl_id_ptr",
                                                    "ss_vr_id",
                                                    "ss_vrf_id",
                                                    "ss_vxlan_ltep_ifh",
                                                    "stale_prefix_deletes",
                                                    "total_load_share_element_bytes",
                                                    "unresolve_entries") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary, self).__setattr__(name, value)


                                class ExclusiveLoadSharingElement(Entity):
                                    """
                                    Exclusive load sharing element
                                    
                                    .. attribute:: platform_shared_load_info_elements
                                    
                                    	Count of platform shared Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: platform_shared_path_list_elements
                                    
                                    	Count of platform shared Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: recursive_load_info_elements
                                    
                                    	Count of recursive Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: recursive_path_list_elements
                                    
                                    	Count of recursive Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: retry_path_list_elements
                                    
                                    	Count of Pathlist elements in retry
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_load_info_elements
                                    
                                    	Total count of Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_load_sharing_element_bytes
                                    
                                    	Total memory used by load sharing elements in bytes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: byte
                                    
                                    .. attribute:: total_load_sharing_element_references
                                    
                                    	Total count of references to load sharing elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: total_path_list_elements
                                    
                                    	Total count of Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: xpl_load_info_elements
                                    
                                    	Count of XPL Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.ExclusiveLoadSharingElement, self).__init__()

                                        self.yang_name = "exclusive-load-sharing-element"
                                        self.yang_parent_name = "summary"

                                        self.platform_shared_load_info_elements = YLeaf(YType.uint32, "platform-shared-load-info-elements")

                                        self.platform_shared_path_list_elements = YLeaf(YType.uint32, "platform-shared-path-list-elements")

                                        self.recursive_load_info_elements = YLeaf(YType.uint32, "recursive-load-info-elements")

                                        self.recursive_path_list_elements = YLeaf(YType.uint32, "recursive-path-list-elements")

                                        self.retry_path_list_elements = YLeaf(YType.uint32, "retry-path-list-elements")

                                        self.total_load_info_elements = YLeaf(YType.uint32, "total-load-info-elements")

                                        self.total_load_sharing_element_bytes = YLeaf(YType.uint32, "total-load-sharing-element-bytes")

                                        self.total_load_sharing_element_references = YLeaf(YType.uint64, "total-load-sharing-element-references")

                                        self.total_path_list_elements = YLeaf(YType.uint32, "total-path-list-elements")

                                        self.xpl_load_info_elements = YLeaf(YType.uint32, "xpl-load-info-elements")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("platform_shared_load_info_elements",
                                                        "platform_shared_path_list_elements",
                                                        "recursive_load_info_elements",
                                                        "recursive_path_list_elements",
                                                        "retry_path_list_elements",
                                                        "total_load_info_elements",
                                                        "total_load_sharing_element_bytes",
                                                        "total_load_sharing_element_references",
                                                        "total_path_list_elements",
                                                        "xpl_load_info_elements") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.ExclusiveLoadSharingElement, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.ExclusiveLoadSharingElement, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.platform_shared_load_info_elements.is_set or
                                            self.platform_shared_path_list_elements.is_set or
                                            self.recursive_load_info_elements.is_set or
                                            self.recursive_path_list_elements.is_set or
                                            self.retry_path_list_elements.is_set or
                                            self.total_load_info_elements.is_set or
                                            self.total_load_sharing_element_bytes.is_set or
                                            self.total_load_sharing_element_references.is_set or
                                            self.total_path_list_elements.is_set or
                                            self.xpl_load_info_elements.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.platform_shared_load_info_elements.yfilter != YFilter.not_set or
                                            self.platform_shared_path_list_elements.yfilter != YFilter.not_set or
                                            self.recursive_load_info_elements.yfilter != YFilter.not_set or
                                            self.recursive_path_list_elements.yfilter != YFilter.not_set or
                                            self.retry_path_list_elements.yfilter != YFilter.not_set or
                                            self.total_load_info_elements.yfilter != YFilter.not_set or
                                            self.total_load_sharing_element_bytes.yfilter != YFilter.not_set or
                                            self.total_load_sharing_element_references.yfilter != YFilter.not_set or
                                            self.total_path_list_elements.yfilter != YFilter.not_set or
                                            self.xpl_load_info_elements.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "exclusive-load-sharing-element" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.platform_shared_load_info_elements.is_set or self.platform_shared_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_shared_load_info_elements.get_name_leafdata())
                                        if (self.platform_shared_path_list_elements.is_set or self.platform_shared_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_shared_path_list_elements.get_name_leafdata())
                                        if (self.recursive_load_info_elements.is_set or self.recursive_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.recursive_load_info_elements.get_name_leafdata())
                                        if (self.recursive_path_list_elements.is_set or self.recursive_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.recursive_path_list_elements.get_name_leafdata())
                                        if (self.retry_path_list_elements.is_set or self.retry_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retry_path_list_elements.get_name_leafdata())
                                        if (self.total_load_info_elements.is_set or self.total_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_info_elements.get_name_leafdata())
                                        if (self.total_load_sharing_element_bytes.is_set or self.total_load_sharing_element_bytes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_sharing_element_bytes.get_name_leafdata())
                                        if (self.total_load_sharing_element_references.is_set or self.total_load_sharing_element_references.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_sharing_element_references.get_name_leafdata())
                                        if (self.total_path_list_elements.is_set or self.total_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_path_list_elements.get_name_leafdata())
                                        if (self.xpl_load_info_elements.is_set or self.xpl_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.xpl_load_info_elements.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "platform-shared-load-info-elements" or name == "platform-shared-path-list-elements" or name == "recursive-load-info-elements" or name == "recursive-path-list-elements" or name == "retry-path-list-elements" or name == "total-load-info-elements" or name == "total-load-sharing-element-bytes" or name == "total-load-sharing-element-references" or name == "total-path-list-elements" or name == "xpl-load-info-elements"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "platform-shared-load-info-elements"):
                                            self.platform_shared_load_info_elements = value
                                            self.platform_shared_load_info_elements.value_namespace = name_space
                                            self.platform_shared_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "platform-shared-path-list-elements"):
                                            self.platform_shared_path_list_elements = value
                                            self.platform_shared_path_list_elements.value_namespace = name_space
                                            self.platform_shared_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "recursive-load-info-elements"):
                                            self.recursive_load_info_elements = value
                                            self.recursive_load_info_elements.value_namespace = name_space
                                            self.recursive_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "recursive-path-list-elements"):
                                            self.recursive_path_list_elements = value
                                            self.recursive_path_list_elements.value_namespace = name_space
                                            self.recursive_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retry-path-list-elements"):
                                            self.retry_path_list_elements = value
                                            self.retry_path_list_elements.value_namespace = name_space
                                            self.retry_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-info-elements"):
                                            self.total_load_info_elements = value
                                            self.total_load_info_elements.value_namespace = name_space
                                            self.total_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-sharing-element-bytes"):
                                            self.total_load_sharing_element_bytes = value
                                            self.total_load_sharing_element_bytes.value_namespace = name_space
                                            self.total_load_sharing_element_bytes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-sharing-element-references"):
                                            self.total_load_sharing_element_references = value
                                            self.total_load_sharing_element_references.value_namespace = name_space
                                            self.total_load_sharing_element_references.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-path-list-elements"):
                                            self.total_path_list_elements = value
                                            self.total_path_list_elements.value_namespace = name_space
                                            self.total_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "xpl-load-info-elements"):
                                            self.xpl_load_info_elements = value
                                            self.xpl_load_info_elements.value_namespace = name_space
                                            self.xpl_load_info_elements.value_namespace_prefix = name_space_prefix


                                class SharedLoadSharingElement(Entity):
                                    """
                                    Shared load sharing element
                                    
                                    .. attribute:: platform_shared_load_info_elements
                                    
                                    	Count of platform shared Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: platform_shared_path_list_elements
                                    
                                    	Count of platform shared Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: recursive_load_info_elements
                                    
                                    	Count of recursive Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: recursive_path_list_elements
                                    
                                    	Count of recursive Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: retry_path_list_elements
                                    
                                    	Count of Pathlist elements in retry
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_load_info_elements
                                    
                                    	Total count of Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_load_sharing_element_bytes
                                    
                                    	Total memory used by load sharing elements in bytes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: byte
                                    
                                    .. attribute:: total_load_sharing_element_references
                                    
                                    	Total count of references to load sharing elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: total_path_list_elements
                                    
                                    	Total count of Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: xpl_load_info_elements
                                    
                                    	Count of XPL Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.SharedLoadSharingElement, self).__init__()

                                        self.yang_name = "shared-load-sharing-element"
                                        self.yang_parent_name = "summary"

                                        self.platform_shared_load_info_elements = YLeaf(YType.uint32, "platform-shared-load-info-elements")

                                        self.platform_shared_path_list_elements = YLeaf(YType.uint32, "platform-shared-path-list-elements")

                                        self.recursive_load_info_elements = YLeaf(YType.uint32, "recursive-load-info-elements")

                                        self.recursive_path_list_elements = YLeaf(YType.uint32, "recursive-path-list-elements")

                                        self.retry_path_list_elements = YLeaf(YType.uint32, "retry-path-list-elements")

                                        self.total_load_info_elements = YLeaf(YType.uint32, "total-load-info-elements")

                                        self.total_load_sharing_element_bytes = YLeaf(YType.uint32, "total-load-sharing-element-bytes")

                                        self.total_load_sharing_element_references = YLeaf(YType.uint64, "total-load-sharing-element-references")

                                        self.total_path_list_elements = YLeaf(YType.uint32, "total-path-list-elements")

                                        self.xpl_load_info_elements = YLeaf(YType.uint32, "xpl-load-info-elements")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("platform_shared_load_info_elements",
                                                        "platform_shared_path_list_elements",
                                                        "recursive_load_info_elements",
                                                        "recursive_path_list_elements",
                                                        "retry_path_list_elements",
                                                        "total_load_info_elements",
                                                        "total_load_sharing_element_bytes",
                                                        "total_load_sharing_element_references",
                                                        "total_path_list_elements",
                                                        "xpl_load_info_elements") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.SharedLoadSharingElement, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.SharedLoadSharingElement, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.platform_shared_load_info_elements.is_set or
                                            self.platform_shared_path_list_elements.is_set or
                                            self.recursive_load_info_elements.is_set or
                                            self.recursive_path_list_elements.is_set or
                                            self.retry_path_list_elements.is_set or
                                            self.total_load_info_elements.is_set or
                                            self.total_load_sharing_element_bytes.is_set or
                                            self.total_load_sharing_element_references.is_set or
                                            self.total_path_list_elements.is_set or
                                            self.xpl_load_info_elements.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.platform_shared_load_info_elements.yfilter != YFilter.not_set or
                                            self.platform_shared_path_list_elements.yfilter != YFilter.not_set or
                                            self.recursive_load_info_elements.yfilter != YFilter.not_set or
                                            self.recursive_path_list_elements.yfilter != YFilter.not_set or
                                            self.retry_path_list_elements.yfilter != YFilter.not_set or
                                            self.total_load_info_elements.yfilter != YFilter.not_set or
                                            self.total_load_sharing_element_bytes.yfilter != YFilter.not_set or
                                            self.total_load_sharing_element_references.yfilter != YFilter.not_set or
                                            self.total_path_list_elements.yfilter != YFilter.not_set or
                                            self.xpl_load_info_elements.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "shared-load-sharing-element" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.platform_shared_load_info_elements.is_set or self.platform_shared_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_shared_load_info_elements.get_name_leafdata())
                                        if (self.platform_shared_path_list_elements.is_set or self.platform_shared_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_shared_path_list_elements.get_name_leafdata())
                                        if (self.recursive_load_info_elements.is_set or self.recursive_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.recursive_load_info_elements.get_name_leafdata())
                                        if (self.recursive_path_list_elements.is_set or self.recursive_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.recursive_path_list_elements.get_name_leafdata())
                                        if (self.retry_path_list_elements.is_set or self.retry_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retry_path_list_elements.get_name_leafdata())
                                        if (self.total_load_info_elements.is_set or self.total_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_info_elements.get_name_leafdata())
                                        if (self.total_load_sharing_element_bytes.is_set or self.total_load_sharing_element_bytes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_sharing_element_bytes.get_name_leafdata())
                                        if (self.total_load_sharing_element_references.is_set or self.total_load_sharing_element_references.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_sharing_element_references.get_name_leafdata())
                                        if (self.total_path_list_elements.is_set or self.total_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_path_list_elements.get_name_leafdata())
                                        if (self.xpl_load_info_elements.is_set or self.xpl_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.xpl_load_info_elements.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "platform-shared-load-info-elements" or name == "platform-shared-path-list-elements" or name == "recursive-load-info-elements" or name == "recursive-path-list-elements" or name == "retry-path-list-elements" or name == "total-load-info-elements" or name == "total-load-sharing-element-bytes" or name == "total-load-sharing-element-references" or name == "total-path-list-elements" or name == "xpl-load-info-elements"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "platform-shared-load-info-elements"):
                                            self.platform_shared_load_info_elements = value
                                            self.platform_shared_load_info_elements.value_namespace = name_space
                                            self.platform_shared_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "platform-shared-path-list-elements"):
                                            self.platform_shared_path_list_elements = value
                                            self.platform_shared_path_list_elements.value_namespace = name_space
                                            self.platform_shared_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "recursive-load-info-elements"):
                                            self.recursive_load_info_elements = value
                                            self.recursive_load_info_elements.value_namespace = name_space
                                            self.recursive_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "recursive-path-list-elements"):
                                            self.recursive_path_list_elements = value
                                            self.recursive_path_list_elements.value_namespace = name_space
                                            self.recursive_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retry-path-list-elements"):
                                            self.retry_path_list_elements = value
                                            self.retry_path_list_elements.value_namespace = name_space
                                            self.retry_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-info-elements"):
                                            self.total_load_info_elements = value
                                            self.total_load_info_elements.value_namespace = name_space
                                            self.total_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-sharing-element-bytes"):
                                            self.total_load_sharing_element_bytes = value
                                            self.total_load_sharing_element_bytes.value_namespace = name_space
                                            self.total_load_sharing_element_bytes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-sharing-element-references"):
                                            self.total_load_sharing_element_references = value
                                            self.total_load_sharing_element_references.value_namespace = name_space
                                            self.total_load_sharing_element_references.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-path-list-elements"):
                                            self.total_path_list_elements = value
                                            self.total_path_list_elements.value_namespace = name_space
                                            self.total_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "xpl-load-info-elements"):
                                            self.xpl_load_info_elements = value
                                            self.xpl_load_info_elements.value_namespace = name_space
                                            self.xpl_load_info_elements.value_namespace_prefix = name_space_prefix


                                class CrossSharedLoadSharingElement(Entity):
                                    """
                                    Cross\-table shared load sharing element
                                    
                                    .. attribute:: platform_shared_load_info_elements
                                    
                                    	Count of platform shared Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: platform_shared_path_list_elements
                                    
                                    	Count of platform shared Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: recursive_load_info_elements
                                    
                                    	Count of recursive Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: recursive_path_list_elements
                                    
                                    	Count of recursive Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: retry_path_list_elements
                                    
                                    	Count of Pathlist elements in retry
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_load_info_elements
                                    
                                    	Total count of Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_load_sharing_element_bytes
                                    
                                    	Total memory used by load sharing elements in bytes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: byte
                                    
                                    .. attribute:: total_load_sharing_element_references
                                    
                                    	Total count of references to load sharing elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: total_path_list_elements
                                    
                                    	Total count of Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: xpl_load_info_elements
                                    
                                    	Count of XPL Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.CrossSharedLoadSharingElement, self).__init__()

                                        self.yang_name = "cross-shared-load-sharing-element"
                                        self.yang_parent_name = "summary"

                                        self.platform_shared_load_info_elements = YLeaf(YType.uint32, "platform-shared-load-info-elements")

                                        self.platform_shared_path_list_elements = YLeaf(YType.uint32, "platform-shared-path-list-elements")

                                        self.recursive_load_info_elements = YLeaf(YType.uint32, "recursive-load-info-elements")

                                        self.recursive_path_list_elements = YLeaf(YType.uint32, "recursive-path-list-elements")

                                        self.retry_path_list_elements = YLeaf(YType.uint32, "retry-path-list-elements")

                                        self.total_load_info_elements = YLeaf(YType.uint32, "total-load-info-elements")

                                        self.total_load_sharing_element_bytes = YLeaf(YType.uint32, "total-load-sharing-element-bytes")

                                        self.total_load_sharing_element_references = YLeaf(YType.uint64, "total-load-sharing-element-references")

                                        self.total_path_list_elements = YLeaf(YType.uint32, "total-path-list-elements")

                                        self.xpl_load_info_elements = YLeaf(YType.uint32, "xpl-load-info-elements")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("platform_shared_load_info_elements",
                                                        "platform_shared_path_list_elements",
                                                        "recursive_load_info_elements",
                                                        "recursive_path_list_elements",
                                                        "retry_path_list_elements",
                                                        "total_load_info_elements",
                                                        "total_load_sharing_element_bytes",
                                                        "total_load_sharing_element_references",
                                                        "total_path_list_elements",
                                                        "xpl_load_info_elements") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.CrossSharedLoadSharingElement, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.CrossSharedLoadSharingElement, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.platform_shared_load_info_elements.is_set or
                                            self.platform_shared_path_list_elements.is_set or
                                            self.recursive_load_info_elements.is_set or
                                            self.recursive_path_list_elements.is_set or
                                            self.retry_path_list_elements.is_set or
                                            self.total_load_info_elements.is_set or
                                            self.total_load_sharing_element_bytes.is_set or
                                            self.total_load_sharing_element_references.is_set or
                                            self.total_path_list_elements.is_set or
                                            self.xpl_load_info_elements.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.platform_shared_load_info_elements.yfilter != YFilter.not_set or
                                            self.platform_shared_path_list_elements.yfilter != YFilter.not_set or
                                            self.recursive_load_info_elements.yfilter != YFilter.not_set or
                                            self.recursive_path_list_elements.yfilter != YFilter.not_set or
                                            self.retry_path_list_elements.yfilter != YFilter.not_set or
                                            self.total_load_info_elements.yfilter != YFilter.not_set or
                                            self.total_load_sharing_element_bytes.yfilter != YFilter.not_set or
                                            self.total_load_sharing_element_references.yfilter != YFilter.not_set or
                                            self.total_path_list_elements.yfilter != YFilter.not_set or
                                            self.xpl_load_info_elements.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "cross-shared-load-sharing-element" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.platform_shared_load_info_elements.is_set or self.platform_shared_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_shared_load_info_elements.get_name_leafdata())
                                        if (self.platform_shared_path_list_elements.is_set or self.platform_shared_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_shared_path_list_elements.get_name_leafdata())
                                        if (self.recursive_load_info_elements.is_set or self.recursive_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.recursive_load_info_elements.get_name_leafdata())
                                        if (self.recursive_path_list_elements.is_set or self.recursive_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.recursive_path_list_elements.get_name_leafdata())
                                        if (self.retry_path_list_elements.is_set or self.retry_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retry_path_list_elements.get_name_leafdata())
                                        if (self.total_load_info_elements.is_set or self.total_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_info_elements.get_name_leafdata())
                                        if (self.total_load_sharing_element_bytes.is_set or self.total_load_sharing_element_bytes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_sharing_element_bytes.get_name_leafdata())
                                        if (self.total_load_sharing_element_references.is_set or self.total_load_sharing_element_references.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_sharing_element_references.get_name_leafdata())
                                        if (self.total_path_list_elements.is_set or self.total_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_path_list_elements.get_name_leafdata())
                                        if (self.xpl_load_info_elements.is_set or self.xpl_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.xpl_load_info_elements.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "platform-shared-load-info-elements" or name == "platform-shared-path-list-elements" or name == "recursive-load-info-elements" or name == "recursive-path-list-elements" or name == "retry-path-list-elements" or name == "total-load-info-elements" or name == "total-load-sharing-element-bytes" or name == "total-load-sharing-element-references" or name == "total-path-list-elements" or name == "xpl-load-info-elements"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "platform-shared-load-info-elements"):
                                            self.platform_shared_load_info_elements = value
                                            self.platform_shared_load_info_elements.value_namespace = name_space
                                            self.platform_shared_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "platform-shared-path-list-elements"):
                                            self.platform_shared_path_list_elements = value
                                            self.platform_shared_path_list_elements.value_namespace = name_space
                                            self.platform_shared_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "recursive-load-info-elements"):
                                            self.recursive_load_info_elements = value
                                            self.recursive_load_info_elements.value_namespace = name_space
                                            self.recursive_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "recursive-path-list-elements"):
                                            self.recursive_path_list_elements = value
                                            self.recursive_path_list_elements.value_namespace = name_space
                                            self.recursive_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retry-path-list-elements"):
                                            self.retry_path_list_elements = value
                                            self.retry_path_list_elements.value_namespace = name_space
                                            self.retry_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-info-elements"):
                                            self.total_load_info_elements = value
                                            self.total_load_info_elements.value_namespace = name_space
                                            self.total_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-sharing-element-bytes"):
                                            self.total_load_sharing_element_bytes = value
                                            self.total_load_sharing_element_bytes.value_namespace = name_space
                                            self.total_load_sharing_element_bytes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-sharing-element-references"):
                                            self.total_load_sharing_element_references = value
                                            self.total_load_sharing_element_references.value_namespace = name_space
                                            self.total_load_sharing_element_references.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-path-list-elements"):
                                            self.total_path_list_elements = value
                                            self.total_path_list_elements.value_namespace = name_space
                                            self.total_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "xpl-load-info-elements"):
                                            self.xpl_load_info_elements = value
                                            self.xpl_load_info_elements.value_namespace = name_space
                                            self.xpl_load_info_elements.value_namespace_prefix = name_space_prefix


                                class LabelSharedLoadSharingElement(Entity):
                                    """
                                    Label\-shared load sharing element
                                    
                                    .. attribute:: platform_shared_load_info_elements
                                    
                                    	Count of platform shared Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: platform_shared_path_list_elements
                                    
                                    	Count of platform shared Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: recursive_load_info_elements
                                    
                                    	Count of recursive Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: recursive_path_list_elements
                                    
                                    	Count of recursive Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: retry_path_list_elements
                                    
                                    	Count of Pathlist elements in retry
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_load_info_elements
                                    
                                    	Total count of Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_load_sharing_element_bytes
                                    
                                    	Total memory used by load sharing elements in bytes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    	**units**\: byte
                                    
                                    .. attribute:: total_load_sharing_element_references
                                    
                                    	Total count of references to load sharing elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: total_path_list_elements
                                    
                                    	Total count of Pathlist elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: xpl_load_info_elements
                                    
                                    	Count of XPL Loadinfo elements
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.LabelSharedLoadSharingElement, self).__init__()

                                        self.yang_name = "label-shared-load-sharing-element"
                                        self.yang_parent_name = "summary"

                                        self.platform_shared_load_info_elements = YLeaf(YType.uint32, "platform-shared-load-info-elements")

                                        self.platform_shared_path_list_elements = YLeaf(YType.uint32, "platform-shared-path-list-elements")

                                        self.recursive_load_info_elements = YLeaf(YType.uint32, "recursive-load-info-elements")

                                        self.recursive_path_list_elements = YLeaf(YType.uint32, "recursive-path-list-elements")

                                        self.retry_path_list_elements = YLeaf(YType.uint32, "retry-path-list-elements")

                                        self.total_load_info_elements = YLeaf(YType.uint32, "total-load-info-elements")

                                        self.total_load_sharing_element_bytes = YLeaf(YType.uint32, "total-load-sharing-element-bytes")

                                        self.total_load_sharing_element_references = YLeaf(YType.uint64, "total-load-sharing-element-references")

                                        self.total_path_list_elements = YLeaf(YType.uint32, "total-path-list-elements")

                                        self.xpl_load_info_elements = YLeaf(YType.uint32, "xpl-load-info-elements")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("platform_shared_load_info_elements",
                                                        "platform_shared_path_list_elements",
                                                        "recursive_load_info_elements",
                                                        "recursive_path_list_elements",
                                                        "retry_path_list_elements",
                                                        "total_load_info_elements",
                                                        "total_load_sharing_element_bytes",
                                                        "total_load_sharing_element_references",
                                                        "total_path_list_elements",
                                                        "xpl_load_info_elements") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.LabelSharedLoadSharingElement, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.LabelSharedLoadSharingElement, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.platform_shared_load_info_elements.is_set or
                                            self.platform_shared_path_list_elements.is_set or
                                            self.recursive_load_info_elements.is_set or
                                            self.recursive_path_list_elements.is_set or
                                            self.retry_path_list_elements.is_set or
                                            self.total_load_info_elements.is_set or
                                            self.total_load_sharing_element_bytes.is_set or
                                            self.total_load_sharing_element_references.is_set or
                                            self.total_path_list_elements.is_set or
                                            self.xpl_load_info_elements.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.platform_shared_load_info_elements.yfilter != YFilter.not_set or
                                            self.platform_shared_path_list_elements.yfilter != YFilter.not_set or
                                            self.recursive_load_info_elements.yfilter != YFilter.not_set or
                                            self.recursive_path_list_elements.yfilter != YFilter.not_set or
                                            self.retry_path_list_elements.yfilter != YFilter.not_set or
                                            self.total_load_info_elements.yfilter != YFilter.not_set or
                                            self.total_load_sharing_element_bytes.yfilter != YFilter.not_set or
                                            self.total_load_sharing_element_references.yfilter != YFilter.not_set or
                                            self.total_path_list_elements.yfilter != YFilter.not_set or
                                            self.xpl_load_info_elements.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "label-shared-load-sharing-element" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.platform_shared_load_info_elements.is_set or self.platform_shared_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_shared_load_info_elements.get_name_leafdata())
                                        if (self.platform_shared_path_list_elements.is_set or self.platform_shared_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_shared_path_list_elements.get_name_leafdata())
                                        if (self.recursive_load_info_elements.is_set or self.recursive_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.recursive_load_info_elements.get_name_leafdata())
                                        if (self.recursive_path_list_elements.is_set or self.recursive_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.recursive_path_list_elements.get_name_leafdata())
                                        if (self.retry_path_list_elements.is_set or self.retry_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.retry_path_list_elements.get_name_leafdata())
                                        if (self.total_load_info_elements.is_set or self.total_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_info_elements.get_name_leafdata())
                                        if (self.total_load_sharing_element_bytes.is_set or self.total_load_sharing_element_bytes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_sharing_element_bytes.get_name_leafdata())
                                        if (self.total_load_sharing_element_references.is_set or self.total_load_sharing_element_references.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_load_sharing_element_references.get_name_leafdata())
                                        if (self.total_path_list_elements.is_set or self.total_path_list_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_path_list_elements.get_name_leafdata())
                                        if (self.xpl_load_info_elements.is_set or self.xpl_load_info_elements.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.xpl_load_info_elements.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "platform-shared-load-info-elements" or name == "platform-shared-path-list-elements" or name == "recursive-load-info-elements" or name == "recursive-path-list-elements" or name == "retry-path-list-elements" or name == "total-load-info-elements" or name == "total-load-sharing-element-bytes" or name == "total-load-sharing-element-references" or name == "total-path-list-elements" or name == "xpl-load-info-elements"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "platform-shared-load-info-elements"):
                                            self.platform_shared_load_info_elements = value
                                            self.platform_shared_load_info_elements.value_namespace = name_space
                                            self.platform_shared_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "platform-shared-path-list-elements"):
                                            self.platform_shared_path_list_elements = value
                                            self.platform_shared_path_list_elements.value_namespace = name_space
                                            self.platform_shared_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "recursive-load-info-elements"):
                                            self.recursive_load_info_elements = value
                                            self.recursive_load_info_elements.value_namespace = name_space
                                            self.recursive_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "recursive-path-list-elements"):
                                            self.recursive_path_list_elements = value
                                            self.recursive_path_list_elements.value_namespace = name_space
                                            self.recursive_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "retry-path-list-elements"):
                                            self.retry_path_list_elements = value
                                            self.retry_path_list_elements.value_namespace = name_space
                                            self.retry_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-info-elements"):
                                            self.total_load_info_elements = value
                                            self.total_load_info_elements.value_namespace = name_space
                                            self.total_load_info_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-sharing-element-bytes"):
                                            self.total_load_sharing_element_bytes = value
                                            self.total_load_sharing_element_bytes.value_namespace = name_space
                                            self.total_load_sharing_element_bytes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-load-sharing-element-references"):
                                            self.total_load_sharing_element_references = value
                                            self.total_load_sharing_element_references.value_namespace = name_space
                                            self.total_load_sharing_element_references.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-path-list-elements"):
                                            self.total_path_list_elements = value
                                            self.total_path_list_elements.value_namespace = name_space
                                            self.total_path_list_elements.value_namespace_prefix = name_space_prefix
                                        if(value_path == "xpl-load-info-elements"):
                                            self.xpl_load_info_elements = value
                                            self.xpl_load_info_elements.value_namespace = name_space
                                            self.xpl_load_info_elements.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.cef_route_drops.is_set or
                                        self.cef_version_mismatch_route_drops.is_set or
                                        self.cefl_bl_recycled_routes.is_set or
                                        self.delete_cache_num_entries.is_set or
                                        self.existing_leaves_revisions.is_set or
                                        self.extended_prefixes.is_set or
                                        self.fib_default_prefix.is_set or
                                        self.fib_default_prefix_mask_length.is_set or
                                        self.forwarding_elements.is_set or
                                        self.imposition_prefixes.is_set or
                                        self.incomplete_next_hops.is_set or
                                        self.ldi_backwalks.is_set or
                                        self.leaves_used_bytes.is_set or
                                        self.lisp_eid_prefixes.is_set or
                                        self.lisp_eid_valid_prefixes.is_set or
                                        self.lisp_rloc_objects.is_set or
                                        self.load_balancing.is_set or
                                        self.load_sharing_elements.is_set or
                                        self.load_sharing_references.is_set or
                                        self.max_resolution_timer.is_set or
                                        self.new_unresolve_entries.is_set or
                                        self.next_hops.is_set or
                                        self.old_unresolve_entries.is_set or
                                        self.prefix.is_set or
                                        self.prefix_in_place_modifications.is_set or
                                        self.reresolve_entries.is_set or
                                        self.resolution_timer.is_set or
                                        self.routes.is_set or
                                        self.slow_process_timer.is_set or
                                        self.ss_drop_pl_count.is_set or
                                        self.ss_prot_route_count.is_set or
                                        self.ss_tbl_id.is_set or
                                        self.ss_tbl_id_ptr.is_set or
                                        self.ss_vr_id.is_set or
                                        self.ss_vrf_id.is_set or
                                        self.ss_vxlan_ltep_ifh.is_set or
                                        self.stale_prefix_deletes.is_set or
                                        self.total_load_share_element_bytes.is_set or
                                        self.unresolve_entries.is_set or
                                        (self.cross_shared_load_sharing_element is not None and self.cross_shared_load_sharing_element.has_data()) or
                                        (self.exclusive_load_sharing_element is not None and self.exclusive_load_sharing_element.has_data()) or
                                        (self.label_shared_load_sharing_element is not None and self.label_shared_load_sharing_element.has_data()) or
                                        (self.shared_load_sharing_element is not None and self.shared_load_sharing_element.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.cef_route_drops.yfilter != YFilter.not_set or
                                        self.cef_version_mismatch_route_drops.yfilter != YFilter.not_set or
                                        self.cefl_bl_recycled_routes.yfilter != YFilter.not_set or
                                        self.delete_cache_num_entries.yfilter != YFilter.not_set or
                                        self.existing_leaves_revisions.yfilter != YFilter.not_set or
                                        self.extended_prefixes.yfilter != YFilter.not_set or
                                        self.fib_default_prefix.yfilter != YFilter.not_set or
                                        self.fib_default_prefix_mask_length.yfilter != YFilter.not_set or
                                        self.forwarding_elements.yfilter != YFilter.not_set or
                                        self.imposition_prefixes.yfilter != YFilter.not_set or
                                        self.incomplete_next_hops.yfilter != YFilter.not_set or
                                        self.ldi_backwalks.yfilter != YFilter.not_set or
                                        self.leaves_used_bytes.yfilter != YFilter.not_set or
                                        self.lisp_eid_prefixes.yfilter != YFilter.not_set or
                                        self.lisp_eid_valid_prefixes.yfilter != YFilter.not_set or
                                        self.lisp_rloc_objects.yfilter != YFilter.not_set or
                                        self.load_balancing.yfilter != YFilter.not_set or
                                        self.load_sharing_elements.yfilter != YFilter.not_set or
                                        self.load_sharing_references.yfilter != YFilter.not_set or
                                        self.max_resolution_timer.yfilter != YFilter.not_set or
                                        self.new_unresolve_entries.yfilter != YFilter.not_set or
                                        self.next_hops.yfilter != YFilter.not_set or
                                        self.old_unresolve_entries.yfilter != YFilter.not_set or
                                        self.prefix.yfilter != YFilter.not_set or
                                        self.prefix_in_place_modifications.yfilter != YFilter.not_set or
                                        self.reresolve_entries.yfilter != YFilter.not_set or
                                        self.resolution_timer.yfilter != YFilter.not_set or
                                        self.routes.yfilter != YFilter.not_set or
                                        self.slow_process_timer.yfilter != YFilter.not_set or
                                        self.ss_drop_pl_count.yfilter != YFilter.not_set or
                                        self.ss_prot_route_count.yfilter != YFilter.not_set or
                                        self.ss_tbl_id.yfilter != YFilter.not_set or
                                        self.ss_tbl_id_ptr.yfilter != YFilter.not_set or
                                        self.ss_vr_id.yfilter != YFilter.not_set or
                                        self.ss_vrf_id.yfilter != YFilter.not_set or
                                        self.ss_vxlan_ltep_ifh.yfilter != YFilter.not_set or
                                        self.stale_prefix_deletes.yfilter != YFilter.not_set or
                                        self.total_load_share_element_bytes.yfilter != YFilter.not_set or
                                        self.unresolve_entries.yfilter != YFilter.not_set or
                                        (self.cross_shared_load_sharing_element is not None and self.cross_shared_load_sharing_element.has_operation()) or
                                        (self.exclusive_load_sharing_element is not None and self.exclusive_load_sharing_element.has_operation()) or
                                        (self.label_shared_load_sharing_element is not None and self.label_shared_load_sharing_element.has_operation()) or
                                        (self.shared_load_sharing_element is not None and self.shared_load_sharing_element.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "summary" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.cef_route_drops.is_set or self.cef_route_drops.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cef_route_drops.get_name_leafdata())
                                    if (self.cef_version_mismatch_route_drops.is_set or self.cef_version_mismatch_route_drops.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cef_version_mismatch_route_drops.get_name_leafdata())
                                    if (self.cefl_bl_recycled_routes.is_set or self.cefl_bl_recycled_routes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.cefl_bl_recycled_routes.get_name_leafdata())
                                    if (self.delete_cache_num_entries.is_set or self.delete_cache_num_entries.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.delete_cache_num_entries.get_name_leafdata())
                                    if (self.existing_leaves_revisions.is_set or self.existing_leaves_revisions.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.existing_leaves_revisions.get_name_leafdata())
                                    if (self.extended_prefixes.is_set or self.extended_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.extended_prefixes.get_name_leafdata())
                                    if (self.fib_default_prefix.is_set or self.fib_default_prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_default_prefix.get_name_leafdata())
                                    if (self.fib_default_prefix_mask_length.is_set or self.fib_default_prefix_mask_length.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_default_prefix_mask_length.get_name_leafdata())
                                    if (self.forwarding_elements.is_set or self.forwarding_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.forwarding_elements.get_name_leafdata())
                                    if (self.imposition_prefixes.is_set or self.imposition_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.imposition_prefixes.get_name_leafdata())
                                    if (self.incomplete_next_hops.is_set or self.incomplete_next_hops.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.incomplete_next_hops.get_name_leafdata())
                                    if (self.ldi_backwalks.is_set or self.ldi_backwalks.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ldi_backwalks.get_name_leafdata())
                                    if (self.leaves_used_bytes.is_set or self.leaves_used_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.leaves_used_bytes.get_name_leafdata())
                                    if (self.lisp_eid_prefixes.is_set or self.lisp_eid_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lisp_eid_prefixes.get_name_leafdata())
                                    if (self.lisp_eid_valid_prefixes.is_set or self.lisp_eid_valid_prefixes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lisp_eid_valid_prefixes.get_name_leafdata())
                                    if (self.lisp_rloc_objects.is_set or self.lisp_rloc_objects.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lisp_rloc_objects.get_name_leafdata())
                                    if (self.load_balancing.is_set or self.load_balancing.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.load_balancing.get_name_leafdata())
                                    if (self.load_sharing_elements.is_set or self.load_sharing_elements.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.load_sharing_elements.get_name_leafdata())
                                    if (self.load_sharing_references.is_set or self.load_sharing_references.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.load_sharing_references.get_name_leafdata())
                                    if (self.max_resolution_timer.is_set or self.max_resolution_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.max_resolution_timer.get_name_leafdata())
                                    if (self.new_unresolve_entries.is_set or self.new_unresolve_entries.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.new_unresolve_entries.get_name_leafdata())
                                    if (self.next_hops.is_set or self.next_hops.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hops.get_name_leafdata())
                                    if (self.old_unresolve_entries.is_set or self.old_unresolve_entries.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.old_unresolve_entries.get_name_leafdata())
                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                    if (self.prefix_in_place_modifications.is_set or self.prefix_in_place_modifications.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_in_place_modifications.get_name_leafdata())
                                    if (self.reresolve_entries.is_set or self.reresolve_entries.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.reresolve_entries.get_name_leafdata())
                                    if (self.resolution_timer.is_set or self.resolution_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.resolution_timer.get_name_leafdata())
                                    if (self.routes.is_set or self.routes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.routes.get_name_leafdata())
                                    if (self.slow_process_timer.is_set or self.slow_process_timer.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.slow_process_timer.get_name_leafdata())
                                    if (self.ss_drop_pl_count.is_set or self.ss_drop_pl_count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ss_drop_pl_count.get_name_leafdata())
                                    if (self.ss_prot_route_count.is_set or self.ss_prot_route_count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ss_prot_route_count.get_name_leafdata())
                                    if (self.ss_tbl_id.is_set or self.ss_tbl_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ss_tbl_id.get_name_leafdata())
                                    if (self.ss_tbl_id_ptr.is_set or self.ss_tbl_id_ptr.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ss_tbl_id_ptr.get_name_leafdata())
                                    if (self.ss_vr_id.is_set or self.ss_vr_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ss_vr_id.get_name_leafdata())
                                    if (self.ss_vrf_id.is_set or self.ss_vrf_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ss_vrf_id.get_name_leafdata())
                                    if (self.ss_vxlan_ltep_ifh.is_set or self.ss_vxlan_ltep_ifh.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ss_vxlan_ltep_ifh.get_name_leafdata())
                                    if (self.stale_prefix_deletes.is_set or self.stale_prefix_deletes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.stale_prefix_deletes.get_name_leafdata())
                                    if (self.total_load_share_element_bytes.is_set or self.total_load_share_element_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_load_share_element_bytes.get_name_leafdata())
                                    if (self.unresolve_entries.is_set or self.unresolve_entries.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.unresolve_entries.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "cross-shared-load-sharing-element"):
                                        if (self.cross_shared_load_sharing_element is None):
                                            self.cross_shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.CrossSharedLoadSharingElement()
                                            self.cross_shared_load_sharing_element.parent = self
                                            self._children_name_map["cross_shared_load_sharing_element"] = "cross-shared-load-sharing-element"
                                        return self.cross_shared_load_sharing_element

                                    if (child_yang_name == "exclusive-load-sharing-element"):
                                        if (self.exclusive_load_sharing_element is None):
                                            self.exclusive_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.ExclusiveLoadSharingElement()
                                            self.exclusive_load_sharing_element.parent = self
                                            self._children_name_map["exclusive_load_sharing_element"] = "exclusive-load-sharing-element"
                                        return self.exclusive_load_sharing_element

                                    if (child_yang_name == "label-shared-load-sharing-element"):
                                        if (self.label_shared_load_sharing_element is None):
                                            self.label_shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.LabelSharedLoadSharingElement()
                                            self.label_shared_load_sharing_element.parent = self
                                            self._children_name_map["label_shared_load_sharing_element"] = "label-shared-load-sharing-element"
                                        return self.label_shared_load_sharing_element

                                    if (child_yang_name == "shared-load-sharing-element"):
                                        if (self.shared_load_sharing_element is None):
                                            self.shared_load_sharing_element = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary.SharedLoadSharingElement()
                                            self.shared_load_sharing_element.parent = self
                                            self._children_name_map["shared_load_sharing_element"] = "shared-load-sharing-element"
                                        return self.shared_load_sharing_element

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "cross-shared-load-sharing-element" or name == "exclusive-load-sharing-element" or name == "label-shared-load-sharing-element" or name == "shared-load-sharing-element" or name == "cef-route-drops" or name == "cef-version-mismatch-route-drops" or name == "cefl-bl-recycled-routes" or name == "delete-cache-num-entries" or name == "existing-leaves-revisions" or name == "extended-prefixes" or name == "fib-default-prefix" or name == "fib-default-prefix-mask-length" or name == "forwarding-elements" or name == "imposition-prefixes" or name == "incomplete-next-hops" or name == "ldi-backwalks" or name == "leaves-used-bytes" or name == "lisp-eid-prefixes" or name == "lisp-eid-valid-prefixes" or name == "lisp-rloc-objects" or name == "load-balancing" or name == "load-sharing-elements" or name == "load-sharing-references" or name == "max-resolution-timer" or name == "new-unresolve-entries" or name == "next-hops" or name == "old-unresolve-entries" or name == "prefix" or name == "prefix-in-place-modifications" or name == "reresolve-entries" or name == "resolution-timer" or name == "routes" or name == "slow-process-timer" or name == "ss-drop-pl-count" or name == "ss-prot-route-count" or name == "ss-tbl-id" or name == "ss-tbl-id-ptr" or name == "ss-vr-id" or name == "ss-vrf-id" or name == "ss-vxlan-ltep-ifh" or name == "stale-prefix-deletes" or name == "total-load-share-element-bytes" or name == "unresolve-entries"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "cef-route-drops"):
                                        self.cef_route_drops = value
                                        self.cef_route_drops.value_namespace = name_space
                                        self.cef_route_drops.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cef-version-mismatch-route-drops"):
                                        self.cef_version_mismatch_route_drops = value
                                        self.cef_version_mismatch_route_drops.value_namespace = name_space
                                        self.cef_version_mismatch_route_drops.value_namespace_prefix = name_space_prefix
                                    if(value_path == "cefl-bl-recycled-routes"):
                                        self.cefl_bl_recycled_routes = value
                                        self.cefl_bl_recycled_routes.value_namespace = name_space
                                        self.cefl_bl_recycled_routes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "delete-cache-num-entries"):
                                        self.delete_cache_num_entries = value
                                        self.delete_cache_num_entries.value_namespace = name_space
                                        self.delete_cache_num_entries.value_namespace_prefix = name_space_prefix
                                    if(value_path == "existing-leaves-revisions"):
                                        self.existing_leaves_revisions = value
                                        self.existing_leaves_revisions.value_namespace = name_space
                                        self.existing_leaves_revisions.value_namespace_prefix = name_space_prefix
                                    if(value_path == "extended-prefixes"):
                                        self.extended_prefixes = value
                                        self.extended_prefixes.value_namespace = name_space
                                        self.extended_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "fib-default-prefix"):
                                        self.fib_default_prefix = value
                                        self.fib_default_prefix.value_namespace = name_space
                                        self.fib_default_prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "fib-default-prefix-mask-length"):
                                        self.fib_default_prefix_mask_length = value
                                        self.fib_default_prefix_mask_length.value_namespace = name_space
                                        self.fib_default_prefix_mask_length.value_namespace_prefix = name_space_prefix
                                    if(value_path == "forwarding-elements"):
                                        self.forwarding_elements = value
                                        self.forwarding_elements.value_namespace = name_space
                                        self.forwarding_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "imposition-prefixes"):
                                        self.imposition_prefixes = value
                                        self.imposition_prefixes.value_namespace = name_space
                                        self.imposition_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "incomplete-next-hops"):
                                        self.incomplete_next_hops = value
                                        self.incomplete_next_hops.value_namespace = name_space
                                        self.incomplete_next_hops.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ldi-backwalks"):
                                        self.ldi_backwalks = value
                                        self.ldi_backwalks.value_namespace = name_space
                                        self.ldi_backwalks.value_namespace_prefix = name_space_prefix
                                    if(value_path == "leaves-used-bytes"):
                                        self.leaves_used_bytes = value
                                        self.leaves_used_bytes.value_namespace = name_space
                                        self.leaves_used_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lisp-eid-prefixes"):
                                        self.lisp_eid_prefixes = value
                                        self.lisp_eid_prefixes.value_namespace = name_space
                                        self.lisp_eid_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lisp-eid-valid-prefixes"):
                                        self.lisp_eid_valid_prefixes = value
                                        self.lisp_eid_valid_prefixes.value_namespace = name_space
                                        self.lisp_eid_valid_prefixes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lisp-rloc-objects"):
                                        self.lisp_rloc_objects = value
                                        self.lisp_rloc_objects.value_namespace = name_space
                                        self.lisp_rloc_objects.value_namespace_prefix = name_space_prefix
                                    if(value_path == "load-balancing"):
                                        self.load_balancing = value
                                        self.load_balancing.value_namespace = name_space
                                        self.load_balancing.value_namespace_prefix = name_space_prefix
                                    if(value_path == "load-sharing-elements"):
                                        self.load_sharing_elements = value
                                        self.load_sharing_elements.value_namespace = name_space
                                        self.load_sharing_elements.value_namespace_prefix = name_space_prefix
                                    if(value_path == "load-sharing-references"):
                                        self.load_sharing_references = value
                                        self.load_sharing_references.value_namespace = name_space
                                        self.load_sharing_references.value_namespace_prefix = name_space_prefix
                                    if(value_path == "max-resolution-timer"):
                                        self.max_resolution_timer = value
                                        self.max_resolution_timer.value_namespace = name_space
                                        self.max_resolution_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "new-unresolve-entries"):
                                        self.new_unresolve_entries = value
                                        self.new_unresolve_entries.value_namespace = name_space
                                        self.new_unresolve_entries.value_namespace_prefix = name_space_prefix
                                    if(value_path == "next-hops"):
                                        self.next_hops = value
                                        self.next_hops.value_namespace = name_space
                                        self.next_hops.value_namespace_prefix = name_space_prefix
                                    if(value_path == "old-unresolve-entries"):
                                        self.old_unresolve_entries = value
                                        self.old_unresolve_entries.value_namespace = name_space
                                        self.old_unresolve_entries.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix"):
                                        self.prefix = value
                                        self.prefix.value_namespace = name_space
                                        self.prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-in-place-modifications"):
                                        self.prefix_in_place_modifications = value
                                        self.prefix_in_place_modifications.value_namespace = name_space
                                        self.prefix_in_place_modifications.value_namespace_prefix = name_space_prefix
                                    if(value_path == "reresolve-entries"):
                                        self.reresolve_entries = value
                                        self.reresolve_entries.value_namespace = name_space
                                        self.reresolve_entries.value_namespace_prefix = name_space_prefix
                                    if(value_path == "resolution-timer"):
                                        self.resolution_timer = value
                                        self.resolution_timer.value_namespace = name_space
                                        self.resolution_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "routes"):
                                        self.routes = value
                                        self.routes.value_namespace = name_space
                                        self.routes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "slow-process-timer"):
                                        self.slow_process_timer = value
                                        self.slow_process_timer.value_namespace = name_space
                                        self.slow_process_timer.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ss-drop-pl-count"):
                                        self.ss_drop_pl_count = value
                                        self.ss_drop_pl_count.value_namespace = name_space
                                        self.ss_drop_pl_count.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ss-prot-route-count"):
                                        self.ss_prot_route_count = value
                                        self.ss_prot_route_count.value_namespace = name_space
                                        self.ss_prot_route_count.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ss-tbl-id"):
                                        self.ss_tbl_id = value
                                        self.ss_tbl_id.value_namespace = name_space
                                        self.ss_tbl_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ss-tbl-id-ptr"):
                                        self.ss_tbl_id_ptr = value
                                        self.ss_tbl_id_ptr.value_namespace = name_space
                                        self.ss_tbl_id_ptr.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ss-vr-id"):
                                        self.ss_vr_id = value
                                        self.ss_vr_id.value_namespace = name_space
                                        self.ss_vr_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ss-vrf-id"):
                                        self.ss_vrf_id = value
                                        self.ss_vrf_id.value_namespace = name_space
                                        self.ss_vrf_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ss-vxlan-ltep-ifh"):
                                        self.ss_vxlan_ltep_ifh = value
                                        self.ss_vxlan_ltep_ifh.value_namespace = name_space
                                        self.ss_vxlan_ltep_ifh.value_namespace_prefix = name_space_prefix
                                    if(value_path == "stale-prefix-deletes"):
                                        self.stale_prefix_deletes = value
                                        self.stale_prefix_deletes.value_namespace = name_space
                                        self.stale_prefix_deletes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-load-share-element-bytes"):
                                        self.total_load_share_element_bytes = value
                                        self.total_load_share_element_bytes.value_namespace = name_space
                                        self.total_load_share_element_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "unresolve-entries"):
                                        self.unresolve_entries = value
                                        self.unresolve_entries.value_namespace = name_space
                                        self.unresolve_entries.value_namespace_prefix = name_space_prefix


                            class InterfaceInfos(Entity):
                                """
                                Table of InterfaceInfo
                                
                                .. attribute:: interface_info
                                
                                	Specify link type
                                	**type**\: list of    :py:class:`InterfaceInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo>`
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos, self).__init__()

                                    self.yang_name = "interface-infos"
                                    self.yang_parent_name = "vrf"

                                    self.interface_info = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos, self).__setattr__(name, value)


                                class InterfaceInfo(Entity):
                                    """
                                    Specify link type
                                    
                                    .. attribute:: link_type  <key>
                                    
                                    	Link type
                                    	**type**\:   :py:class:`FibLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibLink>`
                                    
                                    .. attribute:: interfaces
                                    
                                    	Table of interfaces
                                    	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces>`
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo, self).__init__()

                                        self.yang_name = "interface-info"
                                        self.yang_parent_name = "interface-infos"

                                        self.link_type = YLeaf(YType.enumeration, "link-type")

                                        self.interfaces = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces()
                                        self.interfaces.parent = self
                                        self._children_name_map["interfaces"] = "interfaces"
                                        self._children_yang_names.add("interfaces")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("link_type") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo, self).__setattr__(name, value)


                                    class Interfaces(Entity):
                                        """
                                        Table of interfaces
                                        
                                        .. attribute:: interface
                                        
                                        	Specify Interface name
                                        	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface>`
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces, self).__init__()

                                            self.yang_name = "interfaces"
                                            self.yang_parent_name = "interface-info"

                                            self.interface = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces, self).__setattr__(name, value)


                                        class Interface(Entity):
                                            """
                                            Specify Interface name
                                            
                                            .. attribute:: interface_name  <key>
                                            
                                            	Interface Name
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: detail_fib_int_information
                                            
                                            	Detailed FIB interface information
                                            	**type**\:   :py:class:`DetailFibIntInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.DetailFibIntInformation>`
                                            
                                            .. attribute:: drop_packets_while_fib_switching_flag
                                            
                                            	Drop packets while FIB switching flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: fib_id_extension_flags
                                            
                                            	Flags on fibidb extension
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: fib_id_extension_pointer
                                            
                                            	Pointer to fibidb extension
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: fib_id_flags
                                            
                                            	Flags on fibidb
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: fib_id_pointer
                                            
                                            	Pointer to fibidb
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: fib_interface_type
                                            
                                            	FIB Interface type
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: gre_tunnel_interface_flag
                                            
                                            	GRE Tunnel interface flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: interface_up_flag
                                            
                                            	Interface up flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: last_modified_time
                                            
                                            	Time last modified
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: last_operation
                                            
                                            	Last Oper
                                            	**type**\:   :py:class:`FibidbOper <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibidbOper>`
                                            
                                            .. attribute:: loopback_interface_flag
                                            
                                            	Loopback interface flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: null_interface_flag
                                            
                                            	Null interface flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: number_of_dependent_next_hop_information
                                            
                                            	Number of dependent nhinfo's
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: number_of_input_bytes
                                            
                                            	Number of input bytes
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            	**units**\: byte
                                            
                                            .. attribute:: number_of_input_packets
                                            
                                            	Number of input packets
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            .. attribute:: number_of_output_bytes
                                            
                                            	Number of output bytes
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            	**units**\: byte
                                            
                                            .. attribute:: number_of_output_packets
                                            
                                            	Number of output packets
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            .. attribute:: p2p_interface_flag
                                            
                                            	P2P interface flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: per_interface
                                            
                                            	Interface handle
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: per_packet_load_balancing_flag
                                            
                                            	Per packet loadbalancing flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: primary_ipv4_address
                                            
                                            	Pimary local v4 address for the interface
                                            	**type**\:  str
                                            
                                            	**length:** 0..52
                                            
                                            .. attribute:: primary_ipv6_address
                                            
                                            	Pimary local v6 address for the interface
                                            	**type**\:  str
                                            
                                            	**length:** 0..52
                                            
                                            .. attribute:: protocol_enabled
                                            
                                            	Is the protocol configured?
                                            	**type**\:  bool
                                            
                                            .. attribute:: punt_packets_from_fib_switching_flag
                                            
                                            	Punt packets from FIB switching flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: punt_packets_from_linecard_flag
                                            
                                            	Punt packets from linecard flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: referance_count_for_protocol
                                            
                                            	Reference count for the protocol
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: reference_count
                                            
                                            	Reference count
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            .. attribute:: si_internal
                                            
                                            	Internal Information
                                            	**type**\:   :py:class:`SiInternal <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal>`
                                            
                                            .. attribute:: tunnel_interface_flag
                                            
                                            	Tunnel interface flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: vrf_local_cef_information_pointer
                                            
                                            	Vrf local cef info ptr
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface, self).__init__()

                                                self.yang_name = "interface"
                                                self.yang_parent_name = "interfaces"

                                                self.interface_name = YLeaf(YType.str, "interface-name")

                                                self.drop_packets_while_fib_switching_flag = YLeaf(YType.boolean, "drop-packets-while-fib-switching-flag")

                                                self.fib_id_extension_flags = YLeaf(YType.uint32, "fib-id-extension-flags")

                                                self.fib_id_extension_pointer = YLeaf(YType.uint32, "fib-id-extension-pointer")

                                                self.fib_id_flags = YLeaf(YType.uint32, "fib-id-flags")

                                                self.fib_id_pointer = YLeaf(YType.uint32, "fib-id-pointer")

                                                self.fib_interface_type = YLeaf(YType.uint32, "fib-interface-type")

                                                self.gre_tunnel_interface_flag = YLeaf(YType.boolean, "gre-tunnel-interface-flag")

                                                self.interface_up_flag = YLeaf(YType.boolean, "interface-up-flag")

                                                self.last_modified_time = YLeaf(YType.uint32, "last-modified-time")

                                                self.last_operation = YLeaf(YType.enumeration, "last-operation")

                                                self.loopback_interface_flag = YLeaf(YType.boolean, "loopback-interface-flag")

                                                self.null_interface_flag = YLeaf(YType.boolean, "null-interface-flag")

                                                self.number_of_dependent_next_hop_information = YLeaf(YType.uint32, "number-of-dependent-next-hop-information")

                                                self.number_of_input_bytes = YLeaf(YType.uint64, "number-of-input-bytes")

                                                self.number_of_input_packets = YLeaf(YType.uint64, "number-of-input-packets")

                                                self.number_of_output_bytes = YLeaf(YType.uint64, "number-of-output-bytes")

                                                self.number_of_output_packets = YLeaf(YType.uint64, "number-of-output-packets")

                                                self.p2p_interface_flag = YLeaf(YType.boolean, "p2p-interface-flag")

                                                self.per_interface = YLeaf(YType.str, "per-interface")

                                                self.per_packet_load_balancing_flag = YLeaf(YType.boolean, "per-packet-load-balancing-flag")

                                                self.primary_ipv4_address = YLeaf(YType.str, "primary-ipv4-address")

                                                self.primary_ipv6_address = YLeaf(YType.str, "primary-ipv6-address")

                                                self.protocol_enabled = YLeaf(YType.boolean, "protocol-enabled")

                                                self.punt_packets_from_fib_switching_flag = YLeaf(YType.boolean, "punt-packets-from-fib-switching-flag")

                                                self.punt_packets_from_linecard_flag = YLeaf(YType.boolean, "punt-packets-from-linecard-flag")

                                                self.referance_count_for_protocol = YLeaf(YType.uint32, "referance-count-for-protocol")

                                                self.reference_count = YLeaf(YType.uint16, "reference-count")

                                                self.tunnel_interface_flag = YLeaf(YType.boolean, "tunnel-interface-flag")

                                                self.vrf_local_cef_information_pointer = YLeaf(YType.uint32, "vrf-local-cef-information-pointer")

                                                self.detail_fib_int_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.DetailFibIntInformation()
                                                self.detail_fib_int_information.parent = self
                                                self._children_name_map["detail_fib_int_information"] = "detail-fib-int-information"
                                                self._children_yang_names.add("detail-fib-int-information")

                                                self.si_internal = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal()
                                                self.si_internal.parent = self
                                                self._children_name_map["si_internal"] = "si-internal"
                                                self._children_yang_names.add("si-internal")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("interface_name",
                                                                "drop_packets_while_fib_switching_flag",
                                                                "fib_id_extension_flags",
                                                                "fib_id_extension_pointer",
                                                                "fib_id_flags",
                                                                "fib_id_pointer",
                                                                "fib_interface_type",
                                                                "gre_tunnel_interface_flag",
                                                                "interface_up_flag",
                                                                "last_modified_time",
                                                                "last_operation",
                                                                "loopback_interface_flag",
                                                                "null_interface_flag",
                                                                "number_of_dependent_next_hop_information",
                                                                "number_of_input_bytes",
                                                                "number_of_input_packets",
                                                                "number_of_output_bytes",
                                                                "number_of_output_packets",
                                                                "p2p_interface_flag",
                                                                "per_interface",
                                                                "per_packet_load_balancing_flag",
                                                                "primary_ipv4_address",
                                                                "primary_ipv6_address",
                                                                "protocol_enabled",
                                                                "punt_packets_from_fib_switching_flag",
                                                                "punt_packets_from_linecard_flag",
                                                                "referance_count_for_protocol",
                                                                "reference_count",
                                                                "tunnel_interface_flag",
                                                                "vrf_local_cef_information_pointer") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface, self).__setattr__(name, value)


                                            class DetailFibIntInformation(Entity):
                                                """
                                                Detailed FIB interface information
                                                
                                                .. attribute:: bgp_pa_input_configured_flag
                                                
                                                	BGP PA configured flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: bgp_pa_output_configured_flag
                                                
                                                	BGP PA configured flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: default_route_with_rpf
                                                
                                                	Allow default route with RPF
                                                	**type**\:  bool
                                                
                                                .. attribute:: destination_bgp_pa_input_configured_flag
                                                
                                                	dst BGP PA configured flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: destination_bgp_pa_output_configured_flag
                                                
                                                	dst BGP PA configured flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: forwarding_flag
                                                
                                                	Forwarding enabled/disabled flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: icmp_flag
                                                
                                                	ICMP  configured flag
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: interface_mtu
                                                
                                                	Interface Protocol MTU
                                                	**type**\:  int
                                                
                                                	**range:** 0..65535
                                                
                                                .. attribute:: multi_label_drop_flag
                                                
                                                	Drop packets with multiple\-label\-stack if set
                                                	**type**\:  bool
                                                
                                                .. attribute:: rpf_configured_flag
                                                
                                                	RPF configured flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: rpf_mode
                                                
                                                	RPF mode
                                                	**type**\:   :py:class:`FibRpfMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibRpfMode>`
                                                
                                                .. attribute:: self_ping_with_rpf
                                                
                                                	Allow selfping with RPF
                                                	**type**\:  bool
                                                
                                                .. attribute:: source_bgp_pa_input_configured_flag
                                                
                                                	src BGP PA configured flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: source_bgp_pa_output_configured_flag
                                                
                                                	src BGP PA configured flag
                                                	**type**\:  bool
                                                
                                                

                                                """

                                                _prefix = 'fib-common-oper'
                                                _revision = '2017-01-20'

                                                def __init__(self):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.DetailFibIntInformation, self).__init__()

                                                    self.yang_name = "detail-fib-int-information"
                                                    self.yang_parent_name = "interface"

                                                    self.bgp_pa_input_configured_flag = YLeaf(YType.boolean, "bgp-pa-input-configured-flag")

                                                    self.bgp_pa_output_configured_flag = YLeaf(YType.boolean, "bgp-pa-output-configured-flag")

                                                    self.default_route_with_rpf = YLeaf(YType.boolean, "default-route-with-rpf")

                                                    self.destination_bgp_pa_input_configured_flag = YLeaf(YType.boolean, "destination-bgp-pa-input-configured-flag")

                                                    self.destination_bgp_pa_output_configured_flag = YLeaf(YType.boolean, "destination-bgp-pa-output-configured-flag")

                                                    self.forwarding_flag = YLeaf(YType.boolean, "forwarding-flag")

                                                    self.icmp_flag = YLeaf(YType.uint32, "icmp-flag")

                                                    self.interface_mtu = YLeaf(YType.uint16, "interface-mtu")

                                                    self.multi_label_drop_flag = YLeaf(YType.boolean, "multi-label-drop-flag")

                                                    self.rpf_configured_flag = YLeaf(YType.boolean, "rpf-configured-flag")

                                                    self.rpf_mode = YLeaf(YType.enumeration, "rpf-mode")

                                                    self.self_ping_with_rpf = YLeaf(YType.boolean, "self-ping-with-rpf")

                                                    self.source_bgp_pa_input_configured_flag = YLeaf(YType.boolean, "source-bgp-pa-input-configured-flag")

                                                    self.source_bgp_pa_output_configured_flag = YLeaf(YType.boolean, "source-bgp-pa-output-configured-flag")

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("bgp_pa_input_configured_flag",
                                                                    "bgp_pa_output_configured_flag",
                                                                    "default_route_with_rpf",
                                                                    "destination_bgp_pa_input_configured_flag",
                                                                    "destination_bgp_pa_output_configured_flag",
                                                                    "forwarding_flag",
                                                                    "icmp_flag",
                                                                    "interface_mtu",
                                                                    "multi_label_drop_flag",
                                                                    "rpf_configured_flag",
                                                                    "rpf_mode",
                                                                    "self_ping_with_rpf",
                                                                    "source_bgp_pa_input_configured_flag",
                                                                    "source_bgp_pa_output_configured_flag") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.DetailFibIntInformation, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.DetailFibIntInformation, self).__setattr__(name, value)

                                                def has_data(self):
                                                    return (
                                                        self.bgp_pa_input_configured_flag.is_set or
                                                        self.bgp_pa_output_configured_flag.is_set or
                                                        self.default_route_with_rpf.is_set or
                                                        self.destination_bgp_pa_input_configured_flag.is_set or
                                                        self.destination_bgp_pa_output_configured_flag.is_set or
                                                        self.forwarding_flag.is_set or
                                                        self.icmp_flag.is_set or
                                                        self.interface_mtu.is_set or
                                                        self.multi_label_drop_flag.is_set or
                                                        self.rpf_configured_flag.is_set or
                                                        self.rpf_mode.is_set or
                                                        self.self_ping_with_rpf.is_set or
                                                        self.source_bgp_pa_input_configured_flag.is_set or
                                                        self.source_bgp_pa_output_configured_flag.is_set)

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.bgp_pa_input_configured_flag.yfilter != YFilter.not_set or
                                                        self.bgp_pa_output_configured_flag.yfilter != YFilter.not_set or
                                                        self.default_route_with_rpf.yfilter != YFilter.not_set or
                                                        self.destination_bgp_pa_input_configured_flag.yfilter != YFilter.not_set or
                                                        self.destination_bgp_pa_output_configured_flag.yfilter != YFilter.not_set or
                                                        self.forwarding_flag.yfilter != YFilter.not_set or
                                                        self.icmp_flag.yfilter != YFilter.not_set or
                                                        self.interface_mtu.yfilter != YFilter.not_set or
                                                        self.multi_label_drop_flag.yfilter != YFilter.not_set or
                                                        self.rpf_configured_flag.yfilter != YFilter.not_set or
                                                        self.rpf_mode.yfilter != YFilter.not_set or
                                                        self.self_ping_with_rpf.yfilter != YFilter.not_set or
                                                        self.source_bgp_pa_input_configured_flag.yfilter != YFilter.not_set or
                                                        self.source_bgp_pa_output_configured_flag.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "detail-fib-int-information" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.bgp_pa_input_configured_flag.is_set or self.bgp_pa_input_configured_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.bgp_pa_input_configured_flag.get_name_leafdata())
                                                    if (self.bgp_pa_output_configured_flag.is_set or self.bgp_pa_output_configured_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.bgp_pa_output_configured_flag.get_name_leafdata())
                                                    if (self.default_route_with_rpf.is_set or self.default_route_with_rpf.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.default_route_with_rpf.get_name_leafdata())
                                                    if (self.destination_bgp_pa_input_configured_flag.is_set or self.destination_bgp_pa_input_configured_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.destination_bgp_pa_input_configured_flag.get_name_leafdata())
                                                    if (self.destination_bgp_pa_output_configured_flag.is_set or self.destination_bgp_pa_output_configured_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.destination_bgp_pa_output_configured_flag.get_name_leafdata())
                                                    if (self.forwarding_flag.is_set or self.forwarding_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.forwarding_flag.get_name_leafdata())
                                                    if (self.icmp_flag.is_set or self.icmp_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.icmp_flag.get_name_leafdata())
                                                    if (self.interface_mtu.is_set or self.interface_mtu.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_mtu.get_name_leafdata())
                                                    if (self.multi_label_drop_flag.is_set or self.multi_label_drop_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.multi_label_drop_flag.get_name_leafdata())
                                                    if (self.rpf_configured_flag.is_set or self.rpf_configured_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.rpf_configured_flag.get_name_leafdata())
                                                    if (self.rpf_mode.is_set or self.rpf_mode.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.rpf_mode.get_name_leafdata())
                                                    if (self.self_ping_with_rpf.is_set or self.self_ping_with_rpf.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.self_ping_with_rpf.get_name_leafdata())
                                                    if (self.source_bgp_pa_input_configured_flag.is_set or self.source_bgp_pa_input_configured_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.source_bgp_pa_input_configured_flag.get_name_leafdata())
                                                    if (self.source_bgp_pa_output_configured_flag.is_set or self.source_bgp_pa_output_configured_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.source_bgp_pa_output_configured_flag.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "bgp-pa-input-configured-flag" or name == "bgp-pa-output-configured-flag" or name == "default-route-with-rpf" or name == "destination-bgp-pa-input-configured-flag" or name == "destination-bgp-pa-output-configured-flag" or name == "forwarding-flag" or name == "icmp-flag" or name == "interface-mtu" or name == "multi-label-drop-flag" or name == "rpf-configured-flag" or name == "rpf-mode" or name == "self-ping-with-rpf" or name == "source-bgp-pa-input-configured-flag" or name == "source-bgp-pa-output-configured-flag"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "bgp-pa-input-configured-flag"):
                                                        self.bgp_pa_input_configured_flag = value
                                                        self.bgp_pa_input_configured_flag.value_namespace = name_space
                                                        self.bgp_pa_input_configured_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "bgp-pa-output-configured-flag"):
                                                        self.bgp_pa_output_configured_flag = value
                                                        self.bgp_pa_output_configured_flag.value_namespace = name_space
                                                        self.bgp_pa_output_configured_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "default-route-with-rpf"):
                                                        self.default_route_with_rpf = value
                                                        self.default_route_with_rpf.value_namespace = name_space
                                                        self.default_route_with_rpf.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "destination-bgp-pa-input-configured-flag"):
                                                        self.destination_bgp_pa_input_configured_flag = value
                                                        self.destination_bgp_pa_input_configured_flag.value_namespace = name_space
                                                        self.destination_bgp_pa_input_configured_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "destination-bgp-pa-output-configured-flag"):
                                                        self.destination_bgp_pa_output_configured_flag = value
                                                        self.destination_bgp_pa_output_configured_flag.value_namespace = name_space
                                                        self.destination_bgp_pa_output_configured_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "forwarding-flag"):
                                                        self.forwarding_flag = value
                                                        self.forwarding_flag.value_namespace = name_space
                                                        self.forwarding_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "icmp-flag"):
                                                        self.icmp_flag = value
                                                        self.icmp_flag.value_namespace = name_space
                                                        self.icmp_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "interface-mtu"):
                                                        self.interface_mtu = value
                                                        self.interface_mtu.value_namespace = name_space
                                                        self.interface_mtu.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "multi-label-drop-flag"):
                                                        self.multi_label_drop_flag = value
                                                        self.multi_label_drop_flag.value_namespace = name_space
                                                        self.multi_label_drop_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "rpf-configured-flag"):
                                                        self.rpf_configured_flag = value
                                                        self.rpf_configured_flag.value_namespace = name_space
                                                        self.rpf_configured_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "rpf-mode"):
                                                        self.rpf_mode = value
                                                        self.rpf_mode.value_namespace = name_space
                                                        self.rpf_mode.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "self-ping-with-rpf"):
                                                        self.self_ping_with_rpf = value
                                                        self.self_ping_with_rpf.value_namespace = name_space
                                                        self.self_ping_with_rpf.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "source-bgp-pa-input-configured-flag"):
                                                        self.source_bgp_pa_input_configured_flag = value
                                                        self.source_bgp_pa_input_configured_flag.value_namespace = name_space
                                                        self.source_bgp_pa_input_configured_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "source-bgp-pa-output-configured-flag"):
                                                        self.source_bgp_pa_output_configured_flag = value
                                                        self.source_bgp_pa_output_configured_flag.value_namespace = name_space
                                                        self.source_bgp_pa_output_configured_flag.value_namespace_prefix = name_space_prefix


                                            class SiInternal(Entity):
                                                """
                                                Internal Information
                                                
                                                .. attribute:: fib_idb_hist
                                                
                                                	Event History for IDB
                                                	**type**\:   :py:class:`FibIdbHist <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist>`
                                                
                                                .. attribute:: fib_srte_head_hist
                                                
                                                	Event History for Srtehead
                                                	**type**\:   :py:class:`FibSrteHeadHist <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist>`
                                                
                                                

                                                """

                                                _prefix = 'fib-common-oper'
                                                _revision = '2017-01-20'

                                                def __init__(self):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal, self).__init__()

                                                    self.yang_name = "si-internal"
                                                    self.yang_parent_name = "interface"

                                                    self.fib_idb_hist = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist()
                                                    self.fib_idb_hist.parent = self
                                                    self._children_name_map["fib_idb_hist"] = "fib-idb-hist"
                                                    self._children_yang_names.add("fib-idb-hist")

                                                    self.fib_srte_head_hist = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist()
                                                    self.fib_srte_head_hist.parent = self
                                                    self._children_name_map["fib_srte_head_hist"] = "fib-srte-head-hist"
                                                    self._children_yang_names.add("fib-srte-head-hist")


                                                class FibIdbHist(Entity):
                                                    """
                                                    Event History for IDB
                                                    
                                                    .. attribute:: evt_class_name
                                                    
                                                    	Class name string
                                                    	**type**\:  str
                                                    
                                                    .. attribute:: evt_entry
                                                    
                                                    	Array of event entries
                                                    	**type**\: list of    :py:class:`EvtEntry <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry>`
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist, self).__init__()

                                                        self.yang_name = "fib-idb-hist"
                                                        self.yang_parent_name = "si-internal"

                                                        self.evt_class_name = YLeaf(YType.str, "evt-class-name")

                                                        self.evt_entry = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("evt_class_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist, self).__setattr__(name, value)


                                                    class EvtEntry(Entity):
                                                        """
                                                        Array of event entries
                                                        
                                                        .. attribute:: evt_data
                                                        
                                                        	Optional data
                                                        	**type**\: list of    :py:class:`EvtData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry.EvtData>`
                                                        
                                                        .. attribute:: evt_many
                                                        
                                                        	Multiple instance flag
                                                        	**type**\:  bool
                                                        
                                                        .. attribute:: evt_name
                                                        
                                                        	Event name
                                                        	**type**\:  str
                                                        
                                                        .. attribute:: evt_sticky
                                                        
                                                        	Sticky flag
                                                        	**type**\:  bool
                                                        
                                                        .. attribute:: evt_timestamp
                                                        
                                                        	The timestamp of the event
                                                        	**type**\:  str
                                                        
                                                        .. attribute:: evt_type
                                                        
                                                        	Event type
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..255
                                                        
                                                        

                                                        """

                                                        _prefix = 'fib-common-oper'
                                                        _revision = '2017-01-20'

                                                        def __init__(self):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry, self).__init__()

                                                            self.yang_name = "evt-entry"
                                                            self.yang_parent_name = "fib-idb-hist"

                                                            self.evt_many = YLeaf(YType.boolean, "evt-many")

                                                            self.evt_name = YLeaf(YType.str, "evt-name")

                                                            self.evt_sticky = YLeaf(YType.boolean, "evt-sticky")

                                                            self.evt_timestamp = YLeaf(YType.str, "evt-timestamp")

                                                            self.evt_type = YLeaf(YType.uint8, "evt-type")

                                                            self.evt_data = YList(self)

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("evt_many",
                                                                            "evt_name",
                                                                            "evt_sticky",
                                                                            "evt_timestamp",
                                                                            "evt_type") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry, self).__setattr__(name, value)


                                                        class EvtData(Entity):
                                                            """
                                                            Optional data
                                                            
                                                            .. attribute:: entry
                                                            
                                                            	
                                                            	**type**\:  int
                                                            
                                                            	**range:** 0..4294967295
                                                            
                                                            

                                                            """

                                                            _prefix = 'fib-common-oper'
                                                            _revision = '2017-01-20'

                                                            def __init__(self):
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry.EvtData, self).__init__()

                                                                self.yang_name = "evt-data"
                                                                self.yang_parent_name = "evt-entry"

                                                                self.entry = YLeaf(YType.uint32, "entry")

                                                            def __setattr__(self, name, value):
                                                                self._check_monkey_patching_error(name, value)
                                                                with _handle_type_error():
                                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                            "Please use list append or extend method."
                                                                                            .format(value))
                                                                    if isinstance(value, Enum.YLeaf):
                                                                        value = value.name
                                                                    if name in ("entry") and name in self.__dict__:
                                                                        if isinstance(value, YLeaf):
                                                                            self.__dict__[name].set(value.get())
                                                                        elif isinstance(value, YLeafList):
                                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry.EvtData, self).__setattr__(name, value)
                                                                        else:
                                                                            self.__dict__[name].set(value)
                                                                    else:
                                                                        if hasattr(value, "parent") and name != "parent":
                                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                                value.parent = self
                                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                                value.parent = self
                                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry.EvtData, self).__setattr__(name, value)

                                                            def has_data(self):
                                                                return self.entry.is_set

                                                            def has_operation(self):
                                                                return (
                                                                    self.yfilter != YFilter.not_set or
                                                                    self.entry.yfilter != YFilter.not_set)

                                                            def get_segment_path(self):
                                                                path_buffer = ""
                                                                path_buffer = "evt-data" + path_buffer

                                                                return path_buffer

                                                            def get_entity_path(self, ancestor):
                                                                path_buffer = ""
                                                                if (ancestor is None):
                                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                                else:
                                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                                leaf_name_data = LeafDataList()
                                                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                                return entity_path

                                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                                if child is not None:
                                                                    return child

                                                                return None

                                                            def has_leaf_or_child_of_name(self, name):
                                                                if(name == "entry"):
                                                                    return True
                                                                return False

                                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                                if(value_path == "entry"):
                                                                    self.entry = value
                                                                    self.entry.value_namespace = name_space
                                                                    self.entry.value_namespace_prefix = name_space_prefix

                                                        def has_data(self):
                                                            for c in self.evt_data:
                                                                if (c.has_data()):
                                                                    return True
                                                            return (
                                                                self.evt_many.is_set or
                                                                self.evt_name.is_set or
                                                                self.evt_sticky.is_set or
                                                                self.evt_timestamp.is_set or
                                                                self.evt_type.is_set)

                                                        def has_operation(self):
                                                            for c in self.evt_data:
                                                                if (c.has_operation()):
                                                                    return True
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.evt_many.yfilter != YFilter.not_set or
                                                                self.evt_name.yfilter != YFilter.not_set or
                                                                self.evt_sticky.yfilter != YFilter.not_set or
                                                                self.evt_timestamp.yfilter != YFilter.not_set or
                                                                self.evt_type.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "evt-entry" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.evt_many.is_set or self.evt_many.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_many.get_name_leafdata())
                                                            if (self.evt_name.is_set or self.evt_name.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_name.get_name_leafdata())
                                                            if (self.evt_sticky.is_set or self.evt_sticky.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_sticky.get_name_leafdata())
                                                            if (self.evt_timestamp.is_set or self.evt_timestamp.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_timestamp.get_name_leafdata())
                                                            if (self.evt_type.is_set or self.evt_type.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_type.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            if (child_yang_name == "evt-data"):
                                                                for c in self.evt_data:
                                                                    segment = c.get_segment_path()
                                                                    if (segment_path == segment):
                                                                        return c
                                                                c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry.EvtData()
                                                                c.parent = self
                                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                                self._local_refs[local_reference_key] = c
                                                                self.evt_data.append(c)
                                                                return c

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "evt-data" or name == "evt-many" or name == "evt-name" or name == "evt-sticky" or name == "evt-timestamp" or name == "evt-type"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "evt-many"):
                                                                self.evt_many = value
                                                                self.evt_many.value_namespace = name_space
                                                                self.evt_many.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "evt-name"):
                                                                self.evt_name = value
                                                                self.evt_name.value_namespace = name_space
                                                                self.evt_name.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "evt-sticky"):
                                                                self.evt_sticky = value
                                                                self.evt_sticky.value_namespace = name_space
                                                                self.evt_sticky.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "evt-timestamp"):
                                                                self.evt_timestamp = value
                                                                self.evt_timestamp.value_namespace = name_space
                                                                self.evt_timestamp.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "evt-type"):
                                                                self.evt_type = value
                                                                self.evt_type.value_namespace = name_space
                                                                self.evt_type.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.evt_entry:
                                                            if (c.has_data()):
                                                                return True
                                                        return self.evt_class_name.is_set

                                                    def has_operation(self):
                                                        for c in self.evt_entry:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.evt_class_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "fib-idb-hist" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.evt_class_name.is_set or self.evt_class_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.evt_class_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "evt-entry"):
                                                            for c in self.evt_entry:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist.EvtEntry()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.evt_entry.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "evt-entry" or name == "evt-class-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "evt-class-name"):
                                                            self.evt_class_name = value
                                                            self.evt_class_name.value_namespace = name_space
                                                            self.evt_class_name.value_namespace_prefix = name_space_prefix


                                                class FibSrteHeadHist(Entity):
                                                    """
                                                    Event History for Srtehead
                                                    
                                                    .. attribute:: evt_class_name
                                                    
                                                    	Class name string
                                                    	**type**\:  str
                                                    
                                                    .. attribute:: evt_entry
                                                    
                                                    	Array of event entries
                                                    	**type**\: list of    :py:class:`EvtEntry <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry>`
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist, self).__init__()

                                                        self.yang_name = "fib-srte-head-hist"
                                                        self.yang_parent_name = "si-internal"

                                                        self.evt_class_name = YLeaf(YType.str, "evt-class-name")

                                                        self.evt_entry = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("evt_class_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist, self).__setattr__(name, value)


                                                    class EvtEntry(Entity):
                                                        """
                                                        Array of event entries
                                                        
                                                        .. attribute:: evt_data
                                                        
                                                        	Optional data
                                                        	**type**\: list of    :py:class:`EvtData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry.EvtData>`
                                                        
                                                        .. attribute:: evt_many
                                                        
                                                        	Multiple instance flag
                                                        	**type**\:  bool
                                                        
                                                        .. attribute:: evt_name
                                                        
                                                        	Event name
                                                        	**type**\:  str
                                                        
                                                        .. attribute:: evt_sticky
                                                        
                                                        	Sticky flag
                                                        	**type**\:  bool
                                                        
                                                        .. attribute:: evt_timestamp
                                                        
                                                        	The timestamp of the event
                                                        	**type**\:  str
                                                        
                                                        .. attribute:: evt_type
                                                        
                                                        	Event type
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..255
                                                        
                                                        

                                                        """

                                                        _prefix = 'fib-common-oper'
                                                        _revision = '2017-01-20'

                                                        def __init__(self):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry, self).__init__()

                                                            self.yang_name = "evt-entry"
                                                            self.yang_parent_name = "fib-srte-head-hist"

                                                            self.evt_many = YLeaf(YType.boolean, "evt-many")

                                                            self.evt_name = YLeaf(YType.str, "evt-name")

                                                            self.evt_sticky = YLeaf(YType.boolean, "evt-sticky")

                                                            self.evt_timestamp = YLeaf(YType.str, "evt-timestamp")

                                                            self.evt_type = YLeaf(YType.uint8, "evt-type")

                                                            self.evt_data = YList(self)

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("evt_many",
                                                                            "evt_name",
                                                                            "evt_sticky",
                                                                            "evt_timestamp",
                                                                            "evt_type") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry, self).__setattr__(name, value)


                                                        class EvtData(Entity):
                                                            """
                                                            Optional data
                                                            
                                                            .. attribute:: entry
                                                            
                                                            	
                                                            	**type**\:  int
                                                            
                                                            	**range:** 0..4294967295
                                                            
                                                            

                                                            """

                                                            _prefix = 'fib-common-oper'
                                                            _revision = '2017-01-20'

                                                            def __init__(self):
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry.EvtData, self).__init__()

                                                                self.yang_name = "evt-data"
                                                                self.yang_parent_name = "evt-entry"

                                                                self.entry = YLeaf(YType.uint32, "entry")

                                                            def __setattr__(self, name, value):
                                                                self._check_monkey_patching_error(name, value)
                                                                with _handle_type_error():
                                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                            "Please use list append or extend method."
                                                                                            .format(value))
                                                                    if isinstance(value, Enum.YLeaf):
                                                                        value = value.name
                                                                    if name in ("entry") and name in self.__dict__:
                                                                        if isinstance(value, YLeaf):
                                                                            self.__dict__[name].set(value.get())
                                                                        elif isinstance(value, YLeafList):
                                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry.EvtData, self).__setattr__(name, value)
                                                                        else:
                                                                            self.__dict__[name].set(value)
                                                                    else:
                                                                        if hasattr(value, "parent") and name != "parent":
                                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                                value.parent = self
                                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                                value.parent = self
                                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry.EvtData, self).__setattr__(name, value)

                                                            def has_data(self):
                                                                return self.entry.is_set

                                                            def has_operation(self):
                                                                return (
                                                                    self.yfilter != YFilter.not_set or
                                                                    self.entry.yfilter != YFilter.not_set)

                                                            def get_segment_path(self):
                                                                path_buffer = ""
                                                                path_buffer = "evt-data" + path_buffer

                                                                return path_buffer

                                                            def get_entity_path(self, ancestor):
                                                                path_buffer = ""
                                                                if (ancestor is None):
                                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                                else:
                                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                                leaf_name_data = LeafDataList()
                                                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                                return entity_path

                                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                                if child is not None:
                                                                    return child

                                                                return None

                                                            def has_leaf_or_child_of_name(self, name):
                                                                if(name == "entry"):
                                                                    return True
                                                                return False

                                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                                if(value_path == "entry"):
                                                                    self.entry = value
                                                                    self.entry.value_namespace = name_space
                                                                    self.entry.value_namespace_prefix = name_space_prefix

                                                        def has_data(self):
                                                            for c in self.evt_data:
                                                                if (c.has_data()):
                                                                    return True
                                                            return (
                                                                self.evt_many.is_set or
                                                                self.evt_name.is_set or
                                                                self.evt_sticky.is_set or
                                                                self.evt_timestamp.is_set or
                                                                self.evt_type.is_set)

                                                        def has_operation(self):
                                                            for c in self.evt_data:
                                                                if (c.has_operation()):
                                                                    return True
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.evt_many.yfilter != YFilter.not_set or
                                                                self.evt_name.yfilter != YFilter.not_set or
                                                                self.evt_sticky.yfilter != YFilter.not_set or
                                                                self.evt_timestamp.yfilter != YFilter.not_set or
                                                                self.evt_type.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "evt-entry" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.evt_many.is_set or self.evt_many.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_many.get_name_leafdata())
                                                            if (self.evt_name.is_set or self.evt_name.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_name.get_name_leafdata())
                                                            if (self.evt_sticky.is_set or self.evt_sticky.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_sticky.get_name_leafdata())
                                                            if (self.evt_timestamp.is_set or self.evt_timestamp.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_timestamp.get_name_leafdata())
                                                            if (self.evt_type.is_set or self.evt_type.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.evt_type.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            if (child_yang_name == "evt-data"):
                                                                for c in self.evt_data:
                                                                    segment = c.get_segment_path()
                                                                    if (segment_path == segment):
                                                                        return c
                                                                c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry.EvtData()
                                                                c.parent = self
                                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                                self._local_refs[local_reference_key] = c
                                                                self.evt_data.append(c)
                                                                return c

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "evt-data" or name == "evt-many" or name == "evt-name" or name == "evt-sticky" or name == "evt-timestamp" or name == "evt-type"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "evt-many"):
                                                                self.evt_many = value
                                                                self.evt_many.value_namespace = name_space
                                                                self.evt_many.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "evt-name"):
                                                                self.evt_name = value
                                                                self.evt_name.value_namespace = name_space
                                                                self.evt_name.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "evt-sticky"):
                                                                self.evt_sticky = value
                                                                self.evt_sticky.value_namespace = name_space
                                                                self.evt_sticky.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "evt-timestamp"):
                                                                self.evt_timestamp = value
                                                                self.evt_timestamp.value_namespace = name_space
                                                                self.evt_timestamp.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "evt-type"):
                                                                self.evt_type = value
                                                                self.evt_type.value_namespace = name_space
                                                                self.evt_type.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.evt_entry:
                                                            if (c.has_data()):
                                                                return True
                                                        return self.evt_class_name.is_set

                                                    def has_operation(self):
                                                        for c in self.evt_entry:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.evt_class_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "fib-srte-head-hist" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.evt_class_name.is_set or self.evt_class_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.evt_class_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "evt-entry"):
                                                            for c in self.evt_entry:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist.EvtEntry()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.evt_entry.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "evt-entry" or name == "evt-class-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "evt-class-name"):
                                                            self.evt_class_name = value
                                                            self.evt_class_name.value_namespace = name_space
                                                            self.evt_class_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    return (
                                                        (self.fib_idb_hist is not None and self.fib_idb_hist.has_data()) or
                                                        (self.fib_srte_head_hist is not None and self.fib_srte_head_hist.has_data()))

                                                def has_operation(self):
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        (self.fib_idb_hist is not None and self.fib_idb_hist.has_operation()) or
                                                        (self.fib_srte_head_hist is not None and self.fib_srte_head_hist.has_operation()))

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "si-internal" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "fib-idb-hist"):
                                                        if (self.fib_idb_hist is None):
                                                            self.fib_idb_hist = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibIdbHist()
                                                            self.fib_idb_hist.parent = self
                                                            self._children_name_map["fib_idb_hist"] = "fib-idb-hist"
                                                        return self.fib_idb_hist

                                                    if (child_yang_name == "fib-srte-head-hist"):
                                                        if (self.fib_srte_head_hist is None):
                                                            self.fib_srte_head_hist = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal.FibSrteHeadHist()
                                                            self.fib_srte_head_hist.parent = self
                                                            self._children_name_map["fib_srte_head_hist"] = "fib-srte-head-hist"
                                                        return self.fib_srte_head_hist

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "fib-idb-hist" or name == "fib-srte-head-hist"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    pass

                                            def has_data(self):
                                                return (
                                                    self.interface_name.is_set or
                                                    self.drop_packets_while_fib_switching_flag.is_set or
                                                    self.fib_id_extension_flags.is_set or
                                                    self.fib_id_extension_pointer.is_set or
                                                    self.fib_id_flags.is_set or
                                                    self.fib_id_pointer.is_set or
                                                    self.fib_interface_type.is_set or
                                                    self.gre_tunnel_interface_flag.is_set or
                                                    self.interface_up_flag.is_set or
                                                    self.last_modified_time.is_set or
                                                    self.last_operation.is_set or
                                                    self.loopback_interface_flag.is_set or
                                                    self.null_interface_flag.is_set or
                                                    self.number_of_dependent_next_hop_information.is_set or
                                                    self.number_of_input_bytes.is_set or
                                                    self.number_of_input_packets.is_set or
                                                    self.number_of_output_bytes.is_set or
                                                    self.number_of_output_packets.is_set or
                                                    self.p2p_interface_flag.is_set or
                                                    self.per_interface.is_set or
                                                    self.per_packet_load_balancing_flag.is_set or
                                                    self.primary_ipv4_address.is_set or
                                                    self.primary_ipv6_address.is_set or
                                                    self.protocol_enabled.is_set or
                                                    self.punt_packets_from_fib_switching_flag.is_set or
                                                    self.punt_packets_from_linecard_flag.is_set or
                                                    self.referance_count_for_protocol.is_set or
                                                    self.reference_count.is_set or
                                                    self.tunnel_interface_flag.is_set or
                                                    self.vrf_local_cef_information_pointer.is_set or
                                                    (self.detail_fib_int_information is not None and self.detail_fib_int_information.has_data()) or
                                                    (self.si_internal is not None and self.si_internal.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.interface_name.yfilter != YFilter.not_set or
                                                    self.drop_packets_while_fib_switching_flag.yfilter != YFilter.not_set or
                                                    self.fib_id_extension_flags.yfilter != YFilter.not_set or
                                                    self.fib_id_extension_pointer.yfilter != YFilter.not_set or
                                                    self.fib_id_flags.yfilter != YFilter.not_set or
                                                    self.fib_id_pointer.yfilter != YFilter.not_set or
                                                    self.fib_interface_type.yfilter != YFilter.not_set or
                                                    self.gre_tunnel_interface_flag.yfilter != YFilter.not_set or
                                                    self.interface_up_flag.yfilter != YFilter.not_set or
                                                    self.last_modified_time.yfilter != YFilter.not_set or
                                                    self.last_operation.yfilter != YFilter.not_set or
                                                    self.loopback_interface_flag.yfilter != YFilter.not_set or
                                                    self.null_interface_flag.yfilter != YFilter.not_set or
                                                    self.number_of_dependent_next_hop_information.yfilter != YFilter.not_set or
                                                    self.number_of_input_bytes.yfilter != YFilter.not_set or
                                                    self.number_of_input_packets.yfilter != YFilter.not_set or
                                                    self.number_of_output_bytes.yfilter != YFilter.not_set or
                                                    self.number_of_output_packets.yfilter != YFilter.not_set or
                                                    self.p2p_interface_flag.yfilter != YFilter.not_set or
                                                    self.per_interface.yfilter != YFilter.not_set or
                                                    self.per_packet_load_balancing_flag.yfilter != YFilter.not_set or
                                                    self.primary_ipv4_address.yfilter != YFilter.not_set or
                                                    self.primary_ipv6_address.yfilter != YFilter.not_set or
                                                    self.protocol_enabled.yfilter != YFilter.not_set or
                                                    self.punt_packets_from_fib_switching_flag.yfilter != YFilter.not_set or
                                                    self.punt_packets_from_linecard_flag.yfilter != YFilter.not_set or
                                                    self.referance_count_for_protocol.yfilter != YFilter.not_set or
                                                    self.reference_count.yfilter != YFilter.not_set or
                                                    self.tunnel_interface_flag.yfilter != YFilter.not_set or
                                                    self.vrf_local_cef_information_pointer.yfilter != YFilter.not_set or
                                                    (self.detail_fib_int_information is not None and self.detail_fib_int_information.has_operation()) or
                                                    (self.si_internal is not None and self.si_internal.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                                if (self.drop_packets_while_fib_switching_flag.is_set or self.drop_packets_while_fib_switching_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.drop_packets_while_fib_switching_flag.get_name_leafdata())
                                                if (self.fib_id_extension_flags.is_set or self.fib_id_extension_flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.fib_id_extension_flags.get_name_leafdata())
                                                if (self.fib_id_extension_pointer.is_set or self.fib_id_extension_pointer.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.fib_id_extension_pointer.get_name_leafdata())
                                                if (self.fib_id_flags.is_set or self.fib_id_flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.fib_id_flags.get_name_leafdata())
                                                if (self.fib_id_pointer.is_set or self.fib_id_pointer.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.fib_id_pointer.get_name_leafdata())
                                                if (self.fib_interface_type.is_set or self.fib_interface_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.fib_interface_type.get_name_leafdata())
                                                if (self.gre_tunnel_interface_flag.is_set or self.gre_tunnel_interface_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.gre_tunnel_interface_flag.get_name_leafdata())
                                                if (self.interface_up_flag.is_set or self.interface_up_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.interface_up_flag.get_name_leafdata())
                                                if (self.last_modified_time.is_set or self.last_modified_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.last_modified_time.get_name_leafdata())
                                                if (self.last_operation.is_set or self.last_operation.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.last_operation.get_name_leafdata())
                                                if (self.loopback_interface_flag.is_set or self.loopback_interface_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.loopback_interface_flag.get_name_leafdata())
                                                if (self.null_interface_flag.is_set or self.null_interface_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.null_interface_flag.get_name_leafdata())
                                                if (self.number_of_dependent_next_hop_information.is_set or self.number_of_dependent_next_hop_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.number_of_dependent_next_hop_information.get_name_leafdata())
                                                if (self.number_of_input_bytes.is_set or self.number_of_input_bytes.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.number_of_input_bytes.get_name_leafdata())
                                                if (self.number_of_input_packets.is_set or self.number_of_input_packets.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.number_of_input_packets.get_name_leafdata())
                                                if (self.number_of_output_bytes.is_set or self.number_of_output_bytes.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.number_of_output_bytes.get_name_leafdata())
                                                if (self.number_of_output_packets.is_set or self.number_of_output_packets.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.number_of_output_packets.get_name_leafdata())
                                                if (self.p2p_interface_flag.is_set or self.p2p_interface_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.p2p_interface_flag.get_name_leafdata())
                                                if (self.per_interface.is_set or self.per_interface.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.per_interface.get_name_leafdata())
                                                if (self.per_packet_load_balancing_flag.is_set or self.per_packet_load_balancing_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.per_packet_load_balancing_flag.get_name_leafdata())
                                                if (self.primary_ipv4_address.is_set or self.primary_ipv4_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.primary_ipv4_address.get_name_leafdata())
                                                if (self.primary_ipv6_address.is_set or self.primary_ipv6_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.primary_ipv6_address.get_name_leafdata())
                                                if (self.protocol_enabled.is_set or self.protocol_enabled.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.protocol_enabled.get_name_leafdata())
                                                if (self.punt_packets_from_fib_switching_flag.is_set or self.punt_packets_from_fib_switching_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.punt_packets_from_fib_switching_flag.get_name_leafdata())
                                                if (self.punt_packets_from_linecard_flag.is_set or self.punt_packets_from_linecard_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.punt_packets_from_linecard_flag.get_name_leafdata())
                                                if (self.referance_count_for_protocol.is_set or self.referance_count_for_protocol.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.referance_count_for_protocol.get_name_leafdata())
                                                if (self.reference_count.is_set or self.reference_count.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.reference_count.get_name_leafdata())
                                                if (self.tunnel_interface_flag.is_set or self.tunnel_interface_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.tunnel_interface_flag.get_name_leafdata())
                                                if (self.vrf_local_cef_information_pointer.is_set or self.vrf_local_cef_information_pointer.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.vrf_local_cef_information_pointer.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "detail-fib-int-information"):
                                                    if (self.detail_fib_int_information is None):
                                                        self.detail_fib_int_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.DetailFibIntInformation()
                                                        self.detail_fib_int_information.parent = self
                                                        self._children_name_map["detail_fib_int_information"] = "detail-fib-int-information"
                                                    return self.detail_fib_int_information

                                                if (child_yang_name == "si-internal"):
                                                    if (self.si_internal is None):
                                                        self.si_internal = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface.SiInternal()
                                                        self.si_internal.parent = self
                                                        self._children_name_map["si_internal"] = "si-internal"
                                                    return self.si_internal

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "detail-fib-int-information" or name == "si-internal" or name == "interface-name" or name == "drop-packets-while-fib-switching-flag" or name == "fib-id-extension-flags" or name == "fib-id-extension-pointer" or name == "fib-id-flags" or name == "fib-id-pointer" or name == "fib-interface-type" or name == "gre-tunnel-interface-flag" or name == "interface-up-flag" or name == "last-modified-time" or name == "last-operation" or name == "loopback-interface-flag" or name == "null-interface-flag" or name == "number-of-dependent-next-hop-information" or name == "number-of-input-bytes" or name == "number-of-input-packets" or name == "number-of-output-bytes" or name == "number-of-output-packets" or name == "p2p-interface-flag" or name == "per-interface" or name == "per-packet-load-balancing-flag" or name == "primary-ipv4-address" or name == "primary-ipv6-address" or name == "protocol-enabled" or name == "punt-packets-from-fib-switching-flag" or name == "punt-packets-from-linecard-flag" or name == "referance-count-for-protocol" or name == "reference-count" or name == "tunnel-interface-flag" or name == "vrf-local-cef-information-pointer"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "interface-name"):
                                                    self.interface_name = value
                                                    self.interface_name.value_namespace = name_space
                                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                                if(value_path == "drop-packets-while-fib-switching-flag"):
                                                    self.drop_packets_while_fib_switching_flag = value
                                                    self.drop_packets_while_fib_switching_flag.value_namespace = name_space
                                                    self.drop_packets_while_fib_switching_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "fib-id-extension-flags"):
                                                    self.fib_id_extension_flags = value
                                                    self.fib_id_extension_flags.value_namespace = name_space
                                                    self.fib_id_extension_flags.value_namespace_prefix = name_space_prefix
                                                if(value_path == "fib-id-extension-pointer"):
                                                    self.fib_id_extension_pointer = value
                                                    self.fib_id_extension_pointer.value_namespace = name_space
                                                    self.fib_id_extension_pointer.value_namespace_prefix = name_space_prefix
                                                if(value_path == "fib-id-flags"):
                                                    self.fib_id_flags = value
                                                    self.fib_id_flags.value_namespace = name_space
                                                    self.fib_id_flags.value_namespace_prefix = name_space_prefix
                                                if(value_path == "fib-id-pointer"):
                                                    self.fib_id_pointer = value
                                                    self.fib_id_pointer.value_namespace = name_space
                                                    self.fib_id_pointer.value_namespace_prefix = name_space_prefix
                                                if(value_path == "fib-interface-type"):
                                                    self.fib_interface_type = value
                                                    self.fib_interface_type.value_namespace = name_space
                                                    self.fib_interface_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "gre-tunnel-interface-flag"):
                                                    self.gre_tunnel_interface_flag = value
                                                    self.gre_tunnel_interface_flag.value_namespace = name_space
                                                    self.gre_tunnel_interface_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "interface-up-flag"):
                                                    self.interface_up_flag = value
                                                    self.interface_up_flag.value_namespace = name_space
                                                    self.interface_up_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "last-modified-time"):
                                                    self.last_modified_time = value
                                                    self.last_modified_time.value_namespace = name_space
                                                    self.last_modified_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "last-operation"):
                                                    self.last_operation = value
                                                    self.last_operation.value_namespace = name_space
                                                    self.last_operation.value_namespace_prefix = name_space_prefix
                                                if(value_path == "loopback-interface-flag"):
                                                    self.loopback_interface_flag = value
                                                    self.loopback_interface_flag.value_namespace = name_space
                                                    self.loopback_interface_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "null-interface-flag"):
                                                    self.null_interface_flag = value
                                                    self.null_interface_flag.value_namespace = name_space
                                                    self.null_interface_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "number-of-dependent-next-hop-information"):
                                                    self.number_of_dependent_next_hop_information = value
                                                    self.number_of_dependent_next_hop_information.value_namespace = name_space
                                                    self.number_of_dependent_next_hop_information.value_namespace_prefix = name_space_prefix
                                                if(value_path == "number-of-input-bytes"):
                                                    self.number_of_input_bytes = value
                                                    self.number_of_input_bytes.value_namespace = name_space
                                                    self.number_of_input_bytes.value_namespace_prefix = name_space_prefix
                                                if(value_path == "number-of-input-packets"):
                                                    self.number_of_input_packets = value
                                                    self.number_of_input_packets.value_namespace = name_space
                                                    self.number_of_input_packets.value_namespace_prefix = name_space_prefix
                                                if(value_path == "number-of-output-bytes"):
                                                    self.number_of_output_bytes = value
                                                    self.number_of_output_bytes.value_namespace = name_space
                                                    self.number_of_output_bytes.value_namespace_prefix = name_space_prefix
                                                if(value_path == "number-of-output-packets"):
                                                    self.number_of_output_packets = value
                                                    self.number_of_output_packets.value_namespace = name_space
                                                    self.number_of_output_packets.value_namespace_prefix = name_space_prefix
                                                if(value_path == "p2p-interface-flag"):
                                                    self.p2p_interface_flag = value
                                                    self.p2p_interface_flag.value_namespace = name_space
                                                    self.p2p_interface_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "per-interface"):
                                                    self.per_interface = value
                                                    self.per_interface.value_namespace = name_space
                                                    self.per_interface.value_namespace_prefix = name_space_prefix
                                                if(value_path == "per-packet-load-balancing-flag"):
                                                    self.per_packet_load_balancing_flag = value
                                                    self.per_packet_load_balancing_flag.value_namespace = name_space
                                                    self.per_packet_load_balancing_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "primary-ipv4-address"):
                                                    self.primary_ipv4_address = value
                                                    self.primary_ipv4_address.value_namespace = name_space
                                                    self.primary_ipv4_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "primary-ipv6-address"):
                                                    self.primary_ipv6_address = value
                                                    self.primary_ipv6_address.value_namespace = name_space
                                                    self.primary_ipv6_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "protocol-enabled"):
                                                    self.protocol_enabled = value
                                                    self.protocol_enabled.value_namespace = name_space
                                                    self.protocol_enabled.value_namespace_prefix = name_space_prefix
                                                if(value_path == "punt-packets-from-fib-switching-flag"):
                                                    self.punt_packets_from_fib_switching_flag = value
                                                    self.punt_packets_from_fib_switching_flag.value_namespace = name_space
                                                    self.punt_packets_from_fib_switching_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "punt-packets-from-linecard-flag"):
                                                    self.punt_packets_from_linecard_flag = value
                                                    self.punt_packets_from_linecard_flag.value_namespace = name_space
                                                    self.punt_packets_from_linecard_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "referance-count-for-protocol"):
                                                    self.referance_count_for_protocol = value
                                                    self.referance_count_for_protocol.value_namespace = name_space
                                                    self.referance_count_for_protocol.value_namespace_prefix = name_space_prefix
                                                if(value_path == "reference-count"):
                                                    self.reference_count = value
                                                    self.reference_count.value_namespace = name_space
                                                    self.reference_count.value_namespace_prefix = name_space_prefix
                                                if(value_path == "tunnel-interface-flag"):
                                                    self.tunnel_interface_flag = value
                                                    self.tunnel_interface_flag.value_namespace = name_space
                                                    self.tunnel_interface_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "vrf-local-cef-information-pointer"):
                                                    self.vrf_local_cef_information_pointer = value
                                                    self.vrf_local_cef_information_pointer.value_namespace = name_space
                                                    self.vrf_local_cef_information_pointer.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.interface:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.interface:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "interfaces" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "interface"):
                                                for c in self.interface:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces.Interface()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.interface.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "interface"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass

                                    def has_data(self):
                                        return (
                                            self.link_type.is_set or
                                            (self.interfaces is not None and self.interfaces.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.link_type.yfilter != YFilter.not_set or
                                            (self.interfaces is not None and self.interfaces.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "interface-info" + "[link-type='" + self.link_type.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.link_type.is_set or self.link_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.link_type.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "interfaces"):
                                            if (self.interfaces is None):
                                                self.interfaces = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo.Interfaces()
                                                self.interfaces.parent = self
                                                self._children_name_map["interfaces"] = "interfaces"
                                            return self.interfaces

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "interfaces" or name == "link-type"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "link-type"):
                                            self.link_type = value
                                            self.link_type.value_namespace = name_space
                                            self.link_type.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.interface_info:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.interface_info:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "interface-infos" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "interface-info"):
                                        for c in self.interface_info:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos.InterfaceInfo()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.interface_info.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface-info"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class IpPrefixBriefs(Entity):
                                """
                                IP FIB prefix brief table
                                
                                .. attribute:: ip_prefix_brief
                                
                                	IP FIB prefix brief table entry
                                	**type**\: list of    :py:class:`IpPrefixBrief <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief>`
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs, self).__init__()

                                    self.yang_name = "ip-prefix-briefs"
                                    self.yang_parent_name = "vrf"

                                    self.ip_prefix_brief = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs, self).__setattr__(name, value)


                                class IpPrefixBrief(Entity):
                                    """
                                    IP FIB prefix brief table entry
                                    
                                    .. attribute:: broadcast_forward_flag
                                    
                                    	Broadcast forward flag
                                    	**type**\:  bool
                                    
                                    .. attribute:: broadcast_recive_flag
                                    
                                    	Broadcast receive flag
                                    	**type**\:  bool
                                    
                                    .. attribute:: detail_fib_entry_information
                                    
                                    	Detailed FIB entry information
                                    	**type**\:   :py:class:`DetailFibEntryInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation>`
                                    
                                    .. attribute:: dummy_real_zero_route
                                    
                                    	Dummy real zero route
                                    	**type**\:  bool
                                    
                                    .. attribute:: exact_route_result
                                    
                                    	exact\-route result
                                    	**type**\:  bool
                                    
                                    .. attribute:: extension_object
                                    
                                    	Leaf Extension Object List
                                    	**type**\: list of    :py:class:`ExtensionObject <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject>`
                                    
                                    .. attribute:: external_switch_triggered
                                    
                                    	External switch function triggered
                                    	**type**\:  bool
                                    
                                    .. attribute:: fib_entry_path
                                    
                                    	FIB entry path details
                                    	**type**\:   :py:class:`FibEntryPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath>`
                                    
                                    .. attribute:: fib_route_download_priority
                                    
                                    	Priority at which the route was downloaded
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: flags_external_ldi
                                    
                                    	The flags of ext assocaited with LDI 
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: l2_subscriber_ip_protocol
                                    
                                    	IP protocol associated with L2 subscriber
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: l2_subscriber_route
                                    
                                    	Is L2 Subscriber route
                                    	**type**\:  bool
                                    
                                    .. attribute:: l2_subscriber_xconnect_id
                                    
                                    	XConnect\-id associated with L2 subscriber
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: l2tpv3_cookie_length_bits
                                    
                                    	L2TPv3 cookie length for L2 subscriber
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: ldi_flags
                                    
                                    	The LDI flags
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: ldi_lw_flag
                                    
                                    	The LDI LW flags
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: lspa_flags
                                    
                                    	The LSPA flags
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: number_of_referances_to_ldi
                                    
                                    	Number of references to the LDI
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: number_of_referances_to_path_list
                                    
                                    	Number of references to the pathlist
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: packet_should_recieve
                                    
                                    	Packet should always be received
                                    	**type**\:  bool
                                    
                                    .. attribute:: path_list_flags
                                    
                                    	The pathlist flags
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: path_list_source
                                    
                                    	The pathlist source
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: platform_hardware
                                    
                                    	Platform Hardware info
                                    	**type**\:  str
                                    
                                    	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                    
                                    .. attribute:: prefix
                                    
                                    	Destination IP address
                                    	**type**\: one of the below types:
                                    
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    	**type**\:  str
                                    
                                    	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(%[\\p{N}\\p{L}]+)?
                                    
                                    
                                    ----
                                    .. attribute:: prefix_connected
                                    
                                    	Prefix is connected
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_for_adjancency
                                    
                                    	Prefix is for an adjacency
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_for_pic_next_hop
                                    
                                    	Prefix is for a PIC nexthop
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_is_static_or_connected
                                    
                                    	Prefix is static or connected
                                    	**type**\:  bool
                                    
                                    .. attribute:: prefix_length
                                    
                                    	IP prefix length
                                    	**type**\:  int
                                    
                                    	**range:** 0..128
                                    
                                    .. attribute:: protocol_type_fib_entry
                                    
                                    	Proto type for this entry
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: purgable_after_purge_interval
                                    
                                    	Purgable after the purge interval
                                    	**type**\:  bool
                                    
                                    .. attribute:: ref_counter_of_ldi_lw_ldi
                                    
                                    	The refcounter of LDI LW LDI
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: route_attribute_flag
                                    
                                    	Route attributes summary flag
                                    	**type**\:  bool
                                    
                                    .. attribute:: route_for_external_reach_linecard_flag
                                    
                                    	Route destined for Line Card that support External Reach only
                                    	**type**\:  bool
                                    
                                    .. attribute:: route_is_sr_flag
                                    
                                    	Route is a MPLS Segment\-Routing prefix
                                    	**type**\:  bool
                                    
                                    .. attribute:: srv6_information
                                    
                                    	Information about IPv6 SR prefix
                                    	**type**\:   :py:class:`Srv6Information <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information>`
                                    
                                    .. attribute:: time_of_last_update_in_msec
                                    
                                    	The time of last update in msec
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: type_of_ldi_lw_ldi
                                    
                                    	The type of LDI LW LDI
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: version_of_route
                                    
                                    	The version of the route
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: zero_by_zero_route_as_default
                                    
                                    	0/0 route added as default route
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief, self).__init__()

                                        self.yang_name = "ip-prefix-brief"
                                        self.yang_parent_name = "ip-prefix-briefs"

                                        self.broadcast_forward_flag = YLeaf(YType.boolean, "broadcast-forward-flag")

                                        self.broadcast_recive_flag = YLeaf(YType.boolean, "broadcast-recive-flag")

                                        self.dummy_real_zero_route = YLeaf(YType.boolean, "dummy-real-zero-route")

                                        self.exact_route_result = YLeaf(YType.boolean, "exact-route-result")

                                        self.external_switch_triggered = YLeaf(YType.boolean, "external-switch-triggered")

                                        self.fib_route_download_priority = YLeaf(YType.uint32, "fib-route-download-priority")

                                        self.flags_external_ldi = YLeaf(YType.uint32, "flags-external-ldi")

                                        self.l2_subscriber_ip_protocol = YLeaf(YType.uint32, "l2-subscriber-ip-protocol")

                                        self.l2_subscriber_route = YLeaf(YType.boolean, "l2-subscriber-route")

                                        self.l2_subscriber_xconnect_id = YLeaf(YType.uint32, "l2-subscriber-xconnect-id")

                                        self.l2tpv3_cookie_length_bits = YLeaf(YType.uint32, "l2tpv3-cookie-length-bits")

                                        self.ldi_flags = YLeaf(YType.uint32, "ldi-flags")

                                        self.ldi_lw_flag = YLeaf(YType.uint32, "ldi-lw-flag")

                                        self.lspa_flags = YLeaf(YType.uint32, "lspa-flags")

                                        self.number_of_referances_to_ldi = YLeaf(YType.uint32, "number-of-referances-to-ldi")

                                        self.number_of_referances_to_path_list = YLeaf(YType.uint32, "number-of-referances-to-path-list")

                                        self.packet_should_recieve = YLeaf(YType.boolean, "packet-should-recieve")

                                        self.path_list_flags = YLeaf(YType.uint32, "path-list-flags")

                                        self.path_list_source = YLeaf(YType.uint32, "path-list-source")

                                        self.platform_hardware = YLeaf(YType.str, "platform-hardware")

                                        self.prefix = YLeaf(YType.str, "prefix")

                                        self.prefix_connected = YLeaf(YType.boolean, "prefix-connected")

                                        self.prefix_for_adjancency = YLeaf(YType.boolean, "prefix-for-adjancency")

                                        self.prefix_for_pic_next_hop = YLeaf(YType.boolean, "prefix-for-pic-next-hop")

                                        self.prefix_is_static_or_connected = YLeaf(YType.boolean, "prefix-is-static-or-connected")

                                        self.prefix_length = YLeaf(YType.uint8, "prefix-length")

                                        self.protocol_type_fib_entry = YLeaf(YType.uint32, "protocol-type-fib-entry")

                                        self.purgable_after_purge_interval = YLeaf(YType.boolean, "purgable-after-purge-interval")

                                        self.ref_counter_of_ldi_lw_ldi = YLeaf(YType.uint32, "ref-counter-of-ldi-lw-ldi")

                                        self.route_attribute_flag = YLeaf(YType.boolean, "route-attribute-flag")

                                        self.route_for_external_reach_linecard_flag = YLeaf(YType.boolean, "route-for-external-reach-linecard-flag")

                                        self.route_is_sr_flag = YLeaf(YType.boolean, "route-is-sr-flag")

                                        self.time_of_last_update_in_msec = YLeaf(YType.uint64, "time-of-last-update-in-msec")

                                        self.type_of_ldi_lw_ldi = YLeaf(YType.uint32, "type-of-ldi-lw-ldi")

                                        self.version_of_route = YLeaf(YType.uint64, "version-of-route")

                                        self.zero_by_zero_route_as_default = YLeaf(YType.boolean, "zero-by-zero-route-as-default")

                                        self.detail_fib_entry_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation()
                                        self.detail_fib_entry_information.parent = self
                                        self._children_name_map["detail_fib_entry_information"] = "detail-fib-entry-information"
                                        self._children_yang_names.add("detail-fib-entry-information")

                                        self.fib_entry_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath()
                                        self.fib_entry_path.parent = self
                                        self._children_name_map["fib_entry_path"] = "fib-entry-path"
                                        self._children_yang_names.add("fib-entry-path")

                                        self.srv6_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information()
                                        self.srv6_information.parent = self
                                        self._children_name_map["srv6_information"] = "srv6-information"
                                        self._children_yang_names.add("srv6-information")

                                        self.extension_object = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("broadcast_forward_flag",
                                                        "broadcast_recive_flag",
                                                        "dummy_real_zero_route",
                                                        "exact_route_result",
                                                        "external_switch_triggered",
                                                        "fib_route_download_priority",
                                                        "flags_external_ldi",
                                                        "l2_subscriber_ip_protocol",
                                                        "l2_subscriber_route",
                                                        "l2_subscriber_xconnect_id",
                                                        "l2tpv3_cookie_length_bits",
                                                        "ldi_flags",
                                                        "ldi_lw_flag",
                                                        "lspa_flags",
                                                        "number_of_referances_to_ldi",
                                                        "number_of_referances_to_path_list",
                                                        "packet_should_recieve",
                                                        "path_list_flags",
                                                        "path_list_source",
                                                        "platform_hardware",
                                                        "prefix",
                                                        "prefix_connected",
                                                        "prefix_for_adjancency",
                                                        "prefix_for_pic_next_hop",
                                                        "prefix_is_static_or_connected",
                                                        "prefix_length",
                                                        "protocol_type_fib_entry",
                                                        "purgable_after_purge_interval",
                                                        "ref_counter_of_ldi_lw_ldi",
                                                        "route_attribute_flag",
                                                        "route_for_external_reach_linecard_flag",
                                                        "route_is_sr_flag",
                                                        "time_of_last_update_in_msec",
                                                        "type_of_ldi_lw_ldi",
                                                        "version_of_route",
                                                        "zero_by_zero_route_as_default") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief, self).__setattr__(name, value)


                                    class DetailFibEntryInformation(Entity):
                                        """
                                        Detailed FIB entry information
                                        
                                        .. attribute:: adjacency_address_length
                                        
                                        	ADJ ADDR LEN
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: adjacency_interface
                                        
                                        	ADJ IFH
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: afi_fib_protocol_type
                                        
                                        	AFI FIB protocol type
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: aib_l3_address
                                        
                                        	AIB L3 Address
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: bgp_attribute_id
                                        
                                        	BGP attribute id
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: bgp_attribute_next_hop_as
                                        
                                        	BGP attribute next hop as
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: bgp_attribute_origin_as
                                        
                                        	BGP attribute origin as
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: bgp_local_attribute_id
                                        
                                        	BGP local attribute id
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: bytes_through_fib_entry
                                        
                                        	Bytes through this FIB entry
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        	**units**\: byte
                                        
                                        .. attribute:: com_string
                                        
                                        	com st
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: detailed_prefix_length
                                        
                                        	Prefix length
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: extcom_string
                                        
                                        	extcom st
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: extended_community
                                        
                                        	extended community
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: fast_adjacency_flag
                                        
                                        	Fast adjacency flag
                                        	**type**\:  bool
                                        
                                        .. attribute:: fib_entry_adjacency_address
                                        
                                        	FIB entry adj address
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: fib_entry_adjacency_interface
                                        
                                        	FIB entry adjacency interface
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: fib_entry_adjacency_type
                                        
                                        	FIB entry adjacency type
                                        	**type**\:   :py:class:`FibAdjacencyShow <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibAdjacencyShow>`
                                        
                                        .. attribute:: fib_entry_version
                                        
                                        	FIB entry version number
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: fib_protocol_type
                                        
                                        	FIB Protocol type
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: fib_special_nh_information_type
                                        
                                        	FIB Special NHINFO Type
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: flow_tag
                                        
                                        	PBR flow\-tag
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: forward_class
                                        
                                        	SPP forwarding class ID
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: illegal_fast_adjacency_flag
                                        
                                        	Illegal fast adjacency flag
                                        	**type**\:  bool
                                        
                                        .. attribute:: ldi_time_of_last_update_in_msec
                                        
                                        	The time of last update for LDI in msec
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: load_sharing_type
                                        
                                        	Load sharing type
                                        	**type**\:   :py:class:`FibLoadshareShow <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibLoadshareShow>`
                                        
                                        .. attribute:: loadshare_information
                                        
                                        	Detailed Loadshare info
                                        	**type**\:   :py:class:`LoadshareInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation>`
                                        
                                        .. attribute:: lwldi_time_of_last_update_in_msec
                                        
                                        	The time of last update for LW\-LDI in msec
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: mpls_fec
                                        
                                        	mpls fec
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: packets_through_fib_entry
                                        
                                        	Packets through this FIB entry
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: path_string
                                        
                                        	As path string
                                        	**type**\:  str
                                        
                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                        
                                        .. attribute:: per_prefix_accounting
                                        
                                        	Per Prefix Accounting
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: pl_time_of_last_update_in_msec
                                        
                                        	The time of last update for PL in msec
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: pl_time_stamp_type
                                        
                                        	The type of time\-stamp on PL
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: precedence_forpackets
                                        
                                        	Precedence for packets to this entry
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        .. attribute:: prefix_protocol
                                        
                                        	Prefix protocol
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: qos_group
                                        
                                        	qos group
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: qppb_qos_group_and_ip_precedence
                                        
                                        	qppb QOS group and IP precedence
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: remote_adjacency_flag
                                        
                                        	Remote adjacency flag
                                        	**type**\:  bool
                                        
                                        .. attribute:: switch_compontent_id
                                        
                                        	Switch function compontent ID
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: traffic_index_for_packets
                                        
                                        	Traffic index for packets to this entry
                                        	**type**\:  int
                                        
                                        	**range:** 0..255
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation, self).__init__()

                                            self.yang_name = "detail-fib-entry-information"
                                            self.yang_parent_name = "ip-prefix-brief"

                                            self.adjacency_address_length = YLeaf(YType.uint32, "adjacency-address-length")

                                            self.adjacency_interface = YLeaf(YType.uint32, "adjacency-interface")

                                            self.afi_fib_protocol_type = YLeaf(YType.uint32, "afi-fib-protocol-type")

                                            self.aib_l3_address = YLeaf(YType.str, "aib-l3-address")

                                            self.bgp_attribute_id = YLeaf(YType.uint32, "bgp-attribute-id")

                                            self.bgp_attribute_next_hop_as = YLeaf(YType.uint32, "bgp-attribute-next-hop-as")

                                            self.bgp_attribute_origin_as = YLeaf(YType.uint32, "bgp-attribute-origin-as")

                                            self.bgp_local_attribute_id = YLeaf(YType.uint32, "bgp-local-attribute-id")

                                            self.bytes_through_fib_entry = YLeaf(YType.uint64, "bytes-through-fib-entry")

                                            self.com_string = YLeaf(YType.str, "com-string")

                                            self.detailed_prefix_length = YLeaf(YType.uint32, "detailed-prefix-length")

                                            self.extcom_string = YLeaf(YType.str, "extcom-string")

                                            self.extended_community = YLeaf(YType.uint32, "extended-community")

                                            self.fast_adjacency_flag = YLeaf(YType.boolean, "fast-adjacency-flag")

                                            self.fib_entry_adjacency_address = YLeaf(YType.str, "fib-entry-adjacency-address")

                                            self.fib_entry_adjacency_interface = YLeaf(YType.uint32, "fib-entry-adjacency-interface")

                                            self.fib_entry_adjacency_type = YLeaf(YType.enumeration, "fib-entry-adjacency-type")

                                            self.fib_entry_version = YLeaf(YType.uint32, "fib-entry-version")

                                            self.fib_protocol_type = YLeaf(YType.uint32, "fib-protocol-type")

                                            self.fib_special_nh_information_type = YLeaf(YType.uint32, "fib-special-nh-information-type")

                                            self.flow_tag = YLeaf(YType.uint8, "flow-tag")

                                            self.forward_class = YLeaf(YType.uint8, "forward-class")

                                            self.illegal_fast_adjacency_flag = YLeaf(YType.boolean, "illegal-fast-adjacency-flag")

                                            self.ldi_time_of_last_update_in_msec = YLeaf(YType.uint64, "ldi-time-of-last-update-in-msec")

                                            self.load_sharing_type = YLeaf(YType.enumeration, "load-sharing-type")

                                            self.lwldi_time_of_last_update_in_msec = YLeaf(YType.uint64, "lwldi-time-of-last-update-in-msec")

                                            self.mpls_fec = YLeaf(YType.uint32, "mpls-fec")

                                            self.packets_through_fib_entry = YLeaf(YType.uint64, "packets-through-fib-entry")

                                            self.path_string = YLeaf(YType.str, "path-string")

                                            self.per_prefix_accounting = YLeaf(YType.uint8, "per-prefix-accounting")

                                            self.pl_time_of_last_update_in_msec = YLeaf(YType.uint64, "pl-time-of-last-update-in-msec")

                                            self.pl_time_stamp_type = YLeaf(YType.uint32, "pl-time-stamp-type")

                                            self.precedence_forpackets = YLeaf(YType.uint8, "precedence-forpackets")

                                            self.prefix_protocol = YLeaf(YType.uint32, "prefix-protocol")

                                            self.qos_group = YLeaf(YType.uint32, "qos-group")

                                            self.qppb_qos_group_and_ip_precedence = YLeaf(YType.uint32, "qppb-qos-group-and-ip-precedence")

                                            self.remote_adjacency_flag = YLeaf(YType.boolean, "remote-adjacency-flag")

                                            self.switch_compontent_id = YLeaf(YType.uint32, "switch-compontent-id")

                                            self.traffic_index_for_packets = YLeaf(YType.uint8, "traffic-index-for-packets")

                                            self.loadshare_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation()
                                            self.loadshare_information.parent = self
                                            self._children_name_map["loadshare_information"] = "loadshare-information"
                                            self._children_yang_names.add("loadshare-information")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("adjacency_address_length",
                                                            "adjacency_interface",
                                                            "afi_fib_protocol_type",
                                                            "aib_l3_address",
                                                            "bgp_attribute_id",
                                                            "bgp_attribute_next_hop_as",
                                                            "bgp_attribute_origin_as",
                                                            "bgp_local_attribute_id",
                                                            "bytes_through_fib_entry",
                                                            "com_string",
                                                            "detailed_prefix_length",
                                                            "extcom_string",
                                                            "extended_community",
                                                            "fast_adjacency_flag",
                                                            "fib_entry_adjacency_address",
                                                            "fib_entry_adjacency_interface",
                                                            "fib_entry_adjacency_type",
                                                            "fib_entry_version",
                                                            "fib_protocol_type",
                                                            "fib_special_nh_information_type",
                                                            "flow_tag",
                                                            "forward_class",
                                                            "illegal_fast_adjacency_flag",
                                                            "ldi_time_of_last_update_in_msec",
                                                            "load_sharing_type",
                                                            "lwldi_time_of_last_update_in_msec",
                                                            "mpls_fec",
                                                            "packets_through_fib_entry",
                                                            "path_string",
                                                            "per_prefix_accounting",
                                                            "pl_time_of_last_update_in_msec",
                                                            "pl_time_stamp_type",
                                                            "precedence_forpackets",
                                                            "prefix_protocol",
                                                            "qos_group",
                                                            "qppb_qos_group_and_ip_precedence",
                                                            "remote_adjacency_flag",
                                                            "switch_compontent_id",
                                                            "traffic_index_for_packets") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation, self).__setattr__(name, value)


                                        class LoadshareInformation(Entity):
                                            """
                                            Detailed Loadshare info
                                            
                                            .. attribute:: bytes_through_load_information
                                            
                                            	Bytes through this loadinfo
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            	**units**\: byte
                                            
                                            .. attribute:: is_owner
                                            
                                            	Owner flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: load_information_owner_deleted_flag
                                            
                                            	Loadinfo owner deleted flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: load_information_reference_count
                                            
                                            	Loadinfo reference count
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            .. attribute:: load_informtion_internal_data
                                            
                                            	Loadinfo internal data
                                            	**type**\:   :py:class:`LoadInformtionInternalData <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData>`
                                            
                                            .. attribute:: loadinfo_sanity_flag
                                            
                                            	Loadinfo sanity flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: mask_length_of_owner
                                            
                                            	Mask length of the owner
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: packets_through_load_information
                                            
                                            	Packets through this loadinfo
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            .. attribute:: per_dest_load_sharing_flag
                                            
                                            	Per destination load sharing flag
                                            	**type**\:  bool
                                            
                                            .. attribute:: prefix_of_owner
                                            
                                            	Prefix of the owner
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: total_bytes_through_load_information
                                            
                                            	Total bytes through this loadinfo
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            	**units**\: byte
                                            
                                            .. attribute:: total_packets_through_load_information
                                            
                                            	Total packets through this loadinfo
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation, self).__init__()

                                                self.yang_name = "loadshare-information"
                                                self.yang_parent_name = "detail-fib-entry-information"

                                                self.bytes_through_load_information = YLeaf(YType.uint64, "bytes-through-load-information")

                                                self.is_owner = YLeaf(YType.boolean, "is-owner")

                                                self.load_information_owner_deleted_flag = YLeaf(YType.boolean, "load-information-owner-deleted-flag")

                                                self.load_information_reference_count = YLeaf(YType.uint16, "load-information-reference-count")

                                                self.loadinfo_sanity_flag = YLeaf(YType.boolean, "loadinfo-sanity-flag")

                                                self.mask_length_of_owner = YLeaf(YType.uint32, "mask-length-of-owner")

                                                self.packets_through_load_information = YLeaf(YType.uint64, "packets-through-load-information")

                                                self.per_dest_load_sharing_flag = YLeaf(YType.boolean, "per-dest-load-sharing-flag")

                                                self.prefix_of_owner = YLeaf(YType.uint32, "prefix-of-owner")

                                                self.total_bytes_through_load_information = YLeaf(YType.uint64, "total-bytes-through-load-information")

                                                self.total_packets_through_load_information = YLeaf(YType.uint64, "total-packets-through-load-information")

                                                self.load_informtion_internal_data = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData()
                                                self.load_informtion_internal_data.parent = self
                                                self._children_name_map["load_informtion_internal_data"] = "load-informtion-internal-data"
                                                self._children_yang_names.add("load-informtion-internal-data")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("bytes_through_load_information",
                                                                "is_owner",
                                                                "load_information_owner_deleted_flag",
                                                                "load_information_reference_count",
                                                                "loadinfo_sanity_flag",
                                                                "mask_length_of_owner",
                                                                "packets_through_load_information",
                                                                "per_dest_load_sharing_flag",
                                                                "prefix_of_owner",
                                                                "total_bytes_through_load_information",
                                                                "total_packets_through_load_information") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation, self).__setattr__(name, value)


                                            class LoadInformtionInternalData(Entity):
                                                """
                                                Loadinfo internal data
                                                
                                                .. attribute:: adjacency_address
                                                
                                                	Adjacency address
                                                	**type**\: list of    :py:class:`AdjacencyAddress <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress>`
                                                
                                                .. attribute:: interface_handle
                                                
                                                	Interface handle
                                                	**type**\: list of    :py:class:`InterfaceHandle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle>`
                                                
                                                .. attribute:: is_pbts_info_valid
                                                
                                                	PBTS info valid flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: ldi_next_hop_buckets
                                                
                                                	Number of LDI next hop buckets
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: level_ofldis
                                                
                                                	level of ldis
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: maximum_index_arrays
                                                
                                                	Maximum index of the arrays
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: maximum_slots
                                                
                                                	Maximum slots
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: normalized_weights
                                                
                                                	Normalized weights
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: number_of_ldis
                                                
                                                	no. of ldis
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: path_indices
                                                
                                                	Path indices
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: path_ldi_numbers
                                                
                                                	Path indices
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: pbts_class_is_fallback_mapped
                                                
                                                	Does PBTS class fall back to drop or any class
                                                	**type**\: list of    :py:class:`PbtsClassIsFallbackMapped <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped>`
                                                
                                                .. attribute:: pbts_class_num_paths
                                                
                                                	PBTS class num paths
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: pbts_class_offset
                                                
                                                	PBTS class offset
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: pbts_fallback_mapped_class
                                                
                                                	PBTS class falls back to class
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: pbts_fallback_to_drop
                                                
                                                	PBTS class falls back to drop
                                                	**type**\: list of    :py:class:`PbtsFallbackToDrop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop>`
                                                
                                                .. attribute:: platform_hardware_information
                                                
                                                	Platform Hardware info
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: round_robin_disable
                                                
                                                	Round Robin Disable
                                                	**type**\:  bool
                                                
                                                .. attribute:: sanity_flag
                                                
                                                	Sanity flag
                                                	**type**\: list of    :py:class:`SanityFlag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag>`
                                                
                                                .. attribute:: tunnel_class_value
                                                
                                                	Tunnel class value
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: tunnel_is_forward_class
                                                
                                                	Tunnel is forward class
                                                	**type**\: list of    :py:class:`TunnelIsForwardClass <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass>`
                                                
                                                .. attribute:: weights_of_path
                                                
                                                	Weights of paths
                                                	**type**\: list of    :py:class:`WeightsOfPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath>`
                                                
                                                

                                                """

                                                _prefix = 'fib-common-oper'
                                                _revision = '2017-01-20'

                                                def __init__(self):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData, self).__init__()

                                                    self.yang_name = "load-informtion-internal-data"
                                                    self.yang_parent_name = "loadshare-information"

                                                    self.is_pbts_info_valid = YLeaf(YType.boolean, "is-pbts-info-valid")

                                                    self.ldi_next_hop_buckets = YLeaf(YType.uint8, "ldi-next-hop-buckets")

                                                    self.level_ofldis = YLeaf(YType.uint8, "level-ofldis")

                                                    self.maximum_index_arrays = YLeaf(YType.uint32, "maximum-index-arrays")

                                                    self.maximum_slots = YLeaf(YType.uint32, "maximum-slots")

                                                    self.normalized_weights = YLeaf(YType.str, "normalized-weights")

                                                    self.number_of_ldis = YLeaf(YType.uint8, "number-of-ldis")

                                                    self.path_indices = YLeaf(YType.str, "path-indices")

                                                    self.path_ldi_numbers = YLeaf(YType.str, "path-ldi-numbers")

                                                    self.pbts_class_num_paths = YLeaf(YType.str, "pbts-class-num-paths")

                                                    self.pbts_class_offset = YLeaf(YType.str, "pbts-class-offset")

                                                    self.pbts_fallback_mapped_class = YLeaf(YType.str, "pbts-fallback-mapped-class")

                                                    self.platform_hardware_information = YLeaf(YType.str, "platform-hardware-information")

                                                    self.round_robin_disable = YLeaf(YType.boolean, "round-robin-disable")

                                                    self.tunnel_class_value = YLeaf(YType.str, "tunnel-class-value")

                                                    self.adjacency_address = YList(self)
                                                    self.interface_handle = YList(self)
                                                    self.pbts_class_is_fallback_mapped = YList(self)
                                                    self.pbts_fallback_to_drop = YList(self)
                                                    self.sanity_flag = YList(self)
                                                    self.tunnel_is_forward_class = YList(self)
                                                    self.weights_of_path = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("is_pbts_info_valid",
                                                                    "ldi_next_hop_buckets",
                                                                    "level_ofldis",
                                                                    "maximum_index_arrays",
                                                                    "maximum_slots",
                                                                    "normalized_weights",
                                                                    "number_of_ldis",
                                                                    "path_indices",
                                                                    "path_ldi_numbers",
                                                                    "pbts_class_num_paths",
                                                                    "pbts_class_offset",
                                                                    "pbts_fallback_mapped_class",
                                                                    "platform_hardware_information",
                                                                    "round_robin_disable",
                                                                    "tunnel_class_value") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData, self).__setattr__(name, value)


                                                class SanityFlag(Entity):
                                                    """
                                                    Sanity flag
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	
                                                    	**type**\:  bool
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag, self).__init__()

                                                        self.yang_name = "sanity-flag"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.boolean, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "sanity-flag" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class InterfaceHandle(Entity):
                                                    """
                                                    Interface handle
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle, self).__init__()

                                                        self.yang_name = "interface-handle"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.str, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "interface-handle" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class WeightsOfPath(Entity):
                                                    """
                                                    Weights of paths
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath, self).__init__()

                                                        self.yang_name = "weights-of-path"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.uint32, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "weights-of-path" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class AdjacencyAddress(Entity):
                                                    """
                                                    Adjacency address
                                                    
                                                    .. attribute:: address
                                                    
                                                    	address
                                                    	**type**\:  str
                                                    
                                                    	**length:** 0..60
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress, self).__init__()

                                                        self.yang_name = "adjacency-address"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.address = YLeaf(YType.str, "address")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("address") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.address.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.address.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "adjacency-address" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.address.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "address"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "address"):
                                                            self.address = value
                                                            self.address.value_namespace = name_space
                                                            self.address.value_namespace_prefix = name_space_prefix


                                                class PbtsClassIsFallbackMapped(Entity):
                                                    """
                                                    Does PBTS class fall back to drop or any class
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	Array entry
                                                    	**type**\:  bool
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped, self).__init__()

                                                        self.yang_name = "pbts-class-is-fallback-mapped"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.boolean, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "pbts-class-is-fallback-mapped" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class PbtsFallbackToDrop(Entity):
                                                    """
                                                    PBTS class falls back to drop
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	Array entry
                                                    	**type**\:  bool
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop, self).__init__()

                                                        self.yang_name = "pbts-fallback-to-drop"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.boolean, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "pbts-fallback-to-drop" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix


                                                class TunnelIsForwardClass(Entity):
                                                    """
                                                    Tunnel is forward class
                                                    
                                                    .. attribute:: entry
                                                    
                                                    	Array entry
                                                    	**type**\:  bool
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass, self).__init__()

                                                        self.yang_name = "tunnel-is-forward-class"
                                                        self.yang_parent_name = "load-informtion-internal-data"

                                                        self.entry = YLeaf(YType.boolean, "entry")

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("entry") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass, self).__setattr__(name, value)

                                                    def has_data(self):
                                                        return self.entry.is_set

                                                    def has_operation(self):
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.entry.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "tunnel-is-forward-class" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "entry"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "entry"):
                                                            self.entry = value
                                                            self.entry.value_namespace = name_space
                                                            self.entry.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.adjacency_address:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.interface_handle:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.pbts_class_is_fallback_mapped:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.pbts_fallback_to_drop:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.sanity_flag:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.tunnel_is_forward_class:
                                                        if (c.has_data()):
                                                            return True
                                                    for c in self.weights_of_path:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.is_pbts_info_valid.is_set or
                                                        self.ldi_next_hop_buckets.is_set or
                                                        self.level_ofldis.is_set or
                                                        self.maximum_index_arrays.is_set or
                                                        self.maximum_slots.is_set or
                                                        self.normalized_weights.is_set or
                                                        self.number_of_ldis.is_set or
                                                        self.path_indices.is_set or
                                                        self.path_ldi_numbers.is_set or
                                                        self.pbts_class_num_paths.is_set or
                                                        self.pbts_class_offset.is_set or
                                                        self.pbts_fallback_mapped_class.is_set or
                                                        self.platform_hardware_information.is_set or
                                                        self.round_robin_disable.is_set or
                                                        self.tunnel_class_value.is_set)

                                                def has_operation(self):
                                                    for c in self.adjacency_address:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.interface_handle:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.pbts_class_is_fallback_mapped:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.pbts_fallback_to_drop:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.sanity_flag:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.tunnel_is_forward_class:
                                                        if (c.has_operation()):
                                                            return True
                                                    for c in self.weights_of_path:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.is_pbts_info_valid.yfilter != YFilter.not_set or
                                                        self.ldi_next_hop_buckets.yfilter != YFilter.not_set or
                                                        self.level_ofldis.yfilter != YFilter.not_set or
                                                        self.maximum_index_arrays.yfilter != YFilter.not_set or
                                                        self.maximum_slots.yfilter != YFilter.not_set or
                                                        self.normalized_weights.yfilter != YFilter.not_set or
                                                        self.number_of_ldis.yfilter != YFilter.not_set or
                                                        self.path_indices.yfilter != YFilter.not_set or
                                                        self.path_ldi_numbers.yfilter != YFilter.not_set or
                                                        self.pbts_class_num_paths.yfilter != YFilter.not_set or
                                                        self.pbts_class_offset.yfilter != YFilter.not_set or
                                                        self.pbts_fallback_mapped_class.yfilter != YFilter.not_set or
                                                        self.platform_hardware_information.yfilter != YFilter.not_set or
                                                        self.round_robin_disable.yfilter != YFilter.not_set or
                                                        self.tunnel_class_value.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "load-informtion-internal-data" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.is_pbts_info_valid.is_set or self.is_pbts_info_valid.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.is_pbts_info_valid.get_name_leafdata())
                                                    if (self.ldi_next_hop_buckets.is_set or self.ldi_next_hop_buckets.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.ldi_next_hop_buckets.get_name_leafdata())
                                                    if (self.level_ofldis.is_set or self.level_ofldis.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.level_ofldis.get_name_leafdata())
                                                    if (self.maximum_index_arrays.is_set or self.maximum_index_arrays.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.maximum_index_arrays.get_name_leafdata())
                                                    if (self.maximum_slots.is_set or self.maximum_slots.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.maximum_slots.get_name_leafdata())
                                                    if (self.normalized_weights.is_set or self.normalized_weights.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.normalized_weights.get_name_leafdata())
                                                    if (self.number_of_ldis.is_set or self.number_of_ldis.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.number_of_ldis.get_name_leafdata())
                                                    if (self.path_indices.is_set or self.path_indices.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.path_indices.get_name_leafdata())
                                                    if (self.path_ldi_numbers.is_set or self.path_ldi_numbers.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.path_ldi_numbers.get_name_leafdata())
                                                    if (self.pbts_class_num_paths.is_set or self.pbts_class_num_paths.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.pbts_class_num_paths.get_name_leafdata())
                                                    if (self.pbts_class_offset.is_set or self.pbts_class_offset.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.pbts_class_offset.get_name_leafdata())
                                                    if (self.pbts_fallback_mapped_class.is_set or self.pbts_fallback_mapped_class.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.pbts_fallback_mapped_class.get_name_leafdata())
                                                    if (self.platform_hardware_information.is_set or self.platform_hardware_information.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.platform_hardware_information.get_name_leafdata())
                                                    if (self.round_robin_disable.is_set or self.round_robin_disable.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.round_robin_disable.get_name_leafdata())
                                                    if (self.tunnel_class_value.is_set or self.tunnel_class_value.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.tunnel_class_value.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "adjacency-address"):
                                                        for c in self.adjacency_address:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.AdjacencyAddress()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.adjacency_address.append(c)
                                                        return c

                                                    if (child_yang_name == "interface-handle"):
                                                        for c in self.interface_handle:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.InterfaceHandle()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.interface_handle.append(c)
                                                        return c

                                                    if (child_yang_name == "pbts-class-is-fallback-mapped"):
                                                        for c in self.pbts_class_is_fallback_mapped:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsClassIsFallbackMapped()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.pbts_class_is_fallback_mapped.append(c)
                                                        return c

                                                    if (child_yang_name == "pbts-fallback-to-drop"):
                                                        for c in self.pbts_fallback_to_drop:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.PbtsFallbackToDrop()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.pbts_fallback_to_drop.append(c)
                                                        return c

                                                    if (child_yang_name == "sanity-flag"):
                                                        for c in self.sanity_flag:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.SanityFlag()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.sanity_flag.append(c)
                                                        return c

                                                    if (child_yang_name == "tunnel-is-forward-class"):
                                                        for c in self.tunnel_is_forward_class:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.TunnelIsForwardClass()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.tunnel_is_forward_class.append(c)
                                                        return c

                                                    if (child_yang_name == "weights-of-path"):
                                                        for c in self.weights_of_path:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData.WeightsOfPath()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.weights_of_path.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "adjacency-address" or name == "interface-handle" or name == "pbts-class-is-fallback-mapped" or name == "pbts-fallback-to-drop" or name == "sanity-flag" or name == "tunnel-is-forward-class" or name == "weights-of-path" or name == "is-pbts-info-valid" or name == "ldi-next-hop-buckets" or name == "level-ofldis" or name == "maximum-index-arrays" or name == "maximum-slots" or name == "normalized-weights" or name == "number-of-ldis" or name == "path-indices" or name == "path-ldi-numbers" or name == "pbts-class-num-paths" or name == "pbts-class-offset" or name == "pbts-fallback-mapped-class" or name == "platform-hardware-information" or name == "round-robin-disable" or name == "tunnel-class-value"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "is-pbts-info-valid"):
                                                        self.is_pbts_info_valid = value
                                                        self.is_pbts_info_valid.value_namespace = name_space
                                                        self.is_pbts_info_valid.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "ldi-next-hop-buckets"):
                                                        self.ldi_next_hop_buckets = value
                                                        self.ldi_next_hop_buckets.value_namespace = name_space
                                                        self.ldi_next_hop_buckets.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "level-ofldis"):
                                                        self.level_ofldis = value
                                                        self.level_ofldis.value_namespace = name_space
                                                        self.level_ofldis.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "maximum-index-arrays"):
                                                        self.maximum_index_arrays = value
                                                        self.maximum_index_arrays.value_namespace = name_space
                                                        self.maximum_index_arrays.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "maximum-slots"):
                                                        self.maximum_slots = value
                                                        self.maximum_slots.value_namespace = name_space
                                                        self.maximum_slots.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "normalized-weights"):
                                                        self.normalized_weights = value
                                                        self.normalized_weights.value_namespace = name_space
                                                        self.normalized_weights.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "number-of-ldis"):
                                                        self.number_of_ldis = value
                                                        self.number_of_ldis.value_namespace = name_space
                                                        self.number_of_ldis.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "path-indices"):
                                                        self.path_indices = value
                                                        self.path_indices.value_namespace = name_space
                                                        self.path_indices.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "path-ldi-numbers"):
                                                        self.path_ldi_numbers = value
                                                        self.path_ldi_numbers.value_namespace = name_space
                                                        self.path_ldi_numbers.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "pbts-class-num-paths"):
                                                        self.pbts_class_num_paths = value
                                                        self.pbts_class_num_paths.value_namespace = name_space
                                                        self.pbts_class_num_paths.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "pbts-class-offset"):
                                                        self.pbts_class_offset = value
                                                        self.pbts_class_offset.value_namespace = name_space
                                                        self.pbts_class_offset.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "pbts-fallback-mapped-class"):
                                                        self.pbts_fallback_mapped_class = value
                                                        self.pbts_fallback_mapped_class.value_namespace = name_space
                                                        self.pbts_fallback_mapped_class.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "platform-hardware-information"):
                                                        self.platform_hardware_information = value
                                                        self.platform_hardware_information.value_namespace = name_space
                                                        self.platform_hardware_information.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "round-robin-disable"):
                                                        self.round_robin_disable = value
                                                        self.round_robin_disable.value_namespace = name_space
                                                        self.round_robin_disable.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "tunnel-class-value"):
                                                        self.tunnel_class_value = value
                                                        self.tunnel_class_value.value_namespace = name_space
                                                        self.tunnel_class_value.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                return (
                                                    self.bytes_through_load_information.is_set or
                                                    self.is_owner.is_set or
                                                    self.load_information_owner_deleted_flag.is_set or
                                                    self.load_information_reference_count.is_set or
                                                    self.loadinfo_sanity_flag.is_set or
                                                    self.mask_length_of_owner.is_set or
                                                    self.packets_through_load_information.is_set or
                                                    self.per_dest_load_sharing_flag.is_set or
                                                    self.prefix_of_owner.is_set or
                                                    self.total_bytes_through_load_information.is_set or
                                                    self.total_packets_through_load_information.is_set or
                                                    (self.load_informtion_internal_data is not None and self.load_informtion_internal_data.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.bytes_through_load_information.yfilter != YFilter.not_set or
                                                    self.is_owner.yfilter != YFilter.not_set or
                                                    self.load_information_owner_deleted_flag.yfilter != YFilter.not_set or
                                                    self.load_information_reference_count.yfilter != YFilter.not_set or
                                                    self.loadinfo_sanity_flag.yfilter != YFilter.not_set or
                                                    self.mask_length_of_owner.yfilter != YFilter.not_set or
                                                    self.packets_through_load_information.yfilter != YFilter.not_set or
                                                    self.per_dest_load_sharing_flag.yfilter != YFilter.not_set or
                                                    self.prefix_of_owner.yfilter != YFilter.not_set or
                                                    self.total_bytes_through_load_information.yfilter != YFilter.not_set or
                                                    self.total_packets_through_load_information.yfilter != YFilter.not_set or
                                                    (self.load_informtion_internal_data is not None and self.load_informtion_internal_data.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "loadshare-information" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.bytes_through_load_information.is_set or self.bytes_through_load_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.bytes_through_load_information.get_name_leafdata())
                                                if (self.is_owner.is_set or self.is_owner.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.is_owner.get_name_leafdata())
                                                if (self.load_information_owner_deleted_flag.is_set or self.load_information_owner_deleted_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.load_information_owner_deleted_flag.get_name_leafdata())
                                                if (self.load_information_reference_count.is_set or self.load_information_reference_count.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.load_information_reference_count.get_name_leafdata())
                                                if (self.loadinfo_sanity_flag.is_set or self.loadinfo_sanity_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.loadinfo_sanity_flag.get_name_leafdata())
                                                if (self.mask_length_of_owner.is_set or self.mask_length_of_owner.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.mask_length_of_owner.get_name_leafdata())
                                                if (self.packets_through_load_information.is_set or self.packets_through_load_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.packets_through_load_information.get_name_leafdata())
                                                if (self.per_dest_load_sharing_flag.is_set or self.per_dest_load_sharing_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.per_dest_load_sharing_flag.get_name_leafdata())
                                                if (self.prefix_of_owner.is_set or self.prefix_of_owner.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.prefix_of_owner.get_name_leafdata())
                                                if (self.total_bytes_through_load_information.is_set or self.total_bytes_through_load_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.total_bytes_through_load_information.get_name_leafdata())
                                                if (self.total_packets_through_load_information.is_set or self.total_packets_through_load_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.total_packets_through_load_information.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "load-informtion-internal-data"):
                                                    if (self.load_informtion_internal_data is None):
                                                        self.load_informtion_internal_data = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation.LoadInformtionInternalData()
                                                        self.load_informtion_internal_data.parent = self
                                                        self._children_name_map["load_informtion_internal_data"] = "load-informtion-internal-data"
                                                    return self.load_informtion_internal_data

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "load-informtion-internal-data" or name == "bytes-through-load-information" or name == "is-owner" or name == "load-information-owner-deleted-flag" or name == "load-information-reference-count" or name == "loadinfo-sanity-flag" or name == "mask-length-of-owner" or name == "packets-through-load-information" or name == "per-dest-load-sharing-flag" or name == "prefix-of-owner" or name == "total-bytes-through-load-information" or name == "total-packets-through-load-information"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "bytes-through-load-information"):
                                                    self.bytes_through_load_information = value
                                                    self.bytes_through_load_information.value_namespace = name_space
                                                    self.bytes_through_load_information.value_namespace_prefix = name_space_prefix
                                                if(value_path == "is-owner"):
                                                    self.is_owner = value
                                                    self.is_owner.value_namespace = name_space
                                                    self.is_owner.value_namespace_prefix = name_space_prefix
                                                if(value_path == "load-information-owner-deleted-flag"):
                                                    self.load_information_owner_deleted_flag = value
                                                    self.load_information_owner_deleted_flag.value_namespace = name_space
                                                    self.load_information_owner_deleted_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "load-information-reference-count"):
                                                    self.load_information_reference_count = value
                                                    self.load_information_reference_count.value_namespace = name_space
                                                    self.load_information_reference_count.value_namespace_prefix = name_space_prefix
                                                if(value_path == "loadinfo-sanity-flag"):
                                                    self.loadinfo_sanity_flag = value
                                                    self.loadinfo_sanity_flag.value_namespace = name_space
                                                    self.loadinfo_sanity_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "mask-length-of-owner"):
                                                    self.mask_length_of_owner = value
                                                    self.mask_length_of_owner.value_namespace = name_space
                                                    self.mask_length_of_owner.value_namespace_prefix = name_space_prefix
                                                if(value_path == "packets-through-load-information"):
                                                    self.packets_through_load_information = value
                                                    self.packets_through_load_information.value_namespace = name_space
                                                    self.packets_through_load_information.value_namespace_prefix = name_space_prefix
                                                if(value_path == "per-dest-load-sharing-flag"):
                                                    self.per_dest_load_sharing_flag = value
                                                    self.per_dest_load_sharing_flag.value_namespace = name_space
                                                    self.per_dest_load_sharing_flag.value_namespace_prefix = name_space_prefix
                                                if(value_path == "prefix-of-owner"):
                                                    self.prefix_of_owner = value
                                                    self.prefix_of_owner.value_namespace = name_space
                                                    self.prefix_of_owner.value_namespace_prefix = name_space_prefix
                                                if(value_path == "total-bytes-through-load-information"):
                                                    self.total_bytes_through_load_information = value
                                                    self.total_bytes_through_load_information.value_namespace = name_space
                                                    self.total_bytes_through_load_information.value_namespace_prefix = name_space_prefix
                                                if(value_path == "total-packets-through-load-information"):
                                                    self.total_packets_through_load_information = value
                                                    self.total_packets_through_load_information.value_namespace = name_space
                                                    self.total_packets_through_load_information.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.adjacency_address_length.is_set or
                                                self.adjacency_interface.is_set or
                                                self.afi_fib_protocol_type.is_set or
                                                self.aib_l3_address.is_set or
                                                self.bgp_attribute_id.is_set or
                                                self.bgp_attribute_next_hop_as.is_set or
                                                self.bgp_attribute_origin_as.is_set or
                                                self.bgp_local_attribute_id.is_set or
                                                self.bytes_through_fib_entry.is_set or
                                                self.com_string.is_set or
                                                self.detailed_prefix_length.is_set or
                                                self.extcom_string.is_set or
                                                self.extended_community.is_set or
                                                self.fast_adjacency_flag.is_set or
                                                self.fib_entry_adjacency_address.is_set or
                                                self.fib_entry_adjacency_interface.is_set or
                                                self.fib_entry_adjacency_type.is_set or
                                                self.fib_entry_version.is_set or
                                                self.fib_protocol_type.is_set or
                                                self.fib_special_nh_information_type.is_set or
                                                self.flow_tag.is_set or
                                                self.forward_class.is_set or
                                                self.illegal_fast_adjacency_flag.is_set or
                                                self.ldi_time_of_last_update_in_msec.is_set or
                                                self.load_sharing_type.is_set or
                                                self.lwldi_time_of_last_update_in_msec.is_set or
                                                self.mpls_fec.is_set or
                                                self.packets_through_fib_entry.is_set or
                                                self.path_string.is_set or
                                                self.per_prefix_accounting.is_set or
                                                self.pl_time_of_last_update_in_msec.is_set or
                                                self.pl_time_stamp_type.is_set or
                                                self.precedence_forpackets.is_set or
                                                self.prefix_protocol.is_set or
                                                self.qos_group.is_set or
                                                self.qppb_qos_group_and_ip_precedence.is_set or
                                                self.remote_adjacency_flag.is_set or
                                                self.switch_compontent_id.is_set or
                                                self.traffic_index_for_packets.is_set or
                                                (self.loadshare_information is not None and self.loadshare_information.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.adjacency_address_length.yfilter != YFilter.not_set or
                                                self.adjacency_interface.yfilter != YFilter.not_set or
                                                self.afi_fib_protocol_type.yfilter != YFilter.not_set or
                                                self.aib_l3_address.yfilter != YFilter.not_set or
                                                self.bgp_attribute_id.yfilter != YFilter.not_set or
                                                self.bgp_attribute_next_hop_as.yfilter != YFilter.not_set or
                                                self.bgp_attribute_origin_as.yfilter != YFilter.not_set or
                                                self.bgp_local_attribute_id.yfilter != YFilter.not_set or
                                                self.bytes_through_fib_entry.yfilter != YFilter.not_set or
                                                self.com_string.yfilter != YFilter.not_set or
                                                self.detailed_prefix_length.yfilter != YFilter.not_set or
                                                self.extcom_string.yfilter != YFilter.not_set or
                                                self.extended_community.yfilter != YFilter.not_set or
                                                self.fast_adjacency_flag.yfilter != YFilter.not_set or
                                                self.fib_entry_adjacency_address.yfilter != YFilter.not_set or
                                                self.fib_entry_adjacency_interface.yfilter != YFilter.not_set or
                                                self.fib_entry_adjacency_type.yfilter != YFilter.not_set or
                                                self.fib_entry_version.yfilter != YFilter.not_set or
                                                self.fib_protocol_type.yfilter != YFilter.not_set or
                                                self.fib_special_nh_information_type.yfilter != YFilter.not_set or
                                                self.flow_tag.yfilter != YFilter.not_set or
                                                self.forward_class.yfilter != YFilter.not_set or
                                                self.illegal_fast_adjacency_flag.yfilter != YFilter.not_set or
                                                self.ldi_time_of_last_update_in_msec.yfilter != YFilter.not_set or
                                                self.load_sharing_type.yfilter != YFilter.not_set or
                                                self.lwldi_time_of_last_update_in_msec.yfilter != YFilter.not_set or
                                                self.mpls_fec.yfilter != YFilter.not_set or
                                                self.packets_through_fib_entry.yfilter != YFilter.not_set or
                                                self.path_string.yfilter != YFilter.not_set or
                                                self.per_prefix_accounting.yfilter != YFilter.not_set or
                                                self.pl_time_of_last_update_in_msec.yfilter != YFilter.not_set or
                                                self.pl_time_stamp_type.yfilter != YFilter.not_set or
                                                self.precedence_forpackets.yfilter != YFilter.not_set or
                                                self.prefix_protocol.yfilter != YFilter.not_set or
                                                self.qos_group.yfilter != YFilter.not_set or
                                                self.qppb_qos_group_and_ip_precedence.yfilter != YFilter.not_set or
                                                self.remote_adjacency_flag.yfilter != YFilter.not_set or
                                                self.switch_compontent_id.yfilter != YFilter.not_set or
                                                self.traffic_index_for_packets.yfilter != YFilter.not_set or
                                                (self.loadshare_information is not None and self.loadshare_information.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "detail-fib-entry-information" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.adjacency_address_length.is_set or self.adjacency_address_length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adjacency_address_length.get_name_leafdata())
                                            if (self.adjacency_interface.is_set or self.adjacency_interface.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adjacency_interface.get_name_leafdata())
                                            if (self.afi_fib_protocol_type.is_set or self.afi_fib_protocol_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.afi_fib_protocol_type.get_name_leafdata())
                                            if (self.aib_l3_address.is_set or self.aib_l3_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.aib_l3_address.get_name_leafdata())
                                            if (self.bgp_attribute_id.is_set or self.bgp_attribute_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bgp_attribute_id.get_name_leafdata())
                                            if (self.bgp_attribute_next_hop_as.is_set or self.bgp_attribute_next_hop_as.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bgp_attribute_next_hop_as.get_name_leafdata())
                                            if (self.bgp_attribute_origin_as.is_set or self.bgp_attribute_origin_as.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bgp_attribute_origin_as.get_name_leafdata())
                                            if (self.bgp_local_attribute_id.is_set or self.bgp_local_attribute_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bgp_local_attribute_id.get_name_leafdata())
                                            if (self.bytes_through_fib_entry.is_set or self.bytes_through_fib_entry.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.bytes_through_fib_entry.get_name_leafdata())
                                            if (self.com_string.is_set or self.com_string.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.com_string.get_name_leafdata())
                                            if (self.detailed_prefix_length.is_set or self.detailed_prefix_length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.detailed_prefix_length.get_name_leafdata())
                                            if (self.extcom_string.is_set or self.extcom_string.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.extcom_string.get_name_leafdata())
                                            if (self.extended_community.is_set or self.extended_community.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.extended_community.get_name_leafdata())
                                            if (self.fast_adjacency_flag.is_set or self.fast_adjacency_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fast_adjacency_flag.get_name_leafdata())
                                            if (self.fib_entry_adjacency_address.is_set or self.fib_entry_adjacency_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_entry_adjacency_address.get_name_leafdata())
                                            if (self.fib_entry_adjacency_interface.is_set or self.fib_entry_adjacency_interface.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_entry_adjacency_interface.get_name_leafdata())
                                            if (self.fib_entry_adjacency_type.is_set or self.fib_entry_adjacency_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_entry_adjacency_type.get_name_leafdata())
                                            if (self.fib_entry_version.is_set or self.fib_entry_version.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_entry_version.get_name_leafdata())
                                            if (self.fib_protocol_type.is_set or self.fib_protocol_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_protocol_type.get_name_leafdata())
                                            if (self.fib_special_nh_information_type.is_set or self.fib_special_nh_information_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fib_special_nh_information_type.get_name_leafdata())
                                            if (self.flow_tag.is_set or self.flow_tag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.flow_tag.get_name_leafdata())
                                            if (self.forward_class.is_set or self.forward_class.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.forward_class.get_name_leafdata())
                                            if (self.illegal_fast_adjacency_flag.is_set or self.illegal_fast_adjacency_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.illegal_fast_adjacency_flag.get_name_leafdata())
                                            if (self.ldi_time_of_last_update_in_msec.is_set or self.ldi_time_of_last_update_in_msec.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.ldi_time_of_last_update_in_msec.get_name_leafdata())
                                            if (self.load_sharing_type.is_set or self.load_sharing_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.load_sharing_type.get_name_leafdata())
                                            if (self.lwldi_time_of_last_update_in_msec.is_set or self.lwldi_time_of_last_update_in_msec.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.lwldi_time_of_last_update_in_msec.get_name_leafdata())
                                            if (self.mpls_fec.is_set or self.mpls_fec.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.mpls_fec.get_name_leafdata())
                                            if (self.packets_through_fib_entry.is_set or self.packets_through_fib_entry.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.packets_through_fib_entry.get_name_leafdata())
                                            if (self.path_string.is_set or self.path_string.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.path_string.get_name_leafdata())
                                            if (self.per_prefix_accounting.is_set or self.per_prefix_accounting.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.per_prefix_accounting.get_name_leafdata())
                                            if (self.pl_time_of_last_update_in_msec.is_set or self.pl_time_of_last_update_in_msec.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pl_time_of_last_update_in_msec.get_name_leafdata())
                                            if (self.pl_time_stamp_type.is_set or self.pl_time_stamp_type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pl_time_stamp_type.get_name_leafdata())
                                            if (self.precedence_forpackets.is_set or self.precedence_forpackets.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.precedence_forpackets.get_name_leafdata())
                                            if (self.prefix_protocol.is_set or self.prefix_protocol.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.prefix_protocol.get_name_leafdata())
                                            if (self.qos_group.is_set or self.qos_group.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.qos_group.get_name_leafdata())
                                            if (self.qppb_qos_group_and_ip_precedence.is_set or self.qppb_qos_group_and_ip_precedence.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.qppb_qos_group_and_ip_precedence.get_name_leafdata())
                                            if (self.remote_adjacency_flag.is_set or self.remote_adjacency_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.remote_adjacency_flag.get_name_leafdata())
                                            if (self.switch_compontent_id.is_set or self.switch_compontent_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.switch_compontent_id.get_name_leafdata())
                                            if (self.traffic_index_for_packets.is_set or self.traffic_index_for_packets.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.traffic_index_for_packets.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "loadshare-information"):
                                                if (self.loadshare_information is None):
                                                    self.loadshare_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation.LoadshareInformation()
                                                    self.loadshare_information.parent = self
                                                    self._children_name_map["loadshare_information"] = "loadshare-information"
                                                return self.loadshare_information

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "loadshare-information" or name == "adjacency-address-length" or name == "adjacency-interface" or name == "afi-fib-protocol-type" or name == "aib-l3-address" or name == "bgp-attribute-id" or name == "bgp-attribute-next-hop-as" or name == "bgp-attribute-origin-as" or name == "bgp-local-attribute-id" or name == "bytes-through-fib-entry" or name == "com-string" or name == "detailed-prefix-length" or name == "extcom-string" or name == "extended-community" or name == "fast-adjacency-flag" or name == "fib-entry-adjacency-address" or name == "fib-entry-adjacency-interface" or name == "fib-entry-adjacency-type" or name == "fib-entry-version" or name == "fib-protocol-type" or name == "fib-special-nh-information-type" or name == "flow-tag" or name == "forward-class" or name == "illegal-fast-adjacency-flag" or name == "ldi-time-of-last-update-in-msec" or name == "load-sharing-type" or name == "lwldi-time-of-last-update-in-msec" or name == "mpls-fec" or name == "packets-through-fib-entry" or name == "path-string" or name == "per-prefix-accounting" or name == "pl-time-of-last-update-in-msec" or name == "pl-time-stamp-type" or name == "precedence-forpackets" or name == "prefix-protocol" or name == "qos-group" or name == "qppb-qos-group-and-ip-precedence" or name == "remote-adjacency-flag" or name == "switch-compontent-id" or name == "traffic-index-for-packets"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "adjacency-address-length"):
                                                self.adjacency_address_length = value
                                                self.adjacency_address_length.value_namespace = name_space
                                                self.adjacency_address_length.value_namespace_prefix = name_space_prefix
                                            if(value_path == "adjacency-interface"):
                                                self.adjacency_interface = value
                                                self.adjacency_interface.value_namespace = name_space
                                                self.adjacency_interface.value_namespace_prefix = name_space_prefix
                                            if(value_path == "afi-fib-protocol-type"):
                                                self.afi_fib_protocol_type = value
                                                self.afi_fib_protocol_type.value_namespace = name_space
                                                self.afi_fib_protocol_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "aib-l3-address"):
                                                self.aib_l3_address = value
                                                self.aib_l3_address.value_namespace = name_space
                                                self.aib_l3_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bgp-attribute-id"):
                                                self.bgp_attribute_id = value
                                                self.bgp_attribute_id.value_namespace = name_space
                                                self.bgp_attribute_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bgp-attribute-next-hop-as"):
                                                self.bgp_attribute_next_hop_as = value
                                                self.bgp_attribute_next_hop_as.value_namespace = name_space
                                                self.bgp_attribute_next_hop_as.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bgp-attribute-origin-as"):
                                                self.bgp_attribute_origin_as = value
                                                self.bgp_attribute_origin_as.value_namespace = name_space
                                                self.bgp_attribute_origin_as.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bgp-local-attribute-id"):
                                                self.bgp_local_attribute_id = value
                                                self.bgp_local_attribute_id.value_namespace = name_space
                                                self.bgp_local_attribute_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "bytes-through-fib-entry"):
                                                self.bytes_through_fib_entry = value
                                                self.bytes_through_fib_entry.value_namespace = name_space
                                                self.bytes_through_fib_entry.value_namespace_prefix = name_space_prefix
                                            if(value_path == "com-string"):
                                                self.com_string = value
                                                self.com_string.value_namespace = name_space
                                                self.com_string.value_namespace_prefix = name_space_prefix
                                            if(value_path == "detailed-prefix-length"):
                                                self.detailed_prefix_length = value
                                                self.detailed_prefix_length.value_namespace = name_space
                                                self.detailed_prefix_length.value_namespace_prefix = name_space_prefix
                                            if(value_path == "extcom-string"):
                                                self.extcom_string = value
                                                self.extcom_string.value_namespace = name_space
                                                self.extcom_string.value_namespace_prefix = name_space_prefix
                                            if(value_path == "extended-community"):
                                                self.extended_community = value
                                                self.extended_community.value_namespace = name_space
                                                self.extended_community.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fast-adjacency-flag"):
                                                self.fast_adjacency_flag = value
                                                self.fast_adjacency_flag.value_namespace = name_space
                                                self.fast_adjacency_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-entry-adjacency-address"):
                                                self.fib_entry_adjacency_address = value
                                                self.fib_entry_adjacency_address.value_namespace = name_space
                                                self.fib_entry_adjacency_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-entry-adjacency-interface"):
                                                self.fib_entry_adjacency_interface = value
                                                self.fib_entry_adjacency_interface.value_namespace = name_space
                                                self.fib_entry_adjacency_interface.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-entry-adjacency-type"):
                                                self.fib_entry_adjacency_type = value
                                                self.fib_entry_adjacency_type.value_namespace = name_space
                                                self.fib_entry_adjacency_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-entry-version"):
                                                self.fib_entry_version = value
                                                self.fib_entry_version.value_namespace = name_space
                                                self.fib_entry_version.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-protocol-type"):
                                                self.fib_protocol_type = value
                                                self.fib_protocol_type.value_namespace = name_space
                                                self.fib_protocol_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fib-special-nh-information-type"):
                                                self.fib_special_nh_information_type = value
                                                self.fib_special_nh_information_type.value_namespace = name_space
                                                self.fib_special_nh_information_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "flow-tag"):
                                                self.flow_tag = value
                                                self.flow_tag.value_namespace = name_space
                                                self.flow_tag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "forward-class"):
                                                self.forward_class = value
                                                self.forward_class.value_namespace = name_space
                                                self.forward_class.value_namespace_prefix = name_space_prefix
                                            if(value_path == "illegal-fast-adjacency-flag"):
                                                self.illegal_fast_adjacency_flag = value
                                                self.illegal_fast_adjacency_flag.value_namespace = name_space
                                                self.illegal_fast_adjacency_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "ldi-time-of-last-update-in-msec"):
                                                self.ldi_time_of_last_update_in_msec = value
                                                self.ldi_time_of_last_update_in_msec.value_namespace = name_space
                                                self.ldi_time_of_last_update_in_msec.value_namespace_prefix = name_space_prefix
                                            if(value_path == "load-sharing-type"):
                                                self.load_sharing_type = value
                                                self.load_sharing_type.value_namespace = name_space
                                                self.load_sharing_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "lwldi-time-of-last-update-in-msec"):
                                                self.lwldi_time_of_last_update_in_msec = value
                                                self.lwldi_time_of_last_update_in_msec.value_namespace = name_space
                                                self.lwldi_time_of_last_update_in_msec.value_namespace_prefix = name_space_prefix
                                            if(value_path == "mpls-fec"):
                                                self.mpls_fec = value
                                                self.mpls_fec.value_namespace = name_space
                                                self.mpls_fec.value_namespace_prefix = name_space_prefix
                                            if(value_path == "packets-through-fib-entry"):
                                                self.packets_through_fib_entry = value
                                                self.packets_through_fib_entry.value_namespace = name_space
                                                self.packets_through_fib_entry.value_namespace_prefix = name_space_prefix
                                            if(value_path == "path-string"):
                                                self.path_string = value
                                                self.path_string.value_namespace = name_space
                                                self.path_string.value_namespace_prefix = name_space_prefix
                                            if(value_path == "per-prefix-accounting"):
                                                self.per_prefix_accounting = value
                                                self.per_prefix_accounting.value_namespace = name_space
                                                self.per_prefix_accounting.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pl-time-of-last-update-in-msec"):
                                                self.pl_time_of_last_update_in_msec = value
                                                self.pl_time_of_last_update_in_msec.value_namespace = name_space
                                                self.pl_time_of_last_update_in_msec.value_namespace_prefix = name_space_prefix
                                            if(value_path == "pl-time-stamp-type"):
                                                self.pl_time_stamp_type = value
                                                self.pl_time_stamp_type.value_namespace = name_space
                                                self.pl_time_stamp_type.value_namespace_prefix = name_space_prefix
                                            if(value_path == "precedence-forpackets"):
                                                self.precedence_forpackets = value
                                                self.precedence_forpackets.value_namespace = name_space
                                                self.precedence_forpackets.value_namespace_prefix = name_space_prefix
                                            if(value_path == "prefix-protocol"):
                                                self.prefix_protocol = value
                                                self.prefix_protocol.value_namespace = name_space
                                                self.prefix_protocol.value_namespace_prefix = name_space_prefix
                                            if(value_path == "qos-group"):
                                                self.qos_group = value
                                                self.qos_group.value_namespace = name_space
                                                self.qos_group.value_namespace_prefix = name_space_prefix
                                            if(value_path == "qppb-qos-group-and-ip-precedence"):
                                                self.qppb_qos_group_and_ip_precedence = value
                                                self.qppb_qos_group_and_ip_precedence.value_namespace = name_space
                                                self.qppb_qos_group_and_ip_precedence.value_namespace_prefix = name_space_prefix
                                            if(value_path == "remote-adjacency-flag"):
                                                self.remote_adjacency_flag = value
                                                self.remote_adjacency_flag.value_namespace = name_space
                                                self.remote_adjacency_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "switch-compontent-id"):
                                                self.switch_compontent_id = value
                                                self.switch_compontent_id.value_namespace = name_space
                                                self.switch_compontent_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "traffic-index-for-packets"):
                                                self.traffic_index_for_packets = value
                                                self.traffic_index_for_packets.value_namespace = name_space
                                                self.traffic_index_for_packets.value_namespace_prefix = name_space_prefix


                                    class FibEntryPath(Entity):
                                        """
                                        FIB entry path details
                                        
                                        .. attribute:: fib_sh_tbl_path
                                        
                                        	fib sh tbl path
                                        	**type**\: list of    :py:class:`FibShTblPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath>`
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath, self).__init__()

                                            self.yang_name = "fib-entry-path"
                                            self.yang_parent_name = "ip-prefix-brief"

                                            self.fib_sh_tbl_path = YList(self)

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in () and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath, self).__setattr__(name, value)


                                        class FibShTblPath(Entity):
                                            """
                                            fib sh tbl path
                                            
                                            .. attribute:: attached_path
                                            
                                            	Attached path
                                            	**type**\:  bool
                                            
                                            .. attribute:: backup_index
                                            
                                            	Backup path index
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            .. attribute:: backup_path
                                            
                                            	Backup path
                                            	**type**\:  bool
                                            
                                            .. attribute:: best_external_path
                                            
                                            	Best external path
                                            	**type**\:  bool
                                            
                                            .. attribute:: brief_interface_handle
                                            
                                            	Interface handle
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: brief_lfa_protection_type
                                            
                                            	LFA protection type
                                            	**type**\:   :py:class:`FibUpdatePathLfaProtection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibUpdatePathLfaProtection>`
                                            
                                            .. attribute:: brief_next_hop_prefix
                                            
                                            	Next hop prefix
                                            	**type**\:  str
                                            
                                            	**length:** 0..52
                                            
                                            .. attribute:: brief_pnode_address
                                            
                                            	P\-node address
                                            	**type**\:  str
                                            
                                            	**length:** 0..52
                                            
                                            .. attribute:: brief_qnode_address
                                            
                                            	Q\-node address
                                            	**type**\:  str
                                            
                                            	**length:** 0..52
                                            
                                            .. attribute:: hardware_information
                                            
                                            	Hardware info
                                            	**type**\:  str
                                            
                                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                            
                                            .. attribute:: more_detail_about_path
                                            
                                            	More detail about this path entry
                                            	**type**\:   :py:class:`MoreDetailAboutPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath>`
                                            
                                            .. attribute:: mpls_information_for_path
                                            
                                            	mpls info for this path entry
                                            	**type**\:   :py:class:`MplsInformationForPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath>`
                                            
                                            .. attribute:: next_hop_index
                                            
                                            	Next Hop Index
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: packets_received_path
                                            
                                            	Packets received on this path
                                            	**type**\:  bool
                                            
                                            .. attribute:: parent_interface_handle
                                            
                                            	Parent Interface Handle
                                            	**type**\:  str
                                            
                                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                            
                                            .. attribute:: path_dlb
                                            
                                            	Is this the path used for DLB
                                            	**type**\:  bool
                                            
                                            .. attribute:: path_flags
                                            
                                            	Path flags
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: path_index
                                            
                                            	Path index
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            .. attribute:: path_info_flags
                                            
                                            	Path Info flags
                                            	**type**\:  int
                                            
                                            	**range:** 0..65535
                                            
                                            .. attribute:: protect_ignore
                                            
                                            	Is protection ignored
                                            	**type**\:  bool
                                            
                                            .. attribute:: recursionvia_len
                                            
                                            	recursion via /N constraint
                                            	**type**\:  int
                                            
                                            	**range:** 0..255
                                            
                                            .. attribute:: recursive_path
                                            
                                            	Recursive path
                                            	**type**\:  bool
                                            
                                            .. attribute:: resolved_path
                                            
                                            	Resolved path
                                            	**type**\:  bool
                                            
                                            .. attribute:: via_label_to_recurse
                                            
                                            	Local label to recurse over
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath, self).__init__()

                                                self.yang_name = "fib-sh-tbl-path"
                                                self.yang_parent_name = "fib-entry-path"

                                                self.attached_path = YLeaf(YType.boolean, "attached-path")

                                                self.backup_index = YLeaf(YType.uint8, "backup-index")

                                                self.backup_path = YLeaf(YType.boolean, "backup-path")

                                                self.best_external_path = YLeaf(YType.boolean, "best-external-path")

                                                self.brief_interface_handle = YLeaf(YType.str, "brief-interface-handle")

                                                self.brief_lfa_protection_type = YLeaf(YType.enumeration, "brief-lfa-protection-type")

                                                self.brief_next_hop_prefix = YLeaf(YType.str, "brief-next-hop-prefix")

                                                self.brief_pnode_address = YLeaf(YType.str, "brief-pnode-address")

                                                self.brief_qnode_address = YLeaf(YType.str, "brief-qnode-address")

                                                self.hardware_information = YLeaf(YType.str, "hardware-information")

                                                self.next_hop_index = YLeaf(YType.uint32, "next-hop-index")

                                                self.packets_received_path = YLeaf(YType.boolean, "packets-received-path")

                                                self.parent_interface_handle = YLeaf(YType.str, "parent-interface-handle")

                                                self.path_dlb = YLeaf(YType.boolean, "path-dlb")

                                                self.path_flags = YLeaf(YType.uint32, "path-flags")

                                                self.path_index = YLeaf(YType.uint8, "path-index")

                                                self.path_info_flags = YLeaf(YType.uint16, "path-info-flags")

                                                self.protect_ignore = YLeaf(YType.boolean, "protect-ignore")

                                                self.recursionvia_len = YLeaf(YType.uint8, "recursionvia-len")

                                                self.recursive_path = YLeaf(YType.boolean, "recursive-path")

                                                self.resolved_path = YLeaf(YType.boolean, "resolved-path")

                                                self.via_label_to_recurse = YLeaf(YType.uint32, "via-label-to-recurse")

                                                self.more_detail_about_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath()
                                                self.more_detail_about_path.parent = self
                                                self._children_name_map["more_detail_about_path"] = "more-detail-about-path"
                                                self._children_yang_names.add("more-detail-about-path")

                                                self.mpls_information_for_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath()
                                                self.mpls_information_for_path.parent = self
                                                self._children_name_map["mpls_information_for_path"] = "mpls-information-for-path"
                                                self._children_yang_names.add("mpls-information-for-path")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("attached_path",
                                                                "backup_index",
                                                                "backup_path",
                                                                "best_external_path",
                                                                "brief_interface_handle",
                                                                "brief_lfa_protection_type",
                                                                "brief_next_hop_prefix",
                                                                "brief_pnode_address",
                                                                "brief_qnode_address",
                                                                "hardware_information",
                                                                "next_hop_index",
                                                                "packets_received_path",
                                                                "parent_interface_handle",
                                                                "path_dlb",
                                                                "path_flags",
                                                                "path_index",
                                                                "path_info_flags",
                                                                "protect_ignore",
                                                                "recursionvia_len",
                                                                "recursive_path",
                                                                "resolved_path",
                                                                "via_label_to_recurse") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath, self).__setattr__(name, value)


                                            class MoreDetailAboutPath(Entity):
                                                """
                                                More detail about this path entry
                                                
                                                .. attribute:: current_path_flag
                                                
                                                	Current path flag
                                                	**type**\:  bool
                                                
                                                .. attribute:: detail_fib_adjacency_type
                                                
                                                	FIB entry adjacency type
                                                	**type**\:   :py:class:`FibAdjacencyShow <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibAdjacencyShow>`
                                                
                                                .. attribute:: detail_next_hop_prefix
                                                
                                                	Next hop prefix
                                                	**type**\:  str
                                                
                                                	**length:** 0..52
                                                
                                                .. attribute:: external_adjacency
                                                
                                                	Path is an external adjacency
                                                	**type**\:  bool
                                                
                                                .. attribute:: fib_path_nh_information_type
                                                
                                                	FIB Nhinfo type
                                                	**type**\:   :py:class:`FibNeh <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibNeh>`
                                                
                                                .. attribute:: fib_path_nh_information_type_special
                                                
                                                	FIB Nhinfo type special
                                                	**type**\:   :py:class:`FibNehSpecial <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibNehSpecial>`
                                                
                                                .. attribute:: interface_associated_path
                                                
                                                	Interface associated with this path
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                .. attribute:: ip_address_to_recurse
                                                
                                                	IP address to recurse to
                                                	**type**\:  str
                                                
                                                	**length:** 0..52
                                                
                                                .. attribute:: label_to_recurse
                                                
                                                	Local label to recurse over
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: lisprlocid
                                                
                                                	LISP RLOC ID
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: next_hop_interface
                                                
                                                	Next hop interface
                                                	**type**\:  str
                                                
                                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                
                                                .. attribute:: next_hop_mask_length
                                                
                                                	Next hop mask length
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: next_hop_vrf
                                                
                                                	Next hop VRF
                                                	**type**\:  str
                                                
                                                	**length:** 0..33
                                                
                                                .. attribute:: next_prefix_length
                                                
                                                	Next prefix length
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: next_prefix_length2
                                                
                                                	Next prefix2 length
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: next_prefix_recursion
                                                
                                                	Next prefix recursion in the path
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: next_prefix_recursion2
                                                
                                                	Next prefix2 recursion in the path
                                                	**type**\:  str
                                                
                                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                
                                                .. attribute:: number_of_dependencies_this_path
                                                
                                                	No. of dependents for this path
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: recurse_prefix_object
                                                
                                                	Is recursion object a leaf?
                                                	**type**\:  bool
                                                
                                                .. attribute:: recurse_prefix_object2
                                                
                                                	Recursion has two leaves (e.g. implicit\-null path)
                                                	**type**\:  bool
                                                
                                                .. attribute:: recursive_path_information
                                                
                                                	Recursive path information is available
                                                	**type**\:  bool
                                                
                                                .. attribute:: robin_reset_value
                                                
                                                	Round robin reset value
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: spd_ipencap
                                                
                                                	IP Encap
                                                	**type**\: list of    :py:class:`SpdIpencap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap>`
                                                
                                                .. attribute:: tunnel_class
                                                
                                                	Tunnel class of the path
                                                	**type**\:  int
                                                
                                                	**range:** 0..255
                                                
                                                .. attribute:: tunnel_is_forward_class
                                                
                                                	Tunnel is forward class
                                                	**type**\:  bool
                                                
                                                .. attribute:: tunnle_endpoint_id
                                                
                                                	Tunnel endpoint id
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: weight_of_path
                                                
                                                	Weight of the path
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                

                                                """

                                                _prefix = 'fib-common-oper'
                                                _revision = '2017-01-20'

                                                def __init__(self):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath, self).__init__()

                                                    self.yang_name = "more-detail-about-path"
                                                    self.yang_parent_name = "fib-sh-tbl-path"

                                                    self.current_path_flag = YLeaf(YType.boolean, "current-path-flag")

                                                    self.detail_fib_adjacency_type = YLeaf(YType.enumeration, "detail-fib-adjacency-type")

                                                    self.detail_next_hop_prefix = YLeaf(YType.str, "detail-next-hop-prefix")

                                                    self.external_adjacency = YLeaf(YType.boolean, "external-adjacency")

                                                    self.fib_path_nh_information_type = YLeaf(YType.enumeration, "fib-path-nh-information-type")

                                                    self.fib_path_nh_information_type_special = YLeaf(YType.enumeration, "fib-path-nh-information-type-special")

                                                    self.interface_associated_path = YLeaf(YType.str, "interface-associated-path")

                                                    self.ip_address_to_recurse = YLeaf(YType.str, "ip-address-to-recurse")

                                                    self.label_to_recurse = YLeaf(YType.uint32, "label-to-recurse")

                                                    self.lisprlocid = YLeaf(YType.uint32, "lisprlocid")

                                                    self.next_hop_interface = YLeaf(YType.str, "next-hop-interface")

                                                    self.next_hop_mask_length = YLeaf(YType.uint8, "next-hop-mask-length")

                                                    self.next_hop_vrf = YLeaf(YType.str, "next-hop-vrf")

                                                    self.next_prefix_length = YLeaf(YType.uint8, "next-prefix-length")

                                                    self.next_prefix_length2 = YLeaf(YType.uint8, "next-prefix-length2")

                                                    self.next_prefix_recursion = YLeaf(YType.str, "next-prefix-recursion")

                                                    self.next_prefix_recursion2 = YLeaf(YType.str, "next-prefix-recursion2")

                                                    self.number_of_dependencies_this_path = YLeaf(YType.uint32, "number-of-dependencies-this-path")

                                                    self.recurse_prefix_object = YLeaf(YType.boolean, "recurse-prefix-object")

                                                    self.recurse_prefix_object2 = YLeaf(YType.boolean, "recurse-prefix-object2")

                                                    self.recursive_path_information = YLeaf(YType.boolean, "recursive-path-information")

                                                    self.robin_reset_value = YLeaf(YType.uint8, "robin-reset-value")

                                                    self.tunnel_class = YLeaf(YType.uint8, "tunnel-class")

                                                    self.tunnel_is_forward_class = YLeaf(YType.boolean, "tunnel-is-forward-class")

                                                    self.tunnle_endpoint_id = YLeaf(YType.uint32, "tunnle-endpoint-id")

                                                    self.weight_of_path = YLeaf(YType.uint32, "weight-of-path")

                                                    self.spd_ipencap = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("current_path_flag",
                                                                    "detail_fib_adjacency_type",
                                                                    "detail_next_hop_prefix",
                                                                    "external_adjacency",
                                                                    "fib_path_nh_information_type",
                                                                    "fib_path_nh_information_type_special",
                                                                    "interface_associated_path",
                                                                    "ip_address_to_recurse",
                                                                    "label_to_recurse",
                                                                    "lisprlocid",
                                                                    "next_hop_interface",
                                                                    "next_hop_mask_length",
                                                                    "next_hop_vrf",
                                                                    "next_prefix_length",
                                                                    "next_prefix_length2",
                                                                    "next_prefix_recursion",
                                                                    "next_prefix_recursion2",
                                                                    "number_of_dependencies_this_path",
                                                                    "recurse_prefix_object",
                                                                    "recurse_prefix_object2",
                                                                    "recursive_path_information",
                                                                    "robin_reset_value",
                                                                    "tunnel_class",
                                                                    "tunnel_is_forward_class",
                                                                    "tunnle_endpoint_id",
                                                                    "weight_of_path") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath, self).__setattr__(name, value)


                                                class SpdIpencap(Entity):
                                                    """
                                                    IP Encap
                                                    
                                                    .. attribute:: ip_encap_hdr
                                                    
                                                    	Headers
                                                    	**type**\: list of    :py:class:`IpEncapHdr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr>`
                                                    
                                                    .. attribute:: ip_encap_hdr_count
                                                    
                                                    	Header Count
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..255
                                                    
                                                    .. attribute:: ip_encap_locks
                                                    
                                                    	IPEncap Object Locks
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_parent
                                                    
                                                    	Pointer to parent
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_parent_type
                                                    
                                                    	Parent type enumeration
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_payload_af
                                                    
                                                    	Payload AF
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_payload_mtu
                                                    
                                                    	Payload MTU
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..65535
                                                    
                                                    .. attribute:: ip_encap_transport_af
                                                    
                                                    	Transport AF
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ip_encap_transport_tbl
                                                    
                                                    	Transport Table
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: ipe_transport_vrf_name
                                                    
                                                    	Transport VRF name
                                                    	**type**\:  str
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap, self).__init__()

                                                        self.yang_name = "spd-ipencap"
                                                        self.yang_parent_name = "more-detail-about-path"

                                                        self.ip_encap_hdr_count = YLeaf(YType.uint8, "ip-encap-hdr-count")

                                                        self.ip_encap_locks = YLeaf(YType.uint32, "ip-encap-locks")

                                                        self.ip_encap_parent = YLeaf(YType.uint32, "ip-encap-parent")

                                                        self.ip_encap_parent_type = YLeaf(YType.uint32, "ip-encap-parent-type")

                                                        self.ip_encap_payload_af = YLeaf(YType.uint32, "ip-encap-payload-af")

                                                        self.ip_encap_payload_mtu = YLeaf(YType.uint16, "ip-encap-payload-mtu")

                                                        self.ip_encap_transport_af = YLeaf(YType.uint32, "ip-encap-transport-af")

                                                        self.ip_encap_transport_tbl = YLeaf(YType.uint32, "ip-encap-transport-tbl")

                                                        self.ipe_transport_vrf_name = YLeaf(YType.str, "ipe-transport-vrf-name")

                                                        self.ip_encap_hdr = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("ip_encap_hdr_count",
                                                                        "ip_encap_locks",
                                                                        "ip_encap_parent",
                                                                        "ip_encap_parent_type",
                                                                        "ip_encap_payload_af",
                                                                        "ip_encap_payload_mtu",
                                                                        "ip_encap_transport_af",
                                                                        "ip_encap_transport_tbl",
                                                                        "ipe_transport_vrf_name") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap, self).__setattr__(name, value)


                                                    class IpEncapHdr(Entity):
                                                        """
                                                        Headers
                                                        
                                                        .. attribute:: ip_encap_hdr_dyn
                                                        
                                                        	Dynamic Header Fields
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        .. attribute:: ip_encap_hdr_type
                                                        
                                                        	Header Type
                                                        	**type**\:   :py:class:`FibShIpencapHdr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibShIpencapHdr>`
                                                        
                                                        .. attribute:: ip_encap_hdrp
                                                        
                                                        	Static Header
                                                        	**type**\:  str
                                                        
                                                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                                        
                                                        

                                                        """

                                                        _prefix = 'fib-common-oper'
                                                        _revision = '2017-01-20'

                                                        def __init__(self):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr, self).__init__()

                                                            self.yang_name = "ip-encap-hdr"
                                                            self.yang_parent_name = "spd-ipencap"

                                                            self.ip_encap_hdr_dyn = YLeaf(YType.uint32, "ip-encap-hdr-dyn")

                                                            self.ip_encap_hdr_type = YLeaf(YType.enumeration, "ip-encap-hdr-type")

                                                            self.ip_encap_hdrp = YLeaf(YType.str, "ip-encap-hdrp")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("ip_encap_hdr_dyn",
                                                                            "ip_encap_hdr_type",
                                                                            "ip_encap_hdrp") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return (
                                                                self.ip_encap_hdr_dyn.is_set or
                                                                self.ip_encap_hdr_type.is_set or
                                                                self.ip_encap_hdrp.is_set)

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.ip_encap_hdr_dyn.yfilter != YFilter.not_set or
                                                                self.ip_encap_hdr_type.yfilter != YFilter.not_set or
                                                                self.ip_encap_hdrp.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "ip-encap-hdr" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.ip_encap_hdr_dyn.is_set or self.ip_encap_hdr_dyn.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.ip_encap_hdr_dyn.get_name_leafdata())
                                                            if (self.ip_encap_hdr_type.is_set or self.ip_encap_hdr_type.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.ip_encap_hdr_type.get_name_leafdata())
                                                            if (self.ip_encap_hdrp.is_set or self.ip_encap_hdrp.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.ip_encap_hdrp.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "ip-encap-hdr-dyn" or name == "ip-encap-hdr-type" or name == "ip-encap-hdrp"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "ip-encap-hdr-dyn"):
                                                                self.ip_encap_hdr_dyn = value
                                                                self.ip_encap_hdr_dyn.value_namespace = name_space
                                                                self.ip_encap_hdr_dyn.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "ip-encap-hdr-type"):
                                                                self.ip_encap_hdr_type = value
                                                                self.ip_encap_hdr_type.value_namespace = name_space
                                                                self.ip_encap_hdr_type.value_namespace_prefix = name_space_prefix
                                                            if(value_path == "ip-encap-hdrp"):
                                                                self.ip_encap_hdrp = value
                                                                self.ip_encap_hdrp.value_namespace = name_space
                                                                self.ip_encap_hdrp.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.ip_encap_hdr:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            self.ip_encap_hdr_count.is_set or
                                                            self.ip_encap_locks.is_set or
                                                            self.ip_encap_parent.is_set or
                                                            self.ip_encap_parent_type.is_set or
                                                            self.ip_encap_payload_af.is_set or
                                                            self.ip_encap_payload_mtu.is_set or
                                                            self.ip_encap_transport_af.is_set or
                                                            self.ip_encap_transport_tbl.is_set or
                                                            self.ipe_transport_vrf_name.is_set)

                                                    def has_operation(self):
                                                        for c in self.ip_encap_hdr:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.ip_encap_hdr_count.yfilter != YFilter.not_set or
                                                            self.ip_encap_locks.yfilter != YFilter.not_set or
                                                            self.ip_encap_parent.yfilter != YFilter.not_set or
                                                            self.ip_encap_parent_type.yfilter != YFilter.not_set or
                                                            self.ip_encap_payload_af.yfilter != YFilter.not_set or
                                                            self.ip_encap_payload_mtu.yfilter != YFilter.not_set or
                                                            self.ip_encap_transport_af.yfilter != YFilter.not_set or
                                                            self.ip_encap_transport_tbl.yfilter != YFilter.not_set or
                                                            self.ipe_transport_vrf_name.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "spd-ipencap" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.ip_encap_hdr_count.is_set or self.ip_encap_hdr_count.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_hdr_count.get_name_leafdata())
                                                        if (self.ip_encap_locks.is_set or self.ip_encap_locks.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_locks.get_name_leafdata())
                                                        if (self.ip_encap_parent.is_set or self.ip_encap_parent.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_parent.get_name_leafdata())
                                                        if (self.ip_encap_parent_type.is_set or self.ip_encap_parent_type.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_parent_type.get_name_leafdata())
                                                        if (self.ip_encap_payload_af.is_set or self.ip_encap_payload_af.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_payload_af.get_name_leafdata())
                                                        if (self.ip_encap_payload_mtu.is_set or self.ip_encap_payload_mtu.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_payload_mtu.get_name_leafdata())
                                                        if (self.ip_encap_transport_af.is_set or self.ip_encap_transport_af.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_transport_af.get_name_leafdata())
                                                        if (self.ip_encap_transport_tbl.is_set or self.ip_encap_transport_tbl.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ip_encap_transport_tbl.get_name_leafdata())
                                                        if (self.ipe_transport_vrf_name.is_set or self.ipe_transport_vrf_name.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.ipe_transport_vrf_name.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "ip-encap-hdr"):
                                                            for c in self.ip_encap_hdr:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap.IpEncapHdr()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.ip_encap_hdr.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "ip-encap-hdr" or name == "ip-encap-hdr-count" or name == "ip-encap-locks" or name == "ip-encap-parent" or name == "ip-encap-parent-type" or name == "ip-encap-payload-af" or name == "ip-encap-payload-mtu" or name == "ip-encap-transport-af" or name == "ip-encap-transport-tbl" or name == "ipe-transport-vrf-name"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "ip-encap-hdr-count"):
                                                            self.ip_encap_hdr_count = value
                                                            self.ip_encap_hdr_count.value_namespace = name_space
                                                            self.ip_encap_hdr_count.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-locks"):
                                                            self.ip_encap_locks = value
                                                            self.ip_encap_locks.value_namespace = name_space
                                                            self.ip_encap_locks.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-parent"):
                                                            self.ip_encap_parent = value
                                                            self.ip_encap_parent.value_namespace = name_space
                                                            self.ip_encap_parent.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-parent-type"):
                                                            self.ip_encap_parent_type = value
                                                            self.ip_encap_parent_type.value_namespace = name_space
                                                            self.ip_encap_parent_type.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-payload-af"):
                                                            self.ip_encap_payload_af = value
                                                            self.ip_encap_payload_af.value_namespace = name_space
                                                            self.ip_encap_payload_af.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-payload-mtu"):
                                                            self.ip_encap_payload_mtu = value
                                                            self.ip_encap_payload_mtu.value_namespace = name_space
                                                            self.ip_encap_payload_mtu.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-transport-af"):
                                                            self.ip_encap_transport_af = value
                                                            self.ip_encap_transport_af.value_namespace = name_space
                                                            self.ip_encap_transport_af.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ip-encap-transport-tbl"):
                                                            self.ip_encap_transport_tbl = value
                                                            self.ip_encap_transport_tbl.value_namespace = name_space
                                                            self.ip_encap_transport_tbl.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "ipe-transport-vrf-name"):
                                                            self.ipe_transport_vrf_name = value
                                                            self.ipe_transport_vrf_name.value_namespace = name_space
                                                            self.ipe_transport_vrf_name.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.spd_ipencap:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.current_path_flag.is_set or
                                                        self.detail_fib_adjacency_type.is_set or
                                                        self.detail_next_hop_prefix.is_set or
                                                        self.external_adjacency.is_set or
                                                        self.fib_path_nh_information_type.is_set or
                                                        self.fib_path_nh_information_type_special.is_set or
                                                        self.interface_associated_path.is_set or
                                                        self.ip_address_to_recurse.is_set or
                                                        self.label_to_recurse.is_set or
                                                        self.lisprlocid.is_set or
                                                        self.next_hop_interface.is_set or
                                                        self.next_hop_mask_length.is_set or
                                                        self.next_hop_vrf.is_set or
                                                        self.next_prefix_length.is_set or
                                                        self.next_prefix_length2.is_set or
                                                        self.next_prefix_recursion.is_set or
                                                        self.next_prefix_recursion2.is_set or
                                                        self.number_of_dependencies_this_path.is_set or
                                                        self.recurse_prefix_object.is_set or
                                                        self.recurse_prefix_object2.is_set or
                                                        self.recursive_path_information.is_set or
                                                        self.robin_reset_value.is_set or
                                                        self.tunnel_class.is_set or
                                                        self.tunnel_is_forward_class.is_set or
                                                        self.tunnle_endpoint_id.is_set or
                                                        self.weight_of_path.is_set)

                                                def has_operation(self):
                                                    for c in self.spd_ipencap:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.current_path_flag.yfilter != YFilter.not_set or
                                                        self.detail_fib_adjacency_type.yfilter != YFilter.not_set or
                                                        self.detail_next_hop_prefix.yfilter != YFilter.not_set or
                                                        self.external_adjacency.yfilter != YFilter.not_set or
                                                        self.fib_path_nh_information_type.yfilter != YFilter.not_set or
                                                        self.fib_path_nh_information_type_special.yfilter != YFilter.not_set or
                                                        self.interface_associated_path.yfilter != YFilter.not_set or
                                                        self.ip_address_to_recurse.yfilter != YFilter.not_set or
                                                        self.label_to_recurse.yfilter != YFilter.not_set or
                                                        self.lisprlocid.yfilter != YFilter.not_set or
                                                        self.next_hop_interface.yfilter != YFilter.not_set or
                                                        self.next_hop_mask_length.yfilter != YFilter.not_set or
                                                        self.next_hop_vrf.yfilter != YFilter.not_set or
                                                        self.next_prefix_length.yfilter != YFilter.not_set or
                                                        self.next_prefix_length2.yfilter != YFilter.not_set or
                                                        self.next_prefix_recursion.yfilter != YFilter.not_set or
                                                        self.next_prefix_recursion2.yfilter != YFilter.not_set or
                                                        self.number_of_dependencies_this_path.yfilter != YFilter.not_set or
                                                        self.recurse_prefix_object.yfilter != YFilter.not_set or
                                                        self.recurse_prefix_object2.yfilter != YFilter.not_set or
                                                        self.recursive_path_information.yfilter != YFilter.not_set or
                                                        self.robin_reset_value.yfilter != YFilter.not_set or
                                                        self.tunnel_class.yfilter != YFilter.not_set or
                                                        self.tunnel_is_forward_class.yfilter != YFilter.not_set or
                                                        self.tunnle_endpoint_id.yfilter != YFilter.not_set or
                                                        self.weight_of_path.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "more-detail-about-path" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.current_path_flag.is_set or self.current_path_flag.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.current_path_flag.get_name_leafdata())
                                                    if (self.detail_fib_adjacency_type.is_set or self.detail_fib_adjacency_type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.detail_fib_adjacency_type.get_name_leafdata())
                                                    if (self.detail_next_hop_prefix.is_set or self.detail_next_hop_prefix.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.detail_next_hop_prefix.get_name_leafdata())
                                                    if (self.external_adjacency.is_set or self.external_adjacency.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.external_adjacency.get_name_leafdata())
                                                    if (self.fib_path_nh_information_type.is_set or self.fib_path_nh_information_type.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.fib_path_nh_information_type.get_name_leafdata())
                                                    if (self.fib_path_nh_information_type_special.is_set or self.fib_path_nh_information_type_special.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.fib_path_nh_information_type_special.get_name_leafdata())
                                                    if (self.interface_associated_path.is_set or self.interface_associated_path.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.interface_associated_path.get_name_leafdata())
                                                    if (self.ip_address_to_recurse.is_set or self.ip_address_to_recurse.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.ip_address_to_recurse.get_name_leafdata())
                                                    if (self.label_to_recurse.is_set or self.label_to_recurse.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.label_to_recurse.get_name_leafdata())
                                                    if (self.lisprlocid.is_set or self.lisprlocid.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.lisprlocid.get_name_leafdata())
                                                    if (self.next_hop_interface.is_set or self.next_hop_interface.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_hop_interface.get_name_leafdata())
                                                    if (self.next_hop_mask_length.is_set or self.next_hop_mask_length.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_hop_mask_length.get_name_leafdata())
                                                    if (self.next_hop_vrf.is_set or self.next_hop_vrf.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_hop_vrf.get_name_leafdata())
                                                    if (self.next_prefix_length.is_set or self.next_prefix_length.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_prefix_length.get_name_leafdata())
                                                    if (self.next_prefix_length2.is_set or self.next_prefix_length2.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_prefix_length2.get_name_leafdata())
                                                    if (self.next_prefix_recursion.is_set or self.next_prefix_recursion.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_prefix_recursion.get_name_leafdata())
                                                    if (self.next_prefix_recursion2.is_set or self.next_prefix_recursion2.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.next_prefix_recursion2.get_name_leafdata())
                                                    if (self.number_of_dependencies_this_path.is_set or self.number_of_dependencies_this_path.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.number_of_dependencies_this_path.get_name_leafdata())
                                                    if (self.recurse_prefix_object.is_set or self.recurse_prefix_object.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recurse_prefix_object.get_name_leafdata())
                                                    if (self.recurse_prefix_object2.is_set or self.recurse_prefix_object2.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recurse_prefix_object2.get_name_leafdata())
                                                    if (self.recursive_path_information.is_set or self.recursive_path_information.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recursive_path_information.get_name_leafdata())
                                                    if (self.robin_reset_value.is_set or self.robin_reset_value.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.robin_reset_value.get_name_leafdata())
                                                    if (self.tunnel_class.is_set or self.tunnel_class.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.tunnel_class.get_name_leafdata())
                                                    if (self.tunnel_is_forward_class.is_set or self.tunnel_is_forward_class.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.tunnel_is_forward_class.get_name_leafdata())
                                                    if (self.tunnle_endpoint_id.is_set or self.tunnle_endpoint_id.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.tunnle_endpoint_id.get_name_leafdata())
                                                    if (self.weight_of_path.is_set or self.weight_of_path.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.weight_of_path.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "spd-ipencap"):
                                                        for c in self.spd_ipencap:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath.SpdIpencap()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.spd_ipencap.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "spd-ipencap" or name == "current-path-flag" or name == "detail-fib-adjacency-type" or name == "detail-next-hop-prefix" or name == "external-adjacency" or name == "fib-path-nh-information-type" or name == "fib-path-nh-information-type-special" or name == "interface-associated-path" or name == "ip-address-to-recurse" or name == "label-to-recurse" or name == "lisprlocid" or name == "next-hop-interface" or name == "next-hop-mask-length" or name == "next-hop-vrf" or name == "next-prefix-length" or name == "next-prefix-length2" or name == "next-prefix-recursion" or name == "next-prefix-recursion2" or name == "number-of-dependencies-this-path" or name == "recurse-prefix-object" or name == "recurse-prefix-object2" or name == "recursive-path-information" or name == "robin-reset-value" or name == "tunnel-class" or name == "tunnel-is-forward-class" or name == "tunnle-endpoint-id" or name == "weight-of-path"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "current-path-flag"):
                                                        self.current_path_flag = value
                                                        self.current_path_flag.value_namespace = name_space
                                                        self.current_path_flag.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "detail-fib-adjacency-type"):
                                                        self.detail_fib_adjacency_type = value
                                                        self.detail_fib_adjacency_type.value_namespace = name_space
                                                        self.detail_fib_adjacency_type.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "detail-next-hop-prefix"):
                                                        self.detail_next_hop_prefix = value
                                                        self.detail_next_hop_prefix.value_namespace = name_space
                                                        self.detail_next_hop_prefix.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "external-adjacency"):
                                                        self.external_adjacency = value
                                                        self.external_adjacency.value_namespace = name_space
                                                        self.external_adjacency.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "fib-path-nh-information-type"):
                                                        self.fib_path_nh_information_type = value
                                                        self.fib_path_nh_information_type.value_namespace = name_space
                                                        self.fib_path_nh_information_type.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "fib-path-nh-information-type-special"):
                                                        self.fib_path_nh_information_type_special = value
                                                        self.fib_path_nh_information_type_special.value_namespace = name_space
                                                        self.fib_path_nh_information_type_special.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "interface-associated-path"):
                                                        self.interface_associated_path = value
                                                        self.interface_associated_path.value_namespace = name_space
                                                        self.interface_associated_path.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "ip-address-to-recurse"):
                                                        self.ip_address_to_recurse = value
                                                        self.ip_address_to_recurse.value_namespace = name_space
                                                        self.ip_address_to_recurse.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "label-to-recurse"):
                                                        self.label_to_recurse = value
                                                        self.label_to_recurse.value_namespace = name_space
                                                        self.label_to_recurse.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "lisprlocid"):
                                                        self.lisprlocid = value
                                                        self.lisprlocid.value_namespace = name_space
                                                        self.lisprlocid.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-hop-interface"):
                                                        self.next_hop_interface = value
                                                        self.next_hop_interface.value_namespace = name_space
                                                        self.next_hop_interface.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-hop-mask-length"):
                                                        self.next_hop_mask_length = value
                                                        self.next_hop_mask_length.value_namespace = name_space
                                                        self.next_hop_mask_length.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-hop-vrf"):
                                                        self.next_hop_vrf = value
                                                        self.next_hop_vrf.value_namespace = name_space
                                                        self.next_hop_vrf.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-prefix-length"):
                                                        self.next_prefix_length = value
                                                        self.next_prefix_length.value_namespace = name_space
                                                        self.next_prefix_length.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-prefix-length2"):
                                                        self.next_prefix_length2 = value
                                                        self.next_prefix_length2.value_namespace = name_space
                                                        self.next_prefix_length2.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-prefix-recursion"):
                                                        self.next_prefix_recursion = value
                                                        self.next_prefix_recursion.value_namespace = name_space
                                                        self.next_prefix_recursion.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "next-prefix-recursion2"):
                                                        self.next_prefix_recursion2 = value
                                                        self.next_prefix_recursion2.value_namespace = name_space
                                                        self.next_prefix_recursion2.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "number-of-dependencies-this-path"):
                                                        self.number_of_dependencies_this_path = value
                                                        self.number_of_dependencies_this_path.value_namespace = name_space
                                                        self.number_of_dependencies_this_path.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recurse-prefix-object"):
                                                        self.recurse_prefix_object = value
                                                        self.recurse_prefix_object.value_namespace = name_space
                                                        self.recurse_prefix_object.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recurse-prefix-object2"):
                                                        self.recurse_prefix_object2 = value
                                                        self.recurse_prefix_object2.value_namespace = name_space
                                                        self.recurse_prefix_object2.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recursive-path-information"):
                                                        self.recursive_path_information = value
                                                        self.recursive_path_information.value_namespace = name_space
                                                        self.recursive_path_information.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "robin-reset-value"):
                                                        self.robin_reset_value = value
                                                        self.robin_reset_value.value_namespace = name_space
                                                        self.robin_reset_value.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "tunnel-class"):
                                                        self.tunnel_class = value
                                                        self.tunnel_class.value_namespace = name_space
                                                        self.tunnel_class.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "tunnel-is-forward-class"):
                                                        self.tunnel_is_forward_class = value
                                                        self.tunnel_is_forward_class.value_namespace = name_space
                                                        self.tunnel_is_forward_class.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "tunnle-endpoint-id"):
                                                        self.tunnle_endpoint_id = value
                                                        self.tunnle_endpoint_id.value_namespace = name_space
                                                        self.tunnle_endpoint_id.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "weight-of-path"):
                                                        self.weight_of_path = value
                                                        self.weight_of_path.value_namespace = name_space
                                                        self.weight_of_path.value_namespace_prefix = name_space_prefix


                                            class MplsInformationForPath(Entity):
                                                """
                                                mpls info for this path entry
                                                
                                                .. attribute:: igp_label_stack_array
                                                
                                                	igp label stack array
                                                	**type**\: list of    :py:class:`IgpLabelStackArray <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray>`
                                                
                                                .. attribute:: local_lable
                                                
                                                	LocalLable
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: number_of_igp_paths
                                                
                                                	NumberOfIGPPaths
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: recursive_fwd_chain
                                                
                                                	RecursiveFwdChain
                                                	**type**\:  bool
                                                
                                                .. attribute:: recursive_out_label_valid
                                                
                                                	RecursiveOutLabelValid
                                                	**type**\:  bool
                                                
                                                .. attribute:: recursive_out_lable
                                                
                                                	RecursiveOutLable
                                                	**type**\:  int
                                                
                                                	**range:** 0..4294967295
                                                
                                                .. attribute:: remote_backup
                                                
                                                	RemoteBackupPath
                                                	**type**\:  bool
                                                
                                                

                                                """

                                                _prefix = 'fib-common-oper'
                                                _revision = '2017-01-20'

                                                def __init__(self):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath, self).__init__()

                                                    self.yang_name = "mpls-information-for-path"
                                                    self.yang_parent_name = "fib-sh-tbl-path"

                                                    self.local_lable = YLeaf(YType.uint32, "local-lable")

                                                    self.number_of_igp_paths = YLeaf(YType.uint32, "number-of-igp-paths")

                                                    self.recursive_fwd_chain = YLeaf(YType.boolean, "recursive-fwd-chain")

                                                    self.recursive_out_label_valid = YLeaf(YType.boolean, "recursive-out-label-valid")

                                                    self.recursive_out_lable = YLeaf(YType.uint32, "recursive-out-lable")

                                                    self.remote_backup = YLeaf(YType.boolean, "remote-backup")

                                                    self.igp_label_stack_array = YList(self)

                                                def __setattr__(self, name, value):
                                                    self._check_monkey_patching_error(name, value)
                                                    with _handle_type_error():
                                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                "Please use list append or extend method."
                                                                                .format(value))
                                                        if isinstance(value, Enum.YLeaf):
                                                            value = value.name
                                                        if name in ("local_lable",
                                                                    "number_of_igp_paths",
                                                                    "recursive_fwd_chain",
                                                                    "recursive_out_label_valid",
                                                                    "recursive_out_lable",
                                                                    "remote_backup") and name in self.__dict__:
                                                            if isinstance(value, YLeaf):
                                                                self.__dict__[name].set(value.get())
                                                            elif isinstance(value, YLeafList):
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath, self).__setattr__(name, value)
                                                            else:
                                                                self.__dict__[name].set(value)
                                                        else:
                                                            if hasattr(value, "parent") and name != "parent":
                                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                    value.parent = self
                                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                    value.parent = self
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath, self).__setattr__(name, value)


                                                class IgpLabelStackArray(Entity):
                                                    """
                                                    igp label stack array
                                                    
                                                    .. attribute:: lstack
                                                    
                                                    	lstack
                                                    	**type**\: list of    :py:class:`Lstack <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack>`
                                                    
                                                    .. attribute:: nh_address
                                                    
                                                    	NHAddress
                                                    	**type**\:  str
                                                    
                                                    	**length:** 0..52
                                                    
                                                    .. attribute:: number_of_labels
                                                    
                                                    	NumberOfLabels
                                                    	**type**\:  int
                                                    
                                                    	**range:** 0..4294967295
                                                    
                                                    .. attribute:: out_interface
                                                    
                                                    	OutInterface
                                                    	**type**\:  str
                                                    
                                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                                    
                                                    

                                                    """

                                                    _prefix = 'fib-common-oper'
                                                    _revision = '2017-01-20'

                                                    def __init__(self):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray, self).__init__()

                                                        self.yang_name = "igp-label-stack-array"
                                                        self.yang_parent_name = "mpls-information-for-path"

                                                        self.nh_address = YLeaf(YType.str, "nh-address")

                                                        self.number_of_labels = YLeaf(YType.uint32, "number-of-labels")

                                                        self.out_interface = YLeaf(YType.str, "out-interface")

                                                        self.lstack = YList(self)

                                                    def __setattr__(self, name, value):
                                                        self._check_monkey_patching_error(name, value)
                                                        with _handle_type_error():
                                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                    "Please use list append or extend method."
                                                                                    .format(value))
                                                            if isinstance(value, Enum.YLeaf):
                                                                value = value.name
                                                            if name in ("nh_address",
                                                                        "number_of_labels",
                                                                        "out_interface") and name in self.__dict__:
                                                                if isinstance(value, YLeaf):
                                                                    self.__dict__[name].set(value.get())
                                                                elif isinstance(value, YLeafList):
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray, self).__setattr__(name, value)
                                                                else:
                                                                    self.__dict__[name].set(value)
                                                            else:
                                                                if hasattr(value, "parent") and name != "parent":
                                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                        value.parent = self
                                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                        value.parent = self
                                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray, self).__setattr__(name, value)


                                                    class Lstack(Entity):
                                                        """
                                                        lstack
                                                        
                                                        .. attribute:: entry
                                                        
                                                        	
                                                        	**type**\:  int
                                                        
                                                        	**range:** 0..4294967295
                                                        
                                                        

                                                        """

                                                        _prefix = 'fib-common-oper'
                                                        _revision = '2017-01-20'

                                                        def __init__(self):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack, self).__init__()

                                                            self.yang_name = "lstack"
                                                            self.yang_parent_name = "igp-label-stack-array"

                                                            self.entry = YLeaf(YType.uint32, "entry")

                                                        def __setattr__(self, name, value):
                                                            self._check_monkey_patching_error(name, value)
                                                            with _handle_type_error():
                                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                                        "Please use list append or extend method."
                                                                                        .format(value))
                                                                if isinstance(value, Enum.YLeaf):
                                                                    value = value.name
                                                                if name in ("entry") and name in self.__dict__:
                                                                    if isinstance(value, YLeaf):
                                                                        self.__dict__[name].set(value.get())
                                                                    elif isinstance(value, YLeafList):
                                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack, self).__setattr__(name, value)
                                                                    else:
                                                                        self.__dict__[name].set(value)
                                                                else:
                                                                    if hasattr(value, "parent") and name != "parent":
                                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                            value.parent = self
                                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                            value.parent = self
                                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack, self).__setattr__(name, value)

                                                        def has_data(self):
                                                            return self.entry.is_set

                                                        def has_operation(self):
                                                            return (
                                                                self.yfilter != YFilter.not_set or
                                                                self.entry.yfilter != YFilter.not_set)

                                                        def get_segment_path(self):
                                                            path_buffer = ""
                                                            path_buffer = "lstack" + path_buffer

                                                            return path_buffer

                                                        def get_entity_path(self, ancestor):
                                                            path_buffer = ""
                                                            if (ancestor is None):
                                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                            else:
                                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                            leaf_name_data = LeafDataList()
                                                            if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                                leaf_name_data.append(self.entry.get_name_leafdata())

                                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                                            return entity_path

                                                        def get_child_by_name(self, child_yang_name, segment_path):
                                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                            if child is not None:
                                                                return child

                                                            return None

                                                        def has_leaf_or_child_of_name(self, name):
                                                            if(name == "entry"):
                                                                return True
                                                            return False

                                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                                            if(value_path == "entry"):
                                                                self.entry = value
                                                                self.entry.value_namespace = name_space
                                                                self.entry.value_namespace_prefix = name_space_prefix

                                                    def has_data(self):
                                                        for c in self.lstack:
                                                            if (c.has_data()):
                                                                return True
                                                        return (
                                                            self.nh_address.is_set or
                                                            self.number_of_labels.is_set or
                                                            self.out_interface.is_set)

                                                    def has_operation(self):
                                                        for c in self.lstack:
                                                            if (c.has_operation()):
                                                                return True
                                                        return (
                                                            self.yfilter != YFilter.not_set or
                                                            self.nh_address.yfilter != YFilter.not_set or
                                                            self.number_of_labels.yfilter != YFilter.not_set or
                                                            self.out_interface.yfilter != YFilter.not_set)

                                                    def get_segment_path(self):
                                                        path_buffer = ""
                                                        path_buffer = "igp-label-stack-array" + path_buffer

                                                        return path_buffer

                                                    def get_entity_path(self, ancestor):
                                                        path_buffer = ""
                                                        if (ancestor is None):
                                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                        else:
                                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                        leaf_name_data = LeafDataList()
                                                        if (self.nh_address.is_set or self.nh_address.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.nh_address.get_name_leafdata())
                                                        if (self.number_of_labels.is_set or self.number_of_labels.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.number_of_labels.get_name_leafdata())
                                                        if (self.out_interface.is_set or self.out_interface.yfilter != YFilter.not_set):
                                                            leaf_name_data.append(self.out_interface.get_name_leafdata())

                                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                                        return entity_path

                                                    def get_child_by_name(self, child_yang_name, segment_path):
                                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                        if child is not None:
                                                            return child

                                                        if (child_yang_name == "lstack"):
                                                            for c in self.lstack:
                                                                segment = c.get_segment_path()
                                                                if (segment_path == segment):
                                                                    return c
                                                            c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray.Lstack()
                                                            c.parent = self
                                                            local_reference_key = "ydk::seg::%s" % segment_path
                                                            self._local_refs[local_reference_key] = c
                                                            self.lstack.append(c)
                                                            return c

                                                        return None

                                                    def has_leaf_or_child_of_name(self, name):
                                                        if(name == "lstack" or name == "nh-address" or name == "number-of-labels" or name == "out-interface"):
                                                            return True
                                                        return False

                                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                                        if(value_path == "nh-address"):
                                                            self.nh_address = value
                                                            self.nh_address.value_namespace = name_space
                                                            self.nh_address.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "number-of-labels"):
                                                            self.number_of_labels = value
                                                            self.number_of_labels.value_namespace = name_space
                                                            self.number_of_labels.value_namespace_prefix = name_space_prefix
                                                        if(value_path == "out-interface"):
                                                            self.out_interface = value
                                                            self.out_interface.value_namespace = name_space
                                                            self.out_interface.value_namespace_prefix = name_space_prefix

                                                def has_data(self):
                                                    for c in self.igp_label_stack_array:
                                                        if (c.has_data()):
                                                            return True
                                                    return (
                                                        self.local_lable.is_set or
                                                        self.number_of_igp_paths.is_set or
                                                        self.recursive_fwd_chain.is_set or
                                                        self.recursive_out_label_valid.is_set or
                                                        self.recursive_out_lable.is_set or
                                                        self.remote_backup.is_set)

                                                def has_operation(self):
                                                    for c in self.igp_label_stack_array:
                                                        if (c.has_operation()):
                                                            return True
                                                    return (
                                                        self.yfilter != YFilter.not_set or
                                                        self.local_lable.yfilter != YFilter.not_set or
                                                        self.number_of_igp_paths.yfilter != YFilter.not_set or
                                                        self.recursive_fwd_chain.yfilter != YFilter.not_set or
                                                        self.recursive_out_label_valid.yfilter != YFilter.not_set or
                                                        self.recursive_out_lable.yfilter != YFilter.not_set or
                                                        self.remote_backup.yfilter != YFilter.not_set)

                                                def get_segment_path(self):
                                                    path_buffer = ""
                                                    path_buffer = "mpls-information-for-path" + path_buffer

                                                    return path_buffer

                                                def get_entity_path(self, ancestor):
                                                    path_buffer = ""
                                                    if (ancestor is None):
                                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                    else:
                                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                    leaf_name_data = LeafDataList()
                                                    if (self.local_lable.is_set or self.local_lable.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.local_lable.get_name_leafdata())
                                                    if (self.number_of_igp_paths.is_set or self.number_of_igp_paths.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.number_of_igp_paths.get_name_leafdata())
                                                    if (self.recursive_fwd_chain.is_set or self.recursive_fwd_chain.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recursive_fwd_chain.get_name_leafdata())
                                                    if (self.recursive_out_label_valid.is_set or self.recursive_out_label_valid.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recursive_out_label_valid.get_name_leafdata())
                                                    if (self.recursive_out_lable.is_set or self.recursive_out_lable.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.recursive_out_lable.get_name_leafdata())
                                                    if (self.remote_backup.is_set or self.remote_backup.yfilter != YFilter.not_set):
                                                        leaf_name_data.append(self.remote_backup.get_name_leafdata())

                                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                                    return entity_path

                                                def get_child_by_name(self, child_yang_name, segment_path):
                                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                    if child is not None:
                                                        return child

                                                    if (child_yang_name == "igp-label-stack-array"):
                                                        for c in self.igp_label_stack_array:
                                                            segment = c.get_segment_path()
                                                            if (segment_path == segment):
                                                                return c
                                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath.IgpLabelStackArray()
                                                        c.parent = self
                                                        local_reference_key = "ydk::seg::%s" % segment_path
                                                        self._local_refs[local_reference_key] = c
                                                        self.igp_label_stack_array.append(c)
                                                        return c

                                                    return None

                                                def has_leaf_or_child_of_name(self, name):
                                                    if(name == "igp-label-stack-array" or name == "local-lable" or name == "number-of-igp-paths" or name == "recursive-fwd-chain" or name == "recursive-out-label-valid" or name == "recursive-out-lable" or name == "remote-backup"):
                                                        return True
                                                    return False

                                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                                    if(value_path == "local-lable"):
                                                        self.local_lable = value
                                                        self.local_lable.value_namespace = name_space
                                                        self.local_lable.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "number-of-igp-paths"):
                                                        self.number_of_igp_paths = value
                                                        self.number_of_igp_paths.value_namespace = name_space
                                                        self.number_of_igp_paths.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recursive-fwd-chain"):
                                                        self.recursive_fwd_chain = value
                                                        self.recursive_fwd_chain.value_namespace = name_space
                                                        self.recursive_fwd_chain.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recursive-out-label-valid"):
                                                        self.recursive_out_label_valid = value
                                                        self.recursive_out_label_valid.value_namespace = name_space
                                                        self.recursive_out_label_valid.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "recursive-out-lable"):
                                                        self.recursive_out_lable = value
                                                        self.recursive_out_lable.value_namespace = name_space
                                                        self.recursive_out_lable.value_namespace_prefix = name_space_prefix
                                                    if(value_path == "remote-backup"):
                                                        self.remote_backup = value
                                                        self.remote_backup.value_namespace = name_space
                                                        self.remote_backup.value_namespace_prefix = name_space_prefix

                                            def has_data(self):
                                                return (
                                                    self.attached_path.is_set or
                                                    self.backup_index.is_set or
                                                    self.backup_path.is_set or
                                                    self.best_external_path.is_set or
                                                    self.brief_interface_handle.is_set or
                                                    self.brief_lfa_protection_type.is_set or
                                                    self.brief_next_hop_prefix.is_set or
                                                    self.brief_pnode_address.is_set or
                                                    self.brief_qnode_address.is_set or
                                                    self.hardware_information.is_set or
                                                    self.next_hop_index.is_set or
                                                    self.packets_received_path.is_set or
                                                    self.parent_interface_handle.is_set or
                                                    self.path_dlb.is_set or
                                                    self.path_flags.is_set or
                                                    self.path_index.is_set or
                                                    self.path_info_flags.is_set or
                                                    self.protect_ignore.is_set or
                                                    self.recursionvia_len.is_set or
                                                    self.recursive_path.is_set or
                                                    self.resolved_path.is_set or
                                                    self.via_label_to_recurse.is_set or
                                                    (self.more_detail_about_path is not None and self.more_detail_about_path.has_data()) or
                                                    (self.mpls_information_for_path is not None and self.mpls_information_for_path.has_data()))

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.attached_path.yfilter != YFilter.not_set or
                                                    self.backup_index.yfilter != YFilter.not_set or
                                                    self.backup_path.yfilter != YFilter.not_set or
                                                    self.best_external_path.yfilter != YFilter.not_set or
                                                    self.brief_interface_handle.yfilter != YFilter.not_set or
                                                    self.brief_lfa_protection_type.yfilter != YFilter.not_set or
                                                    self.brief_next_hop_prefix.yfilter != YFilter.not_set or
                                                    self.brief_pnode_address.yfilter != YFilter.not_set or
                                                    self.brief_qnode_address.yfilter != YFilter.not_set or
                                                    self.hardware_information.yfilter != YFilter.not_set or
                                                    self.next_hop_index.yfilter != YFilter.not_set or
                                                    self.packets_received_path.yfilter != YFilter.not_set or
                                                    self.parent_interface_handle.yfilter != YFilter.not_set or
                                                    self.path_dlb.yfilter != YFilter.not_set or
                                                    self.path_flags.yfilter != YFilter.not_set or
                                                    self.path_index.yfilter != YFilter.not_set or
                                                    self.path_info_flags.yfilter != YFilter.not_set or
                                                    self.protect_ignore.yfilter != YFilter.not_set or
                                                    self.recursionvia_len.yfilter != YFilter.not_set or
                                                    self.recursive_path.yfilter != YFilter.not_set or
                                                    self.resolved_path.yfilter != YFilter.not_set or
                                                    self.via_label_to_recurse.yfilter != YFilter.not_set or
                                                    (self.more_detail_about_path is not None and self.more_detail_about_path.has_operation()) or
                                                    (self.mpls_information_for_path is not None and self.mpls_information_for_path.has_operation()))

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-sh-tbl-path" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.attached_path.is_set or self.attached_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.attached_path.get_name_leafdata())
                                                if (self.backup_index.is_set or self.backup_index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.backup_index.get_name_leafdata())
                                                if (self.backup_path.is_set or self.backup_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.backup_path.get_name_leafdata())
                                                if (self.best_external_path.is_set or self.best_external_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.best_external_path.get_name_leafdata())
                                                if (self.brief_interface_handle.is_set or self.brief_interface_handle.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_interface_handle.get_name_leafdata())
                                                if (self.brief_lfa_protection_type.is_set or self.brief_lfa_protection_type.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_lfa_protection_type.get_name_leafdata())
                                                if (self.brief_next_hop_prefix.is_set or self.brief_next_hop_prefix.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_next_hop_prefix.get_name_leafdata())
                                                if (self.brief_pnode_address.is_set or self.brief_pnode_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_pnode_address.get_name_leafdata())
                                                if (self.brief_qnode_address.is_set or self.brief_qnode_address.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.brief_qnode_address.get_name_leafdata())
                                                if (self.hardware_information.is_set or self.hardware_information.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.hardware_information.get_name_leafdata())
                                                if (self.next_hop_index.is_set or self.next_hop_index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.next_hop_index.get_name_leafdata())
                                                if (self.packets_received_path.is_set or self.packets_received_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.packets_received_path.get_name_leafdata())
                                                if (self.parent_interface_handle.is_set or self.parent_interface_handle.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.parent_interface_handle.get_name_leafdata())
                                                if (self.path_dlb.is_set or self.path_dlb.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.path_dlb.get_name_leafdata())
                                                if (self.path_flags.is_set or self.path_flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.path_flags.get_name_leafdata())
                                                if (self.path_index.is_set or self.path_index.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.path_index.get_name_leafdata())
                                                if (self.path_info_flags.is_set or self.path_info_flags.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.path_info_flags.get_name_leafdata())
                                                if (self.protect_ignore.is_set or self.protect_ignore.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.protect_ignore.get_name_leafdata())
                                                if (self.recursionvia_len.is_set or self.recursionvia_len.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.recursionvia_len.get_name_leafdata())
                                                if (self.recursive_path.is_set or self.recursive_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.recursive_path.get_name_leafdata())
                                                if (self.resolved_path.is_set or self.resolved_path.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.resolved_path.get_name_leafdata())
                                                if (self.via_label_to_recurse.is_set or self.via_label_to_recurse.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.via_label_to_recurse.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                if (child_yang_name == "more-detail-about-path"):
                                                    if (self.more_detail_about_path is None):
                                                        self.more_detail_about_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MoreDetailAboutPath()
                                                        self.more_detail_about_path.parent = self
                                                        self._children_name_map["more_detail_about_path"] = "more-detail-about-path"
                                                    return self.more_detail_about_path

                                                if (child_yang_name == "mpls-information-for-path"):
                                                    if (self.mpls_information_for_path is None):
                                                        self.mpls_information_for_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath.MplsInformationForPath()
                                                        self.mpls_information_for_path.parent = self
                                                        self._children_name_map["mpls_information_for_path"] = "mpls-information-for-path"
                                                    return self.mpls_information_for_path

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "more-detail-about-path" or name == "mpls-information-for-path" or name == "attached-path" or name == "backup-index" or name == "backup-path" or name == "best-external-path" or name == "brief-interface-handle" or name == "brief-lfa-protection-type" or name == "brief-next-hop-prefix" or name == "brief-pnode-address" or name == "brief-qnode-address" or name == "hardware-information" or name == "next-hop-index" or name == "packets-received-path" or name == "parent-interface-handle" or name == "path-dlb" or name == "path-flags" or name == "path-index" or name == "path-info-flags" or name == "protect-ignore" or name == "recursionvia-len" or name == "recursive-path" or name == "resolved-path" or name == "via-label-to-recurse"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "attached-path"):
                                                    self.attached_path = value
                                                    self.attached_path.value_namespace = name_space
                                                    self.attached_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "backup-index"):
                                                    self.backup_index = value
                                                    self.backup_index.value_namespace = name_space
                                                    self.backup_index.value_namespace_prefix = name_space_prefix
                                                if(value_path == "backup-path"):
                                                    self.backup_path = value
                                                    self.backup_path.value_namespace = name_space
                                                    self.backup_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "best-external-path"):
                                                    self.best_external_path = value
                                                    self.best_external_path.value_namespace = name_space
                                                    self.best_external_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-interface-handle"):
                                                    self.brief_interface_handle = value
                                                    self.brief_interface_handle.value_namespace = name_space
                                                    self.brief_interface_handle.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-lfa-protection-type"):
                                                    self.brief_lfa_protection_type = value
                                                    self.brief_lfa_protection_type.value_namespace = name_space
                                                    self.brief_lfa_protection_type.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-next-hop-prefix"):
                                                    self.brief_next_hop_prefix = value
                                                    self.brief_next_hop_prefix.value_namespace = name_space
                                                    self.brief_next_hop_prefix.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-pnode-address"):
                                                    self.brief_pnode_address = value
                                                    self.brief_pnode_address.value_namespace = name_space
                                                    self.brief_pnode_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "brief-qnode-address"):
                                                    self.brief_qnode_address = value
                                                    self.brief_qnode_address.value_namespace = name_space
                                                    self.brief_qnode_address.value_namespace_prefix = name_space_prefix
                                                if(value_path == "hardware-information"):
                                                    self.hardware_information = value
                                                    self.hardware_information.value_namespace = name_space
                                                    self.hardware_information.value_namespace_prefix = name_space_prefix
                                                if(value_path == "next-hop-index"):
                                                    self.next_hop_index = value
                                                    self.next_hop_index.value_namespace = name_space
                                                    self.next_hop_index.value_namespace_prefix = name_space_prefix
                                                if(value_path == "packets-received-path"):
                                                    self.packets_received_path = value
                                                    self.packets_received_path.value_namespace = name_space
                                                    self.packets_received_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "parent-interface-handle"):
                                                    self.parent_interface_handle = value
                                                    self.parent_interface_handle.value_namespace = name_space
                                                    self.parent_interface_handle.value_namespace_prefix = name_space_prefix
                                                if(value_path == "path-dlb"):
                                                    self.path_dlb = value
                                                    self.path_dlb.value_namespace = name_space
                                                    self.path_dlb.value_namespace_prefix = name_space_prefix
                                                if(value_path == "path-flags"):
                                                    self.path_flags = value
                                                    self.path_flags.value_namespace = name_space
                                                    self.path_flags.value_namespace_prefix = name_space_prefix
                                                if(value_path == "path-index"):
                                                    self.path_index = value
                                                    self.path_index.value_namespace = name_space
                                                    self.path_index.value_namespace_prefix = name_space_prefix
                                                if(value_path == "path-info-flags"):
                                                    self.path_info_flags = value
                                                    self.path_info_flags.value_namespace = name_space
                                                    self.path_info_flags.value_namespace_prefix = name_space_prefix
                                                if(value_path == "protect-ignore"):
                                                    self.protect_ignore = value
                                                    self.protect_ignore.value_namespace = name_space
                                                    self.protect_ignore.value_namespace_prefix = name_space_prefix
                                                if(value_path == "recursionvia-len"):
                                                    self.recursionvia_len = value
                                                    self.recursionvia_len.value_namespace = name_space
                                                    self.recursionvia_len.value_namespace_prefix = name_space_prefix
                                                if(value_path == "recursive-path"):
                                                    self.recursive_path = value
                                                    self.recursive_path.value_namespace = name_space
                                                    self.recursive_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "resolved-path"):
                                                    self.resolved_path = value
                                                    self.resolved_path.value_namespace = name_space
                                                    self.resolved_path.value_namespace_prefix = name_space_prefix
                                                if(value_path == "via-label-to-recurse"):
                                                    self.via_label_to_recurse = value
                                                    self.via_label_to_recurse.value_namespace = name_space
                                                    self.via_label_to_recurse.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            for c in self.fib_sh_tbl_path:
                                                if (c.has_data()):
                                                    return True
                                            return False

                                        def has_operation(self):
                                            for c in self.fib_sh_tbl_path:
                                                if (c.has_operation()):
                                                    return True
                                            return self.yfilter != YFilter.not_set

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "fib-entry-path" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-sh-tbl-path"):
                                                for c in self.fib_sh_tbl_path:
                                                    segment = c.get_segment_path()
                                                    if (segment_path == segment):
                                                        return c
                                                c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath.FibShTblPath()
                                                c.parent = self
                                                local_reference_key = "ydk::seg::%s" % segment_path
                                                self._local_refs[local_reference_key] = c
                                                self.fib_sh_tbl_path.append(c)
                                                return c

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-sh-tbl-path"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            pass


                                    class Srv6Information(Entity):
                                        """
                                        Information about IPv6 SR prefix
                                        
                                        .. attribute:: route_is_sripv6_flag
                                        
                                        	Route is an IPv6 Segment\-Routing prefix
                                        	**type**\:  bool
                                        
                                        .. attribute:: sripv6_stats_valid_flag
                                        
                                        	Statistics are valid for this prefix
                                        	**type**\:  bool
                                        
                                        .. attribute:: srv6_pfx_resolved_via_policy_label
                                        
                                        	Route is a SRv6 prefix resolved via Policy label
                                        	**type**\:  bool
                                        
                                        .. attribute:: srv6_statistics
                                        
                                        	Statistics for a IPv6 SR prefix
                                        	**type**\:   :py:class:`Srv6Statistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information.Srv6Statistics>`
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information, self).__init__()

                                            self.yang_name = "srv6-information"
                                            self.yang_parent_name = "ip-prefix-brief"

                                            self.route_is_sripv6_flag = YLeaf(YType.boolean, "route-is-sripv6-flag")

                                            self.sripv6_stats_valid_flag = YLeaf(YType.boolean, "sripv6-stats-valid-flag")

                                            self.srv6_pfx_resolved_via_policy_label = YLeaf(YType.boolean, "srv6-pfx-resolved-via-policy-label")

                                            self.srv6_statistics = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information.Srv6Statistics()
                                            self.srv6_statistics.parent = self
                                            self._children_name_map["srv6_statistics"] = "srv6-statistics"
                                            self._children_yang_names.add("srv6-statistics")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("route_is_sripv6_flag",
                                                            "sripv6_stats_valid_flag",
                                                            "srv6_pfx_resolved_via_policy_label") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information, self).__setattr__(name, value)


                                        class Srv6Statistics(Entity):
                                            """
                                            Statistics for a IPv6 SR prefix
                                            
                                            .. attribute:: srv6_packets_dropped
                                            
                                            	SRv6 Packets dropped for a prefix
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            .. attribute:: srv6_packets_forwarded
                                            
                                            	SRv6 packets forwarded for a prefix
                                            	**type**\:  int
                                            
                                            	**range:** 0..18446744073709551615
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information.Srv6Statistics, self).__init__()

                                                self.yang_name = "srv6-statistics"
                                                self.yang_parent_name = "srv6-information"

                                                self.srv6_packets_dropped = YLeaf(YType.uint64, "srv6-packets-dropped")

                                                self.srv6_packets_forwarded = YLeaf(YType.uint64, "srv6-packets-forwarded")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("srv6_packets_dropped",
                                                                "srv6_packets_forwarded") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information.Srv6Statistics, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information.Srv6Statistics, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.srv6_packets_dropped.is_set or
                                                    self.srv6_packets_forwarded.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.srv6_packets_dropped.yfilter != YFilter.not_set or
                                                    self.srv6_packets_forwarded.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "srv6-statistics" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.srv6_packets_dropped.is_set or self.srv6_packets_dropped.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.srv6_packets_dropped.get_name_leafdata())
                                                if (self.srv6_packets_forwarded.is_set or self.srv6_packets_forwarded.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.srv6_packets_forwarded.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "srv6-packets-dropped" or name == "srv6-packets-forwarded"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "srv6-packets-dropped"):
                                                    self.srv6_packets_dropped = value
                                                    self.srv6_packets_dropped.value_namespace = name_space
                                                    self.srv6_packets_dropped.value_namespace_prefix = name_space_prefix
                                                if(value_path == "srv6-packets-forwarded"):
                                                    self.srv6_packets_forwarded = value
                                                    self.srv6_packets_forwarded.value_namespace = name_space
                                                    self.srv6_packets_forwarded.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.route_is_sripv6_flag.is_set or
                                                self.sripv6_stats_valid_flag.is_set or
                                                self.srv6_pfx_resolved_via_policy_label.is_set or
                                                (self.srv6_statistics is not None and self.srv6_statistics.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.route_is_sripv6_flag.yfilter != YFilter.not_set or
                                                self.sripv6_stats_valid_flag.yfilter != YFilter.not_set or
                                                self.srv6_pfx_resolved_via_policy_label.yfilter != YFilter.not_set or
                                                (self.srv6_statistics is not None and self.srv6_statistics.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "srv6-information" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.route_is_sripv6_flag.is_set or self.route_is_sripv6_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.route_is_sripv6_flag.get_name_leafdata())
                                            if (self.sripv6_stats_valid_flag.is_set or self.sripv6_stats_valid_flag.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.sripv6_stats_valid_flag.get_name_leafdata())
                                            if (self.srv6_pfx_resolved_via_policy_label.is_set or self.srv6_pfx_resolved_via_policy_label.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.srv6_pfx_resolved_via_policy_label.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "srv6-statistics"):
                                                if (self.srv6_statistics is None):
                                                    self.srv6_statistics = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information.Srv6Statistics()
                                                    self.srv6_statistics.parent = self
                                                    self._children_name_map["srv6_statistics"] = "srv6-statistics"
                                                return self.srv6_statistics

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "srv6-statistics" or name == "route-is-sripv6-flag" or name == "sripv6-stats-valid-flag" or name == "srv6-pfx-resolved-via-policy-label"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "route-is-sripv6-flag"):
                                                self.route_is_sripv6_flag = value
                                                self.route_is_sripv6_flag.value_namespace = name_space
                                                self.route_is_sripv6_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "sripv6-stats-valid-flag"):
                                                self.sripv6_stats_valid_flag = value
                                                self.sripv6_stats_valid_flag.value_namespace = name_space
                                                self.sripv6_stats_valid_flag.value_namespace_prefix = name_space_prefix
                                            if(value_path == "srv6-pfx-resolved-via-policy-label"):
                                                self.srv6_pfx_resolved_via_policy_label = value
                                                self.srv6_pfx_resolved_via_policy_label.value_namespace = name_space
                                                self.srv6_pfx_resolved_via_policy_label.value_namespace_prefix = name_space_prefix


                                    class ExtensionObject(Entity):
                                        """
                                        Leaf Extension Object List
                                        
                                        .. attribute:: sfecd_le
                                        
                                        	sfecd le
                                        	**type**\:   :py:class:`SfecdLe <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject.SfecdLe>`
                                        
                                        .. attribute:: type
                                        
                                        	type
                                        	**type**\:   :py:class:`FibShTblFibExtBag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibShTblFibExtBag>`
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject, self).__init__()

                                            self.yang_name = "extension-object"
                                            self.yang_parent_name = "ip-prefix-brief"

                                            self.type = YLeaf(YType.enumeration, "type")

                                            self.sfecd_le = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject.SfecdLe()
                                            self.sfecd_le.parent = self
                                            self._children_name_map["sfecd_le"] = "sfecd-le"
                                            self._children_yang_names.add("sfecd-le")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("type") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject, self).__setattr__(name, value)


                                        class SfecdLe(Entity):
                                            """
                                            sfecd le
                                            
                                            .. attribute:: context_label
                                            
                                            	Context Label
                                            	**type**\:  int
                                            
                                            	**range:** 0..4294967295
                                            
                                            .. attribute:: context_label_flag
                                            
                                            	Context Label Exist
                                            	**type**\:  bool
                                            
                                            

                                            """

                                            _prefix = 'fib-common-oper'
                                            _revision = '2017-01-20'

                                            def __init__(self):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject.SfecdLe, self).__init__()

                                                self.yang_name = "sfecd-le"
                                                self.yang_parent_name = "extension-object"

                                                self.context_label = YLeaf(YType.uint32, "context-label")

                                                self.context_label_flag = YLeaf(YType.boolean, "context-label-flag")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("context_label",
                                                                "context_label_flag") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject.SfecdLe, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject.SfecdLe, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.context_label.is_set or
                                                    self.context_label_flag.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.context_label.yfilter != YFilter.not_set or
                                                    self.context_label_flag.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "sfecd-le" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.context_label.is_set or self.context_label.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.context_label.get_name_leafdata())
                                                if (self.context_label_flag.is_set or self.context_label_flag.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.context_label_flag.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "context-label" or name == "context-label-flag"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "context-label"):
                                                    self.context_label = value
                                                    self.context_label.value_namespace = name_space
                                                    self.context_label.value_namespace_prefix = name_space_prefix
                                                if(value_path == "context-label-flag"):
                                                    self.context_label_flag = value
                                                    self.context_label_flag.value_namespace = name_space
                                                    self.context_label_flag.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.type.is_set or
                                                (self.sfecd_le is not None and self.sfecd_le.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.type.yfilter != YFilter.not_set or
                                                (self.sfecd_le is not None and self.sfecd_le.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "extension-object" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.type.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "sfecd-le"):
                                                if (self.sfecd_le is None):
                                                    self.sfecd_le = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject.SfecdLe()
                                                    self.sfecd_le.parent = self
                                                    self._children_name_map["sfecd_le"] = "sfecd-le"
                                                return self.sfecd_le

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "sfecd-le" or name == "type"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "type"):
                                                self.type = value
                                                self.type.value_namespace = name_space
                                                self.type.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.extension_object:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.broadcast_forward_flag.is_set or
                                            self.broadcast_recive_flag.is_set or
                                            self.dummy_real_zero_route.is_set or
                                            self.exact_route_result.is_set or
                                            self.external_switch_triggered.is_set or
                                            self.fib_route_download_priority.is_set or
                                            self.flags_external_ldi.is_set or
                                            self.l2_subscriber_ip_protocol.is_set or
                                            self.l2_subscriber_route.is_set or
                                            self.l2_subscriber_xconnect_id.is_set or
                                            self.l2tpv3_cookie_length_bits.is_set or
                                            self.ldi_flags.is_set or
                                            self.ldi_lw_flag.is_set or
                                            self.lspa_flags.is_set or
                                            self.number_of_referances_to_ldi.is_set or
                                            self.number_of_referances_to_path_list.is_set or
                                            self.packet_should_recieve.is_set or
                                            self.path_list_flags.is_set or
                                            self.path_list_source.is_set or
                                            self.platform_hardware.is_set or
                                            self.prefix.is_set or
                                            self.prefix_connected.is_set or
                                            self.prefix_for_adjancency.is_set or
                                            self.prefix_for_pic_next_hop.is_set or
                                            self.prefix_is_static_or_connected.is_set or
                                            self.prefix_length.is_set or
                                            self.protocol_type_fib_entry.is_set or
                                            self.purgable_after_purge_interval.is_set or
                                            self.ref_counter_of_ldi_lw_ldi.is_set or
                                            self.route_attribute_flag.is_set or
                                            self.route_for_external_reach_linecard_flag.is_set or
                                            self.route_is_sr_flag.is_set or
                                            self.time_of_last_update_in_msec.is_set or
                                            self.type_of_ldi_lw_ldi.is_set or
                                            self.version_of_route.is_set or
                                            self.zero_by_zero_route_as_default.is_set or
                                            (self.detail_fib_entry_information is not None and self.detail_fib_entry_information.has_data()) or
                                            (self.fib_entry_path is not None and self.fib_entry_path.has_data()) or
                                            (self.srv6_information is not None and self.srv6_information.has_data()))

                                    def has_operation(self):
                                        for c in self.extension_object:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.broadcast_forward_flag.yfilter != YFilter.not_set or
                                            self.broadcast_recive_flag.yfilter != YFilter.not_set or
                                            self.dummy_real_zero_route.yfilter != YFilter.not_set or
                                            self.exact_route_result.yfilter != YFilter.not_set or
                                            self.external_switch_triggered.yfilter != YFilter.not_set or
                                            self.fib_route_download_priority.yfilter != YFilter.not_set or
                                            self.flags_external_ldi.yfilter != YFilter.not_set or
                                            self.l2_subscriber_ip_protocol.yfilter != YFilter.not_set or
                                            self.l2_subscriber_route.yfilter != YFilter.not_set or
                                            self.l2_subscriber_xconnect_id.yfilter != YFilter.not_set or
                                            self.l2tpv3_cookie_length_bits.yfilter != YFilter.not_set or
                                            self.ldi_flags.yfilter != YFilter.not_set or
                                            self.ldi_lw_flag.yfilter != YFilter.not_set or
                                            self.lspa_flags.yfilter != YFilter.not_set or
                                            self.number_of_referances_to_ldi.yfilter != YFilter.not_set or
                                            self.number_of_referances_to_path_list.yfilter != YFilter.not_set or
                                            self.packet_should_recieve.yfilter != YFilter.not_set or
                                            self.path_list_flags.yfilter != YFilter.not_set or
                                            self.path_list_source.yfilter != YFilter.not_set or
                                            self.platform_hardware.yfilter != YFilter.not_set or
                                            self.prefix.yfilter != YFilter.not_set or
                                            self.prefix_connected.yfilter != YFilter.not_set or
                                            self.prefix_for_adjancency.yfilter != YFilter.not_set or
                                            self.prefix_for_pic_next_hop.yfilter != YFilter.not_set or
                                            self.prefix_is_static_or_connected.yfilter != YFilter.not_set or
                                            self.prefix_length.yfilter != YFilter.not_set or
                                            self.protocol_type_fib_entry.yfilter != YFilter.not_set or
                                            self.purgable_after_purge_interval.yfilter != YFilter.not_set or
                                            self.ref_counter_of_ldi_lw_ldi.yfilter != YFilter.not_set or
                                            self.route_attribute_flag.yfilter != YFilter.not_set or
                                            self.route_for_external_reach_linecard_flag.yfilter != YFilter.not_set or
                                            self.route_is_sr_flag.yfilter != YFilter.not_set or
                                            self.time_of_last_update_in_msec.yfilter != YFilter.not_set or
                                            self.type_of_ldi_lw_ldi.yfilter != YFilter.not_set or
                                            self.version_of_route.yfilter != YFilter.not_set or
                                            self.zero_by_zero_route_as_default.yfilter != YFilter.not_set or
                                            (self.detail_fib_entry_information is not None and self.detail_fib_entry_information.has_operation()) or
                                            (self.fib_entry_path is not None and self.fib_entry_path.has_operation()) or
                                            (self.srv6_information is not None and self.srv6_information.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ip-prefix-brief" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.broadcast_forward_flag.is_set or self.broadcast_forward_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.broadcast_forward_flag.get_name_leafdata())
                                        if (self.broadcast_recive_flag.is_set or self.broadcast_recive_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.broadcast_recive_flag.get_name_leafdata())
                                        if (self.dummy_real_zero_route.is_set or self.dummy_real_zero_route.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.dummy_real_zero_route.get_name_leafdata())
                                        if (self.exact_route_result.is_set or self.exact_route_result.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.exact_route_result.get_name_leafdata())
                                        if (self.external_switch_triggered.is_set or self.external_switch_triggered.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.external_switch_triggered.get_name_leafdata())
                                        if (self.fib_route_download_priority.is_set or self.fib_route_download_priority.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fib_route_download_priority.get_name_leafdata())
                                        if (self.flags_external_ldi.is_set or self.flags_external_ldi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.flags_external_ldi.get_name_leafdata())
                                        if (self.l2_subscriber_ip_protocol.is_set or self.l2_subscriber_ip_protocol.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.l2_subscriber_ip_protocol.get_name_leafdata())
                                        if (self.l2_subscriber_route.is_set or self.l2_subscriber_route.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.l2_subscriber_route.get_name_leafdata())
                                        if (self.l2_subscriber_xconnect_id.is_set or self.l2_subscriber_xconnect_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.l2_subscriber_xconnect_id.get_name_leafdata())
                                        if (self.l2tpv3_cookie_length_bits.is_set or self.l2tpv3_cookie_length_bits.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.l2tpv3_cookie_length_bits.get_name_leafdata())
                                        if (self.ldi_flags.is_set or self.ldi_flags.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ldi_flags.get_name_leafdata())
                                        if (self.ldi_lw_flag.is_set or self.ldi_lw_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ldi_lw_flag.get_name_leafdata())
                                        if (self.lspa_flags.is_set or self.lspa_flags.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.lspa_flags.get_name_leafdata())
                                        if (self.number_of_referances_to_ldi.is_set or self.number_of_referances_to_ldi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.number_of_referances_to_ldi.get_name_leafdata())
                                        if (self.number_of_referances_to_path_list.is_set or self.number_of_referances_to_path_list.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.number_of_referances_to_path_list.get_name_leafdata())
                                        if (self.packet_should_recieve.is_set or self.packet_should_recieve.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.packet_should_recieve.get_name_leafdata())
                                        if (self.path_list_flags.is_set or self.path_list_flags.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.path_list_flags.get_name_leafdata())
                                        if (self.path_list_source.is_set or self.path_list_source.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.path_list_source.get_name_leafdata())
                                        if (self.platform_hardware.is_set or self.platform_hardware.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.platform_hardware.get_name_leafdata())
                                        if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix.get_name_leafdata())
                                        if (self.prefix_connected.is_set or self.prefix_connected.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_connected.get_name_leafdata())
                                        if (self.prefix_for_adjancency.is_set or self.prefix_for_adjancency.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_for_adjancency.get_name_leafdata())
                                        if (self.prefix_for_pic_next_hop.is_set or self.prefix_for_pic_next_hop.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_for_pic_next_hop.get_name_leafdata())
                                        if (self.prefix_is_static_or_connected.is_set or self.prefix_is_static_or_connected.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_is_static_or_connected.get_name_leafdata())
                                        if (self.prefix_length.is_set or self.prefix_length.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prefix_length.get_name_leafdata())
                                        if (self.protocol_type_fib_entry.is_set or self.protocol_type_fib_entry.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.protocol_type_fib_entry.get_name_leafdata())
                                        if (self.purgable_after_purge_interval.is_set or self.purgable_after_purge_interval.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.purgable_after_purge_interval.get_name_leafdata())
                                        if (self.ref_counter_of_ldi_lw_ldi.is_set or self.ref_counter_of_ldi_lw_ldi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.ref_counter_of_ldi_lw_ldi.get_name_leafdata())
                                        if (self.route_attribute_flag.is_set or self.route_attribute_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_attribute_flag.get_name_leafdata())
                                        if (self.route_for_external_reach_linecard_flag.is_set or self.route_for_external_reach_linecard_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_for_external_reach_linecard_flag.get_name_leafdata())
                                        if (self.route_is_sr_flag.is_set or self.route_is_sr_flag.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.route_is_sr_flag.get_name_leafdata())
                                        if (self.time_of_last_update_in_msec.is_set or self.time_of_last_update_in_msec.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.time_of_last_update_in_msec.get_name_leafdata())
                                        if (self.type_of_ldi_lw_ldi.is_set or self.type_of_ldi_lw_ldi.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type_of_ldi_lw_ldi.get_name_leafdata())
                                        if (self.version_of_route.is_set or self.version_of_route.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.version_of_route.get_name_leafdata())
                                        if (self.zero_by_zero_route_as_default.is_set or self.zero_by_zero_route_as_default.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.zero_by_zero_route_as_default.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "detail-fib-entry-information"):
                                            if (self.detail_fib_entry_information is None):
                                                self.detail_fib_entry_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.DetailFibEntryInformation()
                                                self.detail_fib_entry_information.parent = self
                                                self._children_name_map["detail_fib_entry_information"] = "detail-fib-entry-information"
                                            return self.detail_fib_entry_information

                                        if (child_yang_name == "extension-object"):
                                            for c in self.extension_object:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.ExtensionObject()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.extension_object.append(c)
                                            return c

                                        if (child_yang_name == "fib-entry-path"):
                                            if (self.fib_entry_path is None):
                                                self.fib_entry_path = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.FibEntryPath()
                                                self.fib_entry_path.parent = self
                                                self._children_name_map["fib_entry_path"] = "fib-entry-path"
                                            return self.fib_entry_path

                                        if (child_yang_name == "srv6-information"):
                                            if (self.srv6_information is None):
                                                self.srv6_information = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief.Srv6Information()
                                                self.srv6_information.parent = self
                                                self._children_name_map["srv6_information"] = "srv6-information"
                                            return self.srv6_information

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "detail-fib-entry-information" or name == "extension-object" or name == "fib-entry-path" or name == "srv6-information" or name == "broadcast-forward-flag" or name == "broadcast-recive-flag" or name == "dummy-real-zero-route" or name == "exact-route-result" or name == "external-switch-triggered" or name == "fib-route-download-priority" or name == "flags-external-ldi" or name == "l2-subscriber-ip-protocol" or name == "l2-subscriber-route" or name == "l2-subscriber-xconnect-id" or name == "l2tpv3-cookie-length-bits" or name == "ldi-flags" or name == "ldi-lw-flag" or name == "lspa-flags" or name == "number-of-referances-to-ldi" or name == "number-of-referances-to-path-list" or name == "packet-should-recieve" or name == "path-list-flags" or name == "path-list-source" or name == "platform-hardware" or name == "prefix" or name == "prefix-connected" or name == "prefix-for-adjancency" or name == "prefix-for-pic-next-hop" or name == "prefix-is-static-or-connected" or name == "prefix-length" or name == "protocol-type-fib-entry" or name == "purgable-after-purge-interval" or name == "ref-counter-of-ldi-lw-ldi" or name == "route-attribute-flag" or name == "route-for-external-reach-linecard-flag" or name == "route-is-sr-flag" or name == "time-of-last-update-in-msec" or name == "type-of-ldi-lw-ldi" or name == "version-of-route" or name == "zero-by-zero-route-as-default"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "broadcast-forward-flag"):
                                            self.broadcast_forward_flag = value
                                            self.broadcast_forward_flag.value_namespace = name_space
                                            self.broadcast_forward_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "broadcast-recive-flag"):
                                            self.broadcast_recive_flag = value
                                            self.broadcast_recive_flag.value_namespace = name_space
                                            self.broadcast_recive_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "dummy-real-zero-route"):
                                            self.dummy_real_zero_route = value
                                            self.dummy_real_zero_route.value_namespace = name_space
                                            self.dummy_real_zero_route.value_namespace_prefix = name_space_prefix
                                        if(value_path == "exact-route-result"):
                                            self.exact_route_result = value
                                            self.exact_route_result.value_namespace = name_space
                                            self.exact_route_result.value_namespace_prefix = name_space_prefix
                                        if(value_path == "external-switch-triggered"):
                                            self.external_switch_triggered = value
                                            self.external_switch_triggered.value_namespace = name_space
                                            self.external_switch_triggered.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fib-route-download-priority"):
                                            self.fib_route_download_priority = value
                                            self.fib_route_download_priority.value_namespace = name_space
                                            self.fib_route_download_priority.value_namespace_prefix = name_space_prefix
                                        if(value_path == "flags-external-ldi"):
                                            self.flags_external_ldi = value
                                            self.flags_external_ldi.value_namespace = name_space
                                            self.flags_external_ldi.value_namespace_prefix = name_space_prefix
                                        if(value_path == "l2-subscriber-ip-protocol"):
                                            self.l2_subscriber_ip_protocol = value
                                            self.l2_subscriber_ip_protocol.value_namespace = name_space
                                            self.l2_subscriber_ip_protocol.value_namespace_prefix = name_space_prefix
                                        if(value_path == "l2-subscriber-route"):
                                            self.l2_subscriber_route = value
                                            self.l2_subscriber_route.value_namespace = name_space
                                            self.l2_subscriber_route.value_namespace_prefix = name_space_prefix
                                        if(value_path == "l2-subscriber-xconnect-id"):
                                            self.l2_subscriber_xconnect_id = value
                                            self.l2_subscriber_xconnect_id.value_namespace = name_space
                                            self.l2_subscriber_xconnect_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "l2tpv3-cookie-length-bits"):
                                            self.l2tpv3_cookie_length_bits = value
                                            self.l2tpv3_cookie_length_bits.value_namespace = name_space
                                            self.l2tpv3_cookie_length_bits.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ldi-flags"):
                                            self.ldi_flags = value
                                            self.ldi_flags.value_namespace = name_space
                                            self.ldi_flags.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ldi-lw-flag"):
                                            self.ldi_lw_flag = value
                                            self.ldi_lw_flag.value_namespace = name_space
                                            self.ldi_lw_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "lspa-flags"):
                                            self.lspa_flags = value
                                            self.lspa_flags.value_namespace = name_space
                                            self.lspa_flags.value_namespace_prefix = name_space_prefix
                                        if(value_path == "number-of-referances-to-ldi"):
                                            self.number_of_referances_to_ldi = value
                                            self.number_of_referances_to_ldi.value_namespace = name_space
                                            self.number_of_referances_to_ldi.value_namespace_prefix = name_space_prefix
                                        if(value_path == "number-of-referances-to-path-list"):
                                            self.number_of_referances_to_path_list = value
                                            self.number_of_referances_to_path_list.value_namespace = name_space
                                            self.number_of_referances_to_path_list.value_namespace_prefix = name_space_prefix
                                        if(value_path == "packet-should-recieve"):
                                            self.packet_should_recieve = value
                                            self.packet_should_recieve.value_namespace = name_space
                                            self.packet_should_recieve.value_namespace_prefix = name_space_prefix
                                        if(value_path == "path-list-flags"):
                                            self.path_list_flags = value
                                            self.path_list_flags.value_namespace = name_space
                                            self.path_list_flags.value_namespace_prefix = name_space_prefix
                                        if(value_path == "path-list-source"):
                                            self.path_list_source = value
                                            self.path_list_source.value_namespace = name_space
                                            self.path_list_source.value_namespace_prefix = name_space_prefix
                                        if(value_path == "platform-hardware"):
                                            self.platform_hardware = value
                                            self.platform_hardware.value_namespace = name_space
                                            self.platform_hardware.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix"):
                                            self.prefix = value
                                            self.prefix.value_namespace = name_space
                                            self.prefix.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-connected"):
                                            self.prefix_connected = value
                                            self.prefix_connected.value_namespace = name_space
                                            self.prefix_connected.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-for-adjancency"):
                                            self.prefix_for_adjancency = value
                                            self.prefix_for_adjancency.value_namespace = name_space
                                            self.prefix_for_adjancency.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-for-pic-next-hop"):
                                            self.prefix_for_pic_next_hop = value
                                            self.prefix_for_pic_next_hop.value_namespace = name_space
                                            self.prefix_for_pic_next_hop.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-is-static-or-connected"):
                                            self.prefix_is_static_or_connected = value
                                            self.prefix_is_static_or_connected.value_namespace = name_space
                                            self.prefix_is_static_or_connected.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prefix-length"):
                                            self.prefix_length = value
                                            self.prefix_length.value_namespace = name_space
                                            self.prefix_length.value_namespace_prefix = name_space_prefix
                                        if(value_path == "protocol-type-fib-entry"):
                                            self.protocol_type_fib_entry = value
                                            self.protocol_type_fib_entry.value_namespace = name_space
                                            self.protocol_type_fib_entry.value_namespace_prefix = name_space_prefix
                                        if(value_path == "purgable-after-purge-interval"):
                                            self.purgable_after_purge_interval = value
                                            self.purgable_after_purge_interval.value_namespace = name_space
                                            self.purgable_after_purge_interval.value_namespace_prefix = name_space_prefix
                                        if(value_path == "ref-counter-of-ldi-lw-ldi"):
                                            self.ref_counter_of_ldi_lw_ldi = value
                                            self.ref_counter_of_ldi_lw_ldi.value_namespace = name_space
                                            self.ref_counter_of_ldi_lw_ldi.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-attribute-flag"):
                                            self.route_attribute_flag = value
                                            self.route_attribute_flag.value_namespace = name_space
                                            self.route_attribute_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-for-external-reach-linecard-flag"):
                                            self.route_for_external_reach_linecard_flag = value
                                            self.route_for_external_reach_linecard_flag.value_namespace = name_space
                                            self.route_for_external_reach_linecard_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "route-is-sr-flag"):
                                            self.route_is_sr_flag = value
                                            self.route_is_sr_flag.value_namespace = name_space
                                            self.route_is_sr_flag.value_namespace_prefix = name_space_prefix
                                        if(value_path == "time-of-last-update-in-msec"):
                                            self.time_of_last_update_in_msec = value
                                            self.time_of_last_update_in_msec.value_namespace = name_space
                                            self.time_of_last_update_in_msec.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type-of-ldi-lw-ldi"):
                                            self.type_of_ldi_lw_ldi = value
                                            self.type_of_ldi_lw_ldi.value_namespace = name_space
                                            self.type_of_ldi_lw_ldi.value_namespace_prefix = name_space_prefix
                                        if(value_path == "version-of-route"):
                                            self.version_of_route = value
                                            self.version_of_route.value_namespace = name_space
                                            self.version_of_route.value_namespace_prefix = name_space_prefix
                                        if(value_path == "zero-by-zero-route-as-default"):
                                            self.zero_by_zero_route_as_default = value
                                            self.zero_by_zero_route_as_default.value_namespace = name_space
                                            self.zero_by_zero_route_as_default.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.ip_prefix_brief:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.ip_prefix_brief:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ip-prefix-briefs" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "ip-prefix-brief"):
                                        for c in self.ip_prefix_brief:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs.IpPrefixBrief()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.ip_prefix_brief.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ip-prefix-brief"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.vrf_name.is_set or
                                    (self.interface_infos is not None and self.interface_infos.has_data()) or
                                    (self.ip_prefix_briefs is not None and self.ip_prefix_briefs.has_data()) or
                                    (self.ip_prefix_details is not None and self.ip_prefix_details.has_data()) or
                                    (self.summary is not None and self.summary.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.vrf_name.yfilter != YFilter.not_set or
                                    (self.interface_infos is not None and self.interface_infos.has_operation()) or
                                    (self.ip_prefix_briefs is not None and self.ip_prefix_briefs.has_operation()) or
                                    (self.ip_prefix_details is not None and self.ip_prefix_details.has_operation()) or
                                    (self.summary is not None and self.summary.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "vrf" + "[vrf-name='" + self.vrf_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.vrf_name.is_set or self.vrf_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.vrf_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "interface-infos"):
                                    if (self.interface_infos is None):
                                        self.interface_infos = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.InterfaceInfos()
                                        self.interface_infos.parent = self
                                        self._children_name_map["interface_infos"] = "interface-infos"
                                    return self.interface_infos

                                if (child_yang_name == "ip-prefix-briefs"):
                                    if (self.ip_prefix_briefs is None):
                                        self.ip_prefix_briefs = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixBriefs()
                                        self.ip_prefix_briefs.parent = self
                                        self._children_name_map["ip_prefix_briefs"] = "ip-prefix-briefs"
                                    return self.ip_prefix_briefs

                                if (child_yang_name == "ip-prefix-details"):
                                    if (self.ip_prefix_details is None):
                                        self.ip_prefix_details = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.IpPrefixDetails()
                                        self.ip_prefix_details.parent = self
                                        self._children_name_map["ip_prefix_details"] = "ip-prefix-details"
                                    return self.ip_prefix_details

                                if (child_yang_name == "summary"):
                                    if (self.summary is None):
                                        self.summary = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf.Summary()
                                        self.summary.parent = self
                                        self._children_name_map["summary"] = "summary"
                                    return self.summary

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface-infos" or name == "ip-prefix-briefs" or name == "ip-prefix-details" or name == "summary" or name == "vrf-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "vrf-name"):
                                    self.vrf_name = value
                                    self.vrf_name.value_namespace = name_space
                                    self.vrf_name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.vrf:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.vrf:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "vrfs" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "vrf"):
                                for c in self.vrf:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Vrfs.Vrf()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.vrf.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "vrf"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class NhIds(Entity):
                        """
                        NHIdTable is accessed by two keys;
                        {NHIdValue} and/or {NHInterface,NHAddress
                        
                        .. attribute:: nh_id
                        
                        	NextHopeId table entry
                        	**type**\: list of    :py:class:`NhId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.NhIds.NhId>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.NhIds, self).__init__()

                            self.yang_name = "nh-ids"
                            self.yang_parent_name = "protocol"

                            self.nh_id = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Fib.Nodes.Node.Protocols.Protocol.NhIds, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Fib.Nodes.Node.Protocols.Protocol.NhIds, self).__setattr__(name, value)


                        class NhId(Entity):
                            """
                            NextHopeId table entry
                            
                            .. attribute:: nh_address
                            
                            	Next\-hop address in string format (e.g., 1 .2.3.4)
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: nh_address_xr
                            
                            	Next\-hop address
                            	**type**\:  str
                            
                            .. attribute:: nh_id
                            
                            	NHID value
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: nh_id_application
                            
                            	NHID application type
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: nh_id_value
                            
                            	NexthopId Value
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: nh_interf_handle
                            
                            	Next\-hop interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: nh_interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: nh_link_type
                            
                            	Payload linktype
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: nh_protocol
                            
                            	Next\-hop address protocol, IPv4/IPv6
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: nh_table_id
                            
                            	Table\-ID entry notified for
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: time_of_last_update_in_msec
                            
                            	The time of last update in msec
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: version
                            
                            	RIB version
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.NhIds.NhId, self).__init__()

                                self.yang_name = "nh-id"
                                self.yang_parent_name = "nh-ids"

                                self.nh_address = YLeaf(YType.str, "nh-address")

                                self.nh_address_xr = YLeaf(YType.str, "nh-address-xr")

                                self.nh_id = YLeaf(YType.uint32, "nh-id")

                                self.nh_id_application = YLeaf(YType.uint8, "nh-id-application")

                                self.nh_id_value = YLeaf(YType.int32, "nh-id-value")

                                self.nh_interf_handle = YLeaf(YType.str, "nh-interf-handle")

                                self.nh_interface_name = YLeaf(YType.str, "nh-interface-name")

                                self.nh_link_type = YLeaf(YType.uint8, "nh-link-type")

                                self.nh_protocol = YLeaf(YType.uint8, "nh-protocol")

                                self.nh_table_id = YLeaf(YType.uint32, "nh-table-id")

                                self.time_of_last_update_in_msec = YLeaf(YType.uint64, "time-of-last-update-in-msec")

                                self.version = YLeaf(YType.uint64, "version")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("nh_address",
                                                "nh_address_xr",
                                                "nh_id",
                                                "nh_id_application",
                                                "nh_id_value",
                                                "nh_interf_handle",
                                                "nh_interface_name",
                                                "nh_link_type",
                                                "nh_protocol",
                                                "nh_table_id",
                                                "time_of_last_update_in_msec",
                                                "version") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.NhIds.NhId, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.NhIds.NhId, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.nh_address.is_set or
                                    self.nh_address_xr.is_set or
                                    self.nh_id.is_set or
                                    self.nh_id_application.is_set or
                                    self.nh_id_value.is_set or
                                    self.nh_interf_handle.is_set or
                                    self.nh_interface_name.is_set or
                                    self.nh_link_type.is_set or
                                    self.nh_protocol.is_set or
                                    self.nh_table_id.is_set or
                                    self.time_of_last_update_in_msec.is_set or
                                    self.version.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.nh_address.yfilter != YFilter.not_set or
                                    self.nh_address_xr.yfilter != YFilter.not_set or
                                    self.nh_id.yfilter != YFilter.not_set or
                                    self.nh_id_application.yfilter != YFilter.not_set or
                                    self.nh_id_value.yfilter != YFilter.not_set or
                                    self.nh_interf_handle.yfilter != YFilter.not_set or
                                    self.nh_interface_name.yfilter != YFilter.not_set or
                                    self.nh_link_type.yfilter != YFilter.not_set or
                                    self.nh_protocol.yfilter != YFilter.not_set or
                                    self.nh_table_id.yfilter != YFilter.not_set or
                                    self.time_of_last_update_in_msec.yfilter != YFilter.not_set or
                                    self.version.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "nh-id" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.nh_address.is_set or self.nh_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_address.get_name_leafdata())
                                if (self.nh_address_xr.is_set or self.nh_address_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_address_xr.get_name_leafdata())
                                if (self.nh_id.is_set or self.nh_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_id.get_name_leafdata())
                                if (self.nh_id_application.is_set or self.nh_id_application.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_id_application.get_name_leafdata())
                                if (self.nh_id_value.is_set or self.nh_id_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_id_value.get_name_leafdata())
                                if (self.nh_interf_handle.is_set or self.nh_interf_handle.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_interf_handle.get_name_leafdata())
                                if (self.nh_interface_name.is_set or self.nh_interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_interface_name.get_name_leafdata())
                                if (self.nh_link_type.is_set or self.nh_link_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_link_type.get_name_leafdata())
                                if (self.nh_protocol.is_set or self.nh_protocol.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_protocol.get_name_leafdata())
                                if (self.nh_table_id.is_set or self.nh_table_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.nh_table_id.get_name_leafdata())
                                if (self.time_of_last_update_in_msec.is_set or self.time_of_last_update_in_msec.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.time_of_last_update_in_msec.get_name_leafdata())
                                if (self.version.is_set or self.version.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.version.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "nh-address" or name == "nh-address-xr" or name == "nh-id" or name == "nh-id-application" or name == "nh-id-value" or name == "nh-interf-handle" or name == "nh-interface-name" or name == "nh-link-type" or name == "nh-protocol" or name == "nh-table-id" or name == "time-of-last-update-in-msec" or name == "version"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "nh-address"):
                                    self.nh_address = value
                                    self.nh_address.value_namespace = name_space
                                    self.nh_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "nh-address-xr"):
                                    self.nh_address_xr = value
                                    self.nh_address_xr.value_namespace = name_space
                                    self.nh_address_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "nh-id"):
                                    self.nh_id = value
                                    self.nh_id.value_namespace = name_space
                                    self.nh_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "nh-id-application"):
                                    self.nh_id_application = value
                                    self.nh_id_application.value_namespace = name_space
                                    self.nh_id_application.value_namespace_prefix = name_space_prefix
                                if(value_path == "nh-id-value"):
                                    self.nh_id_value = value
                                    self.nh_id_value.value_namespace = name_space
                                    self.nh_id_value.value_namespace_prefix = name_space_prefix
                                if(value_path == "nh-interf-handle"):
                                    self.nh_interf_handle = value
                                    self.nh_interf_handle.value_namespace = name_space
                                    self.nh_interf_handle.value_namespace_prefix = name_space_prefix
                                if(value_path == "nh-interface-name"):
                                    self.nh_interface_name = value
                                    self.nh_interface_name.value_namespace = name_space
                                    self.nh_interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "nh-link-type"):
                                    self.nh_link_type = value
                                    self.nh_link_type.value_namespace = name_space
                                    self.nh_link_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "nh-protocol"):
                                    self.nh_protocol = value
                                    self.nh_protocol.value_namespace = name_space
                                    self.nh_protocol.value_namespace_prefix = name_space_prefix
                                if(value_path == "nh-table-id"):
                                    self.nh_table_id = value
                                    self.nh_table_id.value_namespace = name_space
                                    self.nh_table_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "time-of-last-update-in-msec"):
                                    self.time_of_last_update_in_msec = value
                                    self.time_of_last_update_in_msec.value_namespace = name_space
                                    self.time_of_last_update_in_msec.value_namespace_prefix = name_space_prefix
                                if(value_path == "version"):
                                    self.version = value
                                    self.version.value_namespace = name_space
                                    self.version.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.nh_id:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.nh_id:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "nh-ids" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "nh-id"):
                                for c in self.nh_id:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.NhIds.NhId()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.nh_id.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "nh-id"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class ExternalClientSummaries(Entity):
                        """
                        External Client Summary Table
                        
                        .. attribute:: external_client_summary
                        
                        	Summary of the external clients
                        	**type**\: list of    :py:class:`ExternalClientSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries, self).__init__()

                            self.yang_name = "external-client-summaries"
                            self.yang_parent_name = "protocol"

                            self.external_client_summary = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries, self).__setattr__(name, value)


                        class ExternalClientSummary(Entity):
                            """
                            Summary of the external clients
                            
                            .. attribute:: ecd_ver
                            
                            	Ecd Version
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: id
                            
                            	ID of the client\: ECDv1 is component id, ECDv2 is client id
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            .. attribute:: ses_client_name
                            
                            	External client name
                            	**type**\:  str
                            
                            .. attribute:: ses_client_pulsed_time
                            
                            	Client pulsed timestamp
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: ses_comp_id
                            
                            	component\-id of the client
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ses_ecd_version
                            
                            	ECD version
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ses_feci_fib_proto
                            
                            	Registration proto
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ses_num_pending
                            
                            	Number of pending notifs
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ses_num_regs
                            
                            	Number of registrations
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ses_pl_sum
                            
                            	ECD pathlist summary
                            	**type**\:   :py:class:`SesPlSum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum>`
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary, self).__init__()

                                self.yang_name = "external-client-summary"
                                self.yang_parent_name = "external-client-summaries"

                                self.ecd_ver = YLeaf(YType.int32, "ecd-ver")

                                self.id = YLeaf(YType.int32, "id")

                                self.ses_client_name = YLeaf(YType.str, "ses-client-name")

                                self.ses_client_pulsed_time = YLeaf(YType.uint64, "ses-client-pulsed-time")

                                self.ses_comp_id = YLeaf(YType.uint32, "ses-comp-id")

                                self.ses_ecd_version = YLeaf(YType.uint32, "ses-ecd-version")

                                self.ses_feci_fib_proto = YLeaf(YType.uint32, "ses-feci-fib-proto")

                                self.ses_num_pending = YLeaf(YType.uint32, "ses-num-pending")

                                self.ses_num_regs = YLeaf(YType.uint32, "ses-num-regs")

                                self.ses_pl_sum = Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum()
                                self.ses_pl_sum.parent = self
                                self._children_name_map["ses_pl_sum"] = "ses-pl-sum"
                                self._children_yang_names.add("ses-pl-sum")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ecd_ver",
                                                "id",
                                                "ses_client_name",
                                                "ses_client_pulsed_time",
                                                "ses_comp_id",
                                                "ses_ecd_version",
                                                "ses_feci_fib_proto",
                                                "ses_num_pending",
                                                "ses_num_regs") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary, self).__setattr__(name, value)


                            class SesPlSum(Entity):
                                """
                                ECD pathlist summary
                                
                                .. attribute:: sep_num_ecd_pathlist
                                
                                	Number of ECD pathlists
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: sep_num_ecd_pl_per_interest
                                
                                	Number of ECD pathlists per interest
                                	**type**\: list of    :py:class:`SepNumEcdPlPerInterest <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum.SepNumEcdPlPerInterest>`
                                
                                .. attribute:: sep_num_ecd_pl_unresolved
                                
                                	Number of ECD pathlists unresolved
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum, self).__init__()

                                    self.yang_name = "ses-pl-sum"
                                    self.yang_parent_name = "external-client-summary"

                                    self.sep_num_ecd_pathlist = YLeaf(YType.uint32, "sep-num-ecd-pathlist")

                                    self.sep_num_ecd_pl_unresolved = YLeaf(YType.uint32, "sep-num-ecd-pl-unresolved")

                                    self.sep_num_ecd_pl_per_interest = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("sep_num_ecd_pathlist",
                                                    "sep_num_ecd_pl_unresolved") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum, self).__setattr__(name, value)


                                class SepNumEcdPlPerInterest(Entity):
                                    """
                                    Number of ECD pathlists per interest
                                    
                                    .. attribute:: entry
                                    
                                    	
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum.SepNumEcdPlPerInterest, self).__init__()

                                        self.yang_name = "sep-num-ecd-pl-per-interest"
                                        self.yang_parent_name = "ses-pl-sum"

                                        self.entry = YLeaf(YType.uint32, "entry")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("entry") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum.SepNumEcdPlPerInterest, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum.SepNumEcdPlPerInterest, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.entry.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.entry.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "sep-num-ecd-pl-per-interest" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "entry"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "entry"):
                                            self.entry = value
                                            self.entry.value_namespace = name_space
                                            self.entry.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.sep_num_ecd_pl_per_interest:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.sep_num_ecd_pathlist.is_set or
                                        self.sep_num_ecd_pl_unresolved.is_set)

                                def has_operation(self):
                                    for c in self.sep_num_ecd_pl_per_interest:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.sep_num_ecd_pathlist.yfilter != YFilter.not_set or
                                        self.sep_num_ecd_pl_unresolved.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ses-pl-sum" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.sep_num_ecd_pathlist.is_set or self.sep_num_ecd_pathlist.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.sep_num_ecd_pathlist.get_name_leafdata())
                                    if (self.sep_num_ecd_pl_unresolved.is_set or self.sep_num_ecd_pl_unresolved.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.sep_num_ecd_pl_unresolved.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "sep-num-ecd-pl-per-interest"):
                                        for c in self.sep_num_ecd_pl_per_interest:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum.SepNumEcdPlPerInterest()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.sep_num_ecd_pl_per_interest.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "sep-num-ecd-pl-per-interest" or name == "sep-num-ecd-pathlist" or name == "sep-num-ecd-pl-unresolved"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "sep-num-ecd-pathlist"):
                                        self.sep_num_ecd_pathlist = value
                                        self.sep_num_ecd_pathlist.value_namespace = name_space
                                        self.sep_num_ecd_pathlist.value_namespace_prefix = name_space_prefix
                                    if(value_path == "sep-num-ecd-pl-unresolved"):
                                        self.sep_num_ecd_pl_unresolved = value
                                        self.sep_num_ecd_pl_unresolved.value_namespace = name_space
                                        self.sep_num_ecd_pl_unresolved.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.ecd_ver.is_set or
                                    self.id.is_set or
                                    self.ses_client_name.is_set or
                                    self.ses_client_pulsed_time.is_set or
                                    self.ses_comp_id.is_set or
                                    self.ses_ecd_version.is_set or
                                    self.ses_feci_fib_proto.is_set or
                                    self.ses_num_pending.is_set or
                                    self.ses_num_regs.is_set or
                                    (self.ses_pl_sum is not None and self.ses_pl_sum.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ecd_ver.yfilter != YFilter.not_set or
                                    self.id.yfilter != YFilter.not_set or
                                    self.ses_client_name.yfilter != YFilter.not_set or
                                    self.ses_client_pulsed_time.yfilter != YFilter.not_set or
                                    self.ses_comp_id.yfilter != YFilter.not_set or
                                    self.ses_ecd_version.yfilter != YFilter.not_set or
                                    self.ses_feci_fib_proto.yfilter != YFilter.not_set or
                                    self.ses_num_pending.yfilter != YFilter.not_set or
                                    self.ses_num_regs.yfilter != YFilter.not_set or
                                    (self.ses_pl_sum is not None and self.ses_pl_sum.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "external-client-summary" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ecd_ver.is_set or self.ecd_ver.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ecd_ver.get_name_leafdata())
                                if (self.id.is_set or self.id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.id.get_name_leafdata())
                                if (self.ses_client_name.is_set or self.ses_client_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ses_client_name.get_name_leafdata())
                                if (self.ses_client_pulsed_time.is_set or self.ses_client_pulsed_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ses_client_pulsed_time.get_name_leafdata())
                                if (self.ses_comp_id.is_set or self.ses_comp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ses_comp_id.get_name_leafdata())
                                if (self.ses_ecd_version.is_set or self.ses_ecd_version.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ses_ecd_version.get_name_leafdata())
                                if (self.ses_feci_fib_proto.is_set or self.ses_feci_fib_proto.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ses_feci_fib_proto.get_name_leafdata())
                                if (self.ses_num_pending.is_set or self.ses_num_pending.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ses_num_pending.get_name_leafdata())
                                if (self.ses_num_regs.is_set or self.ses_num_regs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ses_num_regs.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "ses-pl-sum"):
                                    if (self.ses_pl_sum is None):
                                        self.ses_pl_sum = Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary.SesPlSum()
                                        self.ses_pl_sum.parent = self
                                        self._children_name_map["ses_pl_sum"] = "ses-pl-sum"
                                    return self.ses_pl_sum

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ses-pl-sum" or name == "ecd-ver" or name == "id" or name == "ses-client-name" or name == "ses-client-pulsed-time" or name == "ses-comp-id" or name == "ses-ecd-version" or name == "ses-feci-fib-proto" or name == "ses-num-pending" or name == "ses-num-regs"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ecd-ver"):
                                    self.ecd_ver = value
                                    self.ecd_ver.value_namespace = name_space
                                    self.ecd_ver.value_namespace_prefix = name_space_prefix
                                if(value_path == "id"):
                                    self.id = value
                                    self.id.value_namespace = name_space
                                    self.id.value_namespace_prefix = name_space_prefix
                                if(value_path == "ses-client-name"):
                                    self.ses_client_name = value
                                    self.ses_client_name.value_namespace = name_space
                                    self.ses_client_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "ses-client-pulsed-time"):
                                    self.ses_client_pulsed_time = value
                                    self.ses_client_pulsed_time.value_namespace = name_space
                                    self.ses_client_pulsed_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "ses-comp-id"):
                                    self.ses_comp_id = value
                                    self.ses_comp_id.value_namespace = name_space
                                    self.ses_comp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "ses-ecd-version"):
                                    self.ses_ecd_version = value
                                    self.ses_ecd_version.value_namespace = name_space
                                    self.ses_ecd_version.value_namespace_prefix = name_space_prefix
                                if(value_path == "ses-feci-fib-proto"):
                                    self.ses_feci_fib_proto = value
                                    self.ses_feci_fib_proto.value_namespace = name_space
                                    self.ses_feci_fib_proto.value_namespace_prefix = name_space_prefix
                                if(value_path == "ses-num-pending"):
                                    self.ses_num_pending = value
                                    self.ses_num_pending.value_namespace = name_space
                                    self.ses_num_pending.value_namespace_prefix = name_space_prefix
                                if(value_path == "ses-num-regs"):
                                    self.ses_num_regs = value
                                    self.ses_num_regs.value_namespace = name_space
                                    self.ses_num_regs.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.external_client_summary:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.external_client_summary:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "external-client-summaries" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "external-client-summary"):
                                for c in self.external_client_summary:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries.ExternalClientSummary()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.external_client_summary.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "external-client-summary"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Misc(Entity):
                        """
                        CEF misc hidden data
                        
                        .. attribute:: mi_clock_time
                        
                        	clock download time
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: mi_cpu_time
                        
                        	CPU download time
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: mi_cpuless_count
                        
                        	count of cpuless line cards
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mi_cpuless_init
                        
                        	cpuless node list init
                        	**type**\:  bool
                        
                        .. attribute:: mi_cpuless_node
                        
                        	list of cpuless line cards
                        	**type**\: list of    :py:class:`MiCpulessNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiCpulessNode>`
                        
                        .. attribute:: mi_del
                        
                        	Timestamps of deleted routes
                        	**type**\: list of    :py:class:`MiDel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiDel>`
                        
                        .. attribute:: mi_frr_stat
                        
                        	FRR statistics
                        	**type**\: list of    :py:class:`MiFrrStat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiFrrStat>`
                        
                        .. attribute:: mi_idb_ext_cleanup_failed_count
                        
                        	Number of recycled idb extensions that failed  cleanup
                        	**type**\: list of    :py:class:`MiIdbExtCleanupFailedCount <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbExtCleanupFailedCount>`
                        
                        .. attribute:: mi_idb_lsec_enabled_num
                        
                        	Number of interfaces having label security  enabled
                        	**type**\: list of    :py:class:`MiIdbLsecEnabledNum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbLsecEnabledNum>`
                        
                        .. attribute:: mi_idb_purge_cntr
                        
                        	the number of counters used for purge counter stats
                        	**type**\: list of    :py:class:`MiIdbPurgeCntr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr>`
                        
                        .. attribute:: mi_idb_recycle_cleanup_count
                        
                        	Number of idb cleaned up after hitting ifh recycle
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mi_idb_recycle_count
                        
                        	Number of idbs that hit ifh recycle
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mi_issu_state
                        
                        	FIB ISSU state
                        	**type**\:   :py:class:`MiIssuState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState>`
                        
                        .. attribute:: mi_lrpf_num
                        
                        	Per protocol number of label RPFs
                        	**type**\: list of    :py:class:`MiLrpfNum <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfNum>`
                        
                        .. attribute:: mi_lrpf_stats_act
                        
                        	Per protocol actions stats for label RPF
                        	**type**\: list of    :py:class:`MiLrpfStatsAct <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsAct>`
                        
                        .. attribute:: mi_lrpf_stats_fail
                        
                        	Per protocol Failure stats for label RPF
                        	**type**\: list of    :py:class:`MiLrpfStatsFail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsFail>`
                        
                        .. attribute:: mi_num_lisp_eid
                        
                        	number of LISP EID prefixes
                        	**type**\: list of    :py:class:`MiNumLispEid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispEid>`
                        
                        .. attribute:: mi_num_lisp_valid_eid
                        
                        	number of LISP EID prefixes eligible for  forwarding
                        	**type**\: list of    :py:class:`MiNumLispValidEid <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispValidEid>`
                        
                        .. attribute:: mi_num_mgmt_list
                        
                        	Number of management interfaces
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mi_num_virtual_ll_addresses_added
                        
                        	mi num virtual ll addresses added
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mi_num_virtual_ll_addresses_cached
                        
                        	mi num virtual ll addresses cached
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mi_num_virtual_ll_addresses_deleted
                        
                        	mi num virtual ll addresses deleted
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mi_num_virtual_ll_addresses_dropped
                        
                        	mi num virtual ll addresses dropped
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: mi_pfi_ifh_del
                        
                        	number of pfi ifh delete notif
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: mi_pfi_ifh_stale
                        
                        	number of stale ifh removed
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: mi_pfi_ifh_upd
                        
                        	number of pfi ifh create notif
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: mi_plat_capabilities
                        
                        	FIB platform capabilities
                        	**type**\:   :py:class:`MiPlatCapabilities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities>`
                        
                        .. attribute:: mi_prefer_aib_routes_over_rib_cfg
                        
                        	Prefer AIB routes over RIB/LSD configured state
                        	**type**\:  bool
                        
                        .. attribute:: mi_prefer_aib_routes_over_rib_oper
                        
                        	Prefer AIB routes over RIB/LSD operational state
                        	**type**\:  bool
                        
                        .. attribute:: mi_proto_dbg_stat
                        
                        	Per protocol debug stats
                        	**type**\: list of    :py:class:`MiProtoDbgStat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat>`
                        
                        .. attribute:: mi_shm_reset_ts
                        
                        	Last FIB shared memory reset time stamp
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: mi_tot_dnld_time
                        
                        	total download time
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: mi_tot_gtrie_time
                        
                        	total time spent in gtrie operations
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: mi_tot_plat_upd_time
                        
                        	total platform update time
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: mi_xpl_ldi_enabled
                        
                        	XPL loadinfo is enabled
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.Misc, self).__init__()

                            self.yang_name = "misc"
                            self.yang_parent_name = "protocol"

                            self.mi_clock_time = YLeaf(YType.uint64, "mi-clock-time")

                            self.mi_cpu_time = YLeaf(YType.uint64, "mi-cpu-time")

                            self.mi_cpuless_count = YLeaf(YType.uint32, "mi-cpuless-count")

                            self.mi_cpuless_init = YLeaf(YType.boolean, "mi-cpuless-init")

                            self.mi_idb_recycle_cleanup_count = YLeaf(YType.uint32, "mi-idb-recycle-cleanup-count")

                            self.mi_idb_recycle_count = YLeaf(YType.uint32, "mi-idb-recycle-count")

                            self.mi_num_mgmt_list = YLeaf(YType.uint32, "mi-num-mgmt-list")

                            self.mi_num_virtual_ll_addresses_added = YLeaf(YType.uint32, "mi-num-virtual-ll-addresses-added")

                            self.mi_num_virtual_ll_addresses_cached = YLeaf(YType.uint32, "mi-num-virtual-ll-addresses-cached")

                            self.mi_num_virtual_ll_addresses_deleted = YLeaf(YType.uint32, "mi-num-virtual-ll-addresses-deleted")

                            self.mi_num_virtual_ll_addresses_dropped = YLeaf(YType.uint32, "mi-num-virtual-ll-addresses-dropped")

                            self.mi_pfi_ifh_del = YLeaf(YType.uint64, "mi-pfi-ifh-del")

                            self.mi_pfi_ifh_stale = YLeaf(YType.uint64, "mi-pfi-ifh-stale")

                            self.mi_pfi_ifh_upd = YLeaf(YType.uint64, "mi-pfi-ifh-upd")

                            self.mi_prefer_aib_routes_over_rib_cfg = YLeaf(YType.boolean, "mi-prefer-aib-routes-over-rib-cfg")

                            self.mi_prefer_aib_routes_over_rib_oper = YLeaf(YType.boolean, "mi-prefer-aib-routes-over-rib-oper")

                            self.mi_shm_reset_ts = YLeaf(YType.uint64, "mi-shm-reset-ts")

                            self.mi_tot_dnld_time = YLeaf(YType.uint64, "mi-tot-dnld-time")

                            self.mi_tot_gtrie_time = YLeaf(YType.uint64, "mi-tot-gtrie-time")

                            self.mi_tot_plat_upd_time = YLeaf(YType.uint64, "mi-tot-plat-upd-time")

                            self.mi_xpl_ldi_enabled = YLeaf(YType.boolean, "mi-xpl-ldi-enabled")

                            self.mi_issu_state = Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState()
                            self.mi_issu_state.parent = self
                            self._children_name_map["mi_issu_state"] = "mi-issu-state"
                            self._children_yang_names.add("mi-issu-state")

                            self.mi_plat_capabilities = Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities()
                            self.mi_plat_capabilities.parent = self
                            self._children_name_map["mi_plat_capabilities"] = "mi-plat-capabilities"
                            self._children_yang_names.add("mi-plat-capabilities")

                            self.mi_cpuless_node = YList(self)
                            self.mi_del = YList(self)
                            self.mi_frr_stat = YList(self)
                            self.mi_idb_ext_cleanup_failed_count = YList(self)
                            self.mi_idb_lsec_enabled_num = YList(self)
                            self.mi_idb_purge_cntr = YList(self)
                            self.mi_lrpf_num = YList(self)
                            self.mi_lrpf_stats_act = YList(self)
                            self.mi_lrpf_stats_fail = YList(self)
                            self.mi_num_lisp_eid = YList(self)
                            self.mi_num_lisp_valid_eid = YList(self)
                            self.mi_proto_dbg_stat = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("mi_clock_time",
                                            "mi_cpu_time",
                                            "mi_cpuless_count",
                                            "mi_cpuless_init",
                                            "mi_idb_recycle_cleanup_count",
                                            "mi_idb_recycle_count",
                                            "mi_num_mgmt_list",
                                            "mi_num_virtual_ll_addresses_added",
                                            "mi_num_virtual_ll_addresses_cached",
                                            "mi_num_virtual_ll_addresses_deleted",
                                            "mi_num_virtual_ll_addresses_dropped",
                                            "mi_pfi_ifh_del",
                                            "mi_pfi_ifh_stale",
                                            "mi_pfi_ifh_upd",
                                            "mi_prefer_aib_routes_over_rib_cfg",
                                            "mi_prefer_aib_routes_over_rib_oper",
                                            "mi_shm_reset_ts",
                                            "mi_tot_dnld_time",
                                            "mi_tot_gtrie_time",
                                            "mi_tot_plat_upd_time",
                                            "mi_xpl_ldi_enabled") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc, self).__setattr__(name, value)


                        class MiIssuState(Entity):
                            """
                            FIB ISSU state
                            
                            .. attribute:: eoc_received_imdr_time_stamp
                            
                            	End\-of\-config received from IMDR timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: eoc_received_slc_time_stamp
                            
                            	End\-of\-config received from SLC timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: eod_received_im_time_stamp
                            
                            	End\-of\-download received from IM timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: eod_sent_imdr_time_stamp
                            
                            	End\-of\-download send to IMDR timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: eod_sent_slc_time_stamp
                            
                            	End\-of\-download send to SLC timestamp
                            	**type**\:  str
                            
                            	**length:** 0..33
                            
                            .. attribute:: fis_issu_error_ts
                            
                            	ISSU error sent to ISSUMGR timetstamp
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fis_issu_restart
                            
                            	ISSU restart
                            	**type**\:  bool
                            
                            .. attribute:: fis_proto_state
                            
                            	IMDR state for the protocols
                            	**type**\: list of    :py:class:`FisProtoState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState.FisProtoState>`
                            
                            .. attribute:: imdr_eoc_implicit
                            
                            	IMDR End\-of\-config implicit
                            	**type**\:  bool
                            
                            .. attribute:: imdr_support
                            
                            	IMDR supported
                            	**type**\:  bool
                            
                            .. attribute:: slc_eoc_implicit
                            
                            	SLC End\-of\-config implicit
                            	**type**\:  bool
                            
                            .. attribute:: slc_support
                            
                            	SLC supported
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState, self).__init__()

                                self.yang_name = "mi-issu-state"
                                self.yang_parent_name = "misc"

                                self.eoc_received_imdr_time_stamp = YLeaf(YType.str, "eoc-received-imdr-time-stamp")

                                self.eoc_received_slc_time_stamp = YLeaf(YType.str, "eoc-received-slc-time-stamp")

                                self.eod_received_im_time_stamp = YLeaf(YType.str, "eod-received-im-time-stamp")

                                self.eod_sent_imdr_time_stamp = YLeaf(YType.str, "eod-sent-imdr-time-stamp")

                                self.eod_sent_slc_time_stamp = YLeaf(YType.str, "eod-sent-slc-time-stamp")

                                self.fis_issu_error_ts = YLeaf(YType.uint64, "fis-issu-error-ts")

                                self.fis_issu_restart = YLeaf(YType.boolean, "fis-issu-restart")

                                self.imdr_eoc_implicit = YLeaf(YType.boolean, "imdr-eoc-implicit")

                                self.imdr_support = YLeaf(YType.boolean, "imdr-support")

                                self.slc_eoc_implicit = YLeaf(YType.boolean, "slc-eoc-implicit")

                                self.slc_support = YLeaf(YType.boolean, "slc-support")

                                self.fis_proto_state = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("eoc_received_imdr_time_stamp",
                                                "eoc_received_slc_time_stamp",
                                                "eod_received_im_time_stamp",
                                                "eod_sent_imdr_time_stamp",
                                                "eod_sent_slc_time_stamp",
                                                "fis_issu_error_ts",
                                                "fis_issu_restart",
                                                "imdr_eoc_implicit",
                                                "imdr_support",
                                                "slc_eoc_implicit",
                                                "slc_support") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState, self).__setattr__(name, value)


                            class FisProtoState(Entity):
                                """
                                IMDR state for the protocols
                                
                                .. attribute:: aib_eod_time_stamp
                                
                                	AIB EODTimeStamp
                                	**type**\:  str
                                
                                	**length:** 0..33
                                
                                .. attribute:: bcdl_tables
                                
                                	Number of BCDL tables
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: converged_tables
                                
                                	Number of tables converged
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: lmrib_eod_time_stamp
                                
                                	LMRIB EOD received timestamp
                                	**type**\:  str
                                
                                	**length:** 0..33
                                
                                .. attribute:: lmrib_eod_valid
                                
                                	LMRIB EOD expected/valid
                                	**type**\:  bool
                                
                                .. attribute:: lsd_eod_time_stamp
                                
                                	LSD EOD received timestamp
                                	**type**\:  str
                                
                                	**length:** 0..33
                                
                                .. attribute:: lsd_eod_valid
                                
                                	LSD EOD expected/valid
                                	**type**\:  bool
                                
                                .. attribute:: protocol_eod_time_stamp
                                
                                	Protocol EOD sent timestamp
                                	**type**\:  str
                                
                                	**length:** 0..33
                                
                                .. attribute:: protocol_eod_valid
                                
                                	Protocol EOD expected/valid
                                	**type**\:  bool
                                
                                .. attribute:: protocol_name
                                
                                	Protocol name
                                	**type**\:  str
                                
                                	**length:** 0..6
                                
                                .. attribute:: rib_info_valid
                                
                                	RIB table info valid
                                	**type**\:  bool
                                
                                .. attribute:: rib_tables_converged_time_stamp
                                
                                	All RIB tables converged timestamp
                                	**type**\:  str
                                
                                	**length:** 0..33
                                
                                .. attribute:: rsi_eod_time_stamp
                                
                                	RSI EOD received timestamp
                                	**type**\:  str
                                
                                	**length:** 0..33
                                
                                .. attribute:: rsi_eod_valid
                                
                                	RSI EOD expected/valid
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState.FisProtoState, self).__init__()

                                    self.yang_name = "fis-proto-state"
                                    self.yang_parent_name = "mi-issu-state"

                                    self.aib_eod_time_stamp = YLeaf(YType.str, "aib-eod-time-stamp")

                                    self.bcdl_tables = YLeaf(YType.uint32, "bcdl-tables")

                                    self.converged_tables = YLeaf(YType.uint32, "converged-tables")

                                    self.lmrib_eod_time_stamp = YLeaf(YType.str, "lmrib-eod-time-stamp")

                                    self.lmrib_eod_valid = YLeaf(YType.boolean, "lmrib-eod-valid")

                                    self.lsd_eod_time_stamp = YLeaf(YType.str, "lsd-eod-time-stamp")

                                    self.lsd_eod_valid = YLeaf(YType.boolean, "lsd-eod-valid")

                                    self.protocol_eod_time_stamp = YLeaf(YType.str, "protocol-eod-time-stamp")

                                    self.protocol_eod_valid = YLeaf(YType.boolean, "protocol-eod-valid")

                                    self.protocol_name = YLeaf(YType.str, "protocol-name")

                                    self.rib_info_valid = YLeaf(YType.boolean, "rib-info-valid")

                                    self.rib_tables_converged_time_stamp = YLeaf(YType.str, "rib-tables-converged-time-stamp")

                                    self.rsi_eod_time_stamp = YLeaf(YType.str, "rsi-eod-time-stamp")

                                    self.rsi_eod_valid = YLeaf(YType.boolean, "rsi-eod-valid")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("aib_eod_time_stamp",
                                                    "bcdl_tables",
                                                    "converged_tables",
                                                    "lmrib_eod_time_stamp",
                                                    "lmrib_eod_valid",
                                                    "lsd_eod_time_stamp",
                                                    "lsd_eod_valid",
                                                    "protocol_eod_time_stamp",
                                                    "protocol_eod_valid",
                                                    "protocol_name",
                                                    "rib_info_valid",
                                                    "rib_tables_converged_time_stamp",
                                                    "rsi_eod_time_stamp",
                                                    "rsi_eod_valid") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState.FisProtoState, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState.FisProtoState, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.aib_eod_time_stamp.is_set or
                                        self.bcdl_tables.is_set or
                                        self.converged_tables.is_set or
                                        self.lmrib_eod_time_stamp.is_set or
                                        self.lmrib_eod_valid.is_set or
                                        self.lsd_eod_time_stamp.is_set or
                                        self.lsd_eod_valid.is_set or
                                        self.protocol_eod_time_stamp.is_set or
                                        self.protocol_eod_valid.is_set or
                                        self.protocol_name.is_set or
                                        self.rib_info_valid.is_set or
                                        self.rib_tables_converged_time_stamp.is_set or
                                        self.rsi_eod_time_stamp.is_set or
                                        self.rsi_eod_valid.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.aib_eod_time_stamp.yfilter != YFilter.not_set or
                                        self.bcdl_tables.yfilter != YFilter.not_set or
                                        self.converged_tables.yfilter != YFilter.not_set or
                                        self.lmrib_eod_time_stamp.yfilter != YFilter.not_set or
                                        self.lmrib_eod_valid.yfilter != YFilter.not_set or
                                        self.lsd_eod_time_stamp.yfilter != YFilter.not_set or
                                        self.lsd_eod_valid.yfilter != YFilter.not_set or
                                        self.protocol_eod_time_stamp.yfilter != YFilter.not_set or
                                        self.protocol_eod_valid.yfilter != YFilter.not_set or
                                        self.protocol_name.yfilter != YFilter.not_set or
                                        self.rib_info_valid.yfilter != YFilter.not_set or
                                        self.rib_tables_converged_time_stamp.yfilter != YFilter.not_set or
                                        self.rsi_eod_time_stamp.yfilter != YFilter.not_set or
                                        self.rsi_eod_valid.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fis-proto-state" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.aib_eod_time_stamp.is_set or self.aib_eod_time_stamp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.aib_eod_time_stamp.get_name_leafdata())
                                    if (self.bcdl_tables.is_set or self.bcdl_tables.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.bcdl_tables.get_name_leafdata())
                                    if (self.converged_tables.is_set or self.converged_tables.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.converged_tables.get_name_leafdata())
                                    if (self.lmrib_eod_time_stamp.is_set or self.lmrib_eod_time_stamp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lmrib_eod_time_stamp.get_name_leafdata())
                                    if (self.lmrib_eod_valid.is_set or self.lmrib_eod_valid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lmrib_eod_valid.get_name_leafdata())
                                    if (self.lsd_eod_time_stamp.is_set or self.lsd_eod_time_stamp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsd_eod_time_stamp.get_name_leafdata())
                                    if (self.lsd_eod_valid.is_set or self.lsd_eod_valid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsd_eod_valid.get_name_leafdata())
                                    if (self.protocol_eod_time_stamp.is_set or self.protocol_eod_time_stamp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.protocol_eod_time_stamp.get_name_leafdata())
                                    if (self.protocol_eod_valid.is_set or self.protocol_eod_valid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.protocol_eod_valid.get_name_leafdata())
                                    if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.protocol_name.get_name_leafdata())
                                    if (self.rib_info_valid.is_set or self.rib_info_valid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.rib_info_valid.get_name_leafdata())
                                    if (self.rib_tables_converged_time_stamp.is_set or self.rib_tables_converged_time_stamp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.rib_tables_converged_time_stamp.get_name_leafdata())
                                    if (self.rsi_eod_time_stamp.is_set or self.rsi_eod_time_stamp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.rsi_eod_time_stamp.get_name_leafdata())
                                    if (self.rsi_eod_valid.is_set or self.rsi_eod_valid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.rsi_eod_valid.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "aib-eod-time-stamp" or name == "bcdl-tables" or name == "converged-tables" or name == "lmrib-eod-time-stamp" or name == "lmrib-eod-valid" or name == "lsd-eod-time-stamp" or name == "lsd-eod-valid" or name == "protocol-eod-time-stamp" or name == "protocol-eod-valid" or name == "protocol-name" or name == "rib-info-valid" or name == "rib-tables-converged-time-stamp" or name == "rsi-eod-time-stamp" or name == "rsi-eod-valid"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "aib-eod-time-stamp"):
                                        self.aib_eod_time_stamp = value
                                        self.aib_eod_time_stamp.value_namespace = name_space
                                        self.aib_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "bcdl-tables"):
                                        self.bcdl_tables = value
                                        self.bcdl_tables.value_namespace = name_space
                                        self.bcdl_tables.value_namespace_prefix = name_space_prefix
                                    if(value_path == "converged-tables"):
                                        self.converged_tables = value
                                        self.converged_tables.value_namespace = name_space
                                        self.converged_tables.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lmrib-eod-time-stamp"):
                                        self.lmrib_eod_time_stamp = value
                                        self.lmrib_eod_time_stamp.value_namespace = name_space
                                        self.lmrib_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lmrib-eod-valid"):
                                        self.lmrib_eod_valid = value
                                        self.lmrib_eod_valid.value_namespace = name_space
                                        self.lmrib_eod_valid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsd-eod-time-stamp"):
                                        self.lsd_eod_time_stamp = value
                                        self.lsd_eod_time_stamp.value_namespace = name_space
                                        self.lsd_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsd-eod-valid"):
                                        self.lsd_eod_valid = value
                                        self.lsd_eod_valid.value_namespace = name_space
                                        self.lsd_eod_valid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "protocol-eod-time-stamp"):
                                        self.protocol_eod_time_stamp = value
                                        self.protocol_eod_time_stamp.value_namespace = name_space
                                        self.protocol_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "protocol-eod-valid"):
                                        self.protocol_eod_valid = value
                                        self.protocol_eod_valid.value_namespace = name_space
                                        self.protocol_eod_valid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "protocol-name"):
                                        self.protocol_name = value
                                        self.protocol_name.value_namespace = name_space
                                        self.protocol_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "rib-info-valid"):
                                        self.rib_info_valid = value
                                        self.rib_info_valid.value_namespace = name_space
                                        self.rib_info_valid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "rib-tables-converged-time-stamp"):
                                        self.rib_tables_converged_time_stamp = value
                                        self.rib_tables_converged_time_stamp.value_namespace = name_space
                                        self.rib_tables_converged_time_stamp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "rsi-eod-time-stamp"):
                                        self.rsi_eod_time_stamp = value
                                        self.rsi_eod_time_stamp.value_namespace = name_space
                                        self.rsi_eod_time_stamp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "rsi-eod-valid"):
                                        self.rsi_eod_valid = value
                                        self.rsi_eod_valid.value_namespace = name_space
                                        self.rsi_eod_valid.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.fis_proto_state:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.eoc_received_imdr_time_stamp.is_set or
                                    self.eoc_received_slc_time_stamp.is_set or
                                    self.eod_received_im_time_stamp.is_set or
                                    self.eod_sent_imdr_time_stamp.is_set or
                                    self.eod_sent_slc_time_stamp.is_set or
                                    self.fis_issu_error_ts.is_set or
                                    self.fis_issu_restart.is_set or
                                    self.imdr_eoc_implicit.is_set or
                                    self.imdr_support.is_set or
                                    self.slc_eoc_implicit.is_set or
                                    self.slc_support.is_set)

                            def has_operation(self):
                                for c in self.fis_proto_state:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.eoc_received_imdr_time_stamp.yfilter != YFilter.not_set or
                                    self.eoc_received_slc_time_stamp.yfilter != YFilter.not_set or
                                    self.eod_received_im_time_stamp.yfilter != YFilter.not_set or
                                    self.eod_sent_imdr_time_stamp.yfilter != YFilter.not_set or
                                    self.eod_sent_slc_time_stamp.yfilter != YFilter.not_set or
                                    self.fis_issu_error_ts.yfilter != YFilter.not_set or
                                    self.fis_issu_restart.yfilter != YFilter.not_set or
                                    self.imdr_eoc_implicit.yfilter != YFilter.not_set or
                                    self.imdr_support.yfilter != YFilter.not_set or
                                    self.slc_eoc_implicit.yfilter != YFilter.not_set or
                                    self.slc_support.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-issu-state" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.eoc_received_imdr_time_stamp.is_set or self.eoc_received_imdr_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eoc_received_imdr_time_stamp.get_name_leafdata())
                                if (self.eoc_received_slc_time_stamp.is_set or self.eoc_received_slc_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eoc_received_slc_time_stamp.get_name_leafdata())
                                if (self.eod_received_im_time_stamp.is_set or self.eod_received_im_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eod_received_im_time_stamp.get_name_leafdata())
                                if (self.eod_sent_imdr_time_stamp.is_set or self.eod_sent_imdr_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eod_sent_imdr_time_stamp.get_name_leafdata())
                                if (self.eod_sent_slc_time_stamp.is_set or self.eod_sent_slc_time_stamp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eod_sent_slc_time_stamp.get_name_leafdata())
                                if (self.fis_issu_error_ts.is_set or self.fis_issu_error_ts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fis_issu_error_ts.get_name_leafdata())
                                if (self.fis_issu_restart.is_set or self.fis_issu_restart.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fis_issu_restart.get_name_leafdata())
                                if (self.imdr_eoc_implicit.is_set or self.imdr_eoc_implicit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.imdr_eoc_implicit.get_name_leafdata())
                                if (self.imdr_support.is_set or self.imdr_support.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.imdr_support.get_name_leafdata())
                                if (self.slc_eoc_implicit.is_set or self.slc_eoc_implicit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slc_eoc_implicit.get_name_leafdata())
                                if (self.slc_support.is_set or self.slc_support.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slc_support.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "fis-proto-state"):
                                    for c in self.fis_proto_state:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState.FisProtoState()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fis_proto_state.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fis-proto-state" or name == "eoc-received-imdr-time-stamp" or name == "eoc-received-slc-time-stamp" or name == "eod-received-im-time-stamp" or name == "eod-sent-imdr-time-stamp" or name == "eod-sent-slc-time-stamp" or name == "fis-issu-error-ts" or name == "fis-issu-restart" or name == "imdr-eoc-implicit" or name == "imdr-support" or name == "slc-eoc-implicit" or name == "slc-support"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "eoc-received-imdr-time-stamp"):
                                    self.eoc_received_imdr_time_stamp = value
                                    self.eoc_received_imdr_time_stamp.value_namespace = name_space
                                    self.eoc_received_imdr_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "eoc-received-slc-time-stamp"):
                                    self.eoc_received_slc_time_stamp = value
                                    self.eoc_received_slc_time_stamp.value_namespace = name_space
                                    self.eoc_received_slc_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "eod-received-im-time-stamp"):
                                    self.eod_received_im_time_stamp = value
                                    self.eod_received_im_time_stamp.value_namespace = name_space
                                    self.eod_received_im_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "eod-sent-imdr-time-stamp"):
                                    self.eod_sent_imdr_time_stamp = value
                                    self.eod_sent_imdr_time_stamp.value_namespace = name_space
                                    self.eod_sent_imdr_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "eod-sent-slc-time-stamp"):
                                    self.eod_sent_slc_time_stamp = value
                                    self.eod_sent_slc_time_stamp.value_namespace = name_space
                                    self.eod_sent_slc_time_stamp.value_namespace_prefix = name_space_prefix
                                if(value_path == "fis-issu-error-ts"):
                                    self.fis_issu_error_ts = value
                                    self.fis_issu_error_ts.value_namespace = name_space
                                    self.fis_issu_error_ts.value_namespace_prefix = name_space_prefix
                                if(value_path == "fis-issu-restart"):
                                    self.fis_issu_restart = value
                                    self.fis_issu_restart.value_namespace = name_space
                                    self.fis_issu_restart.value_namespace_prefix = name_space_prefix
                                if(value_path == "imdr-eoc-implicit"):
                                    self.imdr_eoc_implicit = value
                                    self.imdr_eoc_implicit.value_namespace = name_space
                                    self.imdr_eoc_implicit.value_namespace_prefix = name_space_prefix
                                if(value_path == "imdr-support"):
                                    self.imdr_support = value
                                    self.imdr_support.value_namespace = name_space
                                    self.imdr_support.value_namespace_prefix = name_space_prefix
                                if(value_path == "slc-eoc-implicit"):
                                    self.slc_eoc_implicit = value
                                    self.slc_eoc_implicit.value_namespace = name_space
                                    self.slc_eoc_implicit.value_namespace_prefix = name_space_prefix
                                if(value_path == "slc-support"):
                                    self.slc_support = value
                                    self.slc_support.value_namespace = name_space
                                    self.slc_support.value_namespace_prefix = name_space_prefix


                        class MiPlatCapabilities(Entity):
                            """
                            FIB platform capabilities
                            
                            .. attribute:: fpc_dlb_support
                            
                            	Per\-destination load\-balancing support
                            	**type**\:  bool
                            
                            .. attribute:: fpc_exclude_deag_bkup
                            
                            	Exclude Deag backup Paths
                            	**type**\:  bool
                            
                            .. attribute:: fpc_lba_tuples_default
                            
                            	LBA tuples
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: fpc_link_mpls_nhinfo_in_ipv6_thread_support
                            
                            	Link MPLS IPv6 NH support
                            	**type**\:  bool
                            
                            .. attribute:: fpc_lisp_decap_over_v4
                            
                            	LISP Decap over 4
                            	**type**\: list of    :py:class:`FpcLispDecapOverV4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV4>`
                            
                            .. attribute:: fpc_lisp_decap_over_v6
                            
                            	LISP Decap over 6
                            	**type**\: list of    :py:class:`FpcLispDecapOverV6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV6>`
                            
                            .. attribute:: fpc_lisp_ucmp
                            
                            	LISP UCMP support
                            	**type**\: list of    :py:class:`FpcLispUcmp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispUcmp>`
                            
                            .. attribute:: fpc_loadinfo_filter_support
                            
                            	loadinfo filter support
                            	**type**\:  bool
                            
                            .. attribute:: fpc_local_label_split
                            
                            	Label split
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: fpc_mraps_support
                            
                            	MRAPS support
                            	**type**\:  bool
                            
                            .. attribute:: fpc_nhid
                            
                            	NHID support
                            	**type**\:  bool
                            
                            .. attribute:: fpc_num_fwding_stages
                            
                            	Forwarding stages
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: fpc_num_l3_lbl_levels
                            
                            	L3 LBL levels
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: fpc_num_l3_lbl_paths
                            
                            	L3 Hash buckets
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: fpc_num_l3_lbl_rec_paths
                            
                            	L3 Recursive Hash buckets
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: fpc_num_l3_ucmp_paths
                            
                            	L3 Unequal cost hash buckets
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: fpc_num_paths_per_pbts_class
                            
                            	Path per tunnel class
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: fpc_pbts_defclass_support
                            
                            	PBTS default class support
                            	**type**\:  bool
                            
                            .. attribute:: fpc_platf_ready_cb_wait
                            
                            	Plat ready cb register
                            	**type**\:  bool
                            
                            .. attribute:: fpc_platf_temp_back_walk_reqd
                            
                            	Backwalk dependents is required
                            	**type**\:  bool
                            
                            .. attribute:: fpc_platf_v4_upd_disable
                            
                            	V4 update disable
                            	**type**\:  bool
                            
                            .. attribute:: fpc_platf_v6_upd_disable
                            
                            	V6 update disable
                            	**type**\:  bool
                            
                            .. attribute:: fpc_prefix_filter_support
                            
                            	Prefix filter level of support
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: fpc_resolve_via_table
                            
                            	Fallback VRF support
                            	**type**\: list of    :py:class:`FpcResolveViaTable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcResolveViaTable>`
                            
                            .. attribute:: fpc_slowpath_ingress_inject_reqd
                            
                            	Slowpath ingress inject required
                            	**type**\:  bool
                            
                            .. attribute:: fpc_stats_support
                            
                            	Statistics support
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities, self).__init__()

                                self.yang_name = "mi-plat-capabilities"
                                self.yang_parent_name = "misc"

                                self.fpc_dlb_support = YLeaf(YType.boolean, "fpc-dlb-support")

                                self.fpc_exclude_deag_bkup = YLeaf(YType.boolean, "fpc-exclude-deag-bkup")

                                self.fpc_lba_tuples_default = YLeaf(YType.uint32, "fpc-lba-tuples-default")

                                self.fpc_link_mpls_nhinfo_in_ipv6_thread_support = YLeaf(YType.boolean, "fpc-link-mpls-nhinfo-in-ipv6-thread-support")

                                self.fpc_loadinfo_filter_support = YLeaf(YType.boolean, "fpc-loadinfo-filter-support")

                                self.fpc_local_label_split = YLeaf(YType.uint32, "fpc-local-label-split")

                                self.fpc_mraps_support = YLeaf(YType.boolean, "fpc-mraps-support")

                                self.fpc_nhid = YLeaf(YType.boolean, "fpc-nhid")

                                self.fpc_num_fwding_stages = YLeaf(YType.uint8, "fpc-num-fwding-stages")

                                self.fpc_num_l3_lbl_levels = YLeaf(YType.uint8, "fpc-num-l3-lbl-levels")

                                self.fpc_num_l3_lbl_paths = YLeaf(YType.uint8, "fpc-num-l3-lbl-paths")

                                self.fpc_num_l3_lbl_rec_paths = YLeaf(YType.uint8, "fpc-num-l3-lbl-rec-paths")

                                self.fpc_num_l3_ucmp_paths = YLeaf(YType.uint8, "fpc-num-l3-ucmp-paths")

                                self.fpc_num_paths_per_pbts_class = YLeaf(YType.uint8, "fpc-num-paths-per-pbts-class")

                                self.fpc_pbts_defclass_support = YLeaf(YType.boolean, "fpc-pbts-defclass-support")

                                self.fpc_platf_ready_cb_wait = YLeaf(YType.boolean, "fpc-platf-ready-cb-wait")

                                self.fpc_platf_temp_back_walk_reqd = YLeaf(YType.boolean, "fpc-platf-temp-back-walk-reqd")

                                self.fpc_platf_v4_upd_disable = YLeaf(YType.boolean, "fpc-platf-v4-upd-disable")

                                self.fpc_platf_v6_upd_disable = YLeaf(YType.boolean, "fpc-platf-v6-upd-disable")

                                self.fpc_prefix_filter_support = YLeaf(YType.uint8, "fpc-prefix-filter-support")

                                self.fpc_slowpath_ingress_inject_reqd = YLeaf(YType.boolean, "fpc-slowpath-ingress-inject-reqd")

                                self.fpc_stats_support = YLeaf(YType.boolean, "fpc-stats-support")

                                self.fpc_lisp_decap_over_v4 = YList(self)
                                self.fpc_lisp_decap_over_v6 = YList(self)
                                self.fpc_lisp_ucmp = YList(self)
                                self.fpc_resolve_via_table = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fpc_dlb_support",
                                                "fpc_exclude_deag_bkup",
                                                "fpc_lba_tuples_default",
                                                "fpc_link_mpls_nhinfo_in_ipv6_thread_support",
                                                "fpc_loadinfo_filter_support",
                                                "fpc_local_label_split",
                                                "fpc_mraps_support",
                                                "fpc_nhid",
                                                "fpc_num_fwding_stages",
                                                "fpc_num_l3_lbl_levels",
                                                "fpc_num_l3_lbl_paths",
                                                "fpc_num_l3_lbl_rec_paths",
                                                "fpc_num_l3_ucmp_paths",
                                                "fpc_num_paths_per_pbts_class",
                                                "fpc_pbts_defclass_support",
                                                "fpc_platf_ready_cb_wait",
                                                "fpc_platf_temp_back_walk_reqd",
                                                "fpc_platf_v4_upd_disable",
                                                "fpc_platf_v6_upd_disable",
                                                "fpc_prefix_filter_support",
                                                "fpc_slowpath_ingress_inject_reqd",
                                                "fpc_stats_support") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities, self).__setattr__(name, value)


                            class FpcLispDecapOverV4(Entity):
                                """
                                LISP Decap over 4
                                
                                .. attribute:: entry
                                
                                	Array entry
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV4, self).__init__()

                                    self.yang_name = "fpc-lisp-decap-over-v4"
                                    self.yang_parent_name = "mi-plat-capabilities"

                                    self.entry = YLeaf(YType.boolean, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV4, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV4, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpc-lisp-decap-over-v4" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix


                            class FpcLispDecapOverV6(Entity):
                                """
                                LISP Decap over 6
                                
                                .. attribute:: entry
                                
                                	Array entry
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV6, self).__init__()

                                    self.yang_name = "fpc-lisp-decap-over-v6"
                                    self.yang_parent_name = "mi-plat-capabilities"

                                    self.entry = YLeaf(YType.boolean, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV6, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV6, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpc-lisp-decap-over-v6" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix


                            class FpcLispUcmp(Entity):
                                """
                                LISP UCMP support
                                
                                .. attribute:: entry
                                
                                	Array entry
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispUcmp, self).__init__()

                                    self.yang_name = "fpc-lisp-ucmp"
                                    self.yang_parent_name = "mi-plat-capabilities"

                                    self.entry = YLeaf(YType.boolean, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispUcmp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispUcmp, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpc-lisp-ucmp" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix


                            class FpcResolveViaTable(Entity):
                                """
                                Fallback VRF support
                                
                                .. attribute:: entry
                                
                                	Array entry
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcResolveViaTable, self).__init__()

                                    self.yang_name = "fpc-resolve-via-table"
                                    self.yang_parent_name = "mi-plat-capabilities"

                                    self.entry = YLeaf(YType.boolean, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcResolveViaTable, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcResolveViaTable, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpc-resolve-via-table" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.fpc_lisp_decap_over_v4:
                                    if (c.has_data()):
                                        return True
                                for c in self.fpc_lisp_decap_over_v6:
                                    if (c.has_data()):
                                        return True
                                for c in self.fpc_lisp_ucmp:
                                    if (c.has_data()):
                                        return True
                                for c in self.fpc_resolve_via_table:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.fpc_dlb_support.is_set or
                                    self.fpc_exclude_deag_bkup.is_set or
                                    self.fpc_lba_tuples_default.is_set or
                                    self.fpc_link_mpls_nhinfo_in_ipv6_thread_support.is_set or
                                    self.fpc_loadinfo_filter_support.is_set or
                                    self.fpc_local_label_split.is_set or
                                    self.fpc_mraps_support.is_set or
                                    self.fpc_nhid.is_set or
                                    self.fpc_num_fwding_stages.is_set or
                                    self.fpc_num_l3_lbl_levels.is_set or
                                    self.fpc_num_l3_lbl_paths.is_set or
                                    self.fpc_num_l3_lbl_rec_paths.is_set or
                                    self.fpc_num_l3_ucmp_paths.is_set or
                                    self.fpc_num_paths_per_pbts_class.is_set or
                                    self.fpc_pbts_defclass_support.is_set or
                                    self.fpc_platf_ready_cb_wait.is_set or
                                    self.fpc_platf_temp_back_walk_reqd.is_set or
                                    self.fpc_platf_v4_upd_disable.is_set or
                                    self.fpc_platf_v6_upd_disable.is_set or
                                    self.fpc_prefix_filter_support.is_set or
                                    self.fpc_slowpath_ingress_inject_reqd.is_set or
                                    self.fpc_stats_support.is_set)

                            def has_operation(self):
                                for c in self.fpc_lisp_decap_over_v4:
                                    if (c.has_operation()):
                                        return True
                                for c in self.fpc_lisp_decap_over_v6:
                                    if (c.has_operation()):
                                        return True
                                for c in self.fpc_lisp_ucmp:
                                    if (c.has_operation()):
                                        return True
                                for c in self.fpc_resolve_via_table:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fpc_dlb_support.yfilter != YFilter.not_set or
                                    self.fpc_exclude_deag_bkup.yfilter != YFilter.not_set or
                                    self.fpc_lba_tuples_default.yfilter != YFilter.not_set or
                                    self.fpc_link_mpls_nhinfo_in_ipv6_thread_support.yfilter != YFilter.not_set or
                                    self.fpc_loadinfo_filter_support.yfilter != YFilter.not_set or
                                    self.fpc_local_label_split.yfilter != YFilter.not_set or
                                    self.fpc_mraps_support.yfilter != YFilter.not_set or
                                    self.fpc_nhid.yfilter != YFilter.not_set or
                                    self.fpc_num_fwding_stages.yfilter != YFilter.not_set or
                                    self.fpc_num_l3_lbl_levels.yfilter != YFilter.not_set or
                                    self.fpc_num_l3_lbl_paths.yfilter != YFilter.not_set or
                                    self.fpc_num_l3_lbl_rec_paths.yfilter != YFilter.not_set or
                                    self.fpc_num_l3_ucmp_paths.yfilter != YFilter.not_set or
                                    self.fpc_num_paths_per_pbts_class.yfilter != YFilter.not_set or
                                    self.fpc_pbts_defclass_support.yfilter != YFilter.not_set or
                                    self.fpc_platf_ready_cb_wait.yfilter != YFilter.not_set or
                                    self.fpc_platf_temp_back_walk_reqd.yfilter != YFilter.not_set or
                                    self.fpc_platf_v4_upd_disable.yfilter != YFilter.not_set or
                                    self.fpc_platf_v6_upd_disable.yfilter != YFilter.not_set or
                                    self.fpc_prefix_filter_support.yfilter != YFilter.not_set or
                                    self.fpc_slowpath_ingress_inject_reqd.yfilter != YFilter.not_set or
                                    self.fpc_stats_support.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-plat-capabilities" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fpc_dlb_support.is_set or self.fpc_dlb_support.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_dlb_support.get_name_leafdata())
                                if (self.fpc_exclude_deag_bkup.is_set or self.fpc_exclude_deag_bkup.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_exclude_deag_bkup.get_name_leafdata())
                                if (self.fpc_lba_tuples_default.is_set or self.fpc_lba_tuples_default.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_lba_tuples_default.get_name_leafdata())
                                if (self.fpc_link_mpls_nhinfo_in_ipv6_thread_support.is_set or self.fpc_link_mpls_nhinfo_in_ipv6_thread_support.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_link_mpls_nhinfo_in_ipv6_thread_support.get_name_leafdata())
                                if (self.fpc_loadinfo_filter_support.is_set or self.fpc_loadinfo_filter_support.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_loadinfo_filter_support.get_name_leafdata())
                                if (self.fpc_local_label_split.is_set or self.fpc_local_label_split.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_local_label_split.get_name_leafdata())
                                if (self.fpc_mraps_support.is_set or self.fpc_mraps_support.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_mraps_support.get_name_leafdata())
                                if (self.fpc_nhid.is_set or self.fpc_nhid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_nhid.get_name_leafdata())
                                if (self.fpc_num_fwding_stages.is_set or self.fpc_num_fwding_stages.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_num_fwding_stages.get_name_leafdata())
                                if (self.fpc_num_l3_lbl_levels.is_set or self.fpc_num_l3_lbl_levels.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_num_l3_lbl_levels.get_name_leafdata())
                                if (self.fpc_num_l3_lbl_paths.is_set or self.fpc_num_l3_lbl_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_num_l3_lbl_paths.get_name_leafdata())
                                if (self.fpc_num_l3_lbl_rec_paths.is_set or self.fpc_num_l3_lbl_rec_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_num_l3_lbl_rec_paths.get_name_leafdata())
                                if (self.fpc_num_l3_ucmp_paths.is_set or self.fpc_num_l3_ucmp_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_num_l3_ucmp_paths.get_name_leafdata())
                                if (self.fpc_num_paths_per_pbts_class.is_set or self.fpc_num_paths_per_pbts_class.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_num_paths_per_pbts_class.get_name_leafdata())
                                if (self.fpc_pbts_defclass_support.is_set or self.fpc_pbts_defclass_support.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_pbts_defclass_support.get_name_leafdata())
                                if (self.fpc_platf_ready_cb_wait.is_set or self.fpc_platf_ready_cb_wait.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_platf_ready_cb_wait.get_name_leafdata())
                                if (self.fpc_platf_temp_back_walk_reqd.is_set or self.fpc_platf_temp_back_walk_reqd.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_platf_temp_back_walk_reqd.get_name_leafdata())
                                if (self.fpc_platf_v4_upd_disable.is_set or self.fpc_platf_v4_upd_disable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_platf_v4_upd_disable.get_name_leafdata())
                                if (self.fpc_platf_v6_upd_disable.is_set or self.fpc_platf_v6_upd_disable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_platf_v6_upd_disable.get_name_leafdata())
                                if (self.fpc_prefix_filter_support.is_set or self.fpc_prefix_filter_support.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_prefix_filter_support.get_name_leafdata())
                                if (self.fpc_slowpath_ingress_inject_reqd.is_set or self.fpc_slowpath_ingress_inject_reqd.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_slowpath_ingress_inject_reqd.get_name_leafdata())
                                if (self.fpc_stats_support.is_set or self.fpc_stats_support.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpc_stats_support.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "fpc-lisp-decap-over-v4"):
                                    for c in self.fpc_lisp_decap_over_v4:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV4()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fpc_lisp_decap_over_v4.append(c)
                                    return c

                                if (child_yang_name == "fpc-lisp-decap-over-v6"):
                                    for c in self.fpc_lisp_decap_over_v6:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispDecapOverV6()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fpc_lisp_decap_over_v6.append(c)
                                    return c

                                if (child_yang_name == "fpc-lisp-ucmp"):
                                    for c in self.fpc_lisp_ucmp:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcLispUcmp()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fpc_lisp_ucmp.append(c)
                                    return c

                                if (child_yang_name == "fpc-resolve-via-table"):
                                    for c in self.fpc_resolve_via_table:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities.FpcResolveViaTable()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fpc_resolve_via_table.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fpc-lisp-decap-over-v4" or name == "fpc-lisp-decap-over-v6" or name == "fpc-lisp-ucmp" or name == "fpc-resolve-via-table" or name == "fpc-dlb-support" or name == "fpc-exclude-deag-bkup" or name == "fpc-lba-tuples-default" or name == "fpc-link-mpls-nhinfo-in-ipv6-thread-support" or name == "fpc-loadinfo-filter-support" or name == "fpc-local-label-split" or name == "fpc-mraps-support" or name == "fpc-nhid" or name == "fpc-num-fwding-stages" or name == "fpc-num-l3-lbl-levels" or name == "fpc-num-l3-lbl-paths" or name == "fpc-num-l3-lbl-rec-paths" or name == "fpc-num-l3-ucmp-paths" or name == "fpc-num-paths-per-pbts-class" or name == "fpc-pbts-defclass-support" or name == "fpc-platf-ready-cb-wait" or name == "fpc-platf-temp-back-walk-reqd" or name == "fpc-platf-v4-upd-disable" or name == "fpc-platf-v6-upd-disable" or name == "fpc-prefix-filter-support" or name == "fpc-slowpath-ingress-inject-reqd" or name == "fpc-stats-support"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fpc-dlb-support"):
                                    self.fpc_dlb_support = value
                                    self.fpc_dlb_support.value_namespace = name_space
                                    self.fpc_dlb_support.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-exclude-deag-bkup"):
                                    self.fpc_exclude_deag_bkup = value
                                    self.fpc_exclude_deag_bkup.value_namespace = name_space
                                    self.fpc_exclude_deag_bkup.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-lba-tuples-default"):
                                    self.fpc_lba_tuples_default = value
                                    self.fpc_lba_tuples_default.value_namespace = name_space
                                    self.fpc_lba_tuples_default.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-link-mpls-nhinfo-in-ipv6-thread-support"):
                                    self.fpc_link_mpls_nhinfo_in_ipv6_thread_support = value
                                    self.fpc_link_mpls_nhinfo_in_ipv6_thread_support.value_namespace = name_space
                                    self.fpc_link_mpls_nhinfo_in_ipv6_thread_support.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-loadinfo-filter-support"):
                                    self.fpc_loadinfo_filter_support = value
                                    self.fpc_loadinfo_filter_support.value_namespace = name_space
                                    self.fpc_loadinfo_filter_support.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-local-label-split"):
                                    self.fpc_local_label_split = value
                                    self.fpc_local_label_split.value_namespace = name_space
                                    self.fpc_local_label_split.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-mraps-support"):
                                    self.fpc_mraps_support = value
                                    self.fpc_mraps_support.value_namespace = name_space
                                    self.fpc_mraps_support.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-nhid"):
                                    self.fpc_nhid = value
                                    self.fpc_nhid.value_namespace = name_space
                                    self.fpc_nhid.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-num-fwding-stages"):
                                    self.fpc_num_fwding_stages = value
                                    self.fpc_num_fwding_stages.value_namespace = name_space
                                    self.fpc_num_fwding_stages.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-num-l3-lbl-levels"):
                                    self.fpc_num_l3_lbl_levels = value
                                    self.fpc_num_l3_lbl_levels.value_namespace = name_space
                                    self.fpc_num_l3_lbl_levels.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-num-l3-lbl-paths"):
                                    self.fpc_num_l3_lbl_paths = value
                                    self.fpc_num_l3_lbl_paths.value_namespace = name_space
                                    self.fpc_num_l3_lbl_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-num-l3-lbl-rec-paths"):
                                    self.fpc_num_l3_lbl_rec_paths = value
                                    self.fpc_num_l3_lbl_rec_paths.value_namespace = name_space
                                    self.fpc_num_l3_lbl_rec_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-num-l3-ucmp-paths"):
                                    self.fpc_num_l3_ucmp_paths = value
                                    self.fpc_num_l3_ucmp_paths.value_namespace = name_space
                                    self.fpc_num_l3_ucmp_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-num-paths-per-pbts-class"):
                                    self.fpc_num_paths_per_pbts_class = value
                                    self.fpc_num_paths_per_pbts_class.value_namespace = name_space
                                    self.fpc_num_paths_per_pbts_class.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-pbts-defclass-support"):
                                    self.fpc_pbts_defclass_support = value
                                    self.fpc_pbts_defclass_support.value_namespace = name_space
                                    self.fpc_pbts_defclass_support.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-platf-ready-cb-wait"):
                                    self.fpc_platf_ready_cb_wait = value
                                    self.fpc_platf_ready_cb_wait.value_namespace = name_space
                                    self.fpc_platf_ready_cb_wait.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-platf-temp-back-walk-reqd"):
                                    self.fpc_platf_temp_back_walk_reqd = value
                                    self.fpc_platf_temp_back_walk_reqd.value_namespace = name_space
                                    self.fpc_platf_temp_back_walk_reqd.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-platf-v4-upd-disable"):
                                    self.fpc_platf_v4_upd_disable = value
                                    self.fpc_platf_v4_upd_disable.value_namespace = name_space
                                    self.fpc_platf_v4_upd_disable.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-platf-v6-upd-disable"):
                                    self.fpc_platf_v6_upd_disable = value
                                    self.fpc_platf_v6_upd_disable.value_namespace = name_space
                                    self.fpc_platf_v6_upd_disable.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-prefix-filter-support"):
                                    self.fpc_prefix_filter_support = value
                                    self.fpc_prefix_filter_support.value_namespace = name_space
                                    self.fpc_prefix_filter_support.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-slowpath-ingress-inject-reqd"):
                                    self.fpc_slowpath_ingress_inject_reqd = value
                                    self.fpc_slowpath_ingress_inject_reqd.value_namespace = name_space
                                    self.fpc_slowpath_ingress_inject_reqd.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpc-stats-support"):
                                    self.fpc_stats_support = value
                                    self.fpc_stats_support.value_namespace = name_space
                                    self.fpc_stats_support.value_namespace_prefix = name_space_prefix


                        class MiIdbExtCleanupFailedCount(Entity):
                            """
                            Number of recycled idb extensions that failed
                            
                            cleanup
                            
                            .. attribute:: entry
                            
                            	
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbExtCleanupFailedCount, self).__init__()

                                self.yang_name = "mi-idb-ext-cleanup-failed-count"
                                self.yang_parent_name = "misc"

                                self.entry = YLeaf(YType.uint32, "entry")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbExtCleanupFailedCount, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbExtCleanupFailedCount, self).__setattr__(name, value)

                            def has_data(self):
                                return self.entry.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-idb-ext-cleanup-failed-count" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "entry"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry"):
                                    self.entry = value
                                    self.entry.value_namespace = name_space
                                    self.entry.value_namespace_prefix = name_space_prefix


                        class MiLrpfStatsFail(Entity):
                            """
                            Per protocol Failure stats for label RPF
                            
                            .. attribute:: entry
                            
                            	
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsFail, self).__init__()

                                self.yang_name = "mi-lrpf-stats-fail"
                                self.yang_parent_name = "misc"

                                self.entry = YLeaf(YType.uint32, "entry")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsFail, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsFail, self).__setattr__(name, value)

                            def has_data(self):
                                return self.entry.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-lrpf-stats-fail" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "entry"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry"):
                                    self.entry = value
                                    self.entry.value_namespace = name_space
                                    self.entry.value_namespace_prefix = name_space_prefix


                        class MiLrpfStatsAct(Entity):
                            """
                            Per protocol actions stats for label RPF
                            
                            .. attribute:: entry
                            
                            	
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsAct, self).__init__()

                                self.yang_name = "mi-lrpf-stats-act"
                                self.yang_parent_name = "misc"

                                self.entry = YLeaf(YType.uint32, "entry")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsAct, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsAct, self).__setattr__(name, value)

                            def has_data(self):
                                return self.entry.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-lrpf-stats-act" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "entry"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry"):
                                    self.entry = value
                                    self.entry.value_namespace = name_space
                                    self.entry.value_namespace_prefix = name_space_prefix


                        class MiLrpfNum(Entity):
                            """
                            Per protocol number of label RPFs
                            
                            .. attribute:: entry
                            
                            	
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfNum, self).__init__()

                                self.yang_name = "mi-lrpf-num"
                                self.yang_parent_name = "misc"

                                self.entry = YLeaf(YType.uint32, "entry")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfNum, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfNum, self).__setattr__(name, value)

                            def has_data(self):
                                return self.entry.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-lrpf-num" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "entry"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry"):
                                    self.entry = value
                                    self.entry.value_namespace = name_space
                                    self.entry.value_namespace_prefix = name_space_prefix


                        class MiIdbLsecEnabledNum(Entity):
                            """
                            Number of interfaces having label security
                            
                            enabled
                            
                            .. attribute:: entry
                            
                            	
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbLsecEnabledNum, self).__init__()

                                self.yang_name = "mi-idb-lsec-enabled-num"
                                self.yang_parent_name = "misc"

                                self.entry = YLeaf(YType.uint32, "entry")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbLsecEnabledNum, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbLsecEnabledNum, self).__setattr__(name, value)

                            def has_data(self):
                                return self.entry.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-idb-lsec-enabled-num" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "entry"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry"):
                                    self.entry = value
                                    self.entry.value_namespace = name_space
                                    self.entry.value_namespace_prefix = name_space_prefix


                        class MiNumLispEid(Entity):
                            """
                            number of LISP EID prefixes
                            
                            .. attribute:: entry
                            
                            	
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispEid, self).__init__()

                                self.yang_name = "mi-num-lisp-eid"
                                self.yang_parent_name = "misc"

                                self.entry = YLeaf(YType.uint32, "entry")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispEid, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispEid, self).__setattr__(name, value)

                            def has_data(self):
                                return self.entry.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-num-lisp-eid" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "entry"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry"):
                                    self.entry = value
                                    self.entry.value_namespace = name_space
                                    self.entry.value_namespace_prefix = name_space_prefix


                        class MiNumLispValidEid(Entity):
                            """
                            number of LISP EID prefixes eligible for
                            
                            forwarding
                            
                            .. attribute:: entry
                            
                            	
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispValidEid, self).__init__()

                                self.yang_name = "mi-num-lisp-valid-eid"
                                self.yang_parent_name = "misc"

                                self.entry = YLeaf(YType.uint32, "entry")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispValidEid, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispValidEid, self).__setattr__(name, value)

                            def has_data(self):
                                return self.entry.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-num-lisp-valid-eid" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "entry"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry"):
                                    self.entry = value
                                    self.entry.value_namespace = name_space
                                    self.entry.value_namespace_prefix = name_space_prefix


                        class MiCpulessNode(Entity):
                            """
                            list of cpuless line cards
                            
                            .. attribute:: entry
                            
                            	
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiCpulessNode, self).__init__()

                                self.yang_name = "mi-cpuless-node"
                                self.yang_parent_name = "misc"

                                self.entry = YLeaf(YType.uint32, "entry")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiCpulessNode, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiCpulessNode, self).__setattr__(name, value)

                            def has_data(self):
                                return self.entry.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-cpuless-node" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "entry"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry"):
                                    self.entry = value
                                    self.entry.value_namespace = name_space
                                    self.entry.value_namespace_prefix = name_space_prefix


                        class MiProtoDbgStat(Entity):
                            """
                            Per protocol debug stats
                            
                            .. attribute:: fpd_adj_del
                            
                            	the number of adjacency deletes
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_adj_drops
                            
                            	 number of adj updates dropped because of OOR
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_adj_msg
                            
                            	number of AIB messages
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_adj_tx_retry_nh_found
                            
                            	number of TX adj retries that found or created NH
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_adj_tx_retry_obj_reinit
                            
                            	number of times TX NH retry objects updated
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_adj_upd
                            
                            	the number of adjacency updates
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_adj_upd_tx
                            
                            	number of TX adjacency updates from AIB
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_adj_upd_tx_nh_found
                            
                            	number of TX adjacency updates that found or created NH
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_adj_upd_tx_retry_created
                            
                            	number of TX adjacency updates that went to retry
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_bcdl_msgs
                            
                            	the number of bcdl msgs
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_gbltbl_entries
                            
                            	the number of fib entries in global tbl
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_gbltbl_rej_entries
                            
                            	the number of fib entries in global retry tbl
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_gbltbl_src_entry
                            
                            	Number of global routes from                      each route source
                            	**type**\: list of    :py:class:`FpdGbltblSrcEntry <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGbltblSrcEntry>`
                            
                            .. attribute:: fpd_gtrie_timing
                            
                            	Gtrie timing statistics
                            	**type**\:   :py:class:`FpdGtrieTiming <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming>`
                            
                            .. attribute:: fpd_lbl_recycled
                            
                            	the number of routes handled with recycled label
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_ldi_avg_backup_activate_time
                            
                            	avg ldi mod time for backup activation
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_ldi_backup_activate_count
                            
                            	number of ldi backup path activications
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_ldi_last_backup_activate_time
                            
                            	ldi mod time for last backup activation
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_ldi_max_backup_activate_time
                            
                            	max ldi mod time for backup activation
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_ldi_min_backup_activate_time
                            
                            	min ldi mod time for backup activation
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_ldi_num_correct_fixup
                            
                            	the number of corrected fixup LDIs
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_ldi_num_del_refcnt
                            
                            	the number of deleted with non\-zero refcount
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_ldi_num_fixedup
                            
                            	the number of fixup LDIs
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_ldi_total_backup_activate_time
                            
                            	total ldi mod time for backup activation
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_num_allocs
                            
                            	the number of allocs for this proto
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_num_frees
                            
                            	the number of frees for this proto
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_num_retry
                            
                            	the number of retries of each type
                            	**type**\: list of    :py:class:`FpdNumRetry <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdNumRetry>`
                            
                            .. attribute:: fpd_num_retry_touts
                            
                            	the number of retry timeouts
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_num_tbls
                            
                            	the number of tables in table set
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: fpd_pl_backup_disable_count
                            
                            	 number of PLs unmarked to include backup path
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_pl_backup_enable_count
                            
                            	number of PLs marked to include backup path
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_pl_fast_nfn_count
                            
                            	number of PLs visited on fast notification
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_pl_inline_res_q
                            
                            	the number of PLs linked to resolving tables for inline res
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_pl_num_correct_fixup
                            
                            	the number of corrected fixup PLs
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_pl_num_queued_fixedup
                            
                            	the number of PL queued for fixup
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_pl_retry_add_exist
                            
                            	the number PLs added to retry while already in retry
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_pl_with_backup_create_count
                            
                            	number of pl creates with backu path
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_pl_with_backup_del_count
                            
                            	number of pl deletes with backup path
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_platf_upd_stats
                            
                            	platform update statistics
                            	**type**\:   :py:class:`FpdPlatfUpdStats <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats>`
                            
                            .. attribute:: fpd_recursion_constraint_count
                            
                            	number of resolution failures because of recursion constraint
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_retryq_sched_time
                            
                            	Scheduler time period in msec
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: fpd_retryq_size
                            
                            	the number of elements in retryq
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: fpd_retryq_timeout
                            
                            	timeout value in msec
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: fpd_route_del
                            
                            	the number of route deletes
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_route_drops
                            
                            	the number of routes dropped
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_route_rcv
                            
                            	the number of routes received
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_route_upd
                            
                            	the number of route updates
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_te_rcv
                            
                            	the number of TE upds received
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_te_version_mismatch_drops
                            
                            	the number of TE upds dropped because of version mismatch
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_version_mismatch_drops
                            
                            	the number of routes dropped because of version mismatch
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_vrftbl_entries
                            
                            	the number of fib entries in vrf tbls
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_vrftbl_rej_entries
                            
                            	the number of fib entries in vrf retry tbls
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: fpd_vrftbl_src_entry
                            
                            	Number of vrf routes from                         each route source
                            	**type**\: list of    :py:class:`FpdVrftblSrcEntry <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdVrftblSrcEntry>`
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat, self).__init__()

                                self.yang_name = "mi-proto-dbg-stat"
                                self.yang_parent_name = "misc"

                                self.fpd_adj_del = YLeaf(YType.uint64, "fpd-adj-del")

                                self.fpd_adj_drops = YLeaf(YType.uint64, "fpd-adj-drops")

                                self.fpd_adj_msg = YLeaf(YType.uint64, "fpd-adj-msg")

                                self.fpd_adj_tx_retry_nh_found = YLeaf(YType.uint64, "fpd-adj-tx-retry-nh-found")

                                self.fpd_adj_tx_retry_obj_reinit = YLeaf(YType.uint64, "fpd-adj-tx-retry-obj-reinit")

                                self.fpd_adj_upd = YLeaf(YType.uint64, "fpd-adj-upd")

                                self.fpd_adj_upd_tx = YLeaf(YType.uint64, "fpd-adj-upd-tx")

                                self.fpd_adj_upd_tx_nh_found = YLeaf(YType.uint64, "fpd-adj-upd-tx-nh-found")

                                self.fpd_adj_upd_tx_retry_created = YLeaf(YType.uint64, "fpd-adj-upd-tx-retry-created")

                                self.fpd_bcdl_msgs = YLeaf(YType.uint64, "fpd-bcdl-msgs")

                                self.fpd_gbltbl_entries = YLeaf(YType.uint64, "fpd-gbltbl-entries")

                                self.fpd_gbltbl_rej_entries = YLeaf(YType.uint64, "fpd-gbltbl-rej-entries")

                                self.fpd_lbl_recycled = YLeaf(YType.uint64, "fpd-lbl-recycled")

                                self.fpd_ldi_avg_backup_activate_time = YLeaf(YType.uint64, "fpd-ldi-avg-backup-activate-time")

                                self.fpd_ldi_backup_activate_count = YLeaf(YType.uint64, "fpd-ldi-backup-activate-count")

                                self.fpd_ldi_last_backup_activate_time = YLeaf(YType.uint64, "fpd-ldi-last-backup-activate-time")

                                self.fpd_ldi_max_backup_activate_time = YLeaf(YType.uint64, "fpd-ldi-max-backup-activate-time")

                                self.fpd_ldi_min_backup_activate_time = YLeaf(YType.uint64, "fpd-ldi-min-backup-activate-time")

                                self.fpd_ldi_num_correct_fixup = YLeaf(YType.uint64, "fpd-ldi-num-correct-fixup")

                                self.fpd_ldi_num_del_refcnt = YLeaf(YType.uint64, "fpd-ldi-num-del-refcnt")

                                self.fpd_ldi_num_fixedup = YLeaf(YType.uint64, "fpd-ldi-num-fixedup")

                                self.fpd_ldi_total_backup_activate_time = YLeaf(YType.uint64, "fpd-ldi-total-backup-activate-time")

                                self.fpd_num_allocs = YLeaf(YType.uint64, "fpd-num-allocs")

                                self.fpd_num_frees = YLeaf(YType.uint64, "fpd-num-frees")

                                self.fpd_num_retry_touts = YLeaf(YType.uint64, "fpd-num-retry-touts")

                                self.fpd_num_tbls = YLeaf(YType.uint32, "fpd-num-tbls")

                                self.fpd_pl_backup_disable_count = YLeaf(YType.uint64, "fpd-pl-backup-disable-count")

                                self.fpd_pl_backup_enable_count = YLeaf(YType.uint64, "fpd-pl-backup-enable-count")

                                self.fpd_pl_fast_nfn_count = YLeaf(YType.uint64, "fpd-pl-fast-nfn-count")

                                self.fpd_pl_inline_res_q = YLeaf(YType.uint64, "fpd-pl-inline-res-q")

                                self.fpd_pl_num_correct_fixup = YLeaf(YType.uint64, "fpd-pl-num-correct-fixup")

                                self.fpd_pl_num_queued_fixedup = YLeaf(YType.uint64, "fpd-pl-num-queued-fixedup")

                                self.fpd_pl_retry_add_exist = YLeaf(YType.uint64, "fpd-pl-retry-add-exist")

                                self.fpd_pl_with_backup_create_count = YLeaf(YType.uint64, "fpd-pl-with-backup-create-count")

                                self.fpd_pl_with_backup_del_count = YLeaf(YType.uint64, "fpd-pl-with-backup-del-count")

                                self.fpd_recursion_constraint_count = YLeaf(YType.uint64, "fpd-recursion-constraint-count")

                                self.fpd_retryq_sched_time = YLeaf(YType.uint32, "fpd-retryq-sched-time")

                                self.fpd_retryq_size = YLeaf(YType.uint32, "fpd-retryq-size")

                                self.fpd_retryq_timeout = YLeaf(YType.uint32, "fpd-retryq-timeout")

                                self.fpd_route_del = YLeaf(YType.uint64, "fpd-route-del")

                                self.fpd_route_drops = YLeaf(YType.uint64, "fpd-route-drops")

                                self.fpd_route_rcv = YLeaf(YType.uint64, "fpd-route-rcv")

                                self.fpd_route_upd = YLeaf(YType.uint64, "fpd-route-upd")

                                self.fpd_te_rcv = YLeaf(YType.uint64, "fpd-te-rcv")

                                self.fpd_te_version_mismatch_drops = YLeaf(YType.uint64, "fpd-te-version-mismatch-drops")

                                self.fpd_version_mismatch_drops = YLeaf(YType.uint64, "fpd-version-mismatch-drops")

                                self.fpd_vrftbl_entries = YLeaf(YType.uint64, "fpd-vrftbl-entries")

                                self.fpd_vrftbl_rej_entries = YLeaf(YType.uint64, "fpd-vrftbl-rej-entries")

                                self.fpd_gtrie_timing = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming()
                                self.fpd_gtrie_timing.parent = self
                                self._children_name_map["fpd_gtrie_timing"] = "fpd-gtrie-timing"
                                self._children_yang_names.add("fpd-gtrie-timing")

                                self.fpd_platf_upd_stats = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats()
                                self.fpd_platf_upd_stats.parent = self
                                self._children_name_map["fpd_platf_upd_stats"] = "fpd-platf-upd-stats"
                                self._children_yang_names.add("fpd-platf-upd-stats")

                                self.fpd_gbltbl_src_entry = YList(self)
                                self.fpd_num_retry = YList(self)
                                self.fpd_vrftbl_src_entry = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fpd_adj_del",
                                                "fpd_adj_drops",
                                                "fpd_adj_msg",
                                                "fpd_adj_tx_retry_nh_found",
                                                "fpd_adj_tx_retry_obj_reinit",
                                                "fpd_adj_upd",
                                                "fpd_adj_upd_tx",
                                                "fpd_adj_upd_tx_nh_found",
                                                "fpd_adj_upd_tx_retry_created",
                                                "fpd_bcdl_msgs",
                                                "fpd_gbltbl_entries",
                                                "fpd_gbltbl_rej_entries",
                                                "fpd_lbl_recycled",
                                                "fpd_ldi_avg_backup_activate_time",
                                                "fpd_ldi_backup_activate_count",
                                                "fpd_ldi_last_backup_activate_time",
                                                "fpd_ldi_max_backup_activate_time",
                                                "fpd_ldi_min_backup_activate_time",
                                                "fpd_ldi_num_correct_fixup",
                                                "fpd_ldi_num_del_refcnt",
                                                "fpd_ldi_num_fixedup",
                                                "fpd_ldi_total_backup_activate_time",
                                                "fpd_num_allocs",
                                                "fpd_num_frees",
                                                "fpd_num_retry_touts",
                                                "fpd_num_tbls",
                                                "fpd_pl_backup_disable_count",
                                                "fpd_pl_backup_enable_count",
                                                "fpd_pl_fast_nfn_count",
                                                "fpd_pl_inline_res_q",
                                                "fpd_pl_num_correct_fixup",
                                                "fpd_pl_num_queued_fixedup",
                                                "fpd_pl_retry_add_exist",
                                                "fpd_pl_with_backup_create_count",
                                                "fpd_pl_with_backup_del_count",
                                                "fpd_recursion_constraint_count",
                                                "fpd_retryq_sched_time",
                                                "fpd_retryq_size",
                                                "fpd_retryq_timeout",
                                                "fpd_route_del",
                                                "fpd_route_drops",
                                                "fpd_route_rcv",
                                                "fpd_route_upd",
                                                "fpd_te_rcv",
                                                "fpd_te_version_mismatch_drops",
                                                "fpd_version_mismatch_drops",
                                                "fpd_vrftbl_entries",
                                                "fpd_vrftbl_rej_entries") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat, self).__setattr__(name, value)


                            class FpdPlatfUpdStats(Entity):
                                """
                                platform update statistics
                                
                                .. attribute:: fpus_num_failure
                                
                                	Number of unsuccessful updates
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: fpus_num_success
                                
                                	Number of successful updates
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: fpus_obj_stat
                                
                                	Array of max time info indexed by object type
                                	**type**\: list of    :py:class:`FpusObjStat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat>`
                                
                                .. attribute:: fpus_upd_total_time
                                
                                	Total time for all pd updates
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats, self).__init__()

                                    self.yang_name = "fpd-platf-upd-stats"
                                    self.yang_parent_name = "mi-proto-dbg-stat"

                                    self.fpus_num_failure = YLeaf(YType.uint64, "fpus-num-failure")

                                    self.fpus_num_success = YLeaf(YType.uint64, "fpus-num-success")

                                    self.fpus_upd_total_time = YLeaf(YType.uint64, "fpus-upd-total-time")

                                    self.fpus_obj_stat = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fpus_num_failure",
                                                    "fpus_num_success",
                                                    "fpus_upd_total_time") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats, self).__setattr__(name, value)


                                class FpusObjStat(Entity):
                                    """
                                    Array of max time info indexed by object type
                                    
                                    .. attribute:: fos_obj_act_stat
                                    
                                    	Array of max time info indexed by action type
                                    	**type**\: list of    :py:class:`FosObjActStat <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat.FosObjActStat>`
                                    
                                    .. attribute:: fos_tot_upd_time
                                    
                                    	Total time for updates
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: fos_tot_updates
                                    
                                    	Total number of updates
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat, self).__init__()

                                        self.yang_name = "fpus-obj-stat"
                                        self.yang_parent_name = "fpd-platf-upd-stats"

                                        self.fos_tot_upd_time = YLeaf(YType.uint64, "fos-tot-upd-time")

                                        self.fos_tot_updates = YLeaf(YType.uint64, "fos-tot-updates")

                                        self.fos_obj_act_stat = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fos_tot_upd_time",
                                                        "fos_tot_updates") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat, self).__setattr__(name, value)


                                    class FosObjActStat(Entity):
                                        """
                                        Array of max time info indexed by action type
                                        
                                        .. attribute:: foas_max_time
                                        
                                        	Time for the update
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: foas_max_tstamp
                                        
                                        	Time stamp of max update
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: foas_num_failure
                                        
                                        	Total number of failed updates
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: foas_num_success
                                        
                                        	Total number of successful updates
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: foas_tot_upd_time
                                        
                                        	Total time for updates
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: foas_tot_updates
                                        
                                        	Total number of updates
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        .. attribute:: foas_tot_updates_zero
                                        
                                        	Total number of updates that took zero time
                                        	**type**\:  int
                                        
                                        	**range:** 0..18446744073709551615
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat.FosObjActStat, self).__init__()

                                            self.yang_name = "fos-obj-act-stat"
                                            self.yang_parent_name = "fpus-obj-stat"

                                            self.foas_max_time = YLeaf(YType.uint64, "foas-max-time")

                                            self.foas_max_tstamp = YLeaf(YType.uint64, "foas-max-tstamp")

                                            self.foas_num_failure = YLeaf(YType.uint64, "foas-num-failure")

                                            self.foas_num_success = YLeaf(YType.uint64, "foas-num-success")

                                            self.foas_tot_upd_time = YLeaf(YType.uint64, "foas-tot-upd-time")

                                            self.foas_tot_updates = YLeaf(YType.uint64, "foas-tot-updates")

                                            self.foas_tot_updates_zero = YLeaf(YType.uint64, "foas-tot-updates-zero")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("foas_max_time",
                                                            "foas_max_tstamp",
                                                            "foas_num_failure",
                                                            "foas_num_success",
                                                            "foas_tot_upd_time",
                                                            "foas_tot_updates",
                                                            "foas_tot_updates_zero") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat.FosObjActStat, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat.FosObjActStat, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.foas_max_time.is_set or
                                                self.foas_max_tstamp.is_set or
                                                self.foas_num_failure.is_set or
                                                self.foas_num_success.is_set or
                                                self.foas_tot_upd_time.is_set or
                                                self.foas_tot_updates.is_set or
                                                self.foas_tot_updates_zero.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.foas_max_time.yfilter != YFilter.not_set or
                                                self.foas_max_tstamp.yfilter != YFilter.not_set or
                                                self.foas_num_failure.yfilter != YFilter.not_set or
                                                self.foas_num_success.yfilter != YFilter.not_set or
                                                self.foas_tot_upd_time.yfilter != YFilter.not_set or
                                                self.foas_tot_updates.yfilter != YFilter.not_set or
                                                self.foas_tot_updates_zero.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "fos-obj-act-stat" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.foas_max_time.is_set or self.foas_max_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.foas_max_time.get_name_leafdata())
                                            if (self.foas_max_tstamp.is_set or self.foas_max_tstamp.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.foas_max_tstamp.get_name_leafdata())
                                            if (self.foas_num_failure.is_set or self.foas_num_failure.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.foas_num_failure.get_name_leafdata())
                                            if (self.foas_num_success.is_set or self.foas_num_success.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.foas_num_success.get_name_leafdata())
                                            if (self.foas_tot_upd_time.is_set or self.foas_tot_upd_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.foas_tot_upd_time.get_name_leafdata())
                                            if (self.foas_tot_updates.is_set or self.foas_tot_updates.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.foas_tot_updates.get_name_leafdata())
                                            if (self.foas_tot_updates_zero.is_set or self.foas_tot_updates_zero.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.foas_tot_updates_zero.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "foas-max-time" or name == "foas-max-tstamp" or name == "foas-num-failure" or name == "foas-num-success" or name == "foas-tot-upd-time" or name == "foas-tot-updates" or name == "foas-tot-updates-zero"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "foas-max-time"):
                                                self.foas_max_time = value
                                                self.foas_max_time.value_namespace = name_space
                                                self.foas_max_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "foas-max-tstamp"):
                                                self.foas_max_tstamp = value
                                                self.foas_max_tstamp.value_namespace = name_space
                                                self.foas_max_tstamp.value_namespace_prefix = name_space_prefix
                                            if(value_path == "foas-num-failure"):
                                                self.foas_num_failure = value
                                                self.foas_num_failure.value_namespace = name_space
                                                self.foas_num_failure.value_namespace_prefix = name_space_prefix
                                            if(value_path == "foas-num-success"):
                                                self.foas_num_success = value
                                                self.foas_num_success.value_namespace = name_space
                                                self.foas_num_success.value_namespace_prefix = name_space_prefix
                                            if(value_path == "foas-tot-upd-time"):
                                                self.foas_tot_upd_time = value
                                                self.foas_tot_upd_time.value_namespace = name_space
                                                self.foas_tot_upd_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "foas-tot-updates"):
                                                self.foas_tot_updates = value
                                                self.foas_tot_updates.value_namespace = name_space
                                                self.foas_tot_updates.value_namespace_prefix = name_space_prefix
                                            if(value_path == "foas-tot-updates-zero"):
                                                self.foas_tot_updates_zero = value
                                                self.foas_tot_updates_zero.value_namespace = name_space
                                                self.foas_tot_updates_zero.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.fos_obj_act_stat:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.fos_tot_upd_time.is_set or
                                            self.fos_tot_updates.is_set)

                                    def has_operation(self):
                                        for c in self.fos_obj_act_stat:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fos_tot_upd_time.yfilter != YFilter.not_set or
                                            self.fos_tot_updates.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "fpus-obj-stat" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fos_tot_upd_time.is_set or self.fos_tot_upd_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fos_tot_upd_time.get_name_leafdata())
                                        if (self.fos_tot_updates.is_set or self.fos_tot_updates.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fos_tot_updates.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "fos-obj-act-stat"):
                                            for c in self.fos_obj_act_stat:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat.FosObjActStat()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.fos_obj_act_stat.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fos-obj-act-stat" or name == "fos-tot-upd-time" or name == "fos-tot-updates"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fos-tot-upd-time"):
                                            self.fos_tot_upd_time = value
                                            self.fos_tot_upd_time.value_namespace = name_space
                                            self.fos_tot_upd_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fos-tot-updates"):
                                            self.fos_tot_updates = value
                                            self.fos_tot_updates.value_namespace = name_space
                                            self.fos_tot_updates.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.fpus_obj_stat:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.fpus_num_failure.is_set or
                                        self.fpus_num_success.is_set or
                                        self.fpus_upd_total_time.is_set)

                                def has_operation(self):
                                    for c in self.fpus_obj_stat:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fpus_num_failure.yfilter != YFilter.not_set or
                                        self.fpus_num_success.yfilter != YFilter.not_set or
                                        self.fpus_upd_total_time.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpd-platf-upd-stats" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fpus_num_failure.is_set or self.fpus_num_failure.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fpus_num_failure.get_name_leafdata())
                                    if (self.fpus_num_success.is_set or self.fpus_num_success.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fpus_num_success.get_name_leafdata())
                                    if (self.fpus_upd_total_time.is_set or self.fpus_upd_total_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fpus_upd_total_time.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "fpus-obj-stat"):
                                        for c in self.fpus_obj_stat:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats.FpusObjStat()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.fpus_obj_stat.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fpus-obj-stat" or name == "fpus-num-failure" or name == "fpus-num-success" or name == "fpus-upd-total-time"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fpus-num-failure"):
                                        self.fpus_num_failure = value
                                        self.fpus_num_failure.value_namespace = name_space
                                        self.fpus_num_failure.value_namespace_prefix = name_space_prefix
                                    if(value_path == "fpus-num-success"):
                                        self.fpus_num_success = value
                                        self.fpus_num_success.value_namespace = name_space
                                        self.fpus_num_success.value_namespace_prefix = name_space_prefix
                                    if(value_path == "fpus-upd-total-time"):
                                        self.fpus_upd_total_time = value
                                        self.fpus_upd_total_time.value_namespace = name_space
                                        self.fpus_upd_total_time.value_namespace_prefix = name_space_prefix


                            class FpdGtrieTiming(Entity):
                                """
                                Gtrie timing statistics
                                
                                .. attribute:: fgt_gtrie_fn_timing
                                
                                	Array of max time info indexed by gtrie function
                                	**type**\: list of    :py:class:`FgtGtrieFnTiming <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming.FgtGtrieFnTiming>`
                                
                                .. attribute:: fgt_num_failure
                                
                                	Number of unsuccessful updates
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: fgt_num_success
                                
                                	Number of successful updates
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: fgt_upd_total_time
                                
                                	Total time for all pd updates
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming, self).__init__()

                                    self.yang_name = "fpd-gtrie-timing"
                                    self.yang_parent_name = "mi-proto-dbg-stat"

                                    self.fgt_num_failure = YLeaf(YType.uint64, "fgt-num-failure")

                                    self.fgt_num_success = YLeaf(YType.uint64, "fgt-num-success")

                                    self.fgt_upd_total_time = YLeaf(YType.uint64, "fgt-upd-total-time")

                                    self.fgt_gtrie_fn_timing = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fgt_num_failure",
                                                    "fgt_num_success",
                                                    "fgt_upd_total_time") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming, self).__setattr__(name, value)


                                class FgtGtrieFnTiming(Entity):
                                    """
                                    Array of max time info indexed by gtrie function
                                    
                                    .. attribute:: fgft_fn
                                    
                                    	Gtrie operation
                                    	**type**\:  str
                                    
                                    	**length:** 0..64
                                    
                                    .. attribute:: fgft_max_time
                                    
                                    	Time for the update
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: fgft_max_tstamp
                                    
                                    	Time stamp of max update
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: fgft_tot_upd_time
                                    
                                    	Total time for updates
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: fgft_tot_updates
                                    
                                    	Total number of updates
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    .. attribute:: fgft_tot_updates_zero
                                    
                                    	Total number of updates with zero timing (due to timestamp granularity)
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming.FgtGtrieFnTiming, self).__init__()

                                        self.yang_name = "fgt-gtrie-fn-timing"
                                        self.yang_parent_name = "fpd-gtrie-timing"

                                        self.fgft_fn = YLeaf(YType.str, "fgft-fn")

                                        self.fgft_max_time = YLeaf(YType.uint64, "fgft-max-time")

                                        self.fgft_max_tstamp = YLeaf(YType.uint64, "fgft-max-tstamp")

                                        self.fgft_tot_upd_time = YLeaf(YType.uint64, "fgft-tot-upd-time")

                                        self.fgft_tot_updates = YLeaf(YType.uint64, "fgft-tot-updates")

                                        self.fgft_tot_updates_zero = YLeaf(YType.uint64, "fgft-tot-updates-zero")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fgft_fn",
                                                        "fgft_max_time",
                                                        "fgft_max_tstamp",
                                                        "fgft_tot_upd_time",
                                                        "fgft_tot_updates",
                                                        "fgft_tot_updates_zero") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming.FgtGtrieFnTiming, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming.FgtGtrieFnTiming, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fgft_fn.is_set or
                                            self.fgft_max_time.is_set or
                                            self.fgft_max_tstamp.is_set or
                                            self.fgft_tot_upd_time.is_set or
                                            self.fgft_tot_updates.is_set or
                                            self.fgft_tot_updates_zero.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fgft_fn.yfilter != YFilter.not_set or
                                            self.fgft_max_time.yfilter != YFilter.not_set or
                                            self.fgft_max_tstamp.yfilter != YFilter.not_set or
                                            self.fgft_tot_upd_time.yfilter != YFilter.not_set or
                                            self.fgft_tot_updates.yfilter != YFilter.not_set or
                                            self.fgft_tot_updates_zero.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "fgt-gtrie-fn-timing" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fgft_fn.is_set or self.fgft_fn.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fgft_fn.get_name_leafdata())
                                        if (self.fgft_max_time.is_set or self.fgft_max_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fgft_max_time.get_name_leafdata())
                                        if (self.fgft_max_tstamp.is_set or self.fgft_max_tstamp.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fgft_max_tstamp.get_name_leafdata())
                                        if (self.fgft_tot_upd_time.is_set or self.fgft_tot_upd_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fgft_tot_upd_time.get_name_leafdata())
                                        if (self.fgft_tot_updates.is_set or self.fgft_tot_updates.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fgft_tot_updates.get_name_leafdata())
                                        if (self.fgft_tot_updates_zero.is_set or self.fgft_tot_updates_zero.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fgft_tot_updates_zero.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fgft-fn" or name == "fgft-max-time" or name == "fgft-max-tstamp" or name == "fgft-tot-upd-time" or name == "fgft-tot-updates" or name == "fgft-tot-updates-zero"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fgft-fn"):
                                            self.fgft_fn = value
                                            self.fgft_fn.value_namespace = name_space
                                            self.fgft_fn.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fgft-max-time"):
                                            self.fgft_max_time = value
                                            self.fgft_max_time.value_namespace = name_space
                                            self.fgft_max_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fgft-max-tstamp"):
                                            self.fgft_max_tstamp = value
                                            self.fgft_max_tstamp.value_namespace = name_space
                                            self.fgft_max_tstamp.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fgft-tot-upd-time"):
                                            self.fgft_tot_upd_time = value
                                            self.fgft_tot_upd_time.value_namespace = name_space
                                            self.fgft_tot_upd_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fgft-tot-updates"):
                                            self.fgft_tot_updates = value
                                            self.fgft_tot_updates.value_namespace = name_space
                                            self.fgft_tot_updates.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fgft-tot-updates-zero"):
                                            self.fgft_tot_updates_zero = value
                                            self.fgft_tot_updates_zero.value_namespace = name_space
                                            self.fgft_tot_updates_zero.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.fgt_gtrie_fn_timing:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.fgt_num_failure.is_set or
                                        self.fgt_num_success.is_set or
                                        self.fgt_upd_total_time.is_set)

                                def has_operation(self):
                                    for c in self.fgt_gtrie_fn_timing:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fgt_num_failure.yfilter != YFilter.not_set or
                                        self.fgt_num_success.yfilter != YFilter.not_set or
                                        self.fgt_upd_total_time.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpd-gtrie-timing" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fgt_num_failure.is_set or self.fgt_num_failure.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fgt_num_failure.get_name_leafdata())
                                    if (self.fgt_num_success.is_set or self.fgt_num_success.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fgt_num_success.get_name_leafdata())
                                    if (self.fgt_upd_total_time.is_set or self.fgt_upd_total_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fgt_upd_total_time.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "fgt-gtrie-fn-timing"):
                                        for c in self.fgt_gtrie_fn_timing:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming.FgtGtrieFnTiming()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.fgt_gtrie_fn_timing.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fgt-gtrie-fn-timing" or name == "fgt-num-failure" or name == "fgt-num-success" or name == "fgt-upd-total-time"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fgt-num-failure"):
                                        self.fgt_num_failure = value
                                        self.fgt_num_failure.value_namespace = name_space
                                        self.fgt_num_failure.value_namespace_prefix = name_space_prefix
                                    if(value_path == "fgt-num-success"):
                                        self.fgt_num_success = value
                                        self.fgt_num_success.value_namespace = name_space
                                        self.fgt_num_success.value_namespace_prefix = name_space_prefix
                                    if(value_path == "fgt-upd-total-time"):
                                        self.fgt_upd_total_time = value
                                        self.fgt_upd_total_time.value_namespace = name_space
                                        self.fgt_upd_total_time.value_namespace_prefix = name_space_prefix


                            class FpdGbltblSrcEntry(Entity):
                                """
                                Number of global routes from                    
                                
                                each route source
                                
                                .. attribute:: entry
                                
                                	
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGbltblSrcEntry, self).__init__()

                                    self.yang_name = "fpd-gbltbl-src-entry"
                                    self.yang_parent_name = "mi-proto-dbg-stat"

                                    self.entry = YLeaf(YType.uint64, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGbltblSrcEntry, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGbltblSrcEntry, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpd-gbltbl-src-entry" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix


                            class FpdVrftblSrcEntry(Entity):
                                """
                                Number of vrf routes from                       
                                
                                each route source
                                
                                .. attribute:: entry
                                
                                	
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdVrftblSrcEntry, self).__init__()

                                    self.yang_name = "fpd-vrftbl-src-entry"
                                    self.yang_parent_name = "mi-proto-dbg-stat"

                                    self.entry = YLeaf(YType.uint64, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdVrftblSrcEntry, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdVrftblSrcEntry, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpd-vrftbl-src-entry" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix


                            class FpdNumRetry(Entity):
                                """
                                the number of retries of each type
                                
                                .. attribute:: entry
                                
                                	
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdNumRetry, self).__init__()

                                    self.yang_name = "fpd-num-retry"
                                    self.yang_parent_name = "mi-proto-dbg-stat"

                                    self.entry = YLeaf(YType.uint64, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdNumRetry, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdNumRetry, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpd-num-retry" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.fpd_gbltbl_src_entry:
                                    if (c.has_data()):
                                        return True
                                for c in self.fpd_num_retry:
                                    if (c.has_data()):
                                        return True
                                for c in self.fpd_vrftbl_src_entry:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.fpd_adj_del.is_set or
                                    self.fpd_adj_drops.is_set or
                                    self.fpd_adj_msg.is_set or
                                    self.fpd_adj_tx_retry_nh_found.is_set or
                                    self.fpd_adj_tx_retry_obj_reinit.is_set or
                                    self.fpd_adj_upd.is_set or
                                    self.fpd_adj_upd_tx.is_set or
                                    self.fpd_adj_upd_tx_nh_found.is_set or
                                    self.fpd_adj_upd_tx_retry_created.is_set or
                                    self.fpd_bcdl_msgs.is_set or
                                    self.fpd_gbltbl_entries.is_set or
                                    self.fpd_gbltbl_rej_entries.is_set or
                                    self.fpd_lbl_recycled.is_set or
                                    self.fpd_ldi_avg_backup_activate_time.is_set or
                                    self.fpd_ldi_backup_activate_count.is_set or
                                    self.fpd_ldi_last_backup_activate_time.is_set or
                                    self.fpd_ldi_max_backup_activate_time.is_set or
                                    self.fpd_ldi_min_backup_activate_time.is_set or
                                    self.fpd_ldi_num_correct_fixup.is_set or
                                    self.fpd_ldi_num_del_refcnt.is_set or
                                    self.fpd_ldi_num_fixedup.is_set or
                                    self.fpd_ldi_total_backup_activate_time.is_set or
                                    self.fpd_num_allocs.is_set or
                                    self.fpd_num_frees.is_set or
                                    self.fpd_num_retry_touts.is_set or
                                    self.fpd_num_tbls.is_set or
                                    self.fpd_pl_backup_disable_count.is_set or
                                    self.fpd_pl_backup_enable_count.is_set or
                                    self.fpd_pl_fast_nfn_count.is_set or
                                    self.fpd_pl_inline_res_q.is_set or
                                    self.fpd_pl_num_correct_fixup.is_set or
                                    self.fpd_pl_num_queued_fixedup.is_set or
                                    self.fpd_pl_retry_add_exist.is_set or
                                    self.fpd_pl_with_backup_create_count.is_set or
                                    self.fpd_pl_with_backup_del_count.is_set or
                                    self.fpd_recursion_constraint_count.is_set or
                                    self.fpd_retryq_sched_time.is_set or
                                    self.fpd_retryq_size.is_set or
                                    self.fpd_retryq_timeout.is_set or
                                    self.fpd_route_del.is_set or
                                    self.fpd_route_drops.is_set or
                                    self.fpd_route_rcv.is_set or
                                    self.fpd_route_upd.is_set or
                                    self.fpd_te_rcv.is_set or
                                    self.fpd_te_version_mismatch_drops.is_set or
                                    self.fpd_version_mismatch_drops.is_set or
                                    self.fpd_vrftbl_entries.is_set or
                                    self.fpd_vrftbl_rej_entries.is_set or
                                    (self.fpd_gtrie_timing is not None and self.fpd_gtrie_timing.has_data()) or
                                    (self.fpd_platf_upd_stats is not None and self.fpd_platf_upd_stats.has_data()))

                            def has_operation(self):
                                for c in self.fpd_gbltbl_src_entry:
                                    if (c.has_operation()):
                                        return True
                                for c in self.fpd_num_retry:
                                    if (c.has_operation()):
                                        return True
                                for c in self.fpd_vrftbl_src_entry:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fpd_adj_del.yfilter != YFilter.not_set or
                                    self.fpd_adj_drops.yfilter != YFilter.not_set or
                                    self.fpd_adj_msg.yfilter != YFilter.not_set or
                                    self.fpd_adj_tx_retry_nh_found.yfilter != YFilter.not_set or
                                    self.fpd_adj_tx_retry_obj_reinit.yfilter != YFilter.not_set or
                                    self.fpd_adj_upd.yfilter != YFilter.not_set or
                                    self.fpd_adj_upd_tx.yfilter != YFilter.not_set or
                                    self.fpd_adj_upd_tx_nh_found.yfilter != YFilter.not_set or
                                    self.fpd_adj_upd_tx_retry_created.yfilter != YFilter.not_set or
                                    self.fpd_bcdl_msgs.yfilter != YFilter.not_set or
                                    self.fpd_gbltbl_entries.yfilter != YFilter.not_set or
                                    self.fpd_gbltbl_rej_entries.yfilter != YFilter.not_set or
                                    self.fpd_lbl_recycled.yfilter != YFilter.not_set or
                                    self.fpd_ldi_avg_backup_activate_time.yfilter != YFilter.not_set or
                                    self.fpd_ldi_backup_activate_count.yfilter != YFilter.not_set or
                                    self.fpd_ldi_last_backup_activate_time.yfilter != YFilter.not_set or
                                    self.fpd_ldi_max_backup_activate_time.yfilter != YFilter.not_set or
                                    self.fpd_ldi_min_backup_activate_time.yfilter != YFilter.not_set or
                                    self.fpd_ldi_num_correct_fixup.yfilter != YFilter.not_set or
                                    self.fpd_ldi_num_del_refcnt.yfilter != YFilter.not_set or
                                    self.fpd_ldi_num_fixedup.yfilter != YFilter.not_set or
                                    self.fpd_ldi_total_backup_activate_time.yfilter != YFilter.not_set or
                                    self.fpd_num_allocs.yfilter != YFilter.not_set or
                                    self.fpd_num_frees.yfilter != YFilter.not_set or
                                    self.fpd_num_retry_touts.yfilter != YFilter.not_set or
                                    self.fpd_num_tbls.yfilter != YFilter.not_set or
                                    self.fpd_pl_backup_disable_count.yfilter != YFilter.not_set or
                                    self.fpd_pl_backup_enable_count.yfilter != YFilter.not_set or
                                    self.fpd_pl_fast_nfn_count.yfilter != YFilter.not_set or
                                    self.fpd_pl_inline_res_q.yfilter != YFilter.not_set or
                                    self.fpd_pl_num_correct_fixup.yfilter != YFilter.not_set or
                                    self.fpd_pl_num_queued_fixedup.yfilter != YFilter.not_set or
                                    self.fpd_pl_retry_add_exist.yfilter != YFilter.not_set or
                                    self.fpd_pl_with_backup_create_count.yfilter != YFilter.not_set or
                                    self.fpd_pl_with_backup_del_count.yfilter != YFilter.not_set or
                                    self.fpd_recursion_constraint_count.yfilter != YFilter.not_set or
                                    self.fpd_retryq_sched_time.yfilter != YFilter.not_set or
                                    self.fpd_retryq_size.yfilter != YFilter.not_set or
                                    self.fpd_retryq_timeout.yfilter != YFilter.not_set or
                                    self.fpd_route_del.yfilter != YFilter.not_set or
                                    self.fpd_route_drops.yfilter != YFilter.not_set or
                                    self.fpd_route_rcv.yfilter != YFilter.not_set or
                                    self.fpd_route_upd.yfilter != YFilter.not_set or
                                    self.fpd_te_rcv.yfilter != YFilter.not_set or
                                    self.fpd_te_version_mismatch_drops.yfilter != YFilter.not_set or
                                    self.fpd_version_mismatch_drops.yfilter != YFilter.not_set or
                                    self.fpd_vrftbl_entries.yfilter != YFilter.not_set or
                                    self.fpd_vrftbl_rej_entries.yfilter != YFilter.not_set or
                                    (self.fpd_gtrie_timing is not None and self.fpd_gtrie_timing.has_operation()) or
                                    (self.fpd_platf_upd_stats is not None and self.fpd_platf_upd_stats.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-proto-dbg-stat" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fpd_adj_del.is_set or self.fpd_adj_del.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_adj_del.get_name_leafdata())
                                if (self.fpd_adj_drops.is_set or self.fpd_adj_drops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_adj_drops.get_name_leafdata())
                                if (self.fpd_adj_msg.is_set or self.fpd_adj_msg.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_adj_msg.get_name_leafdata())
                                if (self.fpd_adj_tx_retry_nh_found.is_set or self.fpd_adj_tx_retry_nh_found.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_adj_tx_retry_nh_found.get_name_leafdata())
                                if (self.fpd_adj_tx_retry_obj_reinit.is_set or self.fpd_adj_tx_retry_obj_reinit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_adj_tx_retry_obj_reinit.get_name_leafdata())
                                if (self.fpd_adj_upd.is_set or self.fpd_adj_upd.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_adj_upd.get_name_leafdata())
                                if (self.fpd_adj_upd_tx.is_set or self.fpd_adj_upd_tx.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_adj_upd_tx.get_name_leafdata())
                                if (self.fpd_adj_upd_tx_nh_found.is_set or self.fpd_adj_upd_tx_nh_found.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_adj_upd_tx_nh_found.get_name_leafdata())
                                if (self.fpd_adj_upd_tx_retry_created.is_set or self.fpd_adj_upd_tx_retry_created.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_adj_upd_tx_retry_created.get_name_leafdata())
                                if (self.fpd_bcdl_msgs.is_set or self.fpd_bcdl_msgs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_bcdl_msgs.get_name_leafdata())
                                if (self.fpd_gbltbl_entries.is_set or self.fpd_gbltbl_entries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_gbltbl_entries.get_name_leafdata())
                                if (self.fpd_gbltbl_rej_entries.is_set or self.fpd_gbltbl_rej_entries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_gbltbl_rej_entries.get_name_leafdata())
                                if (self.fpd_lbl_recycled.is_set or self.fpd_lbl_recycled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_lbl_recycled.get_name_leafdata())
                                if (self.fpd_ldi_avg_backup_activate_time.is_set or self.fpd_ldi_avg_backup_activate_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_ldi_avg_backup_activate_time.get_name_leafdata())
                                if (self.fpd_ldi_backup_activate_count.is_set or self.fpd_ldi_backup_activate_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_ldi_backup_activate_count.get_name_leafdata())
                                if (self.fpd_ldi_last_backup_activate_time.is_set or self.fpd_ldi_last_backup_activate_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_ldi_last_backup_activate_time.get_name_leafdata())
                                if (self.fpd_ldi_max_backup_activate_time.is_set or self.fpd_ldi_max_backup_activate_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_ldi_max_backup_activate_time.get_name_leafdata())
                                if (self.fpd_ldi_min_backup_activate_time.is_set or self.fpd_ldi_min_backup_activate_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_ldi_min_backup_activate_time.get_name_leafdata())
                                if (self.fpd_ldi_num_correct_fixup.is_set or self.fpd_ldi_num_correct_fixup.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_ldi_num_correct_fixup.get_name_leafdata())
                                if (self.fpd_ldi_num_del_refcnt.is_set or self.fpd_ldi_num_del_refcnt.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_ldi_num_del_refcnt.get_name_leafdata())
                                if (self.fpd_ldi_num_fixedup.is_set or self.fpd_ldi_num_fixedup.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_ldi_num_fixedup.get_name_leafdata())
                                if (self.fpd_ldi_total_backup_activate_time.is_set or self.fpd_ldi_total_backup_activate_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_ldi_total_backup_activate_time.get_name_leafdata())
                                if (self.fpd_num_allocs.is_set or self.fpd_num_allocs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_num_allocs.get_name_leafdata())
                                if (self.fpd_num_frees.is_set or self.fpd_num_frees.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_num_frees.get_name_leafdata())
                                if (self.fpd_num_retry_touts.is_set or self.fpd_num_retry_touts.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_num_retry_touts.get_name_leafdata())
                                if (self.fpd_num_tbls.is_set or self.fpd_num_tbls.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_num_tbls.get_name_leafdata())
                                if (self.fpd_pl_backup_disable_count.is_set or self.fpd_pl_backup_disable_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_pl_backup_disable_count.get_name_leafdata())
                                if (self.fpd_pl_backup_enable_count.is_set or self.fpd_pl_backup_enable_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_pl_backup_enable_count.get_name_leafdata())
                                if (self.fpd_pl_fast_nfn_count.is_set or self.fpd_pl_fast_nfn_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_pl_fast_nfn_count.get_name_leafdata())
                                if (self.fpd_pl_inline_res_q.is_set or self.fpd_pl_inline_res_q.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_pl_inline_res_q.get_name_leafdata())
                                if (self.fpd_pl_num_correct_fixup.is_set or self.fpd_pl_num_correct_fixup.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_pl_num_correct_fixup.get_name_leafdata())
                                if (self.fpd_pl_num_queued_fixedup.is_set or self.fpd_pl_num_queued_fixedup.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_pl_num_queued_fixedup.get_name_leafdata())
                                if (self.fpd_pl_retry_add_exist.is_set or self.fpd_pl_retry_add_exist.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_pl_retry_add_exist.get_name_leafdata())
                                if (self.fpd_pl_with_backup_create_count.is_set or self.fpd_pl_with_backup_create_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_pl_with_backup_create_count.get_name_leafdata())
                                if (self.fpd_pl_with_backup_del_count.is_set or self.fpd_pl_with_backup_del_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_pl_with_backup_del_count.get_name_leafdata())
                                if (self.fpd_recursion_constraint_count.is_set or self.fpd_recursion_constraint_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_recursion_constraint_count.get_name_leafdata())
                                if (self.fpd_retryq_sched_time.is_set or self.fpd_retryq_sched_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_retryq_sched_time.get_name_leafdata())
                                if (self.fpd_retryq_size.is_set or self.fpd_retryq_size.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_retryq_size.get_name_leafdata())
                                if (self.fpd_retryq_timeout.is_set or self.fpd_retryq_timeout.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_retryq_timeout.get_name_leafdata())
                                if (self.fpd_route_del.is_set or self.fpd_route_del.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_route_del.get_name_leafdata())
                                if (self.fpd_route_drops.is_set or self.fpd_route_drops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_route_drops.get_name_leafdata())
                                if (self.fpd_route_rcv.is_set or self.fpd_route_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_route_rcv.get_name_leafdata())
                                if (self.fpd_route_upd.is_set or self.fpd_route_upd.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_route_upd.get_name_leafdata())
                                if (self.fpd_te_rcv.is_set or self.fpd_te_rcv.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_te_rcv.get_name_leafdata())
                                if (self.fpd_te_version_mismatch_drops.is_set or self.fpd_te_version_mismatch_drops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_te_version_mismatch_drops.get_name_leafdata())
                                if (self.fpd_version_mismatch_drops.is_set or self.fpd_version_mismatch_drops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_version_mismatch_drops.get_name_leafdata())
                                if (self.fpd_vrftbl_entries.is_set or self.fpd_vrftbl_entries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_vrftbl_entries.get_name_leafdata())
                                if (self.fpd_vrftbl_rej_entries.is_set or self.fpd_vrftbl_rej_entries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fpd_vrftbl_rej_entries.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "fpd-gbltbl-src-entry"):
                                    for c in self.fpd_gbltbl_src_entry:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGbltblSrcEntry()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fpd_gbltbl_src_entry.append(c)
                                    return c

                                if (child_yang_name == "fpd-gtrie-timing"):
                                    if (self.fpd_gtrie_timing is None):
                                        self.fpd_gtrie_timing = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdGtrieTiming()
                                        self.fpd_gtrie_timing.parent = self
                                        self._children_name_map["fpd_gtrie_timing"] = "fpd-gtrie-timing"
                                    return self.fpd_gtrie_timing

                                if (child_yang_name == "fpd-num-retry"):
                                    for c in self.fpd_num_retry:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdNumRetry()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fpd_num_retry.append(c)
                                    return c

                                if (child_yang_name == "fpd-platf-upd-stats"):
                                    if (self.fpd_platf_upd_stats is None):
                                        self.fpd_platf_upd_stats = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdPlatfUpdStats()
                                        self.fpd_platf_upd_stats.parent = self
                                        self._children_name_map["fpd_platf_upd_stats"] = "fpd-platf-upd-stats"
                                    return self.fpd_platf_upd_stats

                                if (child_yang_name == "fpd-vrftbl-src-entry"):
                                    for c in self.fpd_vrftbl_src_entry:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat.FpdVrftblSrcEntry()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fpd_vrftbl_src_entry.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fpd-gbltbl-src-entry" or name == "fpd-gtrie-timing" or name == "fpd-num-retry" or name == "fpd-platf-upd-stats" or name == "fpd-vrftbl-src-entry" or name == "fpd-adj-del" or name == "fpd-adj-drops" or name == "fpd-adj-msg" or name == "fpd-adj-tx-retry-nh-found" or name == "fpd-adj-tx-retry-obj-reinit" or name == "fpd-adj-upd" or name == "fpd-adj-upd-tx" or name == "fpd-adj-upd-tx-nh-found" or name == "fpd-adj-upd-tx-retry-created" or name == "fpd-bcdl-msgs" or name == "fpd-gbltbl-entries" or name == "fpd-gbltbl-rej-entries" or name == "fpd-lbl-recycled" or name == "fpd-ldi-avg-backup-activate-time" or name == "fpd-ldi-backup-activate-count" or name == "fpd-ldi-last-backup-activate-time" or name == "fpd-ldi-max-backup-activate-time" or name == "fpd-ldi-min-backup-activate-time" or name == "fpd-ldi-num-correct-fixup" or name == "fpd-ldi-num-del-refcnt" or name == "fpd-ldi-num-fixedup" or name == "fpd-ldi-total-backup-activate-time" or name == "fpd-num-allocs" or name == "fpd-num-frees" or name == "fpd-num-retry-touts" or name == "fpd-num-tbls" or name == "fpd-pl-backup-disable-count" or name == "fpd-pl-backup-enable-count" or name == "fpd-pl-fast-nfn-count" or name == "fpd-pl-inline-res-q" or name == "fpd-pl-num-correct-fixup" or name == "fpd-pl-num-queued-fixedup" or name == "fpd-pl-retry-add-exist" or name == "fpd-pl-with-backup-create-count" or name == "fpd-pl-with-backup-del-count" or name == "fpd-recursion-constraint-count" or name == "fpd-retryq-sched-time" or name == "fpd-retryq-size" or name == "fpd-retryq-timeout" or name == "fpd-route-del" or name == "fpd-route-drops" or name == "fpd-route-rcv" or name == "fpd-route-upd" or name == "fpd-te-rcv" or name == "fpd-te-version-mismatch-drops" or name == "fpd-version-mismatch-drops" or name == "fpd-vrftbl-entries" or name == "fpd-vrftbl-rej-entries"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fpd-adj-del"):
                                    self.fpd_adj_del = value
                                    self.fpd_adj_del.value_namespace = name_space
                                    self.fpd_adj_del.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-adj-drops"):
                                    self.fpd_adj_drops = value
                                    self.fpd_adj_drops.value_namespace = name_space
                                    self.fpd_adj_drops.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-adj-msg"):
                                    self.fpd_adj_msg = value
                                    self.fpd_adj_msg.value_namespace = name_space
                                    self.fpd_adj_msg.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-adj-tx-retry-nh-found"):
                                    self.fpd_adj_tx_retry_nh_found = value
                                    self.fpd_adj_tx_retry_nh_found.value_namespace = name_space
                                    self.fpd_adj_tx_retry_nh_found.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-adj-tx-retry-obj-reinit"):
                                    self.fpd_adj_tx_retry_obj_reinit = value
                                    self.fpd_adj_tx_retry_obj_reinit.value_namespace = name_space
                                    self.fpd_adj_tx_retry_obj_reinit.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-adj-upd"):
                                    self.fpd_adj_upd = value
                                    self.fpd_adj_upd.value_namespace = name_space
                                    self.fpd_adj_upd.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-adj-upd-tx"):
                                    self.fpd_adj_upd_tx = value
                                    self.fpd_adj_upd_tx.value_namespace = name_space
                                    self.fpd_adj_upd_tx.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-adj-upd-tx-nh-found"):
                                    self.fpd_adj_upd_tx_nh_found = value
                                    self.fpd_adj_upd_tx_nh_found.value_namespace = name_space
                                    self.fpd_adj_upd_tx_nh_found.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-adj-upd-tx-retry-created"):
                                    self.fpd_adj_upd_tx_retry_created = value
                                    self.fpd_adj_upd_tx_retry_created.value_namespace = name_space
                                    self.fpd_adj_upd_tx_retry_created.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-bcdl-msgs"):
                                    self.fpd_bcdl_msgs = value
                                    self.fpd_bcdl_msgs.value_namespace = name_space
                                    self.fpd_bcdl_msgs.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-gbltbl-entries"):
                                    self.fpd_gbltbl_entries = value
                                    self.fpd_gbltbl_entries.value_namespace = name_space
                                    self.fpd_gbltbl_entries.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-gbltbl-rej-entries"):
                                    self.fpd_gbltbl_rej_entries = value
                                    self.fpd_gbltbl_rej_entries.value_namespace = name_space
                                    self.fpd_gbltbl_rej_entries.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-lbl-recycled"):
                                    self.fpd_lbl_recycled = value
                                    self.fpd_lbl_recycled.value_namespace = name_space
                                    self.fpd_lbl_recycled.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-ldi-avg-backup-activate-time"):
                                    self.fpd_ldi_avg_backup_activate_time = value
                                    self.fpd_ldi_avg_backup_activate_time.value_namespace = name_space
                                    self.fpd_ldi_avg_backup_activate_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-ldi-backup-activate-count"):
                                    self.fpd_ldi_backup_activate_count = value
                                    self.fpd_ldi_backup_activate_count.value_namespace = name_space
                                    self.fpd_ldi_backup_activate_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-ldi-last-backup-activate-time"):
                                    self.fpd_ldi_last_backup_activate_time = value
                                    self.fpd_ldi_last_backup_activate_time.value_namespace = name_space
                                    self.fpd_ldi_last_backup_activate_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-ldi-max-backup-activate-time"):
                                    self.fpd_ldi_max_backup_activate_time = value
                                    self.fpd_ldi_max_backup_activate_time.value_namespace = name_space
                                    self.fpd_ldi_max_backup_activate_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-ldi-min-backup-activate-time"):
                                    self.fpd_ldi_min_backup_activate_time = value
                                    self.fpd_ldi_min_backup_activate_time.value_namespace = name_space
                                    self.fpd_ldi_min_backup_activate_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-ldi-num-correct-fixup"):
                                    self.fpd_ldi_num_correct_fixup = value
                                    self.fpd_ldi_num_correct_fixup.value_namespace = name_space
                                    self.fpd_ldi_num_correct_fixup.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-ldi-num-del-refcnt"):
                                    self.fpd_ldi_num_del_refcnt = value
                                    self.fpd_ldi_num_del_refcnt.value_namespace = name_space
                                    self.fpd_ldi_num_del_refcnt.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-ldi-num-fixedup"):
                                    self.fpd_ldi_num_fixedup = value
                                    self.fpd_ldi_num_fixedup.value_namespace = name_space
                                    self.fpd_ldi_num_fixedup.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-ldi-total-backup-activate-time"):
                                    self.fpd_ldi_total_backup_activate_time = value
                                    self.fpd_ldi_total_backup_activate_time.value_namespace = name_space
                                    self.fpd_ldi_total_backup_activate_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-num-allocs"):
                                    self.fpd_num_allocs = value
                                    self.fpd_num_allocs.value_namespace = name_space
                                    self.fpd_num_allocs.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-num-frees"):
                                    self.fpd_num_frees = value
                                    self.fpd_num_frees.value_namespace = name_space
                                    self.fpd_num_frees.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-num-retry-touts"):
                                    self.fpd_num_retry_touts = value
                                    self.fpd_num_retry_touts.value_namespace = name_space
                                    self.fpd_num_retry_touts.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-num-tbls"):
                                    self.fpd_num_tbls = value
                                    self.fpd_num_tbls.value_namespace = name_space
                                    self.fpd_num_tbls.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-pl-backup-disable-count"):
                                    self.fpd_pl_backup_disable_count = value
                                    self.fpd_pl_backup_disable_count.value_namespace = name_space
                                    self.fpd_pl_backup_disable_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-pl-backup-enable-count"):
                                    self.fpd_pl_backup_enable_count = value
                                    self.fpd_pl_backup_enable_count.value_namespace = name_space
                                    self.fpd_pl_backup_enable_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-pl-fast-nfn-count"):
                                    self.fpd_pl_fast_nfn_count = value
                                    self.fpd_pl_fast_nfn_count.value_namespace = name_space
                                    self.fpd_pl_fast_nfn_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-pl-inline-res-q"):
                                    self.fpd_pl_inline_res_q = value
                                    self.fpd_pl_inline_res_q.value_namespace = name_space
                                    self.fpd_pl_inline_res_q.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-pl-num-correct-fixup"):
                                    self.fpd_pl_num_correct_fixup = value
                                    self.fpd_pl_num_correct_fixup.value_namespace = name_space
                                    self.fpd_pl_num_correct_fixup.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-pl-num-queued-fixedup"):
                                    self.fpd_pl_num_queued_fixedup = value
                                    self.fpd_pl_num_queued_fixedup.value_namespace = name_space
                                    self.fpd_pl_num_queued_fixedup.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-pl-retry-add-exist"):
                                    self.fpd_pl_retry_add_exist = value
                                    self.fpd_pl_retry_add_exist.value_namespace = name_space
                                    self.fpd_pl_retry_add_exist.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-pl-with-backup-create-count"):
                                    self.fpd_pl_with_backup_create_count = value
                                    self.fpd_pl_with_backup_create_count.value_namespace = name_space
                                    self.fpd_pl_with_backup_create_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-pl-with-backup-del-count"):
                                    self.fpd_pl_with_backup_del_count = value
                                    self.fpd_pl_with_backup_del_count.value_namespace = name_space
                                    self.fpd_pl_with_backup_del_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-recursion-constraint-count"):
                                    self.fpd_recursion_constraint_count = value
                                    self.fpd_recursion_constraint_count.value_namespace = name_space
                                    self.fpd_recursion_constraint_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-retryq-sched-time"):
                                    self.fpd_retryq_sched_time = value
                                    self.fpd_retryq_sched_time.value_namespace = name_space
                                    self.fpd_retryq_sched_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-retryq-size"):
                                    self.fpd_retryq_size = value
                                    self.fpd_retryq_size.value_namespace = name_space
                                    self.fpd_retryq_size.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-retryq-timeout"):
                                    self.fpd_retryq_timeout = value
                                    self.fpd_retryq_timeout.value_namespace = name_space
                                    self.fpd_retryq_timeout.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-route-del"):
                                    self.fpd_route_del = value
                                    self.fpd_route_del.value_namespace = name_space
                                    self.fpd_route_del.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-route-drops"):
                                    self.fpd_route_drops = value
                                    self.fpd_route_drops.value_namespace = name_space
                                    self.fpd_route_drops.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-route-rcv"):
                                    self.fpd_route_rcv = value
                                    self.fpd_route_rcv.value_namespace = name_space
                                    self.fpd_route_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-route-upd"):
                                    self.fpd_route_upd = value
                                    self.fpd_route_upd.value_namespace = name_space
                                    self.fpd_route_upd.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-te-rcv"):
                                    self.fpd_te_rcv = value
                                    self.fpd_te_rcv.value_namespace = name_space
                                    self.fpd_te_rcv.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-te-version-mismatch-drops"):
                                    self.fpd_te_version_mismatch_drops = value
                                    self.fpd_te_version_mismatch_drops.value_namespace = name_space
                                    self.fpd_te_version_mismatch_drops.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-version-mismatch-drops"):
                                    self.fpd_version_mismatch_drops = value
                                    self.fpd_version_mismatch_drops.value_namespace = name_space
                                    self.fpd_version_mismatch_drops.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-vrftbl-entries"):
                                    self.fpd_vrftbl_entries = value
                                    self.fpd_vrftbl_entries.value_namespace = name_space
                                    self.fpd_vrftbl_entries.value_namespace_prefix = name_space_prefix
                                if(value_path == "fpd-vrftbl-rej-entries"):
                                    self.fpd_vrftbl_rej_entries = value
                                    self.fpd_vrftbl_rej_entries.value_namespace = name_space
                                    self.fpd_vrftbl_rej_entries.value_namespace_prefix = name_space_prefix


                        class MiIdbPurgeCntr(Entity):
                            """
                            the number of counters used for purge counter
                            stats
                            
                            .. attribute:: fpp_cntr
                            
                            	the number of frees for this proto
                            	**type**\: list of    :py:class:`FppCntr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr.FppCntr>`
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr, self).__init__()

                                self.yang_name = "mi-idb-purge-cntr"
                                self.yang_parent_name = "misc"

                                self.fpp_cntr = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr, self).__setattr__(name, value)


                            class FppCntr(Entity):
                                """
                                the number of frees for this proto
                                
                                .. attribute:: entry
                                
                                	
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr.FppCntr, self).__init__()

                                    self.yang_name = "fpp-cntr"
                                    self.yang_parent_name = "mi-idb-purge-cntr"

                                    self.entry = YLeaf(YType.uint32, "entry")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr.FppCntr, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr.FppCntr, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.entry.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fpp-cntr" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "entry"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry"):
                                        self.entry = value
                                        self.entry.value_namespace = name_space
                                        self.entry.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.fpp_cntr:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.fpp_cntr:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-idb-purge-cntr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "fpp-cntr"):
                                    for c in self.fpp_cntr:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr.FppCntr()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.fpp_cntr.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fpp-cntr"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class MiDel(Entity):
                            """
                            Timestamps of deleted routes
                            
                            .. attribute:: msec_time
                            
                            	msec time
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: prfx
                            
                            	prfx
                            	**type**\:  str
                            
                            	**length:** 0..16
                            
                            .. attribute:: prfx_len
                            
                            	prfx len
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: prfx_proto
                            
                            	prfx proto
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: tableid
                            
                            	tableid
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiDel, self).__init__()

                                self.yang_name = "mi-del"
                                self.yang_parent_name = "misc"

                                self.msec_time = YLeaf(YType.uint64, "msec-time")

                                self.prfx = YLeaf(YType.str, "prfx")

                                self.prfx_len = YLeaf(YType.uint16, "prfx-len")

                                self.prfx_proto = YLeaf(YType.uint16, "prfx-proto")

                                self.tableid = YLeaf(YType.uint32, "tableid")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("msec_time",
                                                "prfx",
                                                "prfx_len",
                                                "prfx_proto",
                                                "tableid") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiDel, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiDel, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.msec_time.is_set or
                                    self.prfx.is_set or
                                    self.prfx_len.is_set or
                                    self.prfx_proto.is_set or
                                    self.tableid.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.msec_time.yfilter != YFilter.not_set or
                                    self.prfx.yfilter != YFilter.not_set or
                                    self.prfx_len.yfilter != YFilter.not_set or
                                    self.prfx_proto.yfilter != YFilter.not_set or
                                    self.tableid.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-del" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.msec_time.is_set or self.msec_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.msec_time.get_name_leafdata())
                                if (self.prfx.is_set or self.prfx.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prfx.get_name_leafdata())
                                if (self.prfx_len.is_set or self.prfx_len.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prfx_len.get_name_leafdata())
                                if (self.prfx_proto.is_set or self.prfx_proto.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prfx_proto.get_name_leafdata())
                                if (self.tableid.is_set or self.tableid.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tableid.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "msec-time" or name == "prfx" or name == "prfx-len" or name == "prfx-proto" or name == "tableid"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "msec-time"):
                                    self.msec_time = value
                                    self.msec_time.value_namespace = name_space
                                    self.msec_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "prfx"):
                                    self.prfx = value
                                    self.prfx.value_namespace = name_space
                                    self.prfx.value_namespace_prefix = name_space_prefix
                                if(value_path == "prfx-len"):
                                    self.prfx_len = value
                                    self.prfx_len.value_namespace = name_space
                                    self.prfx_len.value_namespace_prefix = name_space_prefix
                                if(value_path == "prfx-proto"):
                                    self.prfx_proto = value
                                    self.prfx_proto.value_namespace = name_space
                                    self.prfx_proto.value_namespace_prefix = name_space_prefix
                                if(value_path == "tableid"):
                                    self.tableid = value
                                    self.tableid.value_namespace = name_space
                                    self.tableid.value_namespace_prefix = name_space_prefix


                        class MiFrrStat(Entity):
                            """
                            FRR statistics
                            
                            .. attribute:: mi_num_bfd_down
                            
                            	number of NH down FRR events frm BFD
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_bkup_frr_objects
                            
                            	total number of backup FRR objects
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_frr_logs
                            
                            	frr log size
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_frr_proto_events
                            
                            	number of frr events received in proto thread
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_frr_reset
                            
                            	number of frr resets
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_frr_reset_queue_adds
                            
                            	number of frr reset queue adds
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_frr_reset_queue_remove
                            
                            	number of frr reset queue deletes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_intf_frr
                            
                            	number of FRR events sent on nh interface down
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_parent_intf_frr
                            
                            	number of FRR events sent on nh parent interface down
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_pfi_intf_down
                            
                            	number of interface down FRR events from PFI
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_prot_frr_objects
                            
                            	total number of prot FRR objects
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_tunid_alloc_failures
                            
                            	total number of FRR tunnel ID allocation failures
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_tunid_allocs
                            
                            	total number of successful FRR tunnel ID allocations
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_tunid_free_failures
                            
                            	total number of FRR tunnel ID free failures
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mi_num_tunid_frees
                            
                            	total number of successful FRR tunnel ID frees
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiFrrStat, self).__init__()

                                self.yang_name = "mi-frr-stat"
                                self.yang_parent_name = "misc"

                                self.mi_num_bfd_down = YLeaf(YType.uint32, "mi-num-bfd-down")

                                self.mi_num_bkup_frr_objects = YLeaf(YType.uint32, "mi-num-bkup-frr-objects")

                                self.mi_num_frr_logs = YLeaf(YType.uint32, "mi-num-frr-logs")

                                self.mi_num_frr_proto_events = YLeaf(YType.uint32, "mi-num-frr-proto-events")

                                self.mi_num_frr_reset = YLeaf(YType.uint32, "mi-num-frr-reset")

                                self.mi_num_frr_reset_queue_adds = YLeaf(YType.uint32, "mi-num-frr-reset-queue-adds")

                                self.mi_num_frr_reset_queue_remove = YLeaf(YType.uint32, "mi-num-frr-reset-queue-remove")

                                self.mi_num_intf_frr = YLeaf(YType.uint32, "mi-num-intf-frr")

                                self.mi_num_parent_intf_frr = YLeaf(YType.uint32, "mi-num-parent-intf-frr")

                                self.mi_num_pfi_intf_down = YLeaf(YType.uint32, "mi-num-pfi-intf-down")

                                self.mi_num_prot_frr_objects = YLeaf(YType.uint32, "mi-num-prot-frr-objects")

                                self.mi_num_tunid_alloc_failures = YLeaf(YType.uint32, "mi-num-tunid-alloc-failures")

                                self.mi_num_tunid_allocs = YLeaf(YType.uint32, "mi-num-tunid-allocs")

                                self.mi_num_tunid_free_failures = YLeaf(YType.uint32, "mi-num-tunid-free-failures")

                                self.mi_num_tunid_frees = YLeaf(YType.uint32, "mi-num-tunid-frees")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("mi_num_bfd_down",
                                                "mi_num_bkup_frr_objects",
                                                "mi_num_frr_logs",
                                                "mi_num_frr_proto_events",
                                                "mi_num_frr_reset",
                                                "mi_num_frr_reset_queue_adds",
                                                "mi_num_frr_reset_queue_remove",
                                                "mi_num_intf_frr",
                                                "mi_num_parent_intf_frr",
                                                "mi_num_pfi_intf_down",
                                                "mi_num_prot_frr_objects",
                                                "mi_num_tunid_alloc_failures",
                                                "mi_num_tunid_allocs",
                                                "mi_num_tunid_free_failures",
                                                "mi_num_tunid_frees") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiFrrStat, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.Misc.MiFrrStat, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.mi_num_bfd_down.is_set or
                                    self.mi_num_bkup_frr_objects.is_set or
                                    self.mi_num_frr_logs.is_set or
                                    self.mi_num_frr_proto_events.is_set or
                                    self.mi_num_frr_reset.is_set or
                                    self.mi_num_frr_reset_queue_adds.is_set or
                                    self.mi_num_frr_reset_queue_remove.is_set or
                                    self.mi_num_intf_frr.is_set or
                                    self.mi_num_parent_intf_frr.is_set or
                                    self.mi_num_pfi_intf_down.is_set or
                                    self.mi_num_prot_frr_objects.is_set or
                                    self.mi_num_tunid_alloc_failures.is_set or
                                    self.mi_num_tunid_allocs.is_set or
                                    self.mi_num_tunid_free_failures.is_set or
                                    self.mi_num_tunid_frees.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.mi_num_bfd_down.yfilter != YFilter.not_set or
                                    self.mi_num_bkup_frr_objects.yfilter != YFilter.not_set or
                                    self.mi_num_frr_logs.yfilter != YFilter.not_set or
                                    self.mi_num_frr_proto_events.yfilter != YFilter.not_set or
                                    self.mi_num_frr_reset.yfilter != YFilter.not_set or
                                    self.mi_num_frr_reset_queue_adds.yfilter != YFilter.not_set or
                                    self.mi_num_frr_reset_queue_remove.yfilter != YFilter.not_set or
                                    self.mi_num_intf_frr.yfilter != YFilter.not_set or
                                    self.mi_num_parent_intf_frr.yfilter != YFilter.not_set or
                                    self.mi_num_pfi_intf_down.yfilter != YFilter.not_set or
                                    self.mi_num_prot_frr_objects.yfilter != YFilter.not_set or
                                    self.mi_num_tunid_alloc_failures.yfilter != YFilter.not_set or
                                    self.mi_num_tunid_allocs.yfilter != YFilter.not_set or
                                    self.mi_num_tunid_free_failures.yfilter != YFilter.not_set or
                                    self.mi_num_tunid_frees.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mi-frr-stat" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.mi_num_bfd_down.is_set or self.mi_num_bfd_down.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_bfd_down.get_name_leafdata())
                                if (self.mi_num_bkup_frr_objects.is_set or self.mi_num_bkup_frr_objects.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_bkup_frr_objects.get_name_leafdata())
                                if (self.mi_num_frr_logs.is_set or self.mi_num_frr_logs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_frr_logs.get_name_leafdata())
                                if (self.mi_num_frr_proto_events.is_set or self.mi_num_frr_proto_events.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_frr_proto_events.get_name_leafdata())
                                if (self.mi_num_frr_reset.is_set or self.mi_num_frr_reset.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_frr_reset.get_name_leafdata())
                                if (self.mi_num_frr_reset_queue_adds.is_set or self.mi_num_frr_reset_queue_adds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_frr_reset_queue_adds.get_name_leafdata())
                                if (self.mi_num_frr_reset_queue_remove.is_set or self.mi_num_frr_reset_queue_remove.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_frr_reset_queue_remove.get_name_leafdata())
                                if (self.mi_num_intf_frr.is_set or self.mi_num_intf_frr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_intf_frr.get_name_leafdata())
                                if (self.mi_num_parent_intf_frr.is_set or self.mi_num_parent_intf_frr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_parent_intf_frr.get_name_leafdata())
                                if (self.mi_num_pfi_intf_down.is_set or self.mi_num_pfi_intf_down.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_pfi_intf_down.get_name_leafdata())
                                if (self.mi_num_prot_frr_objects.is_set or self.mi_num_prot_frr_objects.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_prot_frr_objects.get_name_leafdata())
                                if (self.mi_num_tunid_alloc_failures.is_set or self.mi_num_tunid_alloc_failures.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_tunid_alloc_failures.get_name_leafdata())
                                if (self.mi_num_tunid_allocs.is_set or self.mi_num_tunid_allocs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_tunid_allocs.get_name_leafdata())
                                if (self.mi_num_tunid_free_failures.is_set or self.mi_num_tunid_free_failures.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_tunid_free_failures.get_name_leafdata())
                                if (self.mi_num_tunid_frees.is_set or self.mi_num_tunid_frees.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mi_num_tunid_frees.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "mi-num-bfd-down" or name == "mi-num-bkup-frr-objects" or name == "mi-num-frr-logs" or name == "mi-num-frr-proto-events" or name == "mi-num-frr-reset" or name == "mi-num-frr-reset-queue-adds" or name == "mi-num-frr-reset-queue-remove" or name == "mi-num-intf-frr" or name == "mi-num-parent-intf-frr" or name == "mi-num-pfi-intf-down" or name == "mi-num-prot-frr-objects" or name == "mi-num-tunid-alloc-failures" or name == "mi-num-tunid-allocs" or name == "mi-num-tunid-free-failures" or name == "mi-num-tunid-frees"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "mi-num-bfd-down"):
                                    self.mi_num_bfd_down = value
                                    self.mi_num_bfd_down.value_namespace = name_space
                                    self.mi_num_bfd_down.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-bkup-frr-objects"):
                                    self.mi_num_bkup_frr_objects = value
                                    self.mi_num_bkup_frr_objects.value_namespace = name_space
                                    self.mi_num_bkup_frr_objects.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-frr-logs"):
                                    self.mi_num_frr_logs = value
                                    self.mi_num_frr_logs.value_namespace = name_space
                                    self.mi_num_frr_logs.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-frr-proto-events"):
                                    self.mi_num_frr_proto_events = value
                                    self.mi_num_frr_proto_events.value_namespace = name_space
                                    self.mi_num_frr_proto_events.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-frr-reset"):
                                    self.mi_num_frr_reset = value
                                    self.mi_num_frr_reset.value_namespace = name_space
                                    self.mi_num_frr_reset.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-frr-reset-queue-adds"):
                                    self.mi_num_frr_reset_queue_adds = value
                                    self.mi_num_frr_reset_queue_adds.value_namespace = name_space
                                    self.mi_num_frr_reset_queue_adds.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-frr-reset-queue-remove"):
                                    self.mi_num_frr_reset_queue_remove = value
                                    self.mi_num_frr_reset_queue_remove.value_namespace = name_space
                                    self.mi_num_frr_reset_queue_remove.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-intf-frr"):
                                    self.mi_num_intf_frr = value
                                    self.mi_num_intf_frr.value_namespace = name_space
                                    self.mi_num_intf_frr.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-parent-intf-frr"):
                                    self.mi_num_parent_intf_frr = value
                                    self.mi_num_parent_intf_frr.value_namespace = name_space
                                    self.mi_num_parent_intf_frr.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-pfi-intf-down"):
                                    self.mi_num_pfi_intf_down = value
                                    self.mi_num_pfi_intf_down.value_namespace = name_space
                                    self.mi_num_pfi_intf_down.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-prot-frr-objects"):
                                    self.mi_num_prot_frr_objects = value
                                    self.mi_num_prot_frr_objects.value_namespace = name_space
                                    self.mi_num_prot_frr_objects.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-tunid-alloc-failures"):
                                    self.mi_num_tunid_alloc_failures = value
                                    self.mi_num_tunid_alloc_failures.value_namespace = name_space
                                    self.mi_num_tunid_alloc_failures.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-tunid-allocs"):
                                    self.mi_num_tunid_allocs = value
                                    self.mi_num_tunid_allocs.value_namespace = name_space
                                    self.mi_num_tunid_allocs.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-tunid-free-failures"):
                                    self.mi_num_tunid_free_failures = value
                                    self.mi_num_tunid_free_failures.value_namespace = name_space
                                    self.mi_num_tunid_free_failures.value_namespace_prefix = name_space_prefix
                                if(value_path == "mi-num-tunid-frees"):
                                    self.mi_num_tunid_frees = value
                                    self.mi_num_tunid_frees.value_namespace = name_space
                                    self.mi_num_tunid_frees.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.mi_cpuless_node:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_del:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_frr_stat:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_idb_ext_cleanup_failed_count:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_idb_lsec_enabled_num:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_idb_purge_cntr:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_lrpf_num:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_lrpf_stats_act:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_lrpf_stats_fail:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_num_lisp_eid:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_num_lisp_valid_eid:
                                if (c.has_data()):
                                    return True
                            for c in self.mi_proto_dbg_stat:
                                if (c.has_data()):
                                    return True
                            return (
                                self.mi_clock_time.is_set or
                                self.mi_cpu_time.is_set or
                                self.mi_cpuless_count.is_set or
                                self.mi_cpuless_init.is_set or
                                self.mi_idb_recycle_cleanup_count.is_set or
                                self.mi_idb_recycle_count.is_set or
                                self.mi_num_mgmt_list.is_set or
                                self.mi_num_virtual_ll_addresses_added.is_set or
                                self.mi_num_virtual_ll_addresses_cached.is_set or
                                self.mi_num_virtual_ll_addresses_deleted.is_set or
                                self.mi_num_virtual_ll_addresses_dropped.is_set or
                                self.mi_pfi_ifh_del.is_set or
                                self.mi_pfi_ifh_stale.is_set or
                                self.mi_pfi_ifh_upd.is_set or
                                self.mi_prefer_aib_routes_over_rib_cfg.is_set or
                                self.mi_prefer_aib_routes_over_rib_oper.is_set or
                                self.mi_shm_reset_ts.is_set or
                                self.mi_tot_dnld_time.is_set or
                                self.mi_tot_gtrie_time.is_set or
                                self.mi_tot_plat_upd_time.is_set or
                                self.mi_xpl_ldi_enabled.is_set or
                                (self.mi_issu_state is not None and self.mi_issu_state.has_data()) or
                                (self.mi_plat_capabilities is not None and self.mi_plat_capabilities.has_data()))

                        def has_operation(self):
                            for c in self.mi_cpuless_node:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_del:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_frr_stat:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_idb_ext_cleanup_failed_count:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_idb_lsec_enabled_num:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_idb_purge_cntr:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_lrpf_num:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_lrpf_stats_act:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_lrpf_stats_fail:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_num_lisp_eid:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_num_lisp_valid_eid:
                                if (c.has_operation()):
                                    return True
                            for c in self.mi_proto_dbg_stat:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.mi_clock_time.yfilter != YFilter.not_set or
                                self.mi_cpu_time.yfilter != YFilter.not_set or
                                self.mi_cpuless_count.yfilter != YFilter.not_set or
                                self.mi_cpuless_init.yfilter != YFilter.not_set or
                                self.mi_idb_recycle_cleanup_count.yfilter != YFilter.not_set or
                                self.mi_idb_recycle_count.yfilter != YFilter.not_set or
                                self.mi_num_mgmt_list.yfilter != YFilter.not_set or
                                self.mi_num_virtual_ll_addresses_added.yfilter != YFilter.not_set or
                                self.mi_num_virtual_ll_addresses_cached.yfilter != YFilter.not_set or
                                self.mi_num_virtual_ll_addresses_deleted.yfilter != YFilter.not_set or
                                self.mi_num_virtual_ll_addresses_dropped.yfilter != YFilter.not_set or
                                self.mi_pfi_ifh_del.yfilter != YFilter.not_set or
                                self.mi_pfi_ifh_stale.yfilter != YFilter.not_set or
                                self.mi_pfi_ifh_upd.yfilter != YFilter.not_set or
                                self.mi_prefer_aib_routes_over_rib_cfg.yfilter != YFilter.not_set or
                                self.mi_prefer_aib_routes_over_rib_oper.yfilter != YFilter.not_set or
                                self.mi_shm_reset_ts.yfilter != YFilter.not_set or
                                self.mi_tot_dnld_time.yfilter != YFilter.not_set or
                                self.mi_tot_gtrie_time.yfilter != YFilter.not_set or
                                self.mi_tot_plat_upd_time.yfilter != YFilter.not_set or
                                self.mi_xpl_ldi_enabled.yfilter != YFilter.not_set or
                                (self.mi_issu_state is not None and self.mi_issu_state.has_operation()) or
                                (self.mi_plat_capabilities is not None and self.mi_plat_capabilities.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "misc" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.mi_clock_time.is_set or self.mi_clock_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_clock_time.get_name_leafdata())
                            if (self.mi_cpu_time.is_set or self.mi_cpu_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_cpu_time.get_name_leafdata())
                            if (self.mi_cpuless_count.is_set or self.mi_cpuless_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_cpuless_count.get_name_leafdata())
                            if (self.mi_cpuless_init.is_set or self.mi_cpuless_init.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_cpuless_init.get_name_leafdata())
                            if (self.mi_idb_recycle_cleanup_count.is_set or self.mi_idb_recycle_cleanup_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_idb_recycle_cleanup_count.get_name_leafdata())
                            if (self.mi_idb_recycle_count.is_set or self.mi_idb_recycle_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_idb_recycle_count.get_name_leafdata())
                            if (self.mi_num_mgmt_list.is_set or self.mi_num_mgmt_list.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_num_mgmt_list.get_name_leafdata())
                            if (self.mi_num_virtual_ll_addresses_added.is_set or self.mi_num_virtual_ll_addresses_added.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_num_virtual_ll_addresses_added.get_name_leafdata())
                            if (self.mi_num_virtual_ll_addresses_cached.is_set or self.mi_num_virtual_ll_addresses_cached.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_num_virtual_ll_addresses_cached.get_name_leafdata())
                            if (self.mi_num_virtual_ll_addresses_deleted.is_set or self.mi_num_virtual_ll_addresses_deleted.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_num_virtual_ll_addresses_deleted.get_name_leafdata())
                            if (self.mi_num_virtual_ll_addresses_dropped.is_set or self.mi_num_virtual_ll_addresses_dropped.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_num_virtual_ll_addresses_dropped.get_name_leafdata())
                            if (self.mi_pfi_ifh_del.is_set or self.mi_pfi_ifh_del.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_pfi_ifh_del.get_name_leafdata())
                            if (self.mi_pfi_ifh_stale.is_set or self.mi_pfi_ifh_stale.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_pfi_ifh_stale.get_name_leafdata())
                            if (self.mi_pfi_ifh_upd.is_set or self.mi_pfi_ifh_upd.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_pfi_ifh_upd.get_name_leafdata())
                            if (self.mi_prefer_aib_routes_over_rib_cfg.is_set or self.mi_prefer_aib_routes_over_rib_cfg.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_prefer_aib_routes_over_rib_cfg.get_name_leafdata())
                            if (self.mi_prefer_aib_routes_over_rib_oper.is_set or self.mi_prefer_aib_routes_over_rib_oper.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_prefer_aib_routes_over_rib_oper.get_name_leafdata())
                            if (self.mi_shm_reset_ts.is_set or self.mi_shm_reset_ts.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_shm_reset_ts.get_name_leafdata())
                            if (self.mi_tot_dnld_time.is_set or self.mi_tot_dnld_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_tot_dnld_time.get_name_leafdata())
                            if (self.mi_tot_gtrie_time.is_set or self.mi_tot_gtrie_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_tot_gtrie_time.get_name_leafdata())
                            if (self.mi_tot_plat_upd_time.is_set or self.mi_tot_plat_upd_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_tot_plat_upd_time.get_name_leafdata())
                            if (self.mi_xpl_ldi_enabled.is_set or self.mi_xpl_ldi_enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mi_xpl_ldi_enabled.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "mi-cpuless-node"):
                                for c in self.mi_cpuless_node:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiCpulessNode()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_cpuless_node.append(c)
                                return c

                            if (child_yang_name == "mi-del"):
                                for c in self.mi_del:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiDel()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_del.append(c)
                                return c

                            if (child_yang_name == "mi-frr-stat"):
                                for c in self.mi_frr_stat:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiFrrStat()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_frr_stat.append(c)
                                return c

                            if (child_yang_name == "mi-idb-ext-cleanup-failed-count"):
                                for c in self.mi_idb_ext_cleanup_failed_count:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbExtCleanupFailedCount()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_idb_ext_cleanup_failed_count.append(c)
                                return c

                            if (child_yang_name == "mi-idb-lsec-enabled-num"):
                                for c in self.mi_idb_lsec_enabled_num:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbLsecEnabledNum()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_idb_lsec_enabled_num.append(c)
                                return c

                            if (child_yang_name == "mi-idb-purge-cntr"):
                                for c in self.mi_idb_purge_cntr:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiIdbPurgeCntr()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_idb_purge_cntr.append(c)
                                return c

                            if (child_yang_name == "mi-issu-state"):
                                if (self.mi_issu_state is None):
                                    self.mi_issu_state = Fib.Nodes.Node.Protocols.Protocol.Misc.MiIssuState()
                                    self.mi_issu_state.parent = self
                                    self._children_name_map["mi_issu_state"] = "mi-issu-state"
                                return self.mi_issu_state

                            if (child_yang_name == "mi-lrpf-num"):
                                for c in self.mi_lrpf_num:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfNum()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_lrpf_num.append(c)
                                return c

                            if (child_yang_name == "mi-lrpf-stats-act"):
                                for c in self.mi_lrpf_stats_act:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsAct()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_lrpf_stats_act.append(c)
                                return c

                            if (child_yang_name == "mi-lrpf-stats-fail"):
                                for c in self.mi_lrpf_stats_fail:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiLrpfStatsFail()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_lrpf_stats_fail.append(c)
                                return c

                            if (child_yang_name == "mi-num-lisp-eid"):
                                for c in self.mi_num_lisp_eid:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispEid()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_num_lisp_eid.append(c)
                                return c

                            if (child_yang_name == "mi-num-lisp-valid-eid"):
                                for c in self.mi_num_lisp_valid_eid:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiNumLispValidEid()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_num_lisp_valid_eid.append(c)
                                return c

                            if (child_yang_name == "mi-plat-capabilities"):
                                if (self.mi_plat_capabilities is None):
                                    self.mi_plat_capabilities = Fib.Nodes.Node.Protocols.Protocol.Misc.MiPlatCapabilities()
                                    self.mi_plat_capabilities.parent = self
                                    self._children_name_map["mi_plat_capabilities"] = "mi-plat-capabilities"
                                return self.mi_plat_capabilities

                            if (child_yang_name == "mi-proto-dbg-stat"):
                                for c in self.mi_proto_dbg_stat:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Fib.Nodes.Node.Protocols.Protocol.Misc.MiProtoDbgStat()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.mi_proto_dbg_stat.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "mi-cpuless-node" or name == "mi-del" or name == "mi-frr-stat" or name == "mi-idb-ext-cleanup-failed-count" or name == "mi-idb-lsec-enabled-num" or name == "mi-idb-purge-cntr" or name == "mi-issu-state" or name == "mi-lrpf-num" or name == "mi-lrpf-stats-act" or name == "mi-lrpf-stats-fail" or name == "mi-num-lisp-eid" or name == "mi-num-lisp-valid-eid" or name == "mi-plat-capabilities" or name == "mi-proto-dbg-stat" or name == "mi-clock-time" or name == "mi-cpu-time" or name == "mi-cpuless-count" or name == "mi-cpuless-init" or name == "mi-idb-recycle-cleanup-count" or name == "mi-idb-recycle-count" or name == "mi-num-mgmt-list" or name == "mi-num-virtual-ll-addresses-added" or name == "mi-num-virtual-ll-addresses-cached" or name == "mi-num-virtual-ll-addresses-deleted" or name == "mi-num-virtual-ll-addresses-dropped" or name == "mi-pfi-ifh-del" or name == "mi-pfi-ifh-stale" or name == "mi-pfi-ifh-upd" or name == "mi-prefer-aib-routes-over-rib-cfg" or name == "mi-prefer-aib-routes-over-rib-oper" or name == "mi-shm-reset-ts" or name == "mi-tot-dnld-time" or name == "mi-tot-gtrie-time" or name == "mi-tot-plat-upd-time" or name == "mi-xpl-ldi-enabled"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "mi-clock-time"):
                                self.mi_clock_time = value
                                self.mi_clock_time.value_namespace = name_space
                                self.mi_clock_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-cpu-time"):
                                self.mi_cpu_time = value
                                self.mi_cpu_time.value_namespace = name_space
                                self.mi_cpu_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-cpuless-count"):
                                self.mi_cpuless_count = value
                                self.mi_cpuless_count.value_namespace = name_space
                                self.mi_cpuless_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-cpuless-init"):
                                self.mi_cpuless_init = value
                                self.mi_cpuless_init.value_namespace = name_space
                                self.mi_cpuless_init.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-idb-recycle-cleanup-count"):
                                self.mi_idb_recycle_cleanup_count = value
                                self.mi_idb_recycle_cleanup_count.value_namespace = name_space
                                self.mi_idb_recycle_cleanup_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-idb-recycle-count"):
                                self.mi_idb_recycle_count = value
                                self.mi_idb_recycle_count.value_namespace = name_space
                                self.mi_idb_recycle_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-num-mgmt-list"):
                                self.mi_num_mgmt_list = value
                                self.mi_num_mgmt_list.value_namespace = name_space
                                self.mi_num_mgmt_list.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-num-virtual-ll-addresses-added"):
                                self.mi_num_virtual_ll_addresses_added = value
                                self.mi_num_virtual_ll_addresses_added.value_namespace = name_space
                                self.mi_num_virtual_ll_addresses_added.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-num-virtual-ll-addresses-cached"):
                                self.mi_num_virtual_ll_addresses_cached = value
                                self.mi_num_virtual_ll_addresses_cached.value_namespace = name_space
                                self.mi_num_virtual_ll_addresses_cached.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-num-virtual-ll-addresses-deleted"):
                                self.mi_num_virtual_ll_addresses_deleted = value
                                self.mi_num_virtual_ll_addresses_deleted.value_namespace = name_space
                                self.mi_num_virtual_ll_addresses_deleted.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-num-virtual-ll-addresses-dropped"):
                                self.mi_num_virtual_ll_addresses_dropped = value
                                self.mi_num_virtual_ll_addresses_dropped.value_namespace = name_space
                                self.mi_num_virtual_ll_addresses_dropped.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-pfi-ifh-del"):
                                self.mi_pfi_ifh_del = value
                                self.mi_pfi_ifh_del.value_namespace = name_space
                                self.mi_pfi_ifh_del.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-pfi-ifh-stale"):
                                self.mi_pfi_ifh_stale = value
                                self.mi_pfi_ifh_stale.value_namespace = name_space
                                self.mi_pfi_ifh_stale.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-pfi-ifh-upd"):
                                self.mi_pfi_ifh_upd = value
                                self.mi_pfi_ifh_upd.value_namespace = name_space
                                self.mi_pfi_ifh_upd.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-prefer-aib-routes-over-rib-cfg"):
                                self.mi_prefer_aib_routes_over_rib_cfg = value
                                self.mi_prefer_aib_routes_over_rib_cfg.value_namespace = name_space
                                self.mi_prefer_aib_routes_over_rib_cfg.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-prefer-aib-routes-over-rib-oper"):
                                self.mi_prefer_aib_routes_over_rib_oper = value
                                self.mi_prefer_aib_routes_over_rib_oper.value_namespace = name_space
                                self.mi_prefer_aib_routes_over_rib_oper.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-shm-reset-ts"):
                                self.mi_shm_reset_ts = value
                                self.mi_shm_reset_ts.value_namespace = name_space
                                self.mi_shm_reset_ts.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-tot-dnld-time"):
                                self.mi_tot_dnld_time = value
                                self.mi_tot_dnld_time.value_namespace = name_space
                                self.mi_tot_dnld_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-tot-gtrie-time"):
                                self.mi_tot_gtrie_time = value
                                self.mi_tot_gtrie_time.value_namespace = name_space
                                self.mi_tot_gtrie_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-tot-plat-upd-time"):
                                self.mi_tot_plat_upd_time = value
                                self.mi_tot_plat_upd_time.value_namespace = name_space
                                self.mi_tot_plat_upd_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "mi-xpl-ldi-enabled"):
                                self.mi_xpl_ldi_enabled = value
                                self.mi_xpl_ldi_enabled.value_namespace = name_space
                                self.mi_xpl_ldi_enabled.value_namespace_prefix = name_space_prefix


                    class LocalLabel(Entity):
                        """
                        Local label
                        
                        .. attribute:: conflicts
                        
                        	FIB Local\-label conflicts database
                        	**type**\:   :py:class:`Conflicts <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel, self).__init__()

                            self.yang_name = "local-label"
                            self.yang_parent_name = "protocol"

                            self.conflicts = Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts()
                            self.conflicts.parent = self
                            self._children_name_map["conflicts"] = "conflicts"
                            self._children_yang_names.add("conflicts")


                        class Conflicts(Entity):
                            """
                            FIB Local\-label conflicts database
                            
                            .. attribute:: conflict
                            
                            	CEF Local\-label conflicts entry
                            	**type**\: list of    :py:class:`Conflict <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict>`
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts, self).__init__()

                                self.yang_name = "conflicts"
                                self.yang_parent_name = "local-label"

                                self.conflict = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts, self).__setattr__(name, value)


                            class Conflict(Entity):
                                """
                                CEF Local\-label conflicts entry
                                
                                .. attribute:: ext
                                
                                	ext
                                	**type**\:   :py:class:`Ext <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext>`
                                
                                .. attribute:: label
                                
                                	Local label
                                	**type**\:  int
                                
                                	**range:** 16..1048575
                                
                                .. attribute:: ll_ctype
                                
                                	Type of entry
                                	**type**\:   :py:class:`FibllcEntry <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibllcEntry>`
                                
                                .. attribute:: local_label
                                
                                	local label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: num_retries
                                
                                	num retries
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: pfx_tbl_id
                                
                                	Table ID of IP prefix
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                .. attribute:: prefix
                                
                                	IP Prefix
                                	**type**\:  str
                                
                                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                                
                                .. attribute:: prefix_len
                                
                                	Length of IP Prefix
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                .. attribute:: retry_ts
                                
                                	retry ts
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: source
                                
                                	Route source
                                	**type**\:   :py:class:`FibRouteSource <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibRouteSource>`
                                
                                .. attribute:: source_xr
                                
                                	source xr
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: update_ts
                                
                                	update ts
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict, self).__init__()

                                    self.yang_name = "conflict"
                                    self.yang_parent_name = "conflicts"

                                    self.label = YLeaf(YType.uint32, "label")

                                    self.ll_ctype = YLeaf(YType.enumeration, "ll-ctype")

                                    self.local_label = YLeaf(YType.uint32, "local-label")

                                    self.num_retries = YLeaf(YType.uint32, "num-retries")

                                    self.pfx_tbl_id = YLeaf(YType.int32, "pfx-tbl-id")

                                    self.prefix = YLeaf(YType.str, "prefix")

                                    self.prefix_len = YLeaf(YType.int32, "prefix-len")

                                    self.retry_ts = YLeaf(YType.uint64, "retry-ts")

                                    self.source = YLeaf(YType.enumeration, "source")

                                    self.source_xr = YLeaf(YType.uint32, "source-xr")

                                    self.update_ts = YLeaf(YType.uint64, "update-ts")

                                    self.ext = Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext()
                                    self.ext.parent = self
                                    self._children_name_map["ext"] = "ext"
                                    self._children_yang_names.add("ext")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("label",
                                                    "ll_ctype",
                                                    "local_label",
                                                    "num_retries",
                                                    "pfx_tbl_id",
                                                    "prefix",
                                                    "prefix_len",
                                                    "retry_ts",
                                                    "source",
                                                    "source_xr",
                                                    "update_ts") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict, self).__setattr__(name, value)


                                class Ext(Entity):
                                    """
                                    ext
                                    
                                    .. attribute:: lsm
                                    
                                    	lsm
                                    	**type**\:   :py:class:`Lsm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Lsm>`
                                    
                                    .. attribute:: pfx
                                    
                                    	pfx
                                    	**type**\:   :py:class:`Pfx <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Pfx>`
                                    
                                    .. attribute:: type
                                    
                                    	type
                                    	**type**\:   :py:class:`FibMplsLlcEntryBag <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.FibMplsLlcEntryBag>`
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext, self).__init__()

                                        self.yang_name = "ext"
                                        self.yang_parent_name = "conflict"

                                        self.type = YLeaf(YType.enumeration, "type")

                                        self.lsm = Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Lsm()
                                        self.lsm.parent = self
                                        self._children_name_map["lsm"] = "lsm"
                                        self._children_yang_names.add("lsm")

                                        self.pfx = Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Pfx()
                                        self.pfx.parent = self
                                        self._children_name_map["pfx"] = "pfx"
                                        self._children_yang_names.add("pfx")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("type") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext, self).__setattr__(name, value)


                                    class Pfx(Entity):
                                        """
                                        pfx
                                        
                                        .. attribute:: pfx
                                        
                                        	pfx
                                        	**type**\:  str
                                        
                                        	**length:** 0..52
                                        
                                        .. attribute:: tbl_id
                                        
                                        	tbl id
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Pfx, self).__init__()

                                            self.yang_name = "pfx"
                                            self.yang_parent_name = "ext"

                                            self.pfx = YLeaf(YType.str, "pfx")

                                            self.tbl_id = YLeaf(YType.uint32, "tbl-id")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("pfx",
                                                            "tbl_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Pfx, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Pfx, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.pfx.is_set or
                                                self.tbl_id.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.pfx.yfilter != YFilter.not_set or
                                                self.tbl_id.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "pfx" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.pfx.is_set or self.pfx.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.pfx.get_name_leafdata())
                                            if (self.tbl_id.is_set or self.tbl_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.tbl_id.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "pfx" or name == "tbl-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "pfx"):
                                                self.pfx = value
                                                self.pfx.value_namespace = name_space
                                                self.pfx.value_namespace_prefix = name_space_prefix
                                            if(value_path == "tbl-id"):
                                                self.tbl_id = value
                                                self.tbl_id.value_namespace = name_space
                                                self.tbl_id.value_namespace_prefix = name_space_prefix


                                    class Lsm(Entity):
                                        """
                                        lsm
                                        
                                        .. attribute:: mcast_id
                                        
                                        	mcast id
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: nh
                                        
                                        	nh
                                        	**type**\:  str
                                        
                                        	**length:** 0..52
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Lsm, self).__init__()

                                            self.yang_name = "lsm"
                                            self.yang_parent_name = "ext"

                                            self.mcast_id = YLeaf(YType.uint32, "mcast-id")

                                            self.nh = YLeaf(YType.str, "nh")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("mcast_id",
                                                            "nh") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Lsm, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Lsm, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.mcast_id.is_set or
                                                self.nh.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.mcast_id.yfilter != YFilter.not_set or
                                                self.nh.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lsm" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.mcast_id.is_set or self.mcast_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.mcast_id.get_name_leafdata())
                                            if (self.nh.is_set or self.nh.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.nh.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "mcast-id" or name == "nh"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "mcast-id"):
                                                self.mcast_id = value
                                                self.mcast_id.value_namespace = name_space
                                                self.mcast_id.value_namespace_prefix = name_space_prefix
                                            if(value_path == "nh"):
                                                self.nh = value
                                                self.nh.value_namespace = name_space
                                                self.nh.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.type.is_set or
                                            (self.lsm is not None and self.lsm.has_data()) or
                                            (self.pfx is not None and self.pfx.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.type.yfilter != YFilter.not_set or
                                            (self.lsm is not None and self.lsm.has_operation()) or
                                            (self.pfx is not None and self.pfx.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ext" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "lsm"):
                                            if (self.lsm is None):
                                                self.lsm = Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Lsm()
                                                self.lsm.parent = self
                                                self._children_name_map["lsm"] = "lsm"
                                            return self.lsm

                                        if (child_yang_name == "pfx"):
                                            if (self.pfx is None):
                                                self.pfx = Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext.Pfx()
                                                self.pfx.parent = self
                                                self._children_name_map["pfx"] = "pfx"
                                            return self.pfx

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "lsm" or name == "pfx" or name == "type"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "type"):
                                            self.type = value
                                            self.type.value_namespace = name_space
                                            self.type.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.label.is_set or
                                        self.ll_ctype.is_set or
                                        self.local_label.is_set or
                                        self.num_retries.is_set or
                                        self.pfx_tbl_id.is_set or
                                        self.prefix.is_set or
                                        self.prefix_len.is_set or
                                        self.retry_ts.is_set or
                                        self.source.is_set or
                                        self.source_xr.is_set or
                                        self.update_ts.is_set or
                                        (self.ext is not None and self.ext.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.label.yfilter != YFilter.not_set or
                                        self.ll_ctype.yfilter != YFilter.not_set or
                                        self.local_label.yfilter != YFilter.not_set or
                                        self.num_retries.yfilter != YFilter.not_set or
                                        self.pfx_tbl_id.yfilter != YFilter.not_set or
                                        self.prefix.yfilter != YFilter.not_set or
                                        self.prefix_len.yfilter != YFilter.not_set or
                                        self.retry_ts.yfilter != YFilter.not_set or
                                        self.source.yfilter != YFilter.not_set or
                                        self.source_xr.yfilter != YFilter.not_set or
                                        self.update_ts.yfilter != YFilter.not_set or
                                        (self.ext is not None and self.ext.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "conflict" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.label.is_set or self.label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.label.get_name_leafdata())
                                    if (self.ll_ctype.is_set or self.ll_ctype.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ll_ctype.get_name_leafdata())
                                    if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.local_label.get_name_leafdata())
                                    if (self.num_retries.is_set or self.num_retries.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.num_retries.get_name_leafdata())
                                    if (self.pfx_tbl_id.is_set or self.pfx_tbl_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.pfx_tbl_id.get_name_leafdata())
                                    if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix.get_name_leafdata())
                                    if (self.prefix_len.is_set or self.prefix_len.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_len.get_name_leafdata())
                                    if (self.retry_ts.is_set or self.retry_ts.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.retry_ts.get_name_leafdata())
                                    if (self.source.is_set or self.source.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.source.get_name_leafdata())
                                    if (self.source_xr.is_set or self.source_xr.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.source_xr.get_name_leafdata())
                                    if (self.update_ts.is_set or self.update_ts.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.update_ts.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "ext"):
                                        if (self.ext is None):
                                            self.ext = Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict.Ext()
                                            self.ext.parent = self
                                            self._children_name_map["ext"] = "ext"
                                        return self.ext

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ext" or name == "label" or name == "ll-ctype" or name == "local-label" or name == "num-retries" or name == "pfx-tbl-id" or name == "prefix" or name == "prefix-len" or name == "retry-ts" or name == "source" or name == "source-xr" or name == "update-ts"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "label"):
                                        self.label = value
                                        self.label.value_namespace = name_space
                                        self.label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "ll-ctype"):
                                        self.ll_ctype = value
                                        self.ll_ctype.value_namespace = name_space
                                        self.ll_ctype.value_namespace_prefix = name_space_prefix
                                    if(value_path == "local-label"):
                                        self.local_label = value
                                        self.local_label.value_namespace = name_space
                                        self.local_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "num-retries"):
                                        self.num_retries = value
                                        self.num_retries.value_namespace = name_space
                                        self.num_retries.value_namespace_prefix = name_space_prefix
                                    if(value_path == "pfx-tbl-id"):
                                        self.pfx_tbl_id = value
                                        self.pfx_tbl_id.value_namespace = name_space
                                        self.pfx_tbl_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix"):
                                        self.prefix = value
                                        self.prefix.value_namespace = name_space
                                        self.prefix.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-len"):
                                        self.prefix_len = value
                                        self.prefix_len.value_namespace = name_space
                                        self.prefix_len.value_namespace_prefix = name_space_prefix
                                    if(value_path == "retry-ts"):
                                        self.retry_ts = value
                                        self.retry_ts.value_namespace = name_space
                                        self.retry_ts.value_namespace_prefix = name_space_prefix
                                    if(value_path == "source"):
                                        self.source = value
                                        self.source.value_namespace = name_space
                                        self.source.value_namespace_prefix = name_space_prefix
                                    if(value_path == "source-xr"):
                                        self.source_xr = value
                                        self.source_xr.value_namespace = name_space
                                        self.source_xr.value_namespace_prefix = name_space_prefix
                                    if(value_path == "update-ts"):
                                        self.update_ts = value
                                        self.update_ts.value_namespace = name_space
                                        self.update_ts.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.conflict:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.conflict:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "conflicts" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "conflict"):
                                    for c in self.conflict:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts.Conflict()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.conflict.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "conflict"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (self.conflicts is not None and self.conflicts.has_data())

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.conflicts is not None and self.conflicts.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "local-label" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "conflicts"):
                                if (self.conflicts is None):
                                    self.conflicts = Fib.Nodes.Node.Protocols.Protocol.LocalLabel.Conflicts()
                                    self.conflicts.parent = self
                                    self._children_name_map["conflicts"] = "conflicts"
                                return self.conflicts

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "conflicts"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.protocol_name.is_set or
                            (self.external_client_summaries is not None and self.external_client_summaries.has_data()) or
                            (self.external_summary_all is not None and self.external_summary_all.has_data()) or
                            (self.fib_summaries is not None and self.fib_summaries.has_data()) or
                            (self.frr_log is not None and self.frr_log.has_data()) or
                            (self.issu_state is not None and self.issu_state.has_data()) or
                            (self.local_label is not None and self.local_label.has_data()) or
                            (self.misc is not None and self.misc.has_data()) or
                            (self.nh_ids is not None and self.nh_ids.has_data()) or
                            (self.resource is not None and self.resource.has_data()) or
                            (self.vrfs is not None and self.vrfs.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.protocol_name.yfilter != YFilter.not_set or
                            (self.external_client_summaries is not None and self.external_client_summaries.has_operation()) or
                            (self.external_summary_all is not None and self.external_summary_all.has_operation()) or
                            (self.fib_summaries is not None and self.fib_summaries.has_operation()) or
                            (self.frr_log is not None and self.frr_log.has_operation()) or
                            (self.issu_state is not None and self.issu_state.has_operation()) or
                            (self.local_label is not None and self.local_label.has_operation()) or
                            (self.misc is not None and self.misc.has_operation()) or
                            (self.nh_ids is not None and self.nh_ids.has_operation()) or
                            (self.resource is not None and self.resource.has_operation()) or
                            (self.vrfs is not None and self.vrfs.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "protocol" + "[protocol-name='" + self.protocol_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protocol_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "external-client-summaries"):
                            if (self.external_client_summaries is None):
                                self.external_client_summaries = Fib.Nodes.Node.Protocols.Protocol.ExternalClientSummaries()
                                self.external_client_summaries.parent = self
                                self._children_name_map["external_client_summaries"] = "external-client-summaries"
                            return self.external_client_summaries

                        if (child_yang_name == "external-summary-all"):
                            if (self.external_summary_all is None):
                                self.external_summary_all = Fib.Nodes.Node.Protocols.Protocol.ExternalSummaryAll()
                                self.external_summary_all.parent = self
                                self._children_name_map["external_summary_all"] = "external-summary-all"
                            return self.external_summary_all

                        if (child_yang_name == "fib-summaries"):
                            if (self.fib_summaries is None):
                                self.fib_summaries = Fib.Nodes.Node.Protocols.Protocol.FibSummaries()
                                self.fib_summaries.parent = self
                                self._children_name_map["fib_summaries"] = "fib-summaries"
                            return self.fib_summaries

                        if (child_yang_name == "frr-log"):
                            if (self.frr_log is None):
                                self.frr_log = Fib.Nodes.Node.Protocols.Protocol.FrrLog()
                                self.frr_log.parent = self
                                self._children_name_map["frr_log"] = "frr-log"
                            return self.frr_log

                        if (child_yang_name == "issu-state"):
                            if (self.issu_state is None):
                                self.issu_state = Fib.Nodes.Node.Protocols.Protocol.IssuState()
                                self.issu_state.parent = self
                                self._children_name_map["issu_state"] = "issu-state"
                            return self.issu_state

                        if (child_yang_name == "local-label"):
                            if (self.local_label is None):
                                self.local_label = Fib.Nodes.Node.Protocols.Protocol.LocalLabel()
                                self.local_label.parent = self
                                self._children_name_map["local_label"] = "local-label"
                            return self.local_label

                        if (child_yang_name == "misc"):
                            if (self.misc is None):
                                self.misc = Fib.Nodes.Node.Protocols.Protocol.Misc()
                                self.misc.parent = self
                                self._children_name_map["misc"] = "misc"
                            return self.misc

                        if (child_yang_name == "nh-ids"):
                            if (self.nh_ids is None):
                                self.nh_ids = Fib.Nodes.Node.Protocols.Protocol.NhIds()
                                self.nh_ids.parent = self
                                self._children_name_map["nh_ids"] = "nh-ids"
                            return self.nh_ids

                        if (child_yang_name == "resource"):
                            if (self.resource is None):
                                self.resource = Fib.Nodes.Node.Protocols.Protocol.Resource()
                                self.resource.parent = self
                                self._children_name_map["resource"] = "resource"
                            return self.resource

                        if (child_yang_name == "vrfs"):
                            if (self.vrfs is None):
                                self.vrfs = Fib.Nodes.Node.Protocols.Protocol.Vrfs()
                                self.vrfs.parent = self
                                self._children_name_map["vrfs"] = "vrfs"
                            return self.vrfs

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "external-client-summaries" or name == "external-summary-all" or name == "fib-summaries" or name == "frr-log" or name == "issu-state" or name == "local-label" or name == "misc" or name == "nh-ids" or name == "resource" or name == "vrfs" or name == "protocol-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "protocol-name"):
                            self.protocol_name = value
                            self.protocol_name.value_namespace = name_space
                            self.protocol_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.protocol:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.protocol:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "protocols" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "protocol"):
                        for c in self.protocol:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Fib.Nodes.Node.Protocols.Protocol()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.protocol.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "protocol"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.node_name.is_set or
                    (self.global_ is not None and self.global_.has_data()) or
                    (self.protocols is not None and self.protocols.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_name.yfilter != YFilter.not_set or
                    (self.global_ is not None and self.global_.has_operation()) or
                    (self.protocols is not None and self.protocols.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node" + "[node-name='" + self.node_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-fib-common-oper:fib/nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "global"):
                    if (self.global_ is None):
                        self.global_ = Fib.Nodes.Node.Global_()
                        self.global_.parent = self
                        self._children_name_map["global_"] = "global"
                    return self.global_

                if (child_yang_name == "protocols"):
                    if (self.protocols is None):
                        self.protocols = Fib.Nodes.Node.Protocols()
                        self.protocols.parent = self
                        self._children_name_map["protocols"] = "protocols"
                    return self.protocols

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "global" or name == "protocols" or name == "node-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-name"):
                    self.node_name = value
                    self.node_name.value_namespace = name_space
                    self.node_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-fib-common-oper:fib/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node"):
                for c in self.node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Fib.Nodes.Node()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (self.nodes is not None and self.nodes.has_data())

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.nodes is not None and self.nodes.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-fib-common-oper:fib" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "nodes"):
            if (self.nodes is None):
                self.nodes = Fib.Nodes()
                self.nodes.parent = self
                self._children_name_map["nodes"] = "nodes"
            return self.nodes

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "nodes"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Fib()
        return self._top_entity

class MplsForwarding(Entity):
    """
    mpls forwarding
    
    .. attribute:: nodes
    
    	Table of Nodes
    	**type**\:   :py:class:`Nodes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes>`
    
    

    """

    _prefix = 'fib-common-oper'
    _revision = '2017-01-20'

    def __init__(self):
        super(MplsForwarding, self).__init__()
        self._top_entity = None

        self.yang_name = "mpls-forwarding"
        self.yang_parent_name = "Cisco-IOS-XR-fib-common-oper"

        self.nodes = MplsForwarding.Nodes()
        self.nodes.parent = self
        self._children_name_map["nodes"] = "nodes"
        self._children_yang_names.add("nodes")


    class Nodes(Entity):
        """
        Table of Nodes
        
        .. attribute:: node
        
        	Operational data for a specific Node
        	**type**\: list of    :py:class:`Node <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node>`
        
        

        """

        _prefix = 'fib-common-oper'
        _revision = '2017-01-20'

        def __init__(self):
            super(MplsForwarding.Nodes, self).__init__()

            self.yang_name = "nodes"
            self.yang_parent_name = "mpls-forwarding"

            self.node = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(MplsForwarding.Nodes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(MplsForwarding.Nodes, self).__setattr__(name, value)


        class Node(Entity):
            """
            Operational data for a specific Node
            
            .. attribute:: node_name  <key>
            
            	Node ID
            	**type**\:  str
            
            	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
            
            .. attribute:: forwarding_summary
            
            	MPLS forwarding summary
            	**type**\:   :py:class:`ForwardingSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.ForwardingSummary>`
            
            .. attribute:: frr_database
            
            	MPLS forwarding FRR Database
            	**type**\:   :py:class:`FrrDatabase <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase>`
            
            .. attribute:: frr_logs
            
            	FRR Log Table
            	**type**\:   :py:class:`FrrLogs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrLogs>`
            
            .. attribute:: label_fib
            
            	Labels For FIB
            	**type**\:   :py:class:`LabelFib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib>`
            
            .. attribute:: tunnel
            
            	TE Tunnel information
            	**type**\:   :py:class:`Tunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel>`
            
            

            """

            _prefix = 'fib-common-oper'
            _revision = '2017-01-20'

            def __init__(self):
                super(MplsForwarding.Nodes.Node, self).__init__()

                self.yang_name = "node"
                self.yang_parent_name = "nodes"

                self.node_name = YLeaf(YType.str, "node-name")

                self.forwarding_summary = MplsForwarding.Nodes.Node.ForwardingSummary()
                self.forwarding_summary.parent = self
                self._children_name_map["forwarding_summary"] = "forwarding-summary"
                self._children_yang_names.add("forwarding-summary")

                self.frr_database = MplsForwarding.Nodes.Node.FrrDatabase()
                self.frr_database.parent = self
                self._children_name_map["frr_database"] = "frr-database"
                self._children_yang_names.add("frr-database")

                self.frr_logs = MplsForwarding.Nodes.Node.FrrLogs()
                self.frr_logs.parent = self
                self._children_name_map["frr_logs"] = "frr-logs"
                self._children_yang_names.add("frr-logs")

                self.label_fib = MplsForwarding.Nodes.Node.LabelFib()
                self.label_fib.parent = self
                self._children_name_map["label_fib"] = "label-fib"
                self._children_yang_names.add("label-fib")

                self.tunnel = MplsForwarding.Nodes.Node.Tunnel()
                self.tunnel.parent = self
                self._children_name_map["tunnel"] = "tunnel"
                self._children_yang_names.add("tunnel")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("node_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsForwarding.Nodes.Node, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsForwarding.Nodes.Node, self).__setattr__(name, value)


            class ForwardingSummary(Entity):
                """
                MPLS forwarding summary
                
                .. attribute:: deleted_stale_entries
                
                	Number of delete stale label entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: global_dropped_packets
                
                	Number of global FIB packets dropped
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: global_failed_lookups
                
                	Number of global failed lookups
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: global_fragmented_packets
                
                	Number of global FIB packets fragmented
                	**type**\:  int
                
                	**range:** 0..18446744073709551615
                
                .. attribute:: highest_label
                
                	Highest Label in use
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: ignore_protect
                
                	Number of TE tunnels treated as non\-protected
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: ipv4_imposition_entries
                
                	Number of IPv4 imposition entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: label_switched_entries
                
                	Number of label swap/disposition entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lowest_label
                
                	Lowest label in use
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: lrpf_entries
                
                	Number of labels with RPF
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: mte_head_entries
                
                	Number of MTE tunnel head entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: mte_ll_entries
                
                	Number of MTE local entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: mte_midpoint_entries
                
                	Number of MTE midpoint entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: reserved_label_entries
                
                	Number of reserved label entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_frr_head_entries
                
                	Number of TE FRR tunnel head imposition entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_frr_interface_entries
                
                	Number of TE FRR protected interface entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_frr_internal_entries
                
                	Number of TE internal forwarding entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_frr_mid_points_entries
                
                	Number of TE FRR MidPoints forwarding entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_frr_next_hop_entries
                
                	Number of TE FRR protected next\-hop entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_head_entries
                
                	Number of TE tunnel head imposition entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_internal_entries
                
                	Number of TE internal forwarding entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: te_mid_points_entries
                
                	Number of TE MidPoints forwarding entries
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_forwarding_update_messages
                
                	Total forwarding update messages from LSD to LFDs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_forwarding_updates
                
                	Total forwarding updates from LSD to LFDs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_p2mp_forwarding_added_or_modify_messages
                
                	Total p2mp forwarding add/modify messages from MRIB to LFDs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_p2mp_forwarding_delete_messages
                
                	Total p2mp forwarding del messages from MRIB to LFDs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_p2mp_forwarding_drop_messages
                
                	Total p2mp forwarding messages dropped from MRIB to LFDs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_p2mp_forwarding_updates
                
                	Total forwarding updates from MRIB to LFDs
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: total_p2mp_iir_forwarding_drop_messages
                
                	Total IIR triggered p2mp forwarding MRIB messages dropped
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'fib-common-oper'
                _revision = '2017-01-20'

                def __init__(self):
                    super(MplsForwarding.Nodes.Node.ForwardingSummary, self).__init__()

                    self.yang_name = "forwarding-summary"
                    self.yang_parent_name = "node"

                    self.deleted_stale_entries = YLeaf(YType.uint32, "deleted-stale-entries")

                    self.global_dropped_packets = YLeaf(YType.uint64, "global-dropped-packets")

                    self.global_failed_lookups = YLeaf(YType.uint64, "global-failed-lookups")

                    self.global_fragmented_packets = YLeaf(YType.uint64, "global-fragmented-packets")

                    self.highest_label = YLeaf(YType.uint32, "highest-label")

                    self.ignore_protect = YLeaf(YType.uint32, "ignore-protect")

                    self.ipv4_imposition_entries = YLeaf(YType.uint32, "ipv4-imposition-entries")

                    self.label_switched_entries = YLeaf(YType.uint32, "label-switched-entries")

                    self.lowest_label = YLeaf(YType.uint32, "lowest-label")

                    self.lrpf_entries = YLeaf(YType.uint32, "lrpf-entries")

                    self.mte_head_entries = YLeaf(YType.uint32, "mte-head-entries")

                    self.mte_ll_entries = YLeaf(YType.uint32, "mte-ll-entries")

                    self.mte_midpoint_entries = YLeaf(YType.uint32, "mte-midpoint-entries")

                    self.reserved_label_entries = YLeaf(YType.uint32, "reserved-label-entries")

                    self.te_frr_head_entries = YLeaf(YType.uint32, "te-frr-head-entries")

                    self.te_frr_interface_entries = YLeaf(YType.uint32, "te-frr-interface-entries")

                    self.te_frr_internal_entries = YLeaf(YType.uint32, "te-frr-internal-entries")

                    self.te_frr_mid_points_entries = YLeaf(YType.uint32, "te-frr-mid-points-entries")

                    self.te_frr_next_hop_entries = YLeaf(YType.uint32, "te-frr-next-hop-entries")

                    self.te_head_entries = YLeaf(YType.uint32, "te-head-entries")

                    self.te_internal_entries = YLeaf(YType.uint32, "te-internal-entries")

                    self.te_mid_points_entries = YLeaf(YType.uint32, "te-mid-points-entries")

                    self.total_forwarding_update_messages = YLeaf(YType.uint32, "total-forwarding-update-messages")

                    self.total_forwarding_updates = YLeaf(YType.uint32, "total-forwarding-updates")

                    self.total_p2mp_forwarding_added_or_modify_messages = YLeaf(YType.uint32, "total-p2mp-forwarding-added-or-modify-messages")

                    self.total_p2mp_forwarding_delete_messages = YLeaf(YType.uint32, "total-p2mp-forwarding-delete-messages")

                    self.total_p2mp_forwarding_drop_messages = YLeaf(YType.uint32, "total-p2mp-forwarding-drop-messages")

                    self.total_p2mp_forwarding_updates = YLeaf(YType.uint32, "total-p2mp-forwarding-updates")

                    self.total_p2mp_iir_forwarding_drop_messages = YLeaf(YType.uint32, "total-p2mp-iir-forwarding-drop-messages")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("deleted_stale_entries",
                                    "global_dropped_packets",
                                    "global_failed_lookups",
                                    "global_fragmented_packets",
                                    "highest_label",
                                    "ignore_protect",
                                    "ipv4_imposition_entries",
                                    "label_switched_entries",
                                    "lowest_label",
                                    "lrpf_entries",
                                    "mte_head_entries",
                                    "mte_ll_entries",
                                    "mte_midpoint_entries",
                                    "reserved_label_entries",
                                    "te_frr_head_entries",
                                    "te_frr_interface_entries",
                                    "te_frr_internal_entries",
                                    "te_frr_mid_points_entries",
                                    "te_frr_next_hop_entries",
                                    "te_head_entries",
                                    "te_internal_entries",
                                    "te_mid_points_entries",
                                    "total_forwarding_update_messages",
                                    "total_forwarding_updates",
                                    "total_p2mp_forwarding_added_or_modify_messages",
                                    "total_p2mp_forwarding_delete_messages",
                                    "total_p2mp_forwarding_drop_messages",
                                    "total_p2mp_forwarding_updates",
                                    "total_p2mp_iir_forwarding_drop_messages") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsForwarding.Nodes.Node.ForwardingSummary, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsForwarding.Nodes.Node.ForwardingSummary, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.deleted_stale_entries.is_set or
                        self.global_dropped_packets.is_set or
                        self.global_failed_lookups.is_set or
                        self.global_fragmented_packets.is_set or
                        self.highest_label.is_set or
                        self.ignore_protect.is_set or
                        self.ipv4_imposition_entries.is_set or
                        self.label_switched_entries.is_set or
                        self.lowest_label.is_set or
                        self.lrpf_entries.is_set or
                        self.mte_head_entries.is_set or
                        self.mte_ll_entries.is_set or
                        self.mte_midpoint_entries.is_set or
                        self.reserved_label_entries.is_set or
                        self.te_frr_head_entries.is_set or
                        self.te_frr_interface_entries.is_set or
                        self.te_frr_internal_entries.is_set or
                        self.te_frr_mid_points_entries.is_set or
                        self.te_frr_next_hop_entries.is_set or
                        self.te_head_entries.is_set or
                        self.te_internal_entries.is_set or
                        self.te_mid_points_entries.is_set or
                        self.total_forwarding_update_messages.is_set or
                        self.total_forwarding_updates.is_set or
                        self.total_p2mp_forwarding_added_or_modify_messages.is_set or
                        self.total_p2mp_forwarding_delete_messages.is_set or
                        self.total_p2mp_forwarding_drop_messages.is_set or
                        self.total_p2mp_forwarding_updates.is_set or
                        self.total_p2mp_iir_forwarding_drop_messages.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.deleted_stale_entries.yfilter != YFilter.not_set or
                        self.global_dropped_packets.yfilter != YFilter.not_set or
                        self.global_failed_lookups.yfilter != YFilter.not_set or
                        self.global_fragmented_packets.yfilter != YFilter.not_set or
                        self.highest_label.yfilter != YFilter.not_set or
                        self.ignore_protect.yfilter != YFilter.not_set or
                        self.ipv4_imposition_entries.yfilter != YFilter.not_set or
                        self.label_switched_entries.yfilter != YFilter.not_set or
                        self.lowest_label.yfilter != YFilter.not_set or
                        self.lrpf_entries.yfilter != YFilter.not_set or
                        self.mte_head_entries.yfilter != YFilter.not_set or
                        self.mte_ll_entries.yfilter != YFilter.not_set or
                        self.mte_midpoint_entries.yfilter != YFilter.not_set or
                        self.reserved_label_entries.yfilter != YFilter.not_set or
                        self.te_frr_head_entries.yfilter != YFilter.not_set or
                        self.te_frr_interface_entries.yfilter != YFilter.not_set or
                        self.te_frr_internal_entries.yfilter != YFilter.not_set or
                        self.te_frr_mid_points_entries.yfilter != YFilter.not_set or
                        self.te_frr_next_hop_entries.yfilter != YFilter.not_set or
                        self.te_head_entries.yfilter != YFilter.not_set or
                        self.te_internal_entries.yfilter != YFilter.not_set or
                        self.te_mid_points_entries.yfilter != YFilter.not_set or
                        self.total_forwarding_update_messages.yfilter != YFilter.not_set or
                        self.total_forwarding_updates.yfilter != YFilter.not_set or
                        self.total_p2mp_forwarding_added_or_modify_messages.yfilter != YFilter.not_set or
                        self.total_p2mp_forwarding_delete_messages.yfilter != YFilter.not_set or
                        self.total_p2mp_forwarding_drop_messages.yfilter != YFilter.not_set or
                        self.total_p2mp_forwarding_updates.yfilter != YFilter.not_set or
                        self.total_p2mp_iir_forwarding_drop_messages.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "forwarding-summary" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.deleted_stale_entries.is_set or self.deleted_stale_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.deleted_stale_entries.get_name_leafdata())
                    if (self.global_dropped_packets.is_set or self.global_dropped_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.global_dropped_packets.get_name_leafdata())
                    if (self.global_failed_lookups.is_set or self.global_failed_lookups.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.global_failed_lookups.get_name_leafdata())
                    if (self.global_fragmented_packets.is_set or self.global_fragmented_packets.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.global_fragmented_packets.get_name_leafdata())
                    if (self.highest_label.is_set or self.highest_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.highest_label.get_name_leafdata())
                    if (self.ignore_protect.is_set or self.ignore_protect.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ignore_protect.get_name_leafdata())
                    if (self.ipv4_imposition_entries.is_set or self.ipv4_imposition_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipv4_imposition_entries.get_name_leafdata())
                    if (self.label_switched_entries.is_set or self.label_switched_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.label_switched_entries.get_name_leafdata())
                    if (self.lowest_label.is_set or self.lowest_label.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lowest_label.get_name_leafdata())
                    if (self.lrpf_entries.is_set or self.lrpf_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lrpf_entries.get_name_leafdata())
                    if (self.mte_head_entries.is_set or self.mte_head_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mte_head_entries.get_name_leafdata())
                    if (self.mte_ll_entries.is_set or self.mte_ll_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mte_ll_entries.get_name_leafdata())
                    if (self.mte_midpoint_entries.is_set or self.mte_midpoint_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mte_midpoint_entries.get_name_leafdata())
                    if (self.reserved_label_entries.is_set or self.reserved_label_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.reserved_label_entries.get_name_leafdata())
                    if (self.te_frr_head_entries.is_set or self.te_frr_head_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_frr_head_entries.get_name_leafdata())
                    if (self.te_frr_interface_entries.is_set or self.te_frr_interface_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_frr_interface_entries.get_name_leafdata())
                    if (self.te_frr_internal_entries.is_set or self.te_frr_internal_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_frr_internal_entries.get_name_leafdata())
                    if (self.te_frr_mid_points_entries.is_set or self.te_frr_mid_points_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_frr_mid_points_entries.get_name_leafdata())
                    if (self.te_frr_next_hop_entries.is_set or self.te_frr_next_hop_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_frr_next_hop_entries.get_name_leafdata())
                    if (self.te_head_entries.is_set or self.te_head_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_head_entries.get_name_leafdata())
                    if (self.te_internal_entries.is_set or self.te_internal_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_internal_entries.get_name_leafdata())
                    if (self.te_mid_points_entries.is_set or self.te_mid_points_entries.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.te_mid_points_entries.get_name_leafdata())
                    if (self.total_forwarding_update_messages.is_set or self.total_forwarding_update_messages.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_forwarding_update_messages.get_name_leafdata())
                    if (self.total_forwarding_updates.is_set or self.total_forwarding_updates.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_forwarding_updates.get_name_leafdata())
                    if (self.total_p2mp_forwarding_added_or_modify_messages.is_set or self.total_p2mp_forwarding_added_or_modify_messages.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_p2mp_forwarding_added_or_modify_messages.get_name_leafdata())
                    if (self.total_p2mp_forwarding_delete_messages.is_set or self.total_p2mp_forwarding_delete_messages.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_p2mp_forwarding_delete_messages.get_name_leafdata())
                    if (self.total_p2mp_forwarding_drop_messages.is_set or self.total_p2mp_forwarding_drop_messages.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_p2mp_forwarding_drop_messages.get_name_leafdata())
                    if (self.total_p2mp_forwarding_updates.is_set or self.total_p2mp_forwarding_updates.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_p2mp_forwarding_updates.get_name_leafdata())
                    if (self.total_p2mp_iir_forwarding_drop_messages.is_set or self.total_p2mp_iir_forwarding_drop_messages.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.total_p2mp_iir_forwarding_drop_messages.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "deleted-stale-entries" or name == "global-dropped-packets" or name == "global-failed-lookups" or name == "global-fragmented-packets" or name == "highest-label" or name == "ignore-protect" or name == "ipv4-imposition-entries" or name == "label-switched-entries" or name == "lowest-label" or name == "lrpf-entries" or name == "mte-head-entries" or name == "mte-ll-entries" or name == "mte-midpoint-entries" or name == "reserved-label-entries" or name == "te-frr-head-entries" or name == "te-frr-interface-entries" or name == "te-frr-internal-entries" or name == "te-frr-mid-points-entries" or name == "te-frr-next-hop-entries" or name == "te-head-entries" or name == "te-internal-entries" or name == "te-mid-points-entries" or name == "total-forwarding-update-messages" or name == "total-forwarding-updates" or name == "total-p2mp-forwarding-added-or-modify-messages" or name == "total-p2mp-forwarding-delete-messages" or name == "total-p2mp-forwarding-drop-messages" or name == "total-p2mp-forwarding-updates" or name == "total-p2mp-iir-forwarding-drop-messages"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "deleted-stale-entries"):
                        self.deleted_stale_entries = value
                        self.deleted_stale_entries.value_namespace = name_space
                        self.deleted_stale_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "global-dropped-packets"):
                        self.global_dropped_packets = value
                        self.global_dropped_packets.value_namespace = name_space
                        self.global_dropped_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "global-failed-lookups"):
                        self.global_failed_lookups = value
                        self.global_failed_lookups.value_namespace = name_space
                        self.global_failed_lookups.value_namespace_prefix = name_space_prefix
                    if(value_path == "global-fragmented-packets"):
                        self.global_fragmented_packets = value
                        self.global_fragmented_packets.value_namespace = name_space
                        self.global_fragmented_packets.value_namespace_prefix = name_space_prefix
                    if(value_path == "highest-label"):
                        self.highest_label = value
                        self.highest_label.value_namespace = name_space
                        self.highest_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "ignore-protect"):
                        self.ignore_protect = value
                        self.ignore_protect.value_namespace = name_space
                        self.ignore_protect.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipv4-imposition-entries"):
                        self.ipv4_imposition_entries = value
                        self.ipv4_imposition_entries.value_namespace = name_space
                        self.ipv4_imposition_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "label-switched-entries"):
                        self.label_switched_entries = value
                        self.label_switched_entries.value_namespace = name_space
                        self.label_switched_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "lowest-label"):
                        self.lowest_label = value
                        self.lowest_label.value_namespace = name_space
                        self.lowest_label.value_namespace_prefix = name_space_prefix
                    if(value_path == "lrpf-entries"):
                        self.lrpf_entries = value
                        self.lrpf_entries.value_namespace = name_space
                        self.lrpf_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "mte-head-entries"):
                        self.mte_head_entries = value
                        self.mte_head_entries.value_namespace = name_space
                        self.mte_head_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "mte-ll-entries"):
                        self.mte_ll_entries = value
                        self.mte_ll_entries.value_namespace = name_space
                        self.mte_ll_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "mte-midpoint-entries"):
                        self.mte_midpoint_entries = value
                        self.mte_midpoint_entries.value_namespace = name_space
                        self.mte_midpoint_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "reserved-label-entries"):
                        self.reserved_label_entries = value
                        self.reserved_label_entries.value_namespace = name_space
                        self.reserved_label_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-frr-head-entries"):
                        self.te_frr_head_entries = value
                        self.te_frr_head_entries.value_namespace = name_space
                        self.te_frr_head_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-frr-interface-entries"):
                        self.te_frr_interface_entries = value
                        self.te_frr_interface_entries.value_namespace = name_space
                        self.te_frr_interface_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-frr-internal-entries"):
                        self.te_frr_internal_entries = value
                        self.te_frr_internal_entries.value_namespace = name_space
                        self.te_frr_internal_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-frr-mid-points-entries"):
                        self.te_frr_mid_points_entries = value
                        self.te_frr_mid_points_entries.value_namespace = name_space
                        self.te_frr_mid_points_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-frr-next-hop-entries"):
                        self.te_frr_next_hop_entries = value
                        self.te_frr_next_hop_entries.value_namespace = name_space
                        self.te_frr_next_hop_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-head-entries"):
                        self.te_head_entries = value
                        self.te_head_entries.value_namespace = name_space
                        self.te_head_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-internal-entries"):
                        self.te_internal_entries = value
                        self.te_internal_entries.value_namespace = name_space
                        self.te_internal_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "te-mid-points-entries"):
                        self.te_mid_points_entries = value
                        self.te_mid_points_entries.value_namespace = name_space
                        self.te_mid_points_entries.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-forwarding-update-messages"):
                        self.total_forwarding_update_messages = value
                        self.total_forwarding_update_messages.value_namespace = name_space
                        self.total_forwarding_update_messages.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-forwarding-updates"):
                        self.total_forwarding_updates = value
                        self.total_forwarding_updates.value_namespace = name_space
                        self.total_forwarding_updates.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-p2mp-forwarding-added-or-modify-messages"):
                        self.total_p2mp_forwarding_added_or_modify_messages = value
                        self.total_p2mp_forwarding_added_or_modify_messages.value_namespace = name_space
                        self.total_p2mp_forwarding_added_or_modify_messages.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-p2mp-forwarding-delete-messages"):
                        self.total_p2mp_forwarding_delete_messages = value
                        self.total_p2mp_forwarding_delete_messages.value_namespace = name_space
                        self.total_p2mp_forwarding_delete_messages.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-p2mp-forwarding-drop-messages"):
                        self.total_p2mp_forwarding_drop_messages = value
                        self.total_p2mp_forwarding_drop_messages.value_namespace = name_space
                        self.total_p2mp_forwarding_drop_messages.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-p2mp-forwarding-updates"):
                        self.total_p2mp_forwarding_updates = value
                        self.total_p2mp_forwarding_updates.value_namespace = name_space
                        self.total_p2mp_forwarding_updates.value_namespace_prefix = name_space_prefix
                    if(value_path == "total-p2mp-iir-forwarding-drop-messages"):
                        self.total_p2mp_iir_forwarding_drop_messages = value
                        self.total_p2mp_iir_forwarding_drop_messages.value_namespace = name_space
                        self.total_p2mp_iir_forwarding_drop_messages.value_namespace_prefix = name_space_prefix


            class FrrLogs(Entity):
                """
                FRR Log Table
                
                .. attribute:: frr_log
                
                	FRR Log information
                	**type**\: list of    :py:class:`FrrLog <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrLogs.FrrLog>`
                
                

                """

                _prefix = 'fib-common-oper'
                _revision = '2017-01-20'

                def __init__(self):
                    super(MplsForwarding.Nodes.Node.FrrLogs, self).__init__()

                    self.yang_name = "frr-logs"
                    self.yang_parent_name = "node"

                    self.frr_log = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsForwarding.Nodes.Node.FrrLogs, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsForwarding.Nodes.Node.FrrLogs, self).__setattr__(name, value)


                class FrrLog(Entity):
                    """
                    FRR Log information
                    
                    .. attribute:: event_id  <key>
                    
                    	Event ID
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: fast_bundle_member_down_interface
                    
                    	Fast Bundle Member Down Interface
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: frr_event_node_id
                    
                    	Node on which the FRR event happened
                    	**type**\:  str
                    
                    	**pattern:** ([a\-zA\-Z0\-9\_]\*\\d+/){1,2}([a\-zA\-Z0\-9\_]\*\\d+)
                    
                    .. attribute:: main_processing
                    
                    	Main Processing for FRR
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: next_hop
                    
                    	Next Hop
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: number_of_rewrites_affected
                    
                    	Number of rewrites affected
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: protected_frr_interface_name
                    
                    	Interface
                    	**type**\:  str
                    
                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                    
                    .. attribute:: start_time
                    
                    	Time of FRR event processing start, Seconds in UTC, and Nano Seconds
                    	**type**\:   :py:class:`StartTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrLogs.FrrLog.StartTime>`
                    
                    .. attribute:: switching_time_nsecs
                    
                    	Time to switch rewrites [nsecs]
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: nanosecond
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.FrrLogs.FrrLog, self).__init__()

                        self.yang_name = "frr-log"
                        self.yang_parent_name = "frr-logs"

                        self.event_id = YLeaf(YType.int32, "event-id")

                        self.fast_bundle_member_down_interface = YLeaf(YType.uint32, "fast-bundle-member-down-interface")

                        self.frr_event_node_id = YLeaf(YType.str, "frr-event-node-id")

                        self.main_processing = YLeaf(YType.uint32, "main-processing")

                        self.next_hop = YLeaf(YType.uint32, "next-hop")

                        self.number_of_rewrites_affected = YLeaf(YType.uint32, "number-of-rewrites-affected")

                        self.protected_frr_interface_name = YLeaf(YType.str, "protected-frr-interface-name")

                        self.switching_time_nsecs = YLeaf(YType.uint32, "switching-time-nsecs")

                        self.start_time = MplsForwarding.Nodes.Node.FrrLogs.FrrLog.StartTime()
                        self.start_time.parent = self
                        self._children_name_map["start_time"] = "start-time"
                        self._children_yang_names.add("start-time")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("event_id",
                                        "fast_bundle_member_down_interface",
                                        "frr_event_node_id",
                                        "main_processing",
                                        "next_hop",
                                        "number_of_rewrites_affected",
                                        "protected_frr_interface_name",
                                        "switching_time_nsecs") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.FrrLogs.FrrLog, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.FrrLogs.FrrLog, self).__setattr__(name, value)


                    class StartTime(Entity):
                        """
                        Time of FRR event processing start, Seconds in
                        UTC, and Nano Seconds
                        
                        .. attribute:: nanoseconds
                        
                        	Nanoseconds part of time value
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        	**units**\: nanosecond
                        
                        .. attribute:: seconds
                        
                        	Seconds part of time valueiin UTC
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        	**units**\: second
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.FrrLogs.FrrLog.StartTime, self).__init__()

                            self.yang_name = "start-time"
                            self.yang_parent_name = "frr-log"

                            self.nanoseconds = YLeaf(YType.int32, "nanoseconds")

                            self.seconds = YLeaf(YType.int32, "seconds")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("nanoseconds",
                                            "seconds") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.FrrLogs.FrrLog.StartTime, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.FrrLogs.FrrLog.StartTime, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.nanoseconds.is_set or
                                self.seconds.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.nanoseconds.yfilter != YFilter.not_set or
                                self.seconds.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "start-time" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.nanoseconds.is_set or self.nanoseconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.nanoseconds.get_name_leafdata())
                            if (self.seconds.is_set or self.seconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.seconds.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "nanoseconds" or name == "seconds"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "nanoseconds"):
                                self.nanoseconds = value
                                self.nanoseconds.value_namespace = name_space
                                self.nanoseconds.value_namespace_prefix = name_space_prefix
                            if(value_path == "seconds"):
                                self.seconds = value
                                self.seconds.value_namespace = name_space
                                self.seconds.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.event_id.is_set or
                            self.fast_bundle_member_down_interface.is_set or
                            self.frr_event_node_id.is_set or
                            self.main_processing.is_set or
                            self.next_hop.is_set or
                            self.number_of_rewrites_affected.is_set or
                            self.protected_frr_interface_name.is_set or
                            self.switching_time_nsecs.is_set or
                            (self.start_time is not None and self.start_time.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.event_id.yfilter != YFilter.not_set or
                            self.fast_bundle_member_down_interface.yfilter != YFilter.not_set or
                            self.frr_event_node_id.yfilter != YFilter.not_set or
                            self.main_processing.yfilter != YFilter.not_set or
                            self.next_hop.yfilter != YFilter.not_set or
                            self.number_of_rewrites_affected.yfilter != YFilter.not_set or
                            self.protected_frr_interface_name.yfilter != YFilter.not_set or
                            self.switching_time_nsecs.yfilter != YFilter.not_set or
                            (self.start_time is not None and self.start_time.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "frr-log" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.event_id.get_name_leafdata())
                        if (self.fast_bundle_member_down_interface.is_set or self.fast_bundle_member_down_interface.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.fast_bundle_member_down_interface.get_name_leafdata())
                        if (self.frr_event_node_id.is_set or self.frr_event_node_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.frr_event_node_id.get_name_leafdata())
                        if (self.main_processing.is_set or self.main_processing.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.main_processing.get_name_leafdata())
                        if (self.next_hop.is_set or self.next_hop.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.next_hop.get_name_leafdata())
                        if (self.number_of_rewrites_affected.is_set or self.number_of_rewrites_affected.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.number_of_rewrites_affected.get_name_leafdata())
                        if (self.protected_frr_interface_name.is_set or self.protected_frr_interface_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protected_frr_interface_name.get_name_leafdata())
                        if (self.switching_time_nsecs.is_set or self.switching_time_nsecs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.switching_time_nsecs.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "start-time"):
                            if (self.start_time is None):
                                self.start_time = MplsForwarding.Nodes.Node.FrrLogs.FrrLog.StartTime()
                                self.start_time.parent = self
                                self._children_name_map["start_time"] = "start-time"
                            return self.start_time

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "start-time" or name == "event-id" or name == "fast-bundle-member-down-interface" or name == "frr-event-node-id" or name == "main-processing" or name == "next-hop" or name == "number-of-rewrites-affected" or name == "protected-frr-interface-name" or name == "switching-time-nsecs"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "event-id"):
                            self.event_id = value
                            self.event_id.value_namespace = name_space
                            self.event_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "fast-bundle-member-down-interface"):
                            self.fast_bundle_member_down_interface = value
                            self.fast_bundle_member_down_interface.value_namespace = name_space
                            self.fast_bundle_member_down_interface.value_namespace_prefix = name_space_prefix
                        if(value_path == "frr-event-node-id"):
                            self.frr_event_node_id = value
                            self.frr_event_node_id.value_namespace = name_space
                            self.frr_event_node_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "main-processing"):
                            self.main_processing = value
                            self.main_processing.value_namespace = name_space
                            self.main_processing.value_namespace_prefix = name_space_prefix
                        if(value_path == "next-hop"):
                            self.next_hop = value
                            self.next_hop.value_namespace = name_space
                            self.next_hop.value_namespace_prefix = name_space_prefix
                        if(value_path == "number-of-rewrites-affected"):
                            self.number_of_rewrites_affected = value
                            self.number_of_rewrites_affected.value_namespace = name_space
                            self.number_of_rewrites_affected.value_namespace_prefix = name_space_prefix
                        if(value_path == "protected-frr-interface-name"):
                            self.protected_frr_interface_name = value
                            self.protected_frr_interface_name.value_namespace = name_space
                            self.protected_frr_interface_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "switching-time-nsecs"):
                            self.switching_time_nsecs = value
                            self.switching_time_nsecs.value_namespace = name_space
                            self.switching_time_nsecs.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.frr_log:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.frr_log:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "frr-logs" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "frr-log"):
                        for c in self.frr_log:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsForwarding.Nodes.Node.FrrLogs.FrrLog()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.frr_log.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "frr-log"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class LabelFib(Entity):
                """
                Labels For FIB
                
                .. attribute:: forwarding_details
                
                	MPLS Forwarding Detail table
                	**type**\:   :py:class:`ForwardingDetails <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails>`
                
                .. attribute:: informations
                
                	Forwarding filtering details
                	**type**\:   :py:class:`Informations <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.Informations>`
                
                .. attribute:: label_security
                
                	MPLS label security
                	**type**\:   :py:class:`LabelSecurity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.LabelSecurity>`
                
                

                """

                _prefix = 'fib-common-oper'
                _revision = '2017-01-20'

                def __init__(self):
                    super(MplsForwarding.Nodes.Node.LabelFib, self).__init__()

                    self.yang_name = "label-fib"
                    self.yang_parent_name = "node"

                    self.forwarding_details = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails()
                    self.forwarding_details.parent = self
                    self._children_name_map["forwarding_details"] = "forwarding-details"
                    self._children_yang_names.add("forwarding-details")

                    self.informations = MplsForwarding.Nodes.Node.LabelFib.Informations()
                    self.informations.parent = self
                    self._children_name_map["informations"] = "informations"
                    self._children_yang_names.add("informations")

                    self.label_security = MplsForwarding.Nodes.Node.LabelFib.LabelSecurity()
                    self.label_security.parent = self
                    self._children_name_map["label_security"] = "label-security"
                    self._children_yang_names.add("label-security")


                class ForwardingDetails(Entity):
                    """
                    MPLS Forwarding Detail table
                    
                    .. attribute:: forwarding_detail
                    
                    	MPLS forwarding details
                    	**type**\: list of    :py:class:`ForwardingDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails, self).__init__()

                        self.yang_name = "forwarding-details"
                        self.yang_parent_name = "label-fib"

                        self.forwarding_detail = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails, self).__setattr__(name, value)


                    class ForwardingDetail(Entity):
                        """
                        MPLS forwarding details
                        
                        .. attribute:: afi_table_id
                        
                        	The AFI table ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: eos
                        
                        	End of stack flag
                        	**type**\:   :py:class:`Mplseos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Mplseos>`
                        
                        .. attribute:: eos_bit
                        
                        	EOS bit
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hardware_information
                        
                        	Hardware info
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        .. attribute:: label_information
                        
                        	Label\-infos in FIB leaf
                        	**type**\: list of    :py:class:`LabelInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation>`
                        
                        .. attribute:: label_value
                        
                        	Local label value
                        	**type**\:  int
                        
                        	**range:** 16..1048575
                        
                        .. attribute:: ldi_flags
                        
                        	The LDI flags
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ldi_information
                        
                        	LDI\-info in FIB leaf
                        	**type**\:   :py:class:`LdiInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LdiInformation>`
                        
                        .. attribute:: ldi_pointer
                        
                        	The pointer to the LDI
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ldi_referance_count
                        
                        	Number of references to the LDI
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ldi_type
                        
                        	The LDI type
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: leaf_flags
                        
                        	The leaf flags
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: leaf_local_label
                        
                        	Local label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: leaf_referance_count
                        
                        	Number of references to the leaf
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: leaf_time_in_milli_seconds
                        
                        	The time of last update in msec
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: lspa_flags
                        
                        	The LSPA flags
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lw_ldi_pointer
                        
                        	The pointer to the LW\-LDI
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lw_ldi_refernace_count
                        
                        	The LW\-LDI refcounter
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lw_ldi_type
                        
                        	The LW\-LDI type
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lw_shared_ldi_pointer
                        
                        	The pointer to the shared LDI in LW\-LDI
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: multicast_information
                        
                        	The multicast info
                        	**type**\:   :py:class:`MulticastInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.MulticastInformation>`
                        
                        .. attribute:: multicast_label
                        
                        	The unicast or multicast label
                        	**type**\:  bool
                        
                        .. attribute:: path_list_flags
                        
                        	The pathlist flags
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: path_list_referance_count
                        
                        	Number of references to the pathlist
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail, self).__init__()

                            self.yang_name = "forwarding-detail"
                            self.yang_parent_name = "forwarding-details"

                            self.afi_table_id = YLeaf(YType.uint32, "afi-table-id")

                            self.eos = YLeaf(YType.enumeration, "eos")

                            self.eos_bit = YLeaf(YType.uint32, "eos-bit")

                            self.hardware_information = YLeaf(YType.str, "hardware-information")

                            self.label_value = YLeaf(YType.uint32, "label-value")

                            self.ldi_flags = YLeaf(YType.uint32, "ldi-flags")

                            self.ldi_pointer = YLeaf(YType.uint32, "ldi-pointer")

                            self.ldi_referance_count = YLeaf(YType.uint32, "ldi-referance-count")

                            self.ldi_type = YLeaf(YType.uint32, "ldi-type")

                            self.leaf_flags = YLeaf(YType.uint32, "leaf-flags")

                            self.leaf_local_label = YLeaf(YType.uint32, "leaf-local-label")

                            self.leaf_referance_count = YLeaf(YType.uint32, "leaf-referance-count")

                            self.leaf_time_in_milli_seconds = YLeaf(YType.uint64, "leaf-time-in-milli-seconds")

                            self.lspa_flags = YLeaf(YType.uint32, "lspa-flags")

                            self.lw_ldi_pointer = YLeaf(YType.uint32, "lw-ldi-pointer")

                            self.lw_ldi_refernace_count = YLeaf(YType.uint32, "lw-ldi-refernace-count")

                            self.lw_ldi_type = YLeaf(YType.uint32, "lw-ldi-type")

                            self.lw_shared_ldi_pointer = YLeaf(YType.uint32, "lw-shared-ldi-pointer")

                            self.multicast_label = YLeaf(YType.boolean, "multicast-label")

                            self.path_list_flags = YLeaf(YType.uint32, "path-list-flags")

                            self.path_list_referance_count = YLeaf(YType.uint32, "path-list-referance-count")

                            self.ldi_information = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LdiInformation()
                            self.ldi_information.parent = self
                            self._children_name_map["ldi_information"] = "ldi-information"
                            self._children_yang_names.add("ldi-information")

                            self.multicast_information = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.MulticastInformation()
                            self.multicast_information.parent = self
                            self._children_name_map["multicast_information"] = "multicast-information"
                            self._children_yang_names.add("multicast-information")

                            self.label_information = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi_table_id",
                                            "eos",
                                            "eos_bit",
                                            "hardware_information",
                                            "label_value",
                                            "ldi_flags",
                                            "ldi_pointer",
                                            "ldi_referance_count",
                                            "ldi_type",
                                            "leaf_flags",
                                            "leaf_local_label",
                                            "leaf_referance_count",
                                            "leaf_time_in_milli_seconds",
                                            "lspa_flags",
                                            "lw_ldi_pointer",
                                            "lw_ldi_refernace_count",
                                            "lw_ldi_type",
                                            "lw_shared_ldi_pointer",
                                            "multicast_label",
                                            "path_list_flags",
                                            "path_list_referance_count") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail, self).__setattr__(name, value)


                        class LdiInformation(Entity):
                            """
                            LDI\-info in FIB leaf
                            
                            .. attribute:: ldi_hardware_information
                            
                            	Hardware info
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LdiInformation, self).__init__()

                                self.yang_name = "ldi-information"
                                self.yang_parent_name = "forwarding-detail"

                                self.ldi_hardware_information = YLeaf(YType.str, "ldi-hardware-information")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ldi_hardware_information") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LdiInformation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LdiInformation, self).__setattr__(name, value)

                            def has_data(self):
                                return self.ldi_hardware_information.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ldi_hardware_information.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ldi-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ldi_hardware_information.is_set or self.ldi_hardware_information.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldi_hardware_information.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ldi-hardware-information"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ldi-hardware-information"):
                                    self.ldi_hardware_information = value
                                    self.ldi_hardware_information.value_namespace = name_space
                                    self.ldi_hardware_information.value_namespace_prefix = name_space_prefix


                        class MulticastInformation(Entity):
                            """
                            The multicast info
                            
                            .. attribute:: multicast_encap_id
                            
                            	The multicast ENCAP\-ID 
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_mol_base_flags
                            
                            	MOL base flags
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_mol_flags
                            
                            	MOL flags
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_mol_referance_count
                            
                            	MOL refcount
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_mpls_local_output_paths
                            
                            	num multicast mpls local output paths
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_mpls_output_paths
                            
                            	num multicast mpls output paths 
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_mpls_protocol_output_paths
                            
                            	num multicast mpls prot output paths 
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_platform_data
                            
                            	The multicast platform data
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: multicast_platform_data_length
                            
                            	The multicast platform data len
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: multicast_rpf_id
                            
                            	The multicast RPF\-ID 
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_tunnel_id
                            
                            	multicast mpls P2MP\-TE tunnel id or MLDP Tunnel LSMID on all nodes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_tunnel_interface_handler
                            
                            	multicast mpls tunnel
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: multicast_tunnel_lspvif
                            
                            	multicast LSPVIF for MLDP Tunnels
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_tunnel_next_hop_information
                            
                            	multicast nhinfo for p2mp TE Head
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.MulticastInformation, self).__init__()

                                self.yang_name = "multicast-information"
                                self.yang_parent_name = "forwarding-detail"

                                self.multicast_encap_id = YLeaf(YType.uint32, "multicast-encap-id")

                                self.multicast_mol_base_flags = YLeaf(YType.uint32, "multicast-mol-base-flags")

                                self.multicast_mol_flags = YLeaf(YType.uint16, "multicast-mol-flags")

                                self.multicast_mol_referance_count = YLeaf(YType.uint16, "multicast-mol-referance-count")

                                self.multicast_mpls_local_output_paths = YLeaf(YType.uint16, "multicast-mpls-local-output-paths")

                                self.multicast_mpls_output_paths = YLeaf(YType.uint16, "multicast-mpls-output-paths")

                                self.multicast_mpls_protocol_output_paths = YLeaf(YType.uint16, "multicast-mpls-protocol-output-paths")

                                self.multicast_platform_data = YLeaf(YType.str, "multicast-platform-data")

                                self.multicast_platform_data_length = YLeaf(YType.uint8, "multicast-platform-data-length")

                                self.multicast_rpf_id = YLeaf(YType.uint32, "multicast-rpf-id")

                                self.multicast_tunnel_id = YLeaf(YType.uint32, "multicast-tunnel-id")

                                self.multicast_tunnel_interface_handler = YLeaf(YType.str, "multicast-tunnel-interface-handler")

                                self.multicast_tunnel_lspvif = YLeaf(YType.uint32, "multicast-tunnel-lspvif")

                                self.multicast_tunnel_next_hop_information = YLeaf(YType.uint32, "multicast-tunnel-next-hop-information")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("multicast_encap_id",
                                                "multicast_mol_base_flags",
                                                "multicast_mol_flags",
                                                "multicast_mol_referance_count",
                                                "multicast_mpls_local_output_paths",
                                                "multicast_mpls_output_paths",
                                                "multicast_mpls_protocol_output_paths",
                                                "multicast_platform_data",
                                                "multicast_platform_data_length",
                                                "multicast_rpf_id",
                                                "multicast_tunnel_id",
                                                "multicast_tunnel_interface_handler",
                                                "multicast_tunnel_lspvif",
                                                "multicast_tunnel_next_hop_information") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.MulticastInformation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.MulticastInformation, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.multicast_encap_id.is_set or
                                    self.multicast_mol_base_flags.is_set or
                                    self.multicast_mol_flags.is_set or
                                    self.multicast_mol_referance_count.is_set or
                                    self.multicast_mpls_local_output_paths.is_set or
                                    self.multicast_mpls_output_paths.is_set or
                                    self.multicast_mpls_protocol_output_paths.is_set or
                                    self.multicast_platform_data.is_set or
                                    self.multicast_platform_data_length.is_set or
                                    self.multicast_rpf_id.is_set or
                                    self.multicast_tunnel_id.is_set or
                                    self.multicast_tunnel_interface_handler.is_set or
                                    self.multicast_tunnel_lspvif.is_set or
                                    self.multicast_tunnel_next_hop_information.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.multicast_encap_id.yfilter != YFilter.not_set or
                                    self.multicast_mol_base_flags.yfilter != YFilter.not_set or
                                    self.multicast_mol_flags.yfilter != YFilter.not_set or
                                    self.multicast_mol_referance_count.yfilter != YFilter.not_set or
                                    self.multicast_mpls_local_output_paths.yfilter != YFilter.not_set or
                                    self.multicast_mpls_output_paths.yfilter != YFilter.not_set or
                                    self.multicast_mpls_protocol_output_paths.yfilter != YFilter.not_set or
                                    self.multicast_platform_data.yfilter != YFilter.not_set or
                                    self.multicast_platform_data_length.yfilter != YFilter.not_set or
                                    self.multicast_rpf_id.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_id.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_interface_handler.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_lspvif.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_next_hop_information.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "multicast-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.multicast_encap_id.is_set or self.multicast_encap_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_encap_id.get_name_leafdata())
                                if (self.multicast_mol_base_flags.is_set or self.multicast_mol_base_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mol_base_flags.get_name_leafdata())
                                if (self.multicast_mol_flags.is_set or self.multicast_mol_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mol_flags.get_name_leafdata())
                                if (self.multicast_mol_referance_count.is_set or self.multicast_mol_referance_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mol_referance_count.get_name_leafdata())
                                if (self.multicast_mpls_local_output_paths.is_set or self.multicast_mpls_local_output_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mpls_local_output_paths.get_name_leafdata())
                                if (self.multicast_mpls_output_paths.is_set or self.multicast_mpls_output_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mpls_output_paths.get_name_leafdata())
                                if (self.multicast_mpls_protocol_output_paths.is_set or self.multicast_mpls_protocol_output_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mpls_protocol_output_paths.get_name_leafdata())
                                if (self.multicast_platform_data.is_set or self.multicast_platform_data.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_platform_data.get_name_leafdata())
                                if (self.multicast_platform_data_length.is_set or self.multicast_platform_data_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_platform_data_length.get_name_leafdata())
                                if (self.multicast_rpf_id.is_set or self.multicast_rpf_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_rpf_id.get_name_leafdata())
                                if (self.multicast_tunnel_id.is_set or self.multicast_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_id.get_name_leafdata())
                                if (self.multicast_tunnel_interface_handler.is_set or self.multicast_tunnel_interface_handler.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_interface_handler.get_name_leafdata())
                                if (self.multicast_tunnel_lspvif.is_set or self.multicast_tunnel_lspvif.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_lspvif.get_name_leafdata())
                                if (self.multicast_tunnel_next_hop_information.is_set or self.multicast_tunnel_next_hop_information.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_next_hop_information.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "multicast-encap-id" or name == "multicast-mol-base-flags" or name == "multicast-mol-flags" or name == "multicast-mol-referance-count" or name == "multicast-mpls-local-output-paths" or name == "multicast-mpls-output-paths" or name == "multicast-mpls-protocol-output-paths" or name == "multicast-platform-data" or name == "multicast-platform-data-length" or name == "multicast-rpf-id" or name == "multicast-tunnel-id" or name == "multicast-tunnel-interface-handler" or name == "multicast-tunnel-lspvif" or name == "multicast-tunnel-next-hop-information"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "multicast-encap-id"):
                                    self.multicast_encap_id = value
                                    self.multicast_encap_id.value_namespace = name_space
                                    self.multicast_encap_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mol-base-flags"):
                                    self.multicast_mol_base_flags = value
                                    self.multicast_mol_base_flags.value_namespace = name_space
                                    self.multicast_mol_base_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mol-flags"):
                                    self.multicast_mol_flags = value
                                    self.multicast_mol_flags.value_namespace = name_space
                                    self.multicast_mol_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mol-referance-count"):
                                    self.multicast_mol_referance_count = value
                                    self.multicast_mol_referance_count.value_namespace = name_space
                                    self.multicast_mol_referance_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mpls-local-output-paths"):
                                    self.multicast_mpls_local_output_paths = value
                                    self.multicast_mpls_local_output_paths.value_namespace = name_space
                                    self.multicast_mpls_local_output_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mpls-output-paths"):
                                    self.multicast_mpls_output_paths = value
                                    self.multicast_mpls_output_paths.value_namespace = name_space
                                    self.multicast_mpls_output_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mpls-protocol-output-paths"):
                                    self.multicast_mpls_protocol_output_paths = value
                                    self.multicast_mpls_protocol_output_paths.value_namespace = name_space
                                    self.multicast_mpls_protocol_output_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-platform-data"):
                                    self.multicast_platform_data = value
                                    self.multicast_platform_data.value_namespace = name_space
                                    self.multicast_platform_data.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-platform-data-length"):
                                    self.multicast_platform_data_length = value
                                    self.multicast_platform_data_length.value_namespace = name_space
                                    self.multicast_platform_data_length.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-rpf-id"):
                                    self.multicast_rpf_id = value
                                    self.multicast_rpf_id.value_namespace = name_space
                                    self.multicast_rpf_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-id"):
                                    self.multicast_tunnel_id = value
                                    self.multicast_tunnel_id.value_namespace = name_space
                                    self.multicast_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-interface-handler"):
                                    self.multicast_tunnel_interface_handler = value
                                    self.multicast_tunnel_interface_handler.value_namespace = name_space
                                    self.multicast_tunnel_interface_handler.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-lspvif"):
                                    self.multicast_tunnel_lspvif = value
                                    self.multicast_tunnel_lspvif.value_namespace = name_space
                                    self.multicast_tunnel_lspvif.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-next-hop-information"):
                                    self.multicast_tunnel_next_hop_information = value
                                    self.multicast_tunnel_next_hop_information.value_namespace = name_space
                                    self.multicast_tunnel_next_hop_information.value_namespace_prefix = name_space_prefix


                        class LabelInformation(Entity):
                            """
                            Label\-infos in FIB leaf
                            
                            .. attribute:: exact_route_hash_info
                            
                            	Path's Hash info in case of exact\-route command
                            	**type**\:   :py:class:`ExactRouteHashInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.ExactRouteHashInfo>`
                            
                            .. attribute:: label_information_detail
                            
                            	Detail label info
                            	**type**\:   :py:class:`LabelInformationDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail>`
                            
                            .. attribute:: label_information_next_hop_protocol
                            
                            	The address family (v4/v6) 
                            	**type**\:   :py:class:`Proto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Proto>`
                            
                            .. attribute:: label_information_next_hop_string
                            
                            	Next hop address in string format
                            	**type**\:  str
                            
                            .. attribute:: label_information_next_hop_type
                            
                            	NHinfo Type
                            	**type**\:   :py:class:`NextHop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.NextHop>`
                            
                            .. attribute:: label_information_path_index
                            
                            	LabelInformationPathIndex
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: label_information_route_version
                            
                            	The version of the route
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: label_information_time_in_milli_seconds
                            
                            	The time of last update in msec
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: label_information_type
                            
                            	Label\-Info type
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_label
                            
                            	Local label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mpls_adjacency_flags
                            
                            	MPLS Adjacency flags
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_interface
                            
                            	Outgoing interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: outgoing_interface_string
                            
                            	Output Interface in string format
                            	**type**\:  str
                            
                            .. attribute:: outgoing_label
                            
                            	Outgoing label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_label_string
                            
                            	Output Label in string format
                            	**type**\:  str
                            
                            .. attribute:: outgoing_physical_interface
                            
                            	Outgoing Physical Interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: prefix_or_id
                            
                            	Prefix Or ID
                            	**type**\:  str
                            
                            .. attribute:: tunnel_id_present
                            
                            	Tunnel id present?
                            	**type**\:  bool
                            
                            .. attribute:: tunnel_interface
                            
                            	Tunnel Interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: tx_bytes
                            
                            	Bytes transmitted per LSP
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            	**units**\: byte
                            
                            .. attribute:: tx_packets
                            
                            	Packets transmitted per LSP
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation, self).__init__()

                                self.yang_name = "label-information"
                                self.yang_parent_name = "forwarding-detail"

                                self.label_information_next_hop_protocol = YLeaf(YType.enumeration, "label-information-next-hop-protocol")

                                self.label_information_next_hop_string = YLeaf(YType.str, "label-information-next-hop-string")

                                self.label_information_next_hop_type = YLeaf(YType.enumeration, "label-information-next-hop-type")

                                self.label_information_path_index = YLeaf(YType.uint32, "label-information-path-index")

                                self.label_information_route_version = YLeaf(YType.uint64, "label-information-route-version")

                                self.label_information_time_in_milli_seconds = YLeaf(YType.uint64, "label-information-time-in-milli-seconds")

                                self.label_information_type = YLeaf(YType.uint32, "label-information-type")

                                self.local_label = YLeaf(YType.uint32, "local-label")

                                self.mpls_adjacency_flags = YLeaf(YType.uint32, "mpls-adjacency-flags")

                                self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                self.outgoing_interface_string = YLeaf(YType.str, "outgoing-interface-string")

                                self.outgoing_label = YLeaf(YType.uint32, "outgoing-label")

                                self.outgoing_label_string = YLeaf(YType.str, "outgoing-label-string")

                                self.outgoing_physical_interface = YLeaf(YType.str, "outgoing-physical-interface")

                                self.prefix_or_id = YLeaf(YType.str, "prefix-or-id")

                                self.tunnel_id_present = YLeaf(YType.boolean, "tunnel-id-present")

                                self.tunnel_interface = YLeaf(YType.str, "tunnel-interface")

                                self.tx_bytes = YLeaf(YType.uint64, "tx-bytes")

                                self.tx_packets = YLeaf(YType.uint64, "tx-packets")

                                self.exact_route_hash_info = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.ExactRouteHashInfo()
                                self.exact_route_hash_info.parent = self
                                self._children_name_map["exact_route_hash_info"] = "exact-route-hash-info"
                                self._children_yang_names.add("exact-route-hash-info")

                                self.label_information_detail = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail()
                                self.label_information_detail.parent = self
                                self._children_name_map["label_information_detail"] = "label-information-detail"
                                self._children_yang_names.add("label-information-detail")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("label_information_next_hop_protocol",
                                                "label_information_next_hop_string",
                                                "label_information_next_hop_type",
                                                "label_information_path_index",
                                                "label_information_route_version",
                                                "label_information_time_in_milli_seconds",
                                                "label_information_type",
                                                "local_label",
                                                "mpls_adjacency_flags",
                                                "outgoing_interface",
                                                "outgoing_interface_string",
                                                "outgoing_label",
                                                "outgoing_label_string",
                                                "outgoing_physical_interface",
                                                "prefix_or_id",
                                                "tunnel_id_present",
                                                "tunnel_interface",
                                                "tx_bytes",
                                                "tx_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation, self).__setattr__(name, value)


                            class LabelInformationDetail(Entity):
                                """
                                Detail label info
                                
                                .. attribute:: l3_mtu
                                
                                	L3 MTU
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: label_stack
                                
                                	Label stack
                                	**type**\: list of    :py:class:`LabelStack <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail.LabelStack>`
                                
                                .. attribute:: mac_size
                                
                                	Length of L2 encapsulation
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: next_hop_interface
                                
                                	Next hop interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: next_hop_protocol
                                
                                	The address family (V4/V6) 
                                	**type**\:   :py:class:`Proto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Proto>`
                                
                                .. attribute:: next_hop_string
                                
                                	Next hop address in string format
                                	**type**\:  str
                                
                                .. attribute:: status
                                
                                	Status
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                .. attribute:: total_encapsulation_size
                                
                                	Total encapsulation size\: L2 + MPLS
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: transmit_number_of_bytes_switched
                                
                                	Number of Bytes switched
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                .. attribute:: transmit_number_of_packets_switched
                                
                                	Number of packets switched
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail, self).__init__()

                                    self.yang_name = "label-information-detail"
                                    self.yang_parent_name = "label-information"

                                    self.l3_mtu = YLeaf(YType.uint32, "l3-mtu")

                                    self.mac_size = YLeaf(YType.uint32, "mac-size")

                                    self.next_hop_interface = YLeaf(YType.str, "next-hop-interface")

                                    self.next_hop_protocol = YLeaf(YType.enumeration, "next-hop-protocol")

                                    self.next_hop_string = YLeaf(YType.str, "next-hop-string")

                                    self.status = YLeaf(YType.int32, "status")

                                    self.total_encapsulation_size = YLeaf(YType.uint32, "total-encapsulation-size")

                                    self.transmit_number_of_bytes_switched = YLeaf(YType.uint64, "transmit-number-of-bytes-switched")

                                    self.transmit_number_of_packets_switched = YLeaf(YType.uint64, "transmit-number-of-packets-switched")

                                    self.label_stack = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("l3_mtu",
                                                    "mac_size",
                                                    "next_hop_interface",
                                                    "next_hop_protocol",
                                                    "next_hop_string",
                                                    "status",
                                                    "total_encapsulation_size",
                                                    "transmit_number_of_bytes_switched",
                                                    "transmit_number_of_packets_switched") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail, self).__setattr__(name, value)


                                class LabelStack(Entity):
                                    """
                                    Label stack
                                    
                                    .. attribute:: entry
                                    
                                    	
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail.LabelStack, self).__init__()

                                        self.yang_name = "label-stack"
                                        self.yang_parent_name = "label-information-detail"

                                        self.entry = YLeaf(YType.uint32, "entry")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("entry") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail.LabelStack, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail.LabelStack, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.entry.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.entry.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "label-stack" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "entry"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "entry"):
                                            self.entry = value
                                            self.entry.value_namespace = name_space
                                            self.entry.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.label_stack:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.l3_mtu.is_set or
                                        self.mac_size.is_set or
                                        self.next_hop_interface.is_set or
                                        self.next_hop_protocol.is_set or
                                        self.next_hop_string.is_set or
                                        self.status.is_set or
                                        self.total_encapsulation_size.is_set or
                                        self.transmit_number_of_bytes_switched.is_set or
                                        self.transmit_number_of_packets_switched.is_set)

                                def has_operation(self):
                                    for c in self.label_stack:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.l3_mtu.yfilter != YFilter.not_set or
                                        self.mac_size.yfilter != YFilter.not_set or
                                        self.next_hop_interface.yfilter != YFilter.not_set or
                                        self.next_hop_protocol.yfilter != YFilter.not_set or
                                        self.next_hop_string.yfilter != YFilter.not_set or
                                        self.status.yfilter != YFilter.not_set or
                                        self.total_encapsulation_size.yfilter != YFilter.not_set or
                                        self.transmit_number_of_bytes_switched.yfilter != YFilter.not_set or
                                        self.transmit_number_of_packets_switched.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "label-information-detail" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.l3_mtu.is_set or self.l3_mtu.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.l3_mtu.get_name_leafdata())
                                    if (self.mac_size.is_set or self.mac_size.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mac_size.get_name_leafdata())
                                    if (self.next_hop_interface.is_set or self.next_hop_interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop_interface.get_name_leafdata())
                                    if (self.next_hop_protocol.is_set or self.next_hop_protocol.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop_protocol.get_name_leafdata())
                                    if (self.next_hop_string.is_set or self.next_hop_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop_string.get_name_leafdata())
                                    if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.status.get_name_leafdata())
                                    if (self.total_encapsulation_size.is_set or self.total_encapsulation_size.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_encapsulation_size.get_name_leafdata())
                                    if (self.transmit_number_of_bytes_switched.is_set or self.transmit_number_of_bytes_switched.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_number_of_bytes_switched.get_name_leafdata())
                                    if (self.transmit_number_of_packets_switched.is_set or self.transmit_number_of_packets_switched.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_number_of_packets_switched.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "label-stack"):
                                        for c in self.label_stack:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail.LabelStack()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.label_stack.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "label-stack" or name == "l3-mtu" or name == "mac-size" or name == "next-hop-interface" or name == "next-hop-protocol" or name == "next-hop-string" or name == "status" or name == "total-encapsulation-size" or name == "transmit-number-of-bytes-switched" or name == "transmit-number-of-packets-switched"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "l3-mtu"):
                                        self.l3_mtu = value
                                        self.l3_mtu.value_namespace = name_space
                                        self.l3_mtu.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mac-size"):
                                        self.mac_size = value
                                        self.mac_size.value_namespace = name_space
                                        self.mac_size.value_namespace_prefix = name_space_prefix
                                    if(value_path == "next-hop-interface"):
                                        self.next_hop_interface = value
                                        self.next_hop_interface.value_namespace = name_space
                                        self.next_hop_interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "next-hop-protocol"):
                                        self.next_hop_protocol = value
                                        self.next_hop_protocol.value_namespace = name_space
                                        self.next_hop_protocol.value_namespace_prefix = name_space_prefix
                                    if(value_path == "next-hop-string"):
                                        self.next_hop_string = value
                                        self.next_hop_string.value_namespace = name_space
                                        self.next_hop_string.value_namespace_prefix = name_space_prefix
                                    if(value_path == "status"):
                                        self.status = value
                                        self.status.value_namespace = name_space
                                        self.status.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-encapsulation-size"):
                                        self.total_encapsulation_size = value
                                        self.total_encapsulation_size.value_namespace = name_space
                                        self.total_encapsulation_size.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-number-of-bytes-switched"):
                                        self.transmit_number_of_bytes_switched = value
                                        self.transmit_number_of_bytes_switched.value_namespace = name_space
                                        self.transmit_number_of_bytes_switched.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-number-of-packets-switched"):
                                        self.transmit_number_of_packets_switched = value
                                        self.transmit_number_of_packets_switched.value_namespace = name_space
                                        self.transmit_number_of_packets_switched.value_namespace_prefix = name_space_prefix


                            class ExactRouteHashInfo(Entity):
                                """
                                Path's Hash info in case of exact\-route command
                                
                                .. attribute:: hash_index
                                
                                	Hash Index value
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                .. attribute:: hash_index_is_valid
                                
                                	Is Hash Index valid?
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.ExactRouteHashInfo, self).__init__()

                                    self.yang_name = "exact-route-hash-info"
                                    self.yang_parent_name = "label-information"

                                    self.hash_index = YLeaf(YType.uint8, "hash-index")

                                    self.hash_index_is_valid = YLeaf(YType.boolean, "hash-index-is-valid")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("hash_index",
                                                    "hash_index_is_valid") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.ExactRouteHashInfo, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.ExactRouteHashInfo, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.hash_index.is_set or
                                        self.hash_index_is_valid.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.hash_index.yfilter != YFilter.not_set or
                                        self.hash_index_is_valid.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "exact-route-hash-info" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.hash_index.is_set or self.hash_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hash_index.get_name_leafdata())
                                    if (self.hash_index_is_valid.is_set or self.hash_index_is_valid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hash_index_is_valid.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "hash-index" or name == "hash-index-is-valid"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "hash-index"):
                                        self.hash_index = value
                                        self.hash_index.value_namespace = name_space
                                        self.hash_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hash-index-is-valid"):
                                        self.hash_index_is_valid = value
                                        self.hash_index_is_valid.value_namespace = name_space
                                        self.hash_index_is_valid.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.label_information_next_hop_protocol.is_set or
                                    self.label_information_next_hop_string.is_set or
                                    self.label_information_next_hop_type.is_set or
                                    self.label_information_path_index.is_set or
                                    self.label_information_route_version.is_set or
                                    self.label_information_time_in_milli_seconds.is_set or
                                    self.label_information_type.is_set or
                                    self.local_label.is_set or
                                    self.mpls_adjacency_flags.is_set or
                                    self.outgoing_interface.is_set or
                                    self.outgoing_interface_string.is_set or
                                    self.outgoing_label.is_set or
                                    self.outgoing_label_string.is_set or
                                    self.outgoing_physical_interface.is_set or
                                    self.prefix_or_id.is_set or
                                    self.tunnel_id_present.is_set or
                                    self.tunnel_interface.is_set or
                                    self.tx_bytes.is_set or
                                    self.tx_packets.is_set or
                                    (self.exact_route_hash_info is not None and self.exact_route_hash_info.has_data()) or
                                    (self.label_information_detail is not None and self.label_information_detail.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.label_information_next_hop_protocol.yfilter != YFilter.not_set or
                                    self.label_information_next_hop_string.yfilter != YFilter.not_set or
                                    self.label_information_next_hop_type.yfilter != YFilter.not_set or
                                    self.label_information_path_index.yfilter != YFilter.not_set or
                                    self.label_information_route_version.yfilter != YFilter.not_set or
                                    self.label_information_time_in_milli_seconds.yfilter != YFilter.not_set or
                                    self.label_information_type.yfilter != YFilter.not_set or
                                    self.local_label.yfilter != YFilter.not_set or
                                    self.mpls_adjacency_flags.yfilter != YFilter.not_set or
                                    self.outgoing_interface.yfilter != YFilter.not_set or
                                    self.outgoing_interface_string.yfilter != YFilter.not_set or
                                    self.outgoing_label.yfilter != YFilter.not_set or
                                    self.outgoing_label_string.yfilter != YFilter.not_set or
                                    self.outgoing_physical_interface.yfilter != YFilter.not_set or
                                    self.prefix_or_id.yfilter != YFilter.not_set or
                                    self.tunnel_id_present.yfilter != YFilter.not_set or
                                    self.tunnel_interface.yfilter != YFilter.not_set or
                                    self.tx_bytes.yfilter != YFilter.not_set or
                                    self.tx_packets.yfilter != YFilter.not_set or
                                    (self.exact_route_hash_info is not None and self.exact_route_hash_info.has_operation()) or
                                    (self.label_information_detail is not None and self.label_information_detail.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "label-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.label_information_next_hop_protocol.is_set or self.label_information_next_hop_protocol.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_next_hop_protocol.get_name_leafdata())
                                if (self.label_information_next_hop_string.is_set or self.label_information_next_hop_string.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_next_hop_string.get_name_leafdata())
                                if (self.label_information_next_hop_type.is_set or self.label_information_next_hop_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_next_hop_type.get_name_leafdata())
                                if (self.label_information_path_index.is_set or self.label_information_path_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_path_index.get_name_leafdata())
                                if (self.label_information_route_version.is_set or self.label_information_route_version.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_route_version.get_name_leafdata())
                                if (self.label_information_time_in_milli_seconds.is_set or self.label_information_time_in_milli_seconds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_time_in_milli_seconds.get_name_leafdata())
                                if (self.label_information_type.is_set or self.label_information_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_type.get_name_leafdata())
                                if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_label.get_name_leafdata())
                                if (self.mpls_adjacency_flags.is_set or self.mpls_adjacency_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mpls_adjacency_flags.get_name_leafdata())
                                if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                if (self.outgoing_interface_string.is_set or self.outgoing_interface_string.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_interface_string.get_name_leafdata())
                                if (self.outgoing_label.is_set or self.outgoing_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_label.get_name_leafdata())
                                if (self.outgoing_label_string.is_set or self.outgoing_label_string.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_label_string.get_name_leafdata())
                                if (self.outgoing_physical_interface.is_set or self.outgoing_physical_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_physical_interface.get_name_leafdata())
                                if (self.prefix_or_id.is_set or self.prefix_or_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_or_id.get_name_leafdata())
                                if (self.tunnel_id_present.is_set or self.tunnel_id_present.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_id_present.get_name_leafdata())
                                if (self.tunnel_interface.is_set or self.tunnel_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_interface.get_name_leafdata())
                                if (self.tx_bytes.is_set or self.tx_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tx_bytes.get_name_leafdata())
                                if (self.tx_packets.is_set or self.tx_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tx_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "exact-route-hash-info"):
                                    if (self.exact_route_hash_info is None):
                                        self.exact_route_hash_info = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.ExactRouteHashInfo()
                                        self.exact_route_hash_info.parent = self
                                        self._children_name_map["exact_route_hash_info"] = "exact-route-hash-info"
                                    return self.exact_route_hash_info

                                if (child_yang_name == "label-information-detail"):
                                    if (self.label_information_detail is None):
                                        self.label_information_detail = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation.LabelInformationDetail()
                                        self.label_information_detail.parent = self
                                        self._children_name_map["label_information_detail"] = "label-information-detail"
                                    return self.label_information_detail

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "exact-route-hash-info" or name == "label-information-detail" or name == "label-information-next-hop-protocol" or name == "label-information-next-hop-string" or name == "label-information-next-hop-type" or name == "label-information-path-index" or name == "label-information-route-version" or name == "label-information-time-in-milli-seconds" or name == "label-information-type" or name == "local-label" or name == "mpls-adjacency-flags" or name == "outgoing-interface" or name == "outgoing-interface-string" or name == "outgoing-label" or name == "outgoing-label-string" or name == "outgoing-physical-interface" or name == "prefix-or-id" or name == "tunnel-id-present" or name == "tunnel-interface" or name == "tx-bytes" or name == "tx-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "label-information-next-hop-protocol"):
                                    self.label_information_next_hop_protocol = value
                                    self.label_information_next_hop_protocol.value_namespace = name_space
                                    self.label_information_next_hop_protocol.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-next-hop-string"):
                                    self.label_information_next_hop_string = value
                                    self.label_information_next_hop_string.value_namespace = name_space
                                    self.label_information_next_hop_string.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-next-hop-type"):
                                    self.label_information_next_hop_type = value
                                    self.label_information_next_hop_type.value_namespace = name_space
                                    self.label_information_next_hop_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-path-index"):
                                    self.label_information_path_index = value
                                    self.label_information_path_index.value_namespace = name_space
                                    self.label_information_path_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-route-version"):
                                    self.label_information_route_version = value
                                    self.label_information_route_version.value_namespace = name_space
                                    self.label_information_route_version.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-time-in-milli-seconds"):
                                    self.label_information_time_in_milli_seconds = value
                                    self.label_information_time_in_milli_seconds.value_namespace = name_space
                                    self.label_information_time_in_milli_seconds.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-type"):
                                    self.label_information_type = value
                                    self.label_information_type.value_namespace = name_space
                                    self.label_information_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-label"):
                                    self.local_label = value
                                    self.local_label.value_namespace = name_space
                                    self.local_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "mpls-adjacency-flags"):
                                    self.mpls_adjacency_flags = value
                                    self.mpls_adjacency_flags.value_namespace = name_space
                                    self.mpls_adjacency_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-interface"):
                                    self.outgoing_interface = value
                                    self.outgoing_interface.value_namespace = name_space
                                    self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-interface-string"):
                                    self.outgoing_interface_string = value
                                    self.outgoing_interface_string.value_namespace = name_space
                                    self.outgoing_interface_string.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-label"):
                                    self.outgoing_label = value
                                    self.outgoing_label.value_namespace = name_space
                                    self.outgoing_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-label-string"):
                                    self.outgoing_label_string = value
                                    self.outgoing_label_string.value_namespace = name_space
                                    self.outgoing_label_string.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-physical-interface"):
                                    self.outgoing_physical_interface = value
                                    self.outgoing_physical_interface.value_namespace = name_space
                                    self.outgoing_physical_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-or-id"):
                                    self.prefix_or_id = value
                                    self.prefix_or_id.value_namespace = name_space
                                    self.prefix_or_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-id-present"):
                                    self.tunnel_id_present = value
                                    self.tunnel_id_present.value_namespace = name_space
                                    self.tunnel_id_present.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-interface"):
                                    self.tunnel_interface = value
                                    self.tunnel_interface.value_namespace = name_space
                                    self.tunnel_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "tx-bytes"):
                                    self.tx_bytes = value
                                    self.tx_bytes.value_namespace = name_space
                                    self.tx_bytes.value_namespace_prefix = name_space_prefix
                                if(value_path == "tx-packets"):
                                    self.tx_packets = value
                                    self.tx_packets.value_namespace = name_space
                                    self.tx_packets.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.label_information:
                                if (c.has_data()):
                                    return True
                            return (
                                self.afi_table_id.is_set or
                                self.eos.is_set or
                                self.eos_bit.is_set or
                                self.hardware_information.is_set or
                                self.label_value.is_set or
                                self.ldi_flags.is_set or
                                self.ldi_pointer.is_set or
                                self.ldi_referance_count.is_set or
                                self.ldi_type.is_set or
                                self.leaf_flags.is_set or
                                self.leaf_local_label.is_set or
                                self.leaf_referance_count.is_set or
                                self.leaf_time_in_milli_seconds.is_set or
                                self.lspa_flags.is_set or
                                self.lw_ldi_pointer.is_set or
                                self.lw_ldi_refernace_count.is_set or
                                self.lw_ldi_type.is_set or
                                self.lw_shared_ldi_pointer.is_set or
                                self.multicast_label.is_set or
                                self.path_list_flags.is_set or
                                self.path_list_referance_count.is_set or
                                (self.ldi_information is not None and self.ldi_information.has_data()) or
                                (self.multicast_information is not None and self.multicast_information.has_data()))

                        def has_operation(self):
                            for c in self.label_information:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi_table_id.yfilter != YFilter.not_set or
                                self.eos.yfilter != YFilter.not_set or
                                self.eos_bit.yfilter != YFilter.not_set or
                                self.hardware_information.yfilter != YFilter.not_set or
                                self.label_value.yfilter != YFilter.not_set or
                                self.ldi_flags.yfilter != YFilter.not_set or
                                self.ldi_pointer.yfilter != YFilter.not_set or
                                self.ldi_referance_count.yfilter != YFilter.not_set or
                                self.ldi_type.yfilter != YFilter.not_set or
                                self.leaf_flags.yfilter != YFilter.not_set or
                                self.leaf_local_label.yfilter != YFilter.not_set or
                                self.leaf_referance_count.yfilter != YFilter.not_set or
                                self.leaf_time_in_milli_seconds.yfilter != YFilter.not_set or
                                self.lspa_flags.yfilter != YFilter.not_set or
                                self.lw_ldi_pointer.yfilter != YFilter.not_set or
                                self.lw_ldi_refernace_count.yfilter != YFilter.not_set or
                                self.lw_ldi_type.yfilter != YFilter.not_set or
                                self.lw_shared_ldi_pointer.yfilter != YFilter.not_set or
                                self.multicast_label.yfilter != YFilter.not_set or
                                self.path_list_flags.yfilter != YFilter.not_set or
                                self.path_list_referance_count.yfilter != YFilter.not_set or
                                (self.ldi_information is not None and self.ldi_information.has_operation()) or
                                (self.multicast_information is not None and self.multicast_information.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "forwarding-detail" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi_table_id.is_set or self.afi_table_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi_table_id.get_name_leafdata())
                            if (self.eos.is_set or self.eos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.eos.get_name_leafdata())
                            if (self.eos_bit.is_set or self.eos_bit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.eos_bit.get_name_leafdata())
                            if (self.hardware_information.is_set or self.hardware_information.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hardware_information.get_name_leafdata())
                            if (self.label_value.is_set or self.label_value.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.label_value.get_name_leafdata())
                            if (self.ldi_flags.is_set or self.ldi_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldi_flags.get_name_leafdata())
                            if (self.ldi_pointer.is_set or self.ldi_pointer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldi_pointer.get_name_leafdata())
                            if (self.ldi_referance_count.is_set or self.ldi_referance_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldi_referance_count.get_name_leafdata())
                            if (self.ldi_type.is_set or self.ldi_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldi_type.get_name_leafdata())
                            if (self.leaf_flags.is_set or self.leaf_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.leaf_flags.get_name_leafdata())
                            if (self.leaf_local_label.is_set or self.leaf_local_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.leaf_local_label.get_name_leafdata())
                            if (self.leaf_referance_count.is_set or self.leaf_referance_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.leaf_referance_count.get_name_leafdata())
                            if (self.leaf_time_in_milli_seconds.is_set or self.leaf_time_in_milli_seconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.leaf_time_in_milli_seconds.get_name_leafdata())
                            if (self.lspa_flags.is_set or self.lspa_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lspa_flags.get_name_leafdata())
                            if (self.lw_ldi_pointer.is_set or self.lw_ldi_pointer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lw_ldi_pointer.get_name_leafdata())
                            if (self.lw_ldi_refernace_count.is_set or self.lw_ldi_refernace_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lw_ldi_refernace_count.get_name_leafdata())
                            if (self.lw_ldi_type.is_set or self.lw_ldi_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lw_ldi_type.get_name_leafdata())
                            if (self.lw_shared_ldi_pointer.is_set or self.lw_shared_ldi_pointer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lw_shared_ldi_pointer.get_name_leafdata())
                            if (self.multicast_label.is_set or self.multicast_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.multicast_label.get_name_leafdata())
                            if (self.path_list_flags.is_set or self.path_list_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_list_flags.get_name_leafdata())
                            if (self.path_list_referance_count.is_set or self.path_list_referance_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_list_referance_count.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "label-information"):
                                for c in self.label_information:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LabelInformation()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.label_information.append(c)
                                return c

                            if (child_yang_name == "ldi-information"):
                                if (self.ldi_information is None):
                                    self.ldi_information = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.LdiInformation()
                                    self.ldi_information.parent = self
                                    self._children_name_map["ldi_information"] = "ldi-information"
                                return self.ldi_information

                            if (child_yang_name == "multicast-information"):
                                if (self.multicast_information is None):
                                    self.multicast_information = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail.MulticastInformation()
                                    self.multicast_information.parent = self
                                    self._children_name_map["multicast_information"] = "multicast-information"
                                return self.multicast_information

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "label-information" or name == "ldi-information" or name == "multicast-information" or name == "afi-table-id" or name == "eos" or name == "eos-bit" or name == "hardware-information" or name == "label-value" or name == "ldi-flags" or name == "ldi-pointer" or name == "ldi-referance-count" or name == "ldi-type" or name == "leaf-flags" or name == "leaf-local-label" or name == "leaf-referance-count" or name == "leaf-time-in-milli-seconds" or name == "lspa-flags" or name == "lw-ldi-pointer" or name == "lw-ldi-refernace-count" or name == "lw-ldi-type" or name == "lw-shared-ldi-pointer" or name == "multicast-label" or name == "path-list-flags" or name == "path-list-referance-count"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi-table-id"):
                                self.afi_table_id = value
                                self.afi_table_id.value_namespace = name_space
                                self.afi_table_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "eos"):
                                self.eos = value
                                self.eos.value_namespace = name_space
                                self.eos.value_namespace_prefix = name_space_prefix
                            if(value_path == "eos-bit"):
                                self.eos_bit = value
                                self.eos_bit.value_namespace = name_space
                                self.eos_bit.value_namespace_prefix = name_space_prefix
                            if(value_path == "hardware-information"):
                                self.hardware_information = value
                                self.hardware_information.value_namespace = name_space
                                self.hardware_information.value_namespace_prefix = name_space_prefix
                            if(value_path == "label-value"):
                                self.label_value = value
                                self.label_value.value_namespace = name_space
                                self.label_value.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldi-flags"):
                                self.ldi_flags = value
                                self.ldi_flags.value_namespace = name_space
                                self.ldi_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldi-pointer"):
                                self.ldi_pointer = value
                                self.ldi_pointer.value_namespace = name_space
                                self.ldi_pointer.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldi-referance-count"):
                                self.ldi_referance_count = value
                                self.ldi_referance_count.value_namespace = name_space
                                self.ldi_referance_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldi-type"):
                                self.ldi_type = value
                                self.ldi_type.value_namespace = name_space
                                self.ldi_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "leaf-flags"):
                                self.leaf_flags = value
                                self.leaf_flags.value_namespace = name_space
                                self.leaf_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "leaf-local-label"):
                                self.leaf_local_label = value
                                self.leaf_local_label.value_namespace = name_space
                                self.leaf_local_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "leaf-referance-count"):
                                self.leaf_referance_count = value
                                self.leaf_referance_count.value_namespace = name_space
                                self.leaf_referance_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "leaf-time-in-milli-seconds"):
                                self.leaf_time_in_milli_seconds = value
                                self.leaf_time_in_milli_seconds.value_namespace = name_space
                                self.leaf_time_in_milli_seconds.value_namespace_prefix = name_space_prefix
                            if(value_path == "lspa-flags"):
                                self.lspa_flags = value
                                self.lspa_flags.value_namespace = name_space
                                self.lspa_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "lw-ldi-pointer"):
                                self.lw_ldi_pointer = value
                                self.lw_ldi_pointer.value_namespace = name_space
                                self.lw_ldi_pointer.value_namespace_prefix = name_space_prefix
                            if(value_path == "lw-ldi-refernace-count"):
                                self.lw_ldi_refernace_count = value
                                self.lw_ldi_refernace_count.value_namespace = name_space
                                self.lw_ldi_refernace_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "lw-ldi-type"):
                                self.lw_ldi_type = value
                                self.lw_ldi_type.value_namespace = name_space
                                self.lw_ldi_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "lw-shared-ldi-pointer"):
                                self.lw_shared_ldi_pointer = value
                                self.lw_shared_ldi_pointer.value_namespace = name_space
                                self.lw_shared_ldi_pointer.value_namespace_prefix = name_space_prefix
                            if(value_path == "multicast-label"):
                                self.multicast_label = value
                                self.multicast_label.value_namespace = name_space
                                self.multicast_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-list-flags"):
                                self.path_list_flags = value
                                self.path_list_flags.value_namespace = name_space
                                self.path_list_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-list-referance-count"):
                                self.path_list_referance_count = value
                                self.path_list_referance_count.value_namespace = name_space
                                self.path_list_referance_count.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.forwarding_detail:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.forwarding_detail:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "forwarding-details" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "forwarding-detail"):
                            for c in self.forwarding_detail:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails.ForwardingDetail()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.forwarding_detail.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "forwarding-detail"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Informations(Entity):
                    """
                    Forwarding filtering details
                    
                    .. attribute:: information
                    
                    	MPLS forwarding information
                    	**type**\: list of    :py:class:`Information <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.Informations.Information>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.LabelFib.Informations, self).__init__()

                        self.yang_name = "informations"
                        self.yang_parent_name = "label-fib"

                        self.information = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.LabelFib.Informations, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.LabelFib.Informations, self).__setattr__(name, value)


                    class Information(Entity):
                        """
                        MPLS forwarding information
                        
                        .. attribute:: afi_table_id
                        
                        	The AFI table ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: eos
                        
                        	End of stack flag
                        	**type**\:   :py:class:`Mplseos <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Mplseos>`
                        
                        .. attribute:: eos_bit
                        
                        	EOS bit
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: hardware_information
                        
                        	Hardware info
                        	**type**\:  str
                        
                        	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                        
                        .. attribute:: label_information
                        
                        	Label\-infos in FIB leaf
                        	**type**\: list of    :py:class:`LabelInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation>`
                        
                        .. attribute:: label_value
                        
                        	Local label value
                        	**type**\:  int
                        
                        	**range:** 16..1048575
                        
                        .. attribute:: ldi_flags
                        
                        	The LDI flags
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ldi_information
                        
                        	LDI\-info in FIB leaf
                        	**type**\:   :py:class:`LdiInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LdiInformation>`
                        
                        .. attribute:: ldi_pointer
                        
                        	The pointer to the LDI
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ldi_referance_count
                        
                        	Number of references to the LDI
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ldi_type
                        
                        	The LDI type
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: leaf_flags
                        
                        	The leaf flags
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: leaf_local_label
                        
                        	Local label
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: leaf_referance_count
                        
                        	Number of references to the leaf
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: leaf_time_in_milli_seconds
                        
                        	The time of last update in msec
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: lspa_flags
                        
                        	The LSPA flags
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lw_ldi_pointer
                        
                        	The pointer to the LW\-LDI
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lw_ldi_refernace_count
                        
                        	The LW\-LDI refcounter
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lw_ldi_type
                        
                        	The LW\-LDI type
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lw_shared_ldi_pointer
                        
                        	The pointer to the shared LDI in LW\-LDI
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: multicast_information
                        
                        	The multicast info
                        	**type**\:   :py:class:`MulticastInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.Informations.Information.MulticastInformation>`
                        
                        .. attribute:: multicast_label
                        
                        	The unicast or multicast label
                        	**type**\:  bool
                        
                        .. attribute:: path_list_flags
                        
                        	The pathlist flags
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: path_list_referance_count
                        
                        	Number of references to the pathlist
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information, self).__init__()

                            self.yang_name = "information"
                            self.yang_parent_name = "informations"

                            self.afi_table_id = YLeaf(YType.uint32, "afi-table-id")

                            self.eos = YLeaf(YType.enumeration, "eos")

                            self.eos_bit = YLeaf(YType.uint32, "eos-bit")

                            self.hardware_information = YLeaf(YType.str, "hardware-information")

                            self.label_value = YLeaf(YType.uint32, "label-value")

                            self.ldi_flags = YLeaf(YType.uint32, "ldi-flags")

                            self.ldi_pointer = YLeaf(YType.uint32, "ldi-pointer")

                            self.ldi_referance_count = YLeaf(YType.uint32, "ldi-referance-count")

                            self.ldi_type = YLeaf(YType.uint32, "ldi-type")

                            self.leaf_flags = YLeaf(YType.uint32, "leaf-flags")

                            self.leaf_local_label = YLeaf(YType.uint32, "leaf-local-label")

                            self.leaf_referance_count = YLeaf(YType.uint32, "leaf-referance-count")

                            self.leaf_time_in_milli_seconds = YLeaf(YType.uint64, "leaf-time-in-milli-seconds")

                            self.lspa_flags = YLeaf(YType.uint32, "lspa-flags")

                            self.lw_ldi_pointer = YLeaf(YType.uint32, "lw-ldi-pointer")

                            self.lw_ldi_refernace_count = YLeaf(YType.uint32, "lw-ldi-refernace-count")

                            self.lw_ldi_type = YLeaf(YType.uint32, "lw-ldi-type")

                            self.lw_shared_ldi_pointer = YLeaf(YType.uint32, "lw-shared-ldi-pointer")

                            self.multicast_label = YLeaf(YType.boolean, "multicast-label")

                            self.path_list_flags = YLeaf(YType.uint32, "path-list-flags")

                            self.path_list_referance_count = YLeaf(YType.uint32, "path-list-referance-count")

                            self.ldi_information = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LdiInformation()
                            self.ldi_information.parent = self
                            self._children_name_map["ldi_information"] = "ldi-information"
                            self._children_yang_names.add("ldi-information")

                            self.multicast_information = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.MulticastInformation()
                            self.multicast_information.parent = self
                            self._children_name_map["multicast_information"] = "multicast-information"
                            self._children_yang_names.add("multicast-information")

                            self.label_information = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("afi_table_id",
                                            "eos",
                                            "eos_bit",
                                            "hardware_information",
                                            "label_value",
                                            "ldi_flags",
                                            "ldi_pointer",
                                            "ldi_referance_count",
                                            "ldi_type",
                                            "leaf_flags",
                                            "leaf_local_label",
                                            "leaf_referance_count",
                                            "leaf_time_in_milli_seconds",
                                            "lspa_flags",
                                            "lw_ldi_pointer",
                                            "lw_ldi_refernace_count",
                                            "lw_ldi_type",
                                            "lw_shared_ldi_pointer",
                                            "multicast_label",
                                            "path_list_flags",
                                            "path_list_referance_count") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information, self).__setattr__(name, value)


                        class LdiInformation(Entity):
                            """
                            LDI\-info in FIB leaf
                            
                            .. attribute:: ldi_hardware_information
                            
                            	Hardware info
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LdiInformation, self).__init__()

                                self.yang_name = "ldi-information"
                                self.yang_parent_name = "information"

                                self.ldi_hardware_information = YLeaf(YType.str, "ldi-hardware-information")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ldi_hardware_information") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LdiInformation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LdiInformation, self).__setattr__(name, value)

                            def has_data(self):
                                return self.ldi_hardware_information.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ldi_hardware_information.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ldi-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ldi_hardware_information.is_set or self.ldi_hardware_information.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldi_hardware_information.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "ldi-hardware-information"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ldi-hardware-information"):
                                    self.ldi_hardware_information = value
                                    self.ldi_hardware_information.value_namespace = name_space
                                    self.ldi_hardware_information.value_namespace_prefix = name_space_prefix


                        class MulticastInformation(Entity):
                            """
                            The multicast info
                            
                            .. attribute:: multicast_encap_id
                            
                            	The multicast ENCAP\-ID 
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_mol_base_flags
                            
                            	MOL base flags
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_mol_flags
                            
                            	MOL flags
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_mol_referance_count
                            
                            	MOL refcount
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_mpls_local_output_paths
                            
                            	num multicast mpls local output paths
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_mpls_output_paths
                            
                            	num multicast mpls output paths 
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_mpls_protocol_output_paths
                            
                            	num multicast mpls prot output paths 
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: multicast_platform_data
                            
                            	The multicast platform data
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: multicast_platform_data_length
                            
                            	The multicast platform data len
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: multicast_rpf_id
                            
                            	The multicast RPF\-ID 
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_tunnel_id
                            
                            	multicast mpls P2MP\-TE tunnel id or MLDP Tunnel LSMID on all nodes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_tunnel_interface_handler
                            
                            	multicast mpls tunnel
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: multicast_tunnel_lspvif
                            
                            	multicast LSPVIF for MLDP Tunnels
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_tunnel_next_hop_information
                            
                            	multicast nhinfo for p2mp TE Head
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.MulticastInformation, self).__init__()

                                self.yang_name = "multicast-information"
                                self.yang_parent_name = "information"

                                self.multicast_encap_id = YLeaf(YType.uint32, "multicast-encap-id")

                                self.multicast_mol_base_flags = YLeaf(YType.uint32, "multicast-mol-base-flags")

                                self.multicast_mol_flags = YLeaf(YType.uint16, "multicast-mol-flags")

                                self.multicast_mol_referance_count = YLeaf(YType.uint16, "multicast-mol-referance-count")

                                self.multicast_mpls_local_output_paths = YLeaf(YType.uint16, "multicast-mpls-local-output-paths")

                                self.multicast_mpls_output_paths = YLeaf(YType.uint16, "multicast-mpls-output-paths")

                                self.multicast_mpls_protocol_output_paths = YLeaf(YType.uint16, "multicast-mpls-protocol-output-paths")

                                self.multicast_platform_data = YLeaf(YType.str, "multicast-platform-data")

                                self.multicast_platform_data_length = YLeaf(YType.uint8, "multicast-platform-data-length")

                                self.multicast_rpf_id = YLeaf(YType.uint32, "multicast-rpf-id")

                                self.multicast_tunnel_id = YLeaf(YType.uint32, "multicast-tunnel-id")

                                self.multicast_tunnel_interface_handler = YLeaf(YType.str, "multicast-tunnel-interface-handler")

                                self.multicast_tunnel_lspvif = YLeaf(YType.uint32, "multicast-tunnel-lspvif")

                                self.multicast_tunnel_next_hop_information = YLeaf(YType.uint32, "multicast-tunnel-next-hop-information")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("multicast_encap_id",
                                                "multicast_mol_base_flags",
                                                "multicast_mol_flags",
                                                "multicast_mol_referance_count",
                                                "multicast_mpls_local_output_paths",
                                                "multicast_mpls_output_paths",
                                                "multicast_mpls_protocol_output_paths",
                                                "multicast_platform_data",
                                                "multicast_platform_data_length",
                                                "multicast_rpf_id",
                                                "multicast_tunnel_id",
                                                "multicast_tunnel_interface_handler",
                                                "multicast_tunnel_lspvif",
                                                "multicast_tunnel_next_hop_information") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.MulticastInformation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.MulticastInformation, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.multicast_encap_id.is_set or
                                    self.multicast_mol_base_flags.is_set or
                                    self.multicast_mol_flags.is_set or
                                    self.multicast_mol_referance_count.is_set or
                                    self.multicast_mpls_local_output_paths.is_set or
                                    self.multicast_mpls_output_paths.is_set or
                                    self.multicast_mpls_protocol_output_paths.is_set or
                                    self.multicast_platform_data.is_set or
                                    self.multicast_platform_data_length.is_set or
                                    self.multicast_rpf_id.is_set or
                                    self.multicast_tunnel_id.is_set or
                                    self.multicast_tunnel_interface_handler.is_set or
                                    self.multicast_tunnel_lspvif.is_set or
                                    self.multicast_tunnel_next_hop_information.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.multicast_encap_id.yfilter != YFilter.not_set or
                                    self.multicast_mol_base_flags.yfilter != YFilter.not_set or
                                    self.multicast_mol_flags.yfilter != YFilter.not_set or
                                    self.multicast_mol_referance_count.yfilter != YFilter.not_set or
                                    self.multicast_mpls_local_output_paths.yfilter != YFilter.not_set or
                                    self.multicast_mpls_output_paths.yfilter != YFilter.not_set or
                                    self.multicast_mpls_protocol_output_paths.yfilter != YFilter.not_set or
                                    self.multicast_platform_data.yfilter != YFilter.not_set or
                                    self.multicast_platform_data_length.yfilter != YFilter.not_set or
                                    self.multicast_rpf_id.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_id.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_interface_handler.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_lspvif.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_next_hop_information.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "multicast-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.multicast_encap_id.is_set or self.multicast_encap_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_encap_id.get_name_leafdata())
                                if (self.multicast_mol_base_flags.is_set or self.multicast_mol_base_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mol_base_flags.get_name_leafdata())
                                if (self.multicast_mol_flags.is_set or self.multicast_mol_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mol_flags.get_name_leafdata())
                                if (self.multicast_mol_referance_count.is_set or self.multicast_mol_referance_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mol_referance_count.get_name_leafdata())
                                if (self.multicast_mpls_local_output_paths.is_set or self.multicast_mpls_local_output_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mpls_local_output_paths.get_name_leafdata())
                                if (self.multicast_mpls_output_paths.is_set or self.multicast_mpls_output_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mpls_output_paths.get_name_leafdata())
                                if (self.multicast_mpls_protocol_output_paths.is_set or self.multicast_mpls_protocol_output_paths.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_mpls_protocol_output_paths.get_name_leafdata())
                                if (self.multicast_platform_data.is_set or self.multicast_platform_data.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_platform_data.get_name_leafdata())
                                if (self.multicast_platform_data_length.is_set or self.multicast_platform_data_length.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_platform_data_length.get_name_leafdata())
                                if (self.multicast_rpf_id.is_set or self.multicast_rpf_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_rpf_id.get_name_leafdata())
                                if (self.multicast_tunnel_id.is_set or self.multicast_tunnel_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_id.get_name_leafdata())
                                if (self.multicast_tunnel_interface_handler.is_set or self.multicast_tunnel_interface_handler.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_interface_handler.get_name_leafdata())
                                if (self.multicast_tunnel_lspvif.is_set or self.multicast_tunnel_lspvif.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_lspvif.get_name_leafdata())
                                if (self.multicast_tunnel_next_hop_information.is_set or self.multicast_tunnel_next_hop_information.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_next_hop_information.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "multicast-encap-id" or name == "multicast-mol-base-flags" or name == "multicast-mol-flags" or name == "multicast-mol-referance-count" or name == "multicast-mpls-local-output-paths" or name == "multicast-mpls-output-paths" or name == "multicast-mpls-protocol-output-paths" or name == "multicast-platform-data" or name == "multicast-platform-data-length" or name == "multicast-rpf-id" or name == "multicast-tunnel-id" or name == "multicast-tunnel-interface-handler" or name == "multicast-tunnel-lspvif" or name == "multicast-tunnel-next-hop-information"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "multicast-encap-id"):
                                    self.multicast_encap_id = value
                                    self.multicast_encap_id.value_namespace = name_space
                                    self.multicast_encap_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mol-base-flags"):
                                    self.multicast_mol_base_flags = value
                                    self.multicast_mol_base_flags.value_namespace = name_space
                                    self.multicast_mol_base_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mol-flags"):
                                    self.multicast_mol_flags = value
                                    self.multicast_mol_flags.value_namespace = name_space
                                    self.multicast_mol_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mol-referance-count"):
                                    self.multicast_mol_referance_count = value
                                    self.multicast_mol_referance_count.value_namespace = name_space
                                    self.multicast_mol_referance_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mpls-local-output-paths"):
                                    self.multicast_mpls_local_output_paths = value
                                    self.multicast_mpls_local_output_paths.value_namespace = name_space
                                    self.multicast_mpls_local_output_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mpls-output-paths"):
                                    self.multicast_mpls_output_paths = value
                                    self.multicast_mpls_output_paths.value_namespace = name_space
                                    self.multicast_mpls_output_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-mpls-protocol-output-paths"):
                                    self.multicast_mpls_protocol_output_paths = value
                                    self.multicast_mpls_protocol_output_paths.value_namespace = name_space
                                    self.multicast_mpls_protocol_output_paths.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-platform-data"):
                                    self.multicast_platform_data = value
                                    self.multicast_platform_data.value_namespace = name_space
                                    self.multicast_platform_data.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-platform-data-length"):
                                    self.multicast_platform_data_length = value
                                    self.multicast_platform_data_length.value_namespace = name_space
                                    self.multicast_platform_data_length.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-rpf-id"):
                                    self.multicast_rpf_id = value
                                    self.multicast_rpf_id.value_namespace = name_space
                                    self.multicast_rpf_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-id"):
                                    self.multicast_tunnel_id = value
                                    self.multicast_tunnel_id.value_namespace = name_space
                                    self.multicast_tunnel_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-interface-handler"):
                                    self.multicast_tunnel_interface_handler = value
                                    self.multicast_tunnel_interface_handler.value_namespace = name_space
                                    self.multicast_tunnel_interface_handler.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-lspvif"):
                                    self.multicast_tunnel_lspvif = value
                                    self.multicast_tunnel_lspvif.value_namespace = name_space
                                    self.multicast_tunnel_lspvif.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-next-hop-information"):
                                    self.multicast_tunnel_next_hop_information = value
                                    self.multicast_tunnel_next_hop_information.value_namespace = name_space
                                    self.multicast_tunnel_next_hop_information.value_namespace_prefix = name_space_prefix


                        class LabelInformation(Entity):
                            """
                            Label\-infos in FIB leaf
                            
                            .. attribute:: exact_route_hash_info
                            
                            	Path's Hash info in case of exact\-route command
                            	**type**\:   :py:class:`ExactRouteHashInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.ExactRouteHashInfo>`
                            
                            .. attribute:: label_information_detail
                            
                            	Detail label info
                            	**type**\:   :py:class:`LabelInformationDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail>`
                            
                            .. attribute:: label_information_next_hop_protocol
                            
                            	The address family (v4/v6) 
                            	**type**\:   :py:class:`Proto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Proto>`
                            
                            .. attribute:: label_information_next_hop_string
                            
                            	Next hop address in string format
                            	**type**\:  str
                            
                            .. attribute:: label_information_next_hop_type
                            
                            	NHinfo Type
                            	**type**\:   :py:class:`NextHop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.NextHop>`
                            
                            .. attribute:: label_information_path_index
                            
                            	LabelInformationPathIndex
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: label_information_route_version
                            
                            	The version of the route
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: label_information_time_in_milli_seconds
                            
                            	The time of last update in msec
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: label_information_type
                            
                            	Label\-Info type
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_label
                            
                            	Local label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: mpls_adjacency_flags
                            
                            	MPLS Adjacency flags
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_interface
                            
                            	Outgoing interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: outgoing_interface_string
                            
                            	Output Interface in string format
                            	**type**\:  str
                            
                            .. attribute:: outgoing_label
                            
                            	Outgoing label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_label_string
                            
                            	Output Label in string format
                            	**type**\:  str
                            
                            .. attribute:: outgoing_physical_interface
                            
                            	Outgoing Physical Interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: prefix_or_id
                            
                            	Prefix Or ID
                            	**type**\:  str
                            
                            .. attribute:: tunnel_id_present
                            
                            	Tunnel id present?
                            	**type**\:  bool
                            
                            .. attribute:: tunnel_interface
                            
                            	Tunnel Interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: tx_bytes
                            
                            	Bytes transmitted per LSP
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            	**units**\: byte
                            
                            .. attribute:: tx_packets
                            
                            	Packets transmitted per LSP
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation, self).__init__()

                                self.yang_name = "label-information"
                                self.yang_parent_name = "information"

                                self.label_information_next_hop_protocol = YLeaf(YType.enumeration, "label-information-next-hop-protocol")

                                self.label_information_next_hop_string = YLeaf(YType.str, "label-information-next-hop-string")

                                self.label_information_next_hop_type = YLeaf(YType.enumeration, "label-information-next-hop-type")

                                self.label_information_path_index = YLeaf(YType.uint32, "label-information-path-index")

                                self.label_information_route_version = YLeaf(YType.uint64, "label-information-route-version")

                                self.label_information_time_in_milli_seconds = YLeaf(YType.uint64, "label-information-time-in-milli-seconds")

                                self.label_information_type = YLeaf(YType.uint32, "label-information-type")

                                self.local_label = YLeaf(YType.uint32, "local-label")

                                self.mpls_adjacency_flags = YLeaf(YType.uint32, "mpls-adjacency-flags")

                                self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                self.outgoing_interface_string = YLeaf(YType.str, "outgoing-interface-string")

                                self.outgoing_label = YLeaf(YType.uint32, "outgoing-label")

                                self.outgoing_label_string = YLeaf(YType.str, "outgoing-label-string")

                                self.outgoing_physical_interface = YLeaf(YType.str, "outgoing-physical-interface")

                                self.prefix_or_id = YLeaf(YType.str, "prefix-or-id")

                                self.tunnel_id_present = YLeaf(YType.boolean, "tunnel-id-present")

                                self.tunnel_interface = YLeaf(YType.str, "tunnel-interface")

                                self.tx_bytes = YLeaf(YType.uint64, "tx-bytes")

                                self.tx_packets = YLeaf(YType.uint64, "tx-packets")

                                self.exact_route_hash_info = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.ExactRouteHashInfo()
                                self.exact_route_hash_info.parent = self
                                self._children_name_map["exact_route_hash_info"] = "exact-route-hash-info"
                                self._children_yang_names.add("exact-route-hash-info")

                                self.label_information_detail = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail()
                                self.label_information_detail.parent = self
                                self._children_name_map["label_information_detail"] = "label-information-detail"
                                self._children_yang_names.add("label-information-detail")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("label_information_next_hop_protocol",
                                                "label_information_next_hop_string",
                                                "label_information_next_hop_type",
                                                "label_information_path_index",
                                                "label_information_route_version",
                                                "label_information_time_in_milli_seconds",
                                                "label_information_type",
                                                "local_label",
                                                "mpls_adjacency_flags",
                                                "outgoing_interface",
                                                "outgoing_interface_string",
                                                "outgoing_label",
                                                "outgoing_label_string",
                                                "outgoing_physical_interface",
                                                "prefix_or_id",
                                                "tunnel_id_present",
                                                "tunnel_interface",
                                                "tx_bytes",
                                                "tx_packets") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation, self).__setattr__(name, value)


                            class LabelInformationDetail(Entity):
                                """
                                Detail label info
                                
                                .. attribute:: l3_mtu
                                
                                	L3 MTU
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: label_stack
                                
                                	Label stack
                                	**type**\: list of    :py:class:`LabelStack <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail.LabelStack>`
                                
                                .. attribute:: mac_size
                                
                                	Length of L2 encapsulation
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: next_hop_interface
                                
                                	Next hop interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: next_hop_protocol
                                
                                	The address family (V4/V6) 
                                	**type**\:   :py:class:`Proto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Proto>`
                                
                                .. attribute:: next_hop_string
                                
                                	Next hop address in string format
                                	**type**\:  str
                                
                                .. attribute:: status
                                
                                	Status
                                	**type**\:  int
                                
                                	**range:** \-2147483648..2147483647
                                
                                .. attribute:: total_encapsulation_size
                                
                                	Total encapsulation size\: L2 + MPLS
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: transmit_number_of_bytes_switched
                                
                                	Number of Bytes switched
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                .. attribute:: transmit_number_of_packets_switched
                                
                                	Number of packets switched
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail, self).__init__()

                                    self.yang_name = "label-information-detail"
                                    self.yang_parent_name = "label-information"

                                    self.l3_mtu = YLeaf(YType.uint32, "l3-mtu")

                                    self.mac_size = YLeaf(YType.uint32, "mac-size")

                                    self.next_hop_interface = YLeaf(YType.str, "next-hop-interface")

                                    self.next_hop_protocol = YLeaf(YType.enumeration, "next-hop-protocol")

                                    self.next_hop_string = YLeaf(YType.str, "next-hop-string")

                                    self.status = YLeaf(YType.int32, "status")

                                    self.total_encapsulation_size = YLeaf(YType.uint32, "total-encapsulation-size")

                                    self.transmit_number_of_bytes_switched = YLeaf(YType.uint64, "transmit-number-of-bytes-switched")

                                    self.transmit_number_of_packets_switched = YLeaf(YType.uint64, "transmit-number-of-packets-switched")

                                    self.label_stack = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("l3_mtu",
                                                    "mac_size",
                                                    "next_hop_interface",
                                                    "next_hop_protocol",
                                                    "next_hop_string",
                                                    "status",
                                                    "total_encapsulation_size",
                                                    "transmit_number_of_bytes_switched",
                                                    "transmit_number_of_packets_switched") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail, self).__setattr__(name, value)


                                class LabelStack(Entity):
                                    """
                                    Label stack
                                    
                                    .. attribute:: entry
                                    
                                    	
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail.LabelStack, self).__init__()

                                        self.yang_name = "label-stack"
                                        self.yang_parent_name = "label-information-detail"

                                        self.entry = YLeaf(YType.uint32, "entry")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("entry") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail.LabelStack, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail.LabelStack, self).__setattr__(name, value)

                                    def has_data(self):
                                        return self.entry.is_set

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.entry.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "label-stack" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.entry.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "entry"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "entry"):
                                            self.entry = value
                                            self.entry.value_namespace = name_space
                                            self.entry.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.label_stack:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.l3_mtu.is_set or
                                        self.mac_size.is_set or
                                        self.next_hop_interface.is_set or
                                        self.next_hop_protocol.is_set or
                                        self.next_hop_string.is_set or
                                        self.status.is_set or
                                        self.total_encapsulation_size.is_set or
                                        self.transmit_number_of_bytes_switched.is_set or
                                        self.transmit_number_of_packets_switched.is_set)

                                def has_operation(self):
                                    for c in self.label_stack:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.l3_mtu.yfilter != YFilter.not_set or
                                        self.mac_size.yfilter != YFilter.not_set or
                                        self.next_hop_interface.yfilter != YFilter.not_set or
                                        self.next_hop_protocol.yfilter != YFilter.not_set or
                                        self.next_hop_string.yfilter != YFilter.not_set or
                                        self.status.yfilter != YFilter.not_set or
                                        self.total_encapsulation_size.yfilter != YFilter.not_set or
                                        self.transmit_number_of_bytes_switched.yfilter != YFilter.not_set or
                                        self.transmit_number_of_packets_switched.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "label-information-detail" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.l3_mtu.is_set or self.l3_mtu.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.l3_mtu.get_name_leafdata())
                                    if (self.mac_size.is_set or self.mac_size.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mac_size.get_name_leafdata())
                                    if (self.next_hop_interface.is_set or self.next_hop_interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop_interface.get_name_leafdata())
                                    if (self.next_hop_protocol.is_set or self.next_hop_protocol.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop_protocol.get_name_leafdata())
                                    if (self.next_hop_string.is_set or self.next_hop_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.next_hop_string.get_name_leafdata())
                                    if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.status.get_name_leafdata())
                                    if (self.total_encapsulation_size.is_set or self.total_encapsulation_size.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.total_encapsulation_size.get_name_leafdata())
                                    if (self.transmit_number_of_bytes_switched.is_set or self.transmit_number_of_bytes_switched.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_number_of_bytes_switched.get_name_leafdata())
                                    if (self.transmit_number_of_packets_switched.is_set or self.transmit_number_of_packets_switched.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.transmit_number_of_packets_switched.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "label-stack"):
                                        for c in self.label_stack:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail.LabelStack()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.label_stack.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "label-stack" or name == "l3-mtu" or name == "mac-size" or name == "next-hop-interface" or name == "next-hop-protocol" or name == "next-hop-string" or name == "status" or name == "total-encapsulation-size" or name == "transmit-number-of-bytes-switched" or name == "transmit-number-of-packets-switched"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "l3-mtu"):
                                        self.l3_mtu = value
                                        self.l3_mtu.value_namespace = name_space
                                        self.l3_mtu.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mac-size"):
                                        self.mac_size = value
                                        self.mac_size.value_namespace = name_space
                                        self.mac_size.value_namespace_prefix = name_space_prefix
                                    if(value_path == "next-hop-interface"):
                                        self.next_hop_interface = value
                                        self.next_hop_interface.value_namespace = name_space
                                        self.next_hop_interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "next-hop-protocol"):
                                        self.next_hop_protocol = value
                                        self.next_hop_protocol.value_namespace = name_space
                                        self.next_hop_protocol.value_namespace_prefix = name_space_prefix
                                    if(value_path == "next-hop-string"):
                                        self.next_hop_string = value
                                        self.next_hop_string.value_namespace = name_space
                                        self.next_hop_string.value_namespace_prefix = name_space_prefix
                                    if(value_path == "status"):
                                        self.status = value
                                        self.status.value_namespace = name_space
                                        self.status.value_namespace_prefix = name_space_prefix
                                    if(value_path == "total-encapsulation-size"):
                                        self.total_encapsulation_size = value
                                        self.total_encapsulation_size.value_namespace = name_space
                                        self.total_encapsulation_size.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-number-of-bytes-switched"):
                                        self.transmit_number_of_bytes_switched = value
                                        self.transmit_number_of_bytes_switched.value_namespace = name_space
                                        self.transmit_number_of_bytes_switched.value_namespace_prefix = name_space_prefix
                                    if(value_path == "transmit-number-of-packets-switched"):
                                        self.transmit_number_of_packets_switched = value
                                        self.transmit_number_of_packets_switched.value_namespace = name_space
                                        self.transmit_number_of_packets_switched.value_namespace_prefix = name_space_prefix


                            class ExactRouteHashInfo(Entity):
                                """
                                Path's Hash info in case of exact\-route command
                                
                                .. attribute:: hash_index
                                
                                	Hash Index value
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                .. attribute:: hash_index_is_valid
                                
                                	Is Hash Index valid?
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.ExactRouteHashInfo, self).__init__()

                                    self.yang_name = "exact-route-hash-info"
                                    self.yang_parent_name = "label-information"

                                    self.hash_index = YLeaf(YType.uint8, "hash-index")

                                    self.hash_index_is_valid = YLeaf(YType.boolean, "hash-index-is-valid")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("hash_index",
                                                    "hash_index_is_valid") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.ExactRouteHashInfo, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.ExactRouteHashInfo, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.hash_index.is_set or
                                        self.hash_index_is_valid.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.hash_index.yfilter != YFilter.not_set or
                                        self.hash_index_is_valid.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "exact-route-hash-info" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.hash_index.is_set or self.hash_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hash_index.get_name_leafdata())
                                    if (self.hash_index_is_valid.is_set or self.hash_index_is_valid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hash_index_is_valid.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "hash-index" or name == "hash-index-is-valid"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "hash-index"):
                                        self.hash_index = value
                                        self.hash_index.value_namespace = name_space
                                        self.hash_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hash-index-is-valid"):
                                        self.hash_index_is_valid = value
                                        self.hash_index_is_valid.value_namespace = name_space
                                        self.hash_index_is_valid.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.label_information_next_hop_protocol.is_set or
                                    self.label_information_next_hop_string.is_set or
                                    self.label_information_next_hop_type.is_set or
                                    self.label_information_path_index.is_set or
                                    self.label_information_route_version.is_set or
                                    self.label_information_time_in_milli_seconds.is_set or
                                    self.label_information_type.is_set or
                                    self.local_label.is_set or
                                    self.mpls_adjacency_flags.is_set or
                                    self.outgoing_interface.is_set or
                                    self.outgoing_interface_string.is_set or
                                    self.outgoing_label.is_set or
                                    self.outgoing_label_string.is_set or
                                    self.outgoing_physical_interface.is_set or
                                    self.prefix_or_id.is_set or
                                    self.tunnel_id_present.is_set or
                                    self.tunnel_interface.is_set or
                                    self.tx_bytes.is_set or
                                    self.tx_packets.is_set or
                                    (self.exact_route_hash_info is not None and self.exact_route_hash_info.has_data()) or
                                    (self.label_information_detail is not None and self.label_information_detail.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.label_information_next_hop_protocol.yfilter != YFilter.not_set or
                                    self.label_information_next_hop_string.yfilter != YFilter.not_set or
                                    self.label_information_next_hop_type.yfilter != YFilter.not_set or
                                    self.label_information_path_index.yfilter != YFilter.not_set or
                                    self.label_information_route_version.yfilter != YFilter.not_set or
                                    self.label_information_time_in_milli_seconds.yfilter != YFilter.not_set or
                                    self.label_information_type.yfilter != YFilter.not_set or
                                    self.local_label.yfilter != YFilter.not_set or
                                    self.mpls_adjacency_flags.yfilter != YFilter.not_set or
                                    self.outgoing_interface.yfilter != YFilter.not_set or
                                    self.outgoing_interface_string.yfilter != YFilter.not_set or
                                    self.outgoing_label.yfilter != YFilter.not_set or
                                    self.outgoing_label_string.yfilter != YFilter.not_set or
                                    self.outgoing_physical_interface.yfilter != YFilter.not_set or
                                    self.prefix_or_id.yfilter != YFilter.not_set or
                                    self.tunnel_id_present.yfilter != YFilter.not_set or
                                    self.tunnel_interface.yfilter != YFilter.not_set or
                                    self.tx_bytes.yfilter != YFilter.not_set or
                                    self.tx_packets.yfilter != YFilter.not_set or
                                    (self.exact_route_hash_info is not None and self.exact_route_hash_info.has_operation()) or
                                    (self.label_information_detail is not None and self.label_information_detail.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "label-information" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.label_information_next_hop_protocol.is_set or self.label_information_next_hop_protocol.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_next_hop_protocol.get_name_leafdata())
                                if (self.label_information_next_hop_string.is_set or self.label_information_next_hop_string.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_next_hop_string.get_name_leafdata())
                                if (self.label_information_next_hop_type.is_set or self.label_information_next_hop_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_next_hop_type.get_name_leafdata())
                                if (self.label_information_path_index.is_set or self.label_information_path_index.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_path_index.get_name_leafdata())
                                if (self.label_information_route_version.is_set or self.label_information_route_version.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_route_version.get_name_leafdata())
                                if (self.label_information_time_in_milli_seconds.is_set or self.label_information_time_in_milli_seconds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_time_in_milli_seconds.get_name_leafdata())
                                if (self.label_information_type.is_set or self.label_information_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.label_information_type.get_name_leafdata())
                                if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_label.get_name_leafdata())
                                if (self.mpls_adjacency_flags.is_set or self.mpls_adjacency_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mpls_adjacency_flags.get_name_leafdata())
                                if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                if (self.outgoing_interface_string.is_set or self.outgoing_interface_string.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_interface_string.get_name_leafdata())
                                if (self.outgoing_label.is_set or self.outgoing_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_label.get_name_leafdata())
                                if (self.outgoing_label_string.is_set or self.outgoing_label_string.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_label_string.get_name_leafdata())
                                if (self.outgoing_physical_interface.is_set or self.outgoing_physical_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_physical_interface.get_name_leafdata())
                                if (self.prefix_or_id.is_set or self.prefix_or_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.prefix_or_id.get_name_leafdata())
                                if (self.tunnel_id_present.is_set or self.tunnel_id_present.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_id_present.get_name_leafdata())
                                if (self.tunnel_interface.is_set or self.tunnel_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_interface.get_name_leafdata())
                                if (self.tx_bytes.is_set or self.tx_bytes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tx_bytes.get_name_leafdata())
                                if (self.tx_packets.is_set or self.tx_packets.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tx_packets.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "exact-route-hash-info"):
                                    if (self.exact_route_hash_info is None):
                                        self.exact_route_hash_info = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.ExactRouteHashInfo()
                                        self.exact_route_hash_info.parent = self
                                        self._children_name_map["exact_route_hash_info"] = "exact-route-hash-info"
                                    return self.exact_route_hash_info

                                if (child_yang_name == "label-information-detail"):
                                    if (self.label_information_detail is None):
                                        self.label_information_detail = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation.LabelInformationDetail()
                                        self.label_information_detail.parent = self
                                        self._children_name_map["label_information_detail"] = "label-information-detail"
                                    return self.label_information_detail

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "exact-route-hash-info" or name == "label-information-detail" or name == "label-information-next-hop-protocol" or name == "label-information-next-hop-string" or name == "label-information-next-hop-type" or name == "label-information-path-index" or name == "label-information-route-version" or name == "label-information-time-in-milli-seconds" or name == "label-information-type" or name == "local-label" or name == "mpls-adjacency-flags" or name == "outgoing-interface" or name == "outgoing-interface-string" or name == "outgoing-label" or name == "outgoing-label-string" or name == "outgoing-physical-interface" or name == "prefix-or-id" or name == "tunnel-id-present" or name == "tunnel-interface" or name == "tx-bytes" or name == "tx-packets"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "label-information-next-hop-protocol"):
                                    self.label_information_next_hop_protocol = value
                                    self.label_information_next_hop_protocol.value_namespace = name_space
                                    self.label_information_next_hop_protocol.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-next-hop-string"):
                                    self.label_information_next_hop_string = value
                                    self.label_information_next_hop_string.value_namespace = name_space
                                    self.label_information_next_hop_string.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-next-hop-type"):
                                    self.label_information_next_hop_type = value
                                    self.label_information_next_hop_type.value_namespace = name_space
                                    self.label_information_next_hop_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-path-index"):
                                    self.label_information_path_index = value
                                    self.label_information_path_index.value_namespace = name_space
                                    self.label_information_path_index.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-route-version"):
                                    self.label_information_route_version = value
                                    self.label_information_route_version.value_namespace = name_space
                                    self.label_information_route_version.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-time-in-milli-seconds"):
                                    self.label_information_time_in_milli_seconds = value
                                    self.label_information_time_in_milli_seconds.value_namespace = name_space
                                    self.label_information_time_in_milli_seconds.value_namespace_prefix = name_space_prefix
                                if(value_path == "label-information-type"):
                                    self.label_information_type = value
                                    self.label_information_type.value_namespace = name_space
                                    self.label_information_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-label"):
                                    self.local_label = value
                                    self.local_label.value_namespace = name_space
                                    self.local_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "mpls-adjacency-flags"):
                                    self.mpls_adjacency_flags = value
                                    self.mpls_adjacency_flags.value_namespace = name_space
                                    self.mpls_adjacency_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-interface"):
                                    self.outgoing_interface = value
                                    self.outgoing_interface.value_namespace = name_space
                                    self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-interface-string"):
                                    self.outgoing_interface_string = value
                                    self.outgoing_interface_string.value_namespace = name_space
                                    self.outgoing_interface_string.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-label"):
                                    self.outgoing_label = value
                                    self.outgoing_label.value_namespace = name_space
                                    self.outgoing_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-label-string"):
                                    self.outgoing_label_string = value
                                    self.outgoing_label_string.value_namespace = name_space
                                    self.outgoing_label_string.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-physical-interface"):
                                    self.outgoing_physical_interface = value
                                    self.outgoing_physical_interface.value_namespace = name_space
                                    self.outgoing_physical_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "prefix-or-id"):
                                    self.prefix_or_id = value
                                    self.prefix_or_id.value_namespace = name_space
                                    self.prefix_or_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-id-present"):
                                    self.tunnel_id_present = value
                                    self.tunnel_id_present.value_namespace = name_space
                                    self.tunnel_id_present.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-interface"):
                                    self.tunnel_interface = value
                                    self.tunnel_interface.value_namespace = name_space
                                    self.tunnel_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "tx-bytes"):
                                    self.tx_bytes = value
                                    self.tx_bytes.value_namespace = name_space
                                    self.tx_bytes.value_namespace_prefix = name_space_prefix
                                if(value_path == "tx-packets"):
                                    self.tx_packets = value
                                    self.tx_packets.value_namespace = name_space
                                    self.tx_packets.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.label_information:
                                if (c.has_data()):
                                    return True
                            return (
                                self.afi_table_id.is_set or
                                self.eos.is_set or
                                self.eos_bit.is_set or
                                self.hardware_information.is_set or
                                self.label_value.is_set or
                                self.ldi_flags.is_set or
                                self.ldi_pointer.is_set or
                                self.ldi_referance_count.is_set or
                                self.ldi_type.is_set or
                                self.leaf_flags.is_set or
                                self.leaf_local_label.is_set or
                                self.leaf_referance_count.is_set or
                                self.leaf_time_in_milli_seconds.is_set or
                                self.lspa_flags.is_set or
                                self.lw_ldi_pointer.is_set or
                                self.lw_ldi_refernace_count.is_set or
                                self.lw_ldi_type.is_set or
                                self.lw_shared_ldi_pointer.is_set or
                                self.multicast_label.is_set or
                                self.path_list_flags.is_set or
                                self.path_list_referance_count.is_set or
                                (self.ldi_information is not None and self.ldi_information.has_data()) or
                                (self.multicast_information is not None and self.multicast_information.has_data()))

                        def has_operation(self):
                            for c in self.label_information:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.afi_table_id.yfilter != YFilter.not_set or
                                self.eos.yfilter != YFilter.not_set or
                                self.eos_bit.yfilter != YFilter.not_set or
                                self.hardware_information.yfilter != YFilter.not_set or
                                self.label_value.yfilter != YFilter.not_set or
                                self.ldi_flags.yfilter != YFilter.not_set or
                                self.ldi_pointer.yfilter != YFilter.not_set or
                                self.ldi_referance_count.yfilter != YFilter.not_set or
                                self.ldi_type.yfilter != YFilter.not_set or
                                self.leaf_flags.yfilter != YFilter.not_set or
                                self.leaf_local_label.yfilter != YFilter.not_set or
                                self.leaf_referance_count.yfilter != YFilter.not_set or
                                self.leaf_time_in_milli_seconds.yfilter != YFilter.not_set or
                                self.lspa_flags.yfilter != YFilter.not_set or
                                self.lw_ldi_pointer.yfilter != YFilter.not_set or
                                self.lw_ldi_refernace_count.yfilter != YFilter.not_set or
                                self.lw_ldi_type.yfilter != YFilter.not_set or
                                self.lw_shared_ldi_pointer.yfilter != YFilter.not_set or
                                self.multicast_label.yfilter != YFilter.not_set or
                                self.path_list_flags.yfilter != YFilter.not_set or
                                self.path_list_referance_count.yfilter != YFilter.not_set or
                                (self.ldi_information is not None and self.ldi_information.has_operation()) or
                                (self.multicast_information is not None and self.multicast_information.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "information" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.afi_table_id.is_set or self.afi_table_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.afi_table_id.get_name_leafdata())
                            if (self.eos.is_set or self.eos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.eos.get_name_leafdata())
                            if (self.eos_bit.is_set or self.eos_bit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.eos_bit.get_name_leafdata())
                            if (self.hardware_information.is_set or self.hardware_information.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hardware_information.get_name_leafdata())
                            if (self.label_value.is_set or self.label_value.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.label_value.get_name_leafdata())
                            if (self.ldi_flags.is_set or self.ldi_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldi_flags.get_name_leafdata())
                            if (self.ldi_pointer.is_set or self.ldi_pointer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldi_pointer.get_name_leafdata())
                            if (self.ldi_referance_count.is_set or self.ldi_referance_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldi_referance_count.get_name_leafdata())
                            if (self.ldi_type.is_set or self.ldi_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ldi_type.get_name_leafdata())
                            if (self.leaf_flags.is_set or self.leaf_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.leaf_flags.get_name_leafdata())
                            if (self.leaf_local_label.is_set or self.leaf_local_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.leaf_local_label.get_name_leafdata())
                            if (self.leaf_referance_count.is_set or self.leaf_referance_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.leaf_referance_count.get_name_leafdata())
                            if (self.leaf_time_in_milli_seconds.is_set or self.leaf_time_in_milli_seconds.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.leaf_time_in_milli_seconds.get_name_leafdata())
                            if (self.lspa_flags.is_set or self.lspa_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lspa_flags.get_name_leafdata())
                            if (self.lw_ldi_pointer.is_set or self.lw_ldi_pointer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lw_ldi_pointer.get_name_leafdata())
                            if (self.lw_ldi_refernace_count.is_set or self.lw_ldi_refernace_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lw_ldi_refernace_count.get_name_leafdata())
                            if (self.lw_ldi_type.is_set or self.lw_ldi_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lw_ldi_type.get_name_leafdata())
                            if (self.lw_shared_ldi_pointer.is_set or self.lw_shared_ldi_pointer.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lw_shared_ldi_pointer.get_name_leafdata())
                            if (self.multicast_label.is_set or self.multicast_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.multicast_label.get_name_leafdata())
                            if (self.path_list_flags.is_set or self.path_list_flags.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_list_flags.get_name_leafdata())
                            if (self.path_list_referance_count.is_set or self.path_list_referance_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_list_referance_count.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "label-information"):
                                for c in self.label_information:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LabelInformation()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.label_information.append(c)
                                return c

                            if (child_yang_name == "ldi-information"):
                                if (self.ldi_information is None):
                                    self.ldi_information = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.LdiInformation()
                                    self.ldi_information.parent = self
                                    self._children_name_map["ldi_information"] = "ldi-information"
                                return self.ldi_information

                            if (child_yang_name == "multicast-information"):
                                if (self.multicast_information is None):
                                    self.multicast_information = MplsForwarding.Nodes.Node.LabelFib.Informations.Information.MulticastInformation()
                                    self.multicast_information.parent = self
                                    self._children_name_map["multicast_information"] = "multicast-information"
                                return self.multicast_information

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "label-information" or name == "ldi-information" or name == "multicast-information" or name == "afi-table-id" or name == "eos" or name == "eos-bit" or name == "hardware-information" or name == "label-value" or name == "ldi-flags" or name == "ldi-pointer" or name == "ldi-referance-count" or name == "ldi-type" or name == "leaf-flags" or name == "leaf-local-label" or name == "leaf-referance-count" or name == "leaf-time-in-milli-seconds" or name == "lspa-flags" or name == "lw-ldi-pointer" or name == "lw-ldi-refernace-count" or name == "lw-ldi-type" or name == "lw-shared-ldi-pointer" or name == "multicast-label" or name == "path-list-flags" or name == "path-list-referance-count"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "afi-table-id"):
                                self.afi_table_id = value
                                self.afi_table_id.value_namespace = name_space
                                self.afi_table_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "eos"):
                                self.eos = value
                                self.eos.value_namespace = name_space
                                self.eos.value_namespace_prefix = name_space_prefix
                            if(value_path == "eos-bit"):
                                self.eos_bit = value
                                self.eos_bit.value_namespace = name_space
                                self.eos_bit.value_namespace_prefix = name_space_prefix
                            if(value_path == "hardware-information"):
                                self.hardware_information = value
                                self.hardware_information.value_namespace = name_space
                                self.hardware_information.value_namespace_prefix = name_space_prefix
                            if(value_path == "label-value"):
                                self.label_value = value
                                self.label_value.value_namespace = name_space
                                self.label_value.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldi-flags"):
                                self.ldi_flags = value
                                self.ldi_flags.value_namespace = name_space
                                self.ldi_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldi-pointer"):
                                self.ldi_pointer = value
                                self.ldi_pointer.value_namespace = name_space
                                self.ldi_pointer.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldi-referance-count"):
                                self.ldi_referance_count = value
                                self.ldi_referance_count.value_namespace = name_space
                                self.ldi_referance_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "ldi-type"):
                                self.ldi_type = value
                                self.ldi_type.value_namespace = name_space
                                self.ldi_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "leaf-flags"):
                                self.leaf_flags = value
                                self.leaf_flags.value_namespace = name_space
                                self.leaf_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "leaf-local-label"):
                                self.leaf_local_label = value
                                self.leaf_local_label.value_namespace = name_space
                                self.leaf_local_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "leaf-referance-count"):
                                self.leaf_referance_count = value
                                self.leaf_referance_count.value_namespace = name_space
                                self.leaf_referance_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "leaf-time-in-milli-seconds"):
                                self.leaf_time_in_milli_seconds = value
                                self.leaf_time_in_milli_seconds.value_namespace = name_space
                                self.leaf_time_in_milli_seconds.value_namespace_prefix = name_space_prefix
                            if(value_path == "lspa-flags"):
                                self.lspa_flags = value
                                self.lspa_flags.value_namespace = name_space
                                self.lspa_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "lw-ldi-pointer"):
                                self.lw_ldi_pointer = value
                                self.lw_ldi_pointer.value_namespace = name_space
                                self.lw_ldi_pointer.value_namespace_prefix = name_space_prefix
                            if(value_path == "lw-ldi-refernace-count"):
                                self.lw_ldi_refernace_count = value
                                self.lw_ldi_refernace_count.value_namespace = name_space
                                self.lw_ldi_refernace_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "lw-ldi-type"):
                                self.lw_ldi_type = value
                                self.lw_ldi_type.value_namespace = name_space
                                self.lw_ldi_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "lw-shared-ldi-pointer"):
                                self.lw_shared_ldi_pointer = value
                                self.lw_shared_ldi_pointer.value_namespace = name_space
                                self.lw_shared_ldi_pointer.value_namespace_prefix = name_space_prefix
                            if(value_path == "multicast-label"):
                                self.multicast_label = value
                                self.multicast_label.value_namespace = name_space
                                self.multicast_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-list-flags"):
                                self.path_list_flags = value
                                self.path_list_flags.value_namespace = name_space
                                self.path_list_flags.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-list-referance-count"):
                                self.path_list_referance_count = value
                                self.path_list_referance_count.value_namespace = name_space
                                self.path_list_referance_count.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.information:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.information:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "informations" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "information"):
                            for c in self.information:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsForwarding.Nodes.Node.LabelFib.Informations.Information()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.information.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "information"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class LabelSecurity(Entity):
                    """
                    MPLS label security
                    
                    .. attribute:: interfaces
                    
                    	MPLS label security interface table
                    	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces>`
                    
                    .. attribute:: summary
                    
                    	MPLS label security summary
                    	**type**\:   :py:class:`Summary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Summary>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity, self).__init__()

                        self.yang_name = "label-security"
                        self.yang_parent_name = "label-fib"

                        self.interfaces = MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces()
                        self.interfaces.parent = self
                        self._children_name_map["interfaces"] = "interfaces"
                        self._children_yang_names.add("interfaces")

                        self.summary = MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Summary()
                        self.summary.parent = self
                        self._children_name_map["summary"] = "summary"
                        self._children_yang_names.add("summary")


                    class Interfaces(Entity):
                        """
                        MPLS label security interface table
                        
                        .. attribute:: interface
                        
                        	Specify interface Name
                        	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces.Interface>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces, self).__init__()

                            self.yang_name = "interfaces"
                            self.yang_parent_name = "label-security"

                            self.interface = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces, self).__setattr__(name, value)


                        class Interface(Entity):
                            """
                            Specify interface Name
                            
                            .. attribute:: interface_name  <key>
                            
                            	Interface Name
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: mld_enabled
                            
                            	Multi\-label drop is enabled on interface
                            	**type**\:  bool
                            
                            .. attribute:: mld_supported
                            
                            	Multi\-label drop counters are supported per interface
                            	**type**\:  bool
                            
                            .. attribute:: multi_label_drops
                            
                            	Multi\-label drops
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: rpf_drops
                            
                            	RPF drops
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: rpf_enabled
                            
                            	RPF is enabled on interface
                            	**type**\:  bool
                            
                            .. attribute:: rpf_supported
                            
                            	RPF stats supported per interface
                            	**type**\:  bool
                            
                            .. attribute:: rpfifh
                            
                            	RPF interface handle
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces.Interface, self).__init__()

                                self.yang_name = "interface"
                                self.yang_parent_name = "interfaces"

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.mld_enabled = YLeaf(YType.boolean, "mld-enabled")

                                self.mld_supported = YLeaf(YType.boolean, "mld-supported")

                                self.multi_label_drops = YLeaf(YType.uint64, "multi-label-drops")

                                self.rpf_drops = YLeaf(YType.uint64, "rpf-drops")

                                self.rpf_enabled = YLeaf(YType.boolean, "rpf-enabled")

                                self.rpf_supported = YLeaf(YType.boolean, "rpf-supported")

                                self.rpfifh = YLeaf(YType.str, "rpfifh")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("interface_name",
                                                "mld_enabled",
                                                "mld_supported",
                                                "multi_label_drops",
                                                "rpf_drops",
                                                "rpf_enabled",
                                                "rpf_supported",
                                                "rpfifh") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces.Interface, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces.Interface, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.interface_name.is_set or
                                    self.mld_enabled.is_set or
                                    self.mld_supported.is_set or
                                    self.multi_label_drops.is_set or
                                    self.rpf_drops.is_set or
                                    self.rpf_enabled.is_set or
                                    self.rpf_supported.is_set or
                                    self.rpfifh.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.mld_enabled.yfilter != YFilter.not_set or
                                    self.mld_supported.yfilter != YFilter.not_set or
                                    self.multi_label_drops.yfilter != YFilter.not_set or
                                    self.rpf_drops.yfilter != YFilter.not_set or
                                    self.rpf_enabled.yfilter != YFilter.not_set or
                                    self.rpf_supported.yfilter != YFilter.not_set or
                                    self.rpfifh.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.mld_enabled.is_set or self.mld_enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mld_enabled.get_name_leafdata())
                                if (self.mld_supported.is_set or self.mld_supported.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.mld_supported.get_name_leafdata())
                                if (self.multi_label_drops.is_set or self.multi_label_drops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multi_label_drops.get_name_leafdata())
                                if (self.rpf_drops.is_set or self.rpf_drops.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rpf_drops.get_name_leafdata())
                                if (self.rpf_enabled.is_set or self.rpf_enabled.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rpf_enabled.get_name_leafdata())
                                if (self.rpf_supported.is_set or self.rpf_supported.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rpf_supported.get_name_leafdata())
                                if (self.rpfifh.is_set or self.rpfifh.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.rpfifh.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "interface-name" or name == "mld-enabled" or name == "mld-supported" or name == "multi-label-drops" or name == "rpf-drops" or name == "rpf-enabled" or name == "rpf-supported" or name == "rpfifh"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "mld-enabled"):
                                    self.mld_enabled = value
                                    self.mld_enabled.value_namespace = name_space
                                    self.mld_enabled.value_namespace_prefix = name_space_prefix
                                if(value_path == "mld-supported"):
                                    self.mld_supported = value
                                    self.mld_supported.value_namespace = name_space
                                    self.mld_supported.value_namespace_prefix = name_space_prefix
                                if(value_path == "multi-label-drops"):
                                    self.multi_label_drops = value
                                    self.multi_label_drops.value_namespace = name_space
                                    self.multi_label_drops.value_namespace_prefix = name_space_prefix
                                if(value_path == "rpf-drops"):
                                    self.rpf_drops = value
                                    self.rpf_drops.value_namespace = name_space
                                    self.rpf_drops.value_namespace_prefix = name_space_prefix
                                if(value_path == "rpf-enabled"):
                                    self.rpf_enabled = value
                                    self.rpf_enabled.value_namespace = name_space
                                    self.rpf_enabled.value_namespace_prefix = name_space_prefix
                                if(value_path == "rpf-supported"):
                                    self.rpf_supported = value
                                    self.rpf_supported.value_namespace = name_space
                                    self.rpf_supported.value_namespace_prefix = name_space_prefix
                                if(value_path == "rpfifh"):
                                    self.rpfifh = value
                                    self.rpfifh.value_namespace = name_space
                                    self.rpfifh.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.interface:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.interface:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "interfaces" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "interface"):
                                for c in self.interface:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces.Interface()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.interface.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "interface"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Summary(Entity):
                        """
                        MPLS label security summary
                        
                        .. attribute:: multi_label_drops
                        
                        	Multi\-label drops
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        .. attribute:: rpf_drops
                        
                        	RPF drops
                        	**type**\:  int
                        
                        	**range:** 0..18446744073709551615
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Summary, self).__init__()

                            self.yang_name = "summary"
                            self.yang_parent_name = "label-security"

                            self.multi_label_drops = YLeaf(YType.uint64, "multi-label-drops")

                            self.rpf_drops = YLeaf(YType.uint64, "rpf-drops")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("multi_label_drops",
                                            "rpf_drops") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Summary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Summary, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.multi_label_drops.is_set or
                                self.rpf_drops.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.multi_label_drops.yfilter != YFilter.not_set or
                                self.rpf_drops.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "summary" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.multi_label_drops.is_set or self.multi_label_drops.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.multi_label_drops.get_name_leafdata())
                            if (self.rpf_drops.is_set or self.rpf_drops.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.rpf_drops.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "multi-label-drops" or name == "rpf-drops"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "multi-label-drops"):
                                self.multi_label_drops = value
                                self.multi_label_drops.value_namespace = name_space
                                self.multi_label_drops.value_namespace_prefix = name_space_prefix
                            if(value_path == "rpf-drops"):
                                self.rpf_drops = value
                                self.rpf_drops.value_namespace = name_space
                                self.rpf_drops.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            (self.interfaces is not None and self.interfaces.has_data()) or
                            (self.summary is not None and self.summary.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.interfaces is not None and self.interfaces.has_operation()) or
                            (self.summary is not None and self.summary.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "label-security" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "interfaces"):
                            if (self.interfaces is None):
                                self.interfaces = MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Interfaces()
                                self.interfaces.parent = self
                                self._children_name_map["interfaces"] = "interfaces"
                            return self.interfaces

                        if (child_yang_name == "summary"):
                            if (self.summary is None):
                                self.summary = MplsForwarding.Nodes.Node.LabelFib.LabelSecurity.Summary()
                                self.summary.parent = self
                                self._children_name_map["summary"] = "summary"
                            return self.summary

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "interfaces" or name == "summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.forwarding_details is not None and self.forwarding_details.has_data()) or
                        (self.informations is not None and self.informations.has_data()) or
                        (self.label_security is not None and self.label_security.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.forwarding_details is not None and self.forwarding_details.has_operation()) or
                        (self.informations is not None and self.informations.has_operation()) or
                        (self.label_security is not None and self.label_security.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "label-fib" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "forwarding-details"):
                        if (self.forwarding_details is None):
                            self.forwarding_details = MplsForwarding.Nodes.Node.LabelFib.ForwardingDetails()
                            self.forwarding_details.parent = self
                            self._children_name_map["forwarding_details"] = "forwarding-details"
                        return self.forwarding_details

                    if (child_yang_name == "informations"):
                        if (self.informations is None):
                            self.informations = MplsForwarding.Nodes.Node.LabelFib.Informations()
                            self.informations.parent = self
                            self._children_name_map["informations"] = "informations"
                        return self.informations

                    if (child_yang_name == "label-security"):
                        if (self.label_security is None):
                            self.label_security = MplsForwarding.Nodes.Node.LabelFib.LabelSecurity()
                            self.label_security.parent = self
                            self._children_name_map["label_security"] = "label-security"
                        return self.label_security

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "forwarding-details" or name == "informations" or name == "label-security"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Tunnel(Entity):
                """
                TE Tunnel information
                
                .. attribute:: forwarding_tunnels
                
                	Forwarding details for TE tunnels
                	**type**\:   :py:class:`ForwardingTunnels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels>`
                
                

                """

                _prefix = 'fib-common-oper'
                _revision = '2017-01-20'

                def __init__(self):
                    super(MplsForwarding.Nodes.Node.Tunnel, self).__init__()

                    self.yang_name = "tunnel"
                    self.yang_parent_name = "node"

                    self.forwarding_tunnels = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels()
                    self.forwarding_tunnels.parent = self
                    self._children_name_map["forwarding_tunnels"] = "forwarding-tunnels"
                    self._children_yang_names.add("forwarding-tunnels")


                class ForwardingTunnels(Entity):
                    """
                    Forwarding details for TE tunnels
                    
                    .. attribute:: forwarding_tunnel
                    
                    	Forwarding information for the TE tunnel
                    	**type**\: list of    :py:class:`ForwardingTunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels, self).__init__()

                        self.yang_name = "forwarding-tunnels"
                        self.yang_parent_name = "tunnel"

                        self.forwarding_tunnel = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels, self).__setattr__(name, value)


                    class ForwardingTunnel(Entity):
                        """
                        Forwarding information for the TE tunnel
                        
                        .. attribute:: interface_name  <key>
                        
                        	Interface Name
                        	**type**\:  str
                        
                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                        
                        .. attribute:: fwdg
                        
                        	Tunnel forwarding information
                        	**type**\:   :py:class:`Fwdg <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg>`
                        
                        .. attribute:: tunnel_info
                        
                        	Tunnel head information
                        	**type**\:   :py:class:`TunnelInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.TunnelInfo>`
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel, self).__init__()

                            self.yang_name = "forwarding-tunnel"
                            self.yang_parent_name = "forwarding-tunnels"

                            self.interface_name = YLeaf(YType.str, "interface-name")

                            self.fwdg = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg()
                            self.fwdg.parent = self
                            self._children_name_map["fwdg"] = "fwdg"
                            self._children_yang_names.add("fwdg")

                            self.tunnel_info = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.TunnelInfo()
                            self.tunnel_info.parent = self
                            self._children_name_map["tunnel_info"] = "tunnel-info"
                            self._children_yang_names.add("tunnel-info")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("interface_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel, self).__setattr__(name, value)


                        class TunnelInfo(Entity):
                            """
                            Tunnel head information
                            
                            .. attribute:: tunnel_fwd_class
                            
                            	Tunnel Forward Class
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: tunnel_interface_name
                            
                            	Tunnel interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: tunnel_is_programmed_to_drop
                            
                            	Is Tunnel programmed as drop
                            	**type**\:  bool
                            
                            .. attribute:: tunnel_is_srte
                            
                            	Is Tunnel SRTE
                            	**type**\:  bool
                            
                            .. attribute:: tunnel_load_metric
                            
                            	 Tunnel Load Metric
                            	**type**\:  int
                            
                            	**range:** 0..255
                            
                            .. attribute:: tunnel_local_label
                            
                            	Tunnel Local label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: tunnel_resolution_incomplete
                            
                            	Tunnel head resolution is incomplete
                            	**type**\:  bool
                            
                            .. attribute:: tunnel_resolution_inconsistent
                            
                            	Tunnel head resolition is inconsitent b/w TEhead and Local label
                            	**type**\:  bool
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.TunnelInfo, self).__init__()

                                self.yang_name = "tunnel-info"
                                self.yang_parent_name = "forwarding-tunnel"

                                self.tunnel_fwd_class = YLeaf(YType.uint8, "tunnel-fwd-class")

                                self.tunnel_interface_name = YLeaf(YType.str, "tunnel-interface-name")

                                self.tunnel_is_programmed_to_drop = YLeaf(YType.boolean, "tunnel-is-programmed-to-drop")

                                self.tunnel_is_srte = YLeaf(YType.boolean, "tunnel-is-srte")

                                self.tunnel_load_metric = YLeaf(YType.uint8, "tunnel-load-metric")

                                self.tunnel_local_label = YLeaf(YType.uint32, "tunnel-local-label")

                                self.tunnel_resolution_incomplete = YLeaf(YType.boolean, "tunnel-resolution-incomplete")

                                self.tunnel_resolution_inconsistent = YLeaf(YType.boolean, "tunnel-resolution-inconsistent")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("tunnel_fwd_class",
                                                "tunnel_interface_name",
                                                "tunnel_is_programmed_to_drop",
                                                "tunnel_is_srte",
                                                "tunnel_load_metric",
                                                "tunnel_local_label",
                                                "tunnel_resolution_incomplete",
                                                "tunnel_resolution_inconsistent") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.TunnelInfo, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.TunnelInfo, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.tunnel_fwd_class.is_set or
                                    self.tunnel_interface_name.is_set or
                                    self.tunnel_is_programmed_to_drop.is_set or
                                    self.tunnel_is_srte.is_set or
                                    self.tunnel_load_metric.is_set or
                                    self.tunnel_local_label.is_set or
                                    self.tunnel_resolution_incomplete.is_set or
                                    self.tunnel_resolution_inconsistent.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.tunnel_fwd_class.yfilter != YFilter.not_set or
                                    self.tunnel_interface_name.yfilter != YFilter.not_set or
                                    self.tunnel_is_programmed_to_drop.yfilter != YFilter.not_set or
                                    self.tunnel_is_srte.yfilter != YFilter.not_set or
                                    self.tunnel_load_metric.yfilter != YFilter.not_set or
                                    self.tunnel_local_label.yfilter != YFilter.not_set or
                                    self.tunnel_resolution_incomplete.yfilter != YFilter.not_set or
                                    self.tunnel_resolution_inconsistent.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "tunnel-info" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.tunnel_fwd_class.is_set or self.tunnel_fwd_class.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_fwd_class.get_name_leafdata())
                                if (self.tunnel_interface_name.is_set or self.tunnel_interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_interface_name.get_name_leafdata())
                                if (self.tunnel_is_programmed_to_drop.is_set or self.tunnel_is_programmed_to_drop.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_is_programmed_to_drop.get_name_leafdata())
                                if (self.tunnel_is_srte.is_set or self.tunnel_is_srte.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_is_srte.get_name_leafdata())
                                if (self.tunnel_load_metric.is_set or self.tunnel_load_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_load_metric.get_name_leafdata())
                                if (self.tunnel_local_label.is_set or self.tunnel_local_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_local_label.get_name_leafdata())
                                if (self.tunnel_resolution_incomplete.is_set or self.tunnel_resolution_incomplete.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_resolution_incomplete.get_name_leafdata())
                                if (self.tunnel_resolution_inconsistent.is_set or self.tunnel_resolution_inconsistent.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_resolution_inconsistent.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "tunnel-fwd-class" or name == "tunnel-interface-name" or name == "tunnel-is-programmed-to-drop" or name == "tunnel-is-srte" or name == "tunnel-load-metric" or name == "tunnel-local-label" or name == "tunnel-resolution-incomplete" or name == "tunnel-resolution-inconsistent"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "tunnel-fwd-class"):
                                    self.tunnel_fwd_class = value
                                    self.tunnel_fwd_class.value_namespace = name_space
                                    self.tunnel_fwd_class.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-interface-name"):
                                    self.tunnel_interface_name = value
                                    self.tunnel_interface_name.value_namespace = name_space
                                    self.tunnel_interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-is-programmed-to-drop"):
                                    self.tunnel_is_programmed_to_drop = value
                                    self.tunnel_is_programmed_to_drop.value_namespace = name_space
                                    self.tunnel_is_programmed_to_drop.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-is-srte"):
                                    self.tunnel_is_srte = value
                                    self.tunnel_is_srte.value_namespace = name_space
                                    self.tunnel_is_srte.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-load-metric"):
                                    self.tunnel_load_metric = value
                                    self.tunnel_load_metric.value_namespace = name_space
                                    self.tunnel_load_metric.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-local-label"):
                                    self.tunnel_local_label = value
                                    self.tunnel_local_label.value_namespace = name_space
                                    self.tunnel_local_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-resolution-incomplete"):
                                    self.tunnel_resolution_incomplete = value
                                    self.tunnel_resolution_incomplete.value_namespace = name_space
                                    self.tunnel_resolution_incomplete.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-resolution-inconsistent"):
                                    self.tunnel_resolution_inconsistent = value
                                    self.tunnel_resolution_inconsistent.value_namespace = name_space
                                    self.tunnel_resolution_inconsistent.value_namespace_prefix = name_space_prefix


                        class Fwdg(Entity):
                            """
                            Tunnel forwarding information
                            
                            .. attribute:: afi_table_id
                            
                            	The AFI table ID
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: eos_bit
                            
                            	EOS bit
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: hardware_information
                            
                            	Hardware info
                            	**type**\:  str
                            
                            	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                            
                            .. attribute:: label_information
                            
                            	Label\-infos in FIB leaf
                            	**type**\: list of    :py:class:`LabelInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation>`
                            
                            .. attribute:: ldi_flags
                            
                            	The LDI flags
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ldi_information
                            
                            	LDI\-info in FIB leaf
                            	**type**\:   :py:class:`LdiInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LdiInformation>`
                            
                            .. attribute:: ldi_pointer
                            
                            	The pointer to the LDI
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ldi_referance_count
                            
                            	Number of references to the LDI
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: ldi_type
                            
                            	The LDI type
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: leaf_flags
                            
                            	The leaf flags
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: leaf_local_label
                            
                            	Local label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: leaf_referance_count
                            
                            	Number of references to the leaf
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: leaf_time_in_milli_seconds
                            
                            	The time of last update in msec
                            	**type**\:  int
                            
                            	**range:** 0..18446744073709551615
                            
                            .. attribute:: lspa_flags
                            
                            	The LSPA flags
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lw_ldi_pointer
                            
                            	The pointer to the LW\-LDI
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lw_ldi_refernace_count
                            
                            	The LW\-LDI refcounter
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lw_ldi_type
                            
                            	The LW\-LDI type
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: lw_shared_ldi_pointer
                            
                            	The pointer to the shared LDI in LW\-LDI
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: multicast_information
                            
                            	The multicast info
                            	**type**\:   :py:class:`MulticastInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.MulticastInformation>`
                            
                            .. attribute:: multicast_label
                            
                            	The unicast or multicast label
                            	**type**\:  bool
                            
                            .. attribute:: path_list_flags
                            
                            	The pathlist flags
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: path_list_referance_count
                            
                            	Number of references to the pathlist
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg, self).__init__()

                                self.yang_name = "fwdg"
                                self.yang_parent_name = "forwarding-tunnel"

                                self.afi_table_id = YLeaf(YType.uint32, "afi-table-id")

                                self.eos_bit = YLeaf(YType.uint32, "eos-bit")

                                self.hardware_information = YLeaf(YType.str, "hardware-information")

                                self.ldi_flags = YLeaf(YType.uint32, "ldi-flags")

                                self.ldi_pointer = YLeaf(YType.uint32, "ldi-pointer")

                                self.ldi_referance_count = YLeaf(YType.uint32, "ldi-referance-count")

                                self.ldi_type = YLeaf(YType.uint32, "ldi-type")

                                self.leaf_flags = YLeaf(YType.uint32, "leaf-flags")

                                self.leaf_local_label = YLeaf(YType.uint32, "leaf-local-label")

                                self.leaf_referance_count = YLeaf(YType.uint32, "leaf-referance-count")

                                self.leaf_time_in_milli_seconds = YLeaf(YType.uint64, "leaf-time-in-milli-seconds")

                                self.lspa_flags = YLeaf(YType.uint32, "lspa-flags")

                                self.lw_ldi_pointer = YLeaf(YType.uint32, "lw-ldi-pointer")

                                self.lw_ldi_refernace_count = YLeaf(YType.uint32, "lw-ldi-refernace-count")

                                self.lw_ldi_type = YLeaf(YType.uint32, "lw-ldi-type")

                                self.lw_shared_ldi_pointer = YLeaf(YType.uint32, "lw-shared-ldi-pointer")

                                self.multicast_label = YLeaf(YType.boolean, "multicast-label")

                                self.path_list_flags = YLeaf(YType.uint32, "path-list-flags")

                                self.path_list_referance_count = YLeaf(YType.uint32, "path-list-referance-count")

                                self.ldi_information = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LdiInformation()
                                self.ldi_information.parent = self
                                self._children_name_map["ldi_information"] = "ldi-information"
                                self._children_yang_names.add("ldi-information")

                                self.multicast_information = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.MulticastInformation()
                                self.multicast_information.parent = self
                                self._children_name_map["multicast_information"] = "multicast-information"
                                self._children_yang_names.add("multicast-information")

                                self.label_information = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("afi_table_id",
                                                "eos_bit",
                                                "hardware_information",
                                                "ldi_flags",
                                                "ldi_pointer",
                                                "ldi_referance_count",
                                                "ldi_type",
                                                "leaf_flags",
                                                "leaf_local_label",
                                                "leaf_referance_count",
                                                "leaf_time_in_milli_seconds",
                                                "lspa_flags",
                                                "lw_ldi_pointer",
                                                "lw_ldi_refernace_count",
                                                "lw_ldi_type",
                                                "lw_shared_ldi_pointer",
                                                "multicast_label",
                                                "path_list_flags",
                                                "path_list_referance_count") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg, self).__setattr__(name, value)


                            class LdiInformation(Entity):
                                """
                                LDI\-info in FIB leaf
                                
                                .. attribute:: ldi_hardware_information
                                
                                	Hardware info
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LdiInformation, self).__init__()

                                    self.yang_name = "ldi-information"
                                    self.yang_parent_name = "fwdg"

                                    self.ldi_hardware_information = YLeaf(YType.str, "ldi-hardware-information")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("ldi_hardware_information") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LdiInformation, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LdiInformation, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.ldi_hardware_information.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.ldi_hardware_information.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "ldi-information" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.ldi_hardware_information.is_set or self.ldi_hardware_information.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.ldi_hardware_information.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "ldi-hardware-information"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "ldi-hardware-information"):
                                        self.ldi_hardware_information = value
                                        self.ldi_hardware_information.value_namespace = name_space
                                        self.ldi_hardware_information.value_namespace_prefix = name_space_prefix


                            class MulticastInformation(Entity):
                                """
                                The multicast info
                                
                                .. attribute:: multicast_encap_id
                                
                                	The multicast ENCAP\-ID 
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: multicast_mol_base_flags
                                
                                	MOL base flags
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: multicast_mol_flags
                                
                                	MOL flags
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: multicast_mol_referance_count
                                
                                	MOL refcount
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: multicast_mpls_local_output_paths
                                
                                	num multicast mpls local output paths
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: multicast_mpls_output_paths
                                
                                	num multicast mpls output paths 
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: multicast_mpls_protocol_output_paths
                                
                                	num multicast mpls prot output paths 
                                	**type**\:  int
                                
                                	**range:** 0..65535
                                
                                .. attribute:: multicast_platform_data
                                
                                	The multicast platform data
                                	**type**\:  str
                                
                                	**pattern:** ([0\-9a\-fA\-F]{2}(\:[0\-9a\-fA\-F]{2})\*)?
                                
                                .. attribute:: multicast_platform_data_length
                                
                                	The multicast platform data len
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                .. attribute:: multicast_rpf_id
                                
                                	The multicast RPF\-ID 
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: multicast_tunnel_id
                                
                                	multicast mpls P2MP\-TE tunnel id or MLDP Tunnel LSMID on all nodes
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: multicast_tunnel_interface_handler
                                
                                	multicast mpls tunnel
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: multicast_tunnel_lspvif
                                
                                	multicast LSPVIF for MLDP Tunnels
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: multicast_tunnel_next_hop_information
                                
                                	multicast nhinfo for p2mp TE Head
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.MulticastInformation, self).__init__()

                                    self.yang_name = "multicast-information"
                                    self.yang_parent_name = "fwdg"

                                    self.multicast_encap_id = YLeaf(YType.uint32, "multicast-encap-id")

                                    self.multicast_mol_base_flags = YLeaf(YType.uint32, "multicast-mol-base-flags")

                                    self.multicast_mol_flags = YLeaf(YType.uint16, "multicast-mol-flags")

                                    self.multicast_mol_referance_count = YLeaf(YType.uint16, "multicast-mol-referance-count")

                                    self.multicast_mpls_local_output_paths = YLeaf(YType.uint16, "multicast-mpls-local-output-paths")

                                    self.multicast_mpls_output_paths = YLeaf(YType.uint16, "multicast-mpls-output-paths")

                                    self.multicast_mpls_protocol_output_paths = YLeaf(YType.uint16, "multicast-mpls-protocol-output-paths")

                                    self.multicast_platform_data = YLeaf(YType.str, "multicast-platform-data")

                                    self.multicast_platform_data_length = YLeaf(YType.uint8, "multicast-platform-data-length")

                                    self.multicast_rpf_id = YLeaf(YType.uint32, "multicast-rpf-id")

                                    self.multicast_tunnel_id = YLeaf(YType.uint32, "multicast-tunnel-id")

                                    self.multicast_tunnel_interface_handler = YLeaf(YType.str, "multicast-tunnel-interface-handler")

                                    self.multicast_tunnel_lspvif = YLeaf(YType.uint32, "multicast-tunnel-lspvif")

                                    self.multicast_tunnel_next_hop_information = YLeaf(YType.uint32, "multicast-tunnel-next-hop-information")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("multicast_encap_id",
                                                    "multicast_mol_base_flags",
                                                    "multicast_mol_flags",
                                                    "multicast_mol_referance_count",
                                                    "multicast_mpls_local_output_paths",
                                                    "multicast_mpls_output_paths",
                                                    "multicast_mpls_protocol_output_paths",
                                                    "multicast_platform_data",
                                                    "multicast_platform_data_length",
                                                    "multicast_rpf_id",
                                                    "multicast_tunnel_id",
                                                    "multicast_tunnel_interface_handler",
                                                    "multicast_tunnel_lspvif",
                                                    "multicast_tunnel_next_hop_information") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.MulticastInformation, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.MulticastInformation, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.multicast_encap_id.is_set or
                                        self.multicast_mol_base_flags.is_set or
                                        self.multicast_mol_flags.is_set or
                                        self.multicast_mol_referance_count.is_set or
                                        self.multicast_mpls_local_output_paths.is_set or
                                        self.multicast_mpls_output_paths.is_set or
                                        self.multicast_mpls_protocol_output_paths.is_set or
                                        self.multicast_platform_data.is_set or
                                        self.multicast_platform_data_length.is_set or
                                        self.multicast_rpf_id.is_set or
                                        self.multicast_tunnel_id.is_set or
                                        self.multicast_tunnel_interface_handler.is_set or
                                        self.multicast_tunnel_lspvif.is_set or
                                        self.multicast_tunnel_next_hop_information.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.multicast_encap_id.yfilter != YFilter.not_set or
                                        self.multicast_mol_base_flags.yfilter != YFilter.not_set or
                                        self.multicast_mol_flags.yfilter != YFilter.not_set or
                                        self.multicast_mol_referance_count.yfilter != YFilter.not_set or
                                        self.multicast_mpls_local_output_paths.yfilter != YFilter.not_set or
                                        self.multicast_mpls_output_paths.yfilter != YFilter.not_set or
                                        self.multicast_mpls_protocol_output_paths.yfilter != YFilter.not_set or
                                        self.multicast_platform_data.yfilter != YFilter.not_set or
                                        self.multicast_platform_data_length.yfilter != YFilter.not_set or
                                        self.multicast_rpf_id.yfilter != YFilter.not_set or
                                        self.multicast_tunnel_id.yfilter != YFilter.not_set or
                                        self.multicast_tunnel_interface_handler.yfilter != YFilter.not_set or
                                        self.multicast_tunnel_lspvif.yfilter != YFilter.not_set or
                                        self.multicast_tunnel_next_hop_information.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "multicast-information" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.multicast_encap_id.is_set or self.multicast_encap_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_encap_id.get_name_leafdata())
                                    if (self.multicast_mol_base_flags.is_set or self.multicast_mol_base_flags.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_mol_base_flags.get_name_leafdata())
                                    if (self.multicast_mol_flags.is_set or self.multicast_mol_flags.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_mol_flags.get_name_leafdata())
                                    if (self.multicast_mol_referance_count.is_set or self.multicast_mol_referance_count.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_mol_referance_count.get_name_leafdata())
                                    if (self.multicast_mpls_local_output_paths.is_set or self.multicast_mpls_local_output_paths.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_mpls_local_output_paths.get_name_leafdata())
                                    if (self.multicast_mpls_output_paths.is_set or self.multicast_mpls_output_paths.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_mpls_output_paths.get_name_leafdata())
                                    if (self.multicast_mpls_protocol_output_paths.is_set or self.multicast_mpls_protocol_output_paths.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_mpls_protocol_output_paths.get_name_leafdata())
                                    if (self.multicast_platform_data.is_set or self.multicast_platform_data.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_platform_data.get_name_leafdata())
                                    if (self.multicast_platform_data_length.is_set or self.multicast_platform_data_length.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_platform_data_length.get_name_leafdata())
                                    if (self.multicast_rpf_id.is_set or self.multicast_rpf_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_rpf_id.get_name_leafdata())
                                    if (self.multicast_tunnel_id.is_set or self.multicast_tunnel_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_tunnel_id.get_name_leafdata())
                                    if (self.multicast_tunnel_interface_handler.is_set or self.multicast_tunnel_interface_handler.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_tunnel_interface_handler.get_name_leafdata())
                                    if (self.multicast_tunnel_lspvif.is_set or self.multicast_tunnel_lspvif.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_tunnel_lspvif.get_name_leafdata())
                                    if (self.multicast_tunnel_next_hop_information.is_set or self.multicast_tunnel_next_hop_information.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.multicast_tunnel_next_hop_information.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "multicast-encap-id" or name == "multicast-mol-base-flags" or name == "multicast-mol-flags" or name == "multicast-mol-referance-count" or name == "multicast-mpls-local-output-paths" or name == "multicast-mpls-output-paths" or name == "multicast-mpls-protocol-output-paths" or name == "multicast-platform-data" or name == "multicast-platform-data-length" or name == "multicast-rpf-id" or name == "multicast-tunnel-id" or name == "multicast-tunnel-interface-handler" or name == "multicast-tunnel-lspvif" or name == "multicast-tunnel-next-hop-information"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "multicast-encap-id"):
                                        self.multicast_encap_id = value
                                        self.multicast_encap_id.value_namespace = name_space
                                        self.multicast_encap_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-mol-base-flags"):
                                        self.multicast_mol_base_flags = value
                                        self.multicast_mol_base_flags.value_namespace = name_space
                                        self.multicast_mol_base_flags.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-mol-flags"):
                                        self.multicast_mol_flags = value
                                        self.multicast_mol_flags.value_namespace = name_space
                                        self.multicast_mol_flags.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-mol-referance-count"):
                                        self.multicast_mol_referance_count = value
                                        self.multicast_mol_referance_count.value_namespace = name_space
                                        self.multicast_mol_referance_count.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-mpls-local-output-paths"):
                                        self.multicast_mpls_local_output_paths = value
                                        self.multicast_mpls_local_output_paths.value_namespace = name_space
                                        self.multicast_mpls_local_output_paths.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-mpls-output-paths"):
                                        self.multicast_mpls_output_paths = value
                                        self.multicast_mpls_output_paths.value_namespace = name_space
                                        self.multicast_mpls_output_paths.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-mpls-protocol-output-paths"):
                                        self.multicast_mpls_protocol_output_paths = value
                                        self.multicast_mpls_protocol_output_paths.value_namespace = name_space
                                        self.multicast_mpls_protocol_output_paths.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-platform-data"):
                                        self.multicast_platform_data = value
                                        self.multicast_platform_data.value_namespace = name_space
                                        self.multicast_platform_data.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-platform-data-length"):
                                        self.multicast_platform_data_length = value
                                        self.multicast_platform_data_length.value_namespace = name_space
                                        self.multicast_platform_data_length.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-rpf-id"):
                                        self.multicast_rpf_id = value
                                        self.multicast_rpf_id.value_namespace = name_space
                                        self.multicast_rpf_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-tunnel-id"):
                                        self.multicast_tunnel_id = value
                                        self.multicast_tunnel_id.value_namespace = name_space
                                        self.multicast_tunnel_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-tunnel-interface-handler"):
                                        self.multicast_tunnel_interface_handler = value
                                        self.multicast_tunnel_interface_handler.value_namespace = name_space
                                        self.multicast_tunnel_interface_handler.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-tunnel-lspvif"):
                                        self.multicast_tunnel_lspvif = value
                                        self.multicast_tunnel_lspvif.value_namespace = name_space
                                        self.multicast_tunnel_lspvif.value_namespace_prefix = name_space_prefix
                                    if(value_path == "multicast-tunnel-next-hop-information"):
                                        self.multicast_tunnel_next_hop_information = value
                                        self.multicast_tunnel_next_hop_information.value_namespace = name_space
                                        self.multicast_tunnel_next_hop_information.value_namespace_prefix = name_space_prefix


                            class LabelInformation(Entity):
                                """
                                Label\-infos in FIB leaf
                                
                                .. attribute:: exact_route_hash_info
                                
                                	Path's Hash info in case of exact\-route command
                                	**type**\:   :py:class:`ExactRouteHashInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.ExactRouteHashInfo>`
                                
                                .. attribute:: label_information_detail
                                
                                	Detail label info
                                	**type**\:   :py:class:`LabelInformationDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail>`
                                
                                .. attribute:: label_information_next_hop_protocol
                                
                                	The address family (v4/v6) 
                                	**type**\:   :py:class:`Proto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Proto>`
                                
                                .. attribute:: label_information_next_hop_string
                                
                                	Next hop address in string format
                                	**type**\:  str
                                
                                .. attribute:: label_information_next_hop_type
                                
                                	NHinfo Type
                                	**type**\:   :py:class:`NextHop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.NextHop>`
                                
                                .. attribute:: label_information_path_index
                                
                                	LabelInformationPathIndex
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: label_information_route_version
                                
                                	The version of the route
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: label_information_time_in_milli_seconds
                                
                                	The time of last update in msec
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                .. attribute:: label_information_type
                                
                                	Label\-Info type
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: local_label
                                
                                	Local label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: mpls_adjacency_flags
                                
                                	MPLS Adjacency flags
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: outgoing_interface
                                
                                	Outgoing interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: outgoing_interface_string
                                
                                	Output Interface in string format
                                	**type**\:  str
                                
                                .. attribute:: outgoing_label
                                
                                	Outgoing label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: outgoing_label_string
                                
                                	Output Label in string format
                                	**type**\:  str
                                
                                .. attribute:: outgoing_physical_interface
                                
                                	Outgoing Physical Interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: prefix_or_id
                                
                                	Prefix Or ID
                                	**type**\:  str
                                
                                .. attribute:: tunnel_id_present
                                
                                	Tunnel id present?
                                	**type**\:  bool
                                
                                .. attribute:: tunnel_interface
                                
                                	Tunnel Interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: tx_bytes
                                
                                	Bytes transmitted per LSP
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                	**units**\: byte
                                
                                .. attribute:: tx_packets
                                
                                	Packets transmitted per LSP
                                	**type**\:  int
                                
                                	**range:** 0..18446744073709551615
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation, self).__init__()

                                    self.yang_name = "label-information"
                                    self.yang_parent_name = "fwdg"

                                    self.label_information_next_hop_protocol = YLeaf(YType.enumeration, "label-information-next-hop-protocol")

                                    self.label_information_next_hop_string = YLeaf(YType.str, "label-information-next-hop-string")

                                    self.label_information_next_hop_type = YLeaf(YType.enumeration, "label-information-next-hop-type")

                                    self.label_information_path_index = YLeaf(YType.uint32, "label-information-path-index")

                                    self.label_information_route_version = YLeaf(YType.uint64, "label-information-route-version")

                                    self.label_information_time_in_milli_seconds = YLeaf(YType.uint64, "label-information-time-in-milli-seconds")

                                    self.label_information_type = YLeaf(YType.uint32, "label-information-type")

                                    self.local_label = YLeaf(YType.uint32, "local-label")

                                    self.mpls_adjacency_flags = YLeaf(YType.uint32, "mpls-adjacency-flags")

                                    self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                    self.outgoing_interface_string = YLeaf(YType.str, "outgoing-interface-string")

                                    self.outgoing_label = YLeaf(YType.uint32, "outgoing-label")

                                    self.outgoing_label_string = YLeaf(YType.str, "outgoing-label-string")

                                    self.outgoing_physical_interface = YLeaf(YType.str, "outgoing-physical-interface")

                                    self.prefix_or_id = YLeaf(YType.str, "prefix-or-id")

                                    self.tunnel_id_present = YLeaf(YType.boolean, "tunnel-id-present")

                                    self.tunnel_interface = YLeaf(YType.str, "tunnel-interface")

                                    self.tx_bytes = YLeaf(YType.uint64, "tx-bytes")

                                    self.tx_packets = YLeaf(YType.uint64, "tx-packets")

                                    self.exact_route_hash_info = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.ExactRouteHashInfo()
                                    self.exact_route_hash_info.parent = self
                                    self._children_name_map["exact_route_hash_info"] = "exact-route-hash-info"
                                    self._children_yang_names.add("exact-route-hash-info")

                                    self.label_information_detail = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail()
                                    self.label_information_detail.parent = self
                                    self._children_name_map["label_information_detail"] = "label-information-detail"
                                    self._children_yang_names.add("label-information-detail")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("label_information_next_hop_protocol",
                                                    "label_information_next_hop_string",
                                                    "label_information_next_hop_type",
                                                    "label_information_path_index",
                                                    "label_information_route_version",
                                                    "label_information_time_in_milli_seconds",
                                                    "label_information_type",
                                                    "local_label",
                                                    "mpls_adjacency_flags",
                                                    "outgoing_interface",
                                                    "outgoing_interface_string",
                                                    "outgoing_label",
                                                    "outgoing_label_string",
                                                    "outgoing_physical_interface",
                                                    "prefix_or_id",
                                                    "tunnel_id_present",
                                                    "tunnel_interface",
                                                    "tx_bytes",
                                                    "tx_packets") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation, self).__setattr__(name, value)


                                class LabelInformationDetail(Entity):
                                    """
                                    Detail label info
                                    
                                    .. attribute:: l3_mtu
                                    
                                    	L3 MTU
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: label_stack
                                    
                                    	Label stack
                                    	**type**\: list of    :py:class:`LabelStack <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail.LabelStack>`
                                    
                                    .. attribute:: mac_size
                                    
                                    	Length of L2 encapsulation
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: next_hop_interface
                                    
                                    	Next hop interface
                                    	**type**\:  str
                                    
                                    	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                    
                                    .. attribute:: next_hop_protocol
                                    
                                    	The address family (V4/V6) 
                                    	**type**\:   :py:class:`Proto <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.Proto>`
                                    
                                    .. attribute:: next_hop_string
                                    
                                    	Next hop address in string format
                                    	**type**\:  str
                                    
                                    .. attribute:: status
                                    
                                    	Status
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    .. attribute:: total_encapsulation_size
                                    
                                    	Total encapsulation size\: L2 + MPLS
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: transmit_number_of_bytes_switched
                                    
                                    	Number of Bytes switched
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    	**units**\: byte
                                    
                                    .. attribute:: transmit_number_of_packets_switched
                                    
                                    	Number of packets switched
                                    	**type**\:  int
                                    
                                    	**range:** 0..18446744073709551615
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail, self).__init__()

                                        self.yang_name = "label-information-detail"
                                        self.yang_parent_name = "label-information"

                                        self.l3_mtu = YLeaf(YType.uint32, "l3-mtu")

                                        self.mac_size = YLeaf(YType.uint32, "mac-size")

                                        self.next_hop_interface = YLeaf(YType.str, "next-hop-interface")

                                        self.next_hop_protocol = YLeaf(YType.enumeration, "next-hop-protocol")

                                        self.next_hop_string = YLeaf(YType.str, "next-hop-string")

                                        self.status = YLeaf(YType.int32, "status")

                                        self.total_encapsulation_size = YLeaf(YType.uint32, "total-encapsulation-size")

                                        self.transmit_number_of_bytes_switched = YLeaf(YType.uint64, "transmit-number-of-bytes-switched")

                                        self.transmit_number_of_packets_switched = YLeaf(YType.uint64, "transmit-number-of-packets-switched")

                                        self.label_stack = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("l3_mtu",
                                                        "mac_size",
                                                        "next_hop_interface",
                                                        "next_hop_protocol",
                                                        "next_hop_string",
                                                        "status",
                                                        "total_encapsulation_size",
                                                        "transmit_number_of_bytes_switched",
                                                        "transmit_number_of_packets_switched") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail, self).__setattr__(name, value)


                                    class LabelStack(Entity):
                                        """
                                        Label stack
                                        
                                        .. attribute:: entry
                                        
                                        	
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail.LabelStack, self).__init__()

                                            self.yang_name = "label-stack"
                                            self.yang_parent_name = "label-information-detail"

                                            self.entry = YLeaf(YType.uint32, "entry")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("entry") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail.LabelStack, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail.LabelStack, self).__setattr__(name, value)

                                        def has_data(self):
                                            return self.entry.is_set

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.entry.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "label-stack" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.entry.is_set or self.entry.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.entry.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "entry"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "entry"):
                                                self.entry = value
                                                self.entry.value_namespace = name_space
                                                self.entry.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.label_stack:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.l3_mtu.is_set or
                                            self.mac_size.is_set or
                                            self.next_hop_interface.is_set or
                                            self.next_hop_protocol.is_set or
                                            self.next_hop_string.is_set or
                                            self.status.is_set or
                                            self.total_encapsulation_size.is_set or
                                            self.transmit_number_of_bytes_switched.is_set or
                                            self.transmit_number_of_packets_switched.is_set)

                                    def has_operation(self):
                                        for c in self.label_stack:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.l3_mtu.yfilter != YFilter.not_set or
                                            self.mac_size.yfilter != YFilter.not_set or
                                            self.next_hop_interface.yfilter != YFilter.not_set or
                                            self.next_hop_protocol.yfilter != YFilter.not_set or
                                            self.next_hop_string.yfilter != YFilter.not_set or
                                            self.status.yfilter != YFilter.not_set or
                                            self.total_encapsulation_size.yfilter != YFilter.not_set or
                                            self.transmit_number_of_bytes_switched.yfilter != YFilter.not_set or
                                            self.transmit_number_of_packets_switched.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "label-information-detail" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.l3_mtu.is_set or self.l3_mtu.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.l3_mtu.get_name_leafdata())
                                        if (self.mac_size.is_set or self.mac_size.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mac_size.get_name_leafdata())
                                        if (self.next_hop_interface.is_set or self.next_hop_interface.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.next_hop_interface.get_name_leafdata())
                                        if (self.next_hop_protocol.is_set or self.next_hop_protocol.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.next_hop_protocol.get_name_leafdata())
                                        if (self.next_hop_string.is_set or self.next_hop_string.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.next_hop_string.get_name_leafdata())
                                        if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.status.get_name_leafdata())
                                        if (self.total_encapsulation_size.is_set or self.total_encapsulation_size.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_encapsulation_size.get_name_leafdata())
                                        if (self.transmit_number_of_bytes_switched.is_set or self.transmit_number_of_bytes_switched.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.transmit_number_of_bytes_switched.get_name_leafdata())
                                        if (self.transmit_number_of_packets_switched.is_set or self.transmit_number_of_packets_switched.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.transmit_number_of_packets_switched.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "label-stack"):
                                            for c in self.label_stack:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail.LabelStack()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.label_stack.append(c)
                                            return c

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "label-stack" or name == "l3-mtu" or name == "mac-size" or name == "next-hop-interface" or name == "next-hop-protocol" or name == "next-hop-string" or name == "status" or name == "total-encapsulation-size" or name == "transmit-number-of-bytes-switched" or name == "transmit-number-of-packets-switched"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "l3-mtu"):
                                            self.l3_mtu = value
                                            self.l3_mtu.value_namespace = name_space
                                            self.l3_mtu.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mac-size"):
                                            self.mac_size = value
                                            self.mac_size.value_namespace = name_space
                                            self.mac_size.value_namespace_prefix = name_space_prefix
                                        if(value_path == "next-hop-interface"):
                                            self.next_hop_interface = value
                                            self.next_hop_interface.value_namespace = name_space
                                            self.next_hop_interface.value_namespace_prefix = name_space_prefix
                                        if(value_path == "next-hop-protocol"):
                                            self.next_hop_protocol = value
                                            self.next_hop_protocol.value_namespace = name_space
                                            self.next_hop_protocol.value_namespace_prefix = name_space_prefix
                                        if(value_path == "next-hop-string"):
                                            self.next_hop_string = value
                                            self.next_hop_string.value_namespace = name_space
                                            self.next_hop_string.value_namespace_prefix = name_space_prefix
                                        if(value_path == "status"):
                                            self.status = value
                                            self.status.value_namespace = name_space
                                            self.status.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-encapsulation-size"):
                                            self.total_encapsulation_size = value
                                            self.total_encapsulation_size.value_namespace = name_space
                                            self.total_encapsulation_size.value_namespace_prefix = name_space_prefix
                                        if(value_path == "transmit-number-of-bytes-switched"):
                                            self.transmit_number_of_bytes_switched = value
                                            self.transmit_number_of_bytes_switched.value_namespace = name_space
                                            self.transmit_number_of_bytes_switched.value_namespace_prefix = name_space_prefix
                                        if(value_path == "transmit-number-of-packets-switched"):
                                            self.transmit_number_of_packets_switched = value
                                            self.transmit_number_of_packets_switched.value_namespace = name_space
                                            self.transmit_number_of_packets_switched.value_namespace_prefix = name_space_prefix


                                class ExactRouteHashInfo(Entity):
                                    """
                                    Path's Hash info in case of exact\-route command
                                    
                                    .. attribute:: hash_index
                                    
                                    	Hash Index value
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    .. attribute:: hash_index_is_valid
                                    
                                    	Is Hash Index valid?
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.ExactRouteHashInfo, self).__init__()

                                        self.yang_name = "exact-route-hash-info"
                                        self.yang_parent_name = "label-information"

                                        self.hash_index = YLeaf(YType.uint8, "hash-index")

                                        self.hash_index_is_valid = YLeaf(YType.boolean, "hash-index-is-valid")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("hash_index",
                                                        "hash_index_is_valid") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.ExactRouteHashInfo, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.ExactRouteHashInfo, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.hash_index.is_set or
                                            self.hash_index_is_valid.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.hash_index.yfilter != YFilter.not_set or
                                            self.hash_index_is_valid.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "exact-route-hash-info" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.hash_index.is_set or self.hash_index.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hash_index.get_name_leafdata())
                                        if (self.hash_index_is_valid.is_set or self.hash_index_is_valid.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.hash_index_is_valid.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "hash-index" or name == "hash-index-is-valid"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "hash-index"):
                                            self.hash_index = value
                                            self.hash_index.value_namespace = name_space
                                            self.hash_index.value_namespace_prefix = name_space_prefix
                                        if(value_path == "hash-index-is-valid"):
                                            self.hash_index_is_valid = value
                                            self.hash_index_is_valid.value_namespace = name_space
                                            self.hash_index_is_valid.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.label_information_next_hop_protocol.is_set or
                                        self.label_information_next_hop_string.is_set or
                                        self.label_information_next_hop_type.is_set or
                                        self.label_information_path_index.is_set or
                                        self.label_information_route_version.is_set or
                                        self.label_information_time_in_milli_seconds.is_set or
                                        self.label_information_type.is_set or
                                        self.local_label.is_set or
                                        self.mpls_adjacency_flags.is_set or
                                        self.outgoing_interface.is_set or
                                        self.outgoing_interface_string.is_set or
                                        self.outgoing_label.is_set or
                                        self.outgoing_label_string.is_set or
                                        self.outgoing_physical_interface.is_set or
                                        self.prefix_or_id.is_set or
                                        self.tunnel_id_present.is_set or
                                        self.tunnel_interface.is_set or
                                        self.tx_bytes.is_set or
                                        self.tx_packets.is_set or
                                        (self.exact_route_hash_info is not None and self.exact_route_hash_info.has_data()) or
                                        (self.label_information_detail is not None and self.label_information_detail.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.label_information_next_hop_protocol.yfilter != YFilter.not_set or
                                        self.label_information_next_hop_string.yfilter != YFilter.not_set or
                                        self.label_information_next_hop_type.yfilter != YFilter.not_set or
                                        self.label_information_path_index.yfilter != YFilter.not_set or
                                        self.label_information_route_version.yfilter != YFilter.not_set or
                                        self.label_information_time_in_milli_seconds.yfilter != YFilter.not_set or
                                        self.label_information_type.yfilter != YFilter.not_set or
                                        self.local_label.yfilter != YFilter.not_set or
                                        self.mpls_adjacency_flags.yfilter != YFilter.not_set or
                                        self.outgoing_interface.yfilter != YFilter.not_set or
                                        self.outgoing_interface_string.yfilter != YFilter.not_set or
                                        self.outgoing_label.yfilter != YFilter.not_set or
                                        self.outgoing_label_string.yfilter != YFilter.not_set or
                                        self.outgoing_physical_interface.yfilter != YFilter.not_set or
                                        self.prefix_or_id.yfilter != YFilter.not_set or
                                        self.tunnel_id_present.yfilter != YFilter.not_set or
                                        self.tunnel_interface.yfilter != YFilter.not_set or
                                        self.tx_bytes.yfilter != YFilter.not_set or
                                        self.tx_packets.yfilter != YFilter.not_set or
                                        (self.exact_route_hash_info is not None and self.exact_route_hash_info.has_operation()) or
                                        (self.label_information_detail is not None and self.label_information_detail.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "label-information" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.label_information_next_hop_protocol.is_set or self.label_information_next_hop_protocol.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.label_information_next_hop_protocol.get_name_leafdata())
                                    if (self.label_information_next_hop_string.is_set or self.label_information_next_hop_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.label_information_next_hop_string.get_name_leafdata())
                                    if (self.label_information_next_hop_type.is_set or self.label_information_next_hop_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.label_information_next_hop_type.get_name_leafdata())
                                    if (self.label_information_path_index.is_set or self.label_information_path_index.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.label_information_path_index.get_name_leafdata())
                                    if (self.label_information_route_version.is_set or self.label_information_route_version.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.label_information_route_version.get_name_leafdata())
                                    if (self.label_information_time_in_milli_seconds.is_set or self.label_information_time_in_milli_seconds.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.label_information_time_in_milli_seconds.get_name_leafdata())
                                    if (self.label_information_type.is_set or self.label_information_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.label_information_type.get_name_leafdata())
                                    if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.local_label.get_name_leafdata())
                                    if (self.mpls_adjacency_flags.is_set or self.mpls_adjacency_flags.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.mpls_adjacency_flags.get_name_leafdata())
                                    if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                    if (self.outgoing_interface_string.is_set or self.outgoing_interface_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_interface_string.get_name_leafdata())
                                    if (self.outgoing_label.is_set or self.outgoing_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_label.get_name_leafdata())
                                    if (self.outgoing_label_string.is_set or self.outgoing_label_string.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_label_string.get_name_leafdata())
                                    if (self.outgoing_physical_interface.is_set or self.outgoing_physical_interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_physical_interface.get_name_leafdata())
                                    if (self.prefix_or_id.is_set or self.prefix_or_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.prefix_or_id.get_name_leafdata())
                                    if (self.tunnel_id_present.is_set or self.tunnel_id_present.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tunnel_id_present.get_name_leafdata())
                                    if (self.tunnel_interface.is_set or self.tunnel_interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tunnel_interface.get_name_leafdata())
                                    if (self.tx_bytes.is_set or self.tx_bytes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tx_bytes.get_name_leafdata())
                                    if (self.tx_packets.is_set or self.tx_packets.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tx_packets.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "exact-route-hash-info"):
                                        if (self.exact_route_hash_info is None):
                                            self.exact_route_hash_info = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.ExactRouteHashInfo()
                                            self.exact_route_hash_info.parent = self
                                            self._children_name_map["exact_route_hash_info"] = "exact-route-hash-info"
                                        return self.exact_route_hash_info

                                    if (child_yang_name == "label-information-detail"):
                                        if (self.label_information_detail is None):
                                            self.label_information_detail = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation.LabelInformationDetail()
                                            self.label_information_detail.parent = self
                                            self._children_name_map["label_information_detail"] = "label-information-detail"
                                        return self.label_information_detail

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "exact-route-hash-info" or name == "label-information-detail" or name == "label-information-next-hop-protocol" or name == "label-information-next-hop-string" or name == "label-information-next-hop-type" or name == "label-information-path-index" or name == "label-information-route-version" or name == "label-information-time-in-milli-seconds" or name == "label-information-type" or name == "local-label" or name == "mpls-adjacency-flags" or name == "outgoing-interface" or name == "outgoing-interface-string" or name == "outgoing-label" or name == "outgoing-label-string" or name == "outgoing-physical-interface" or name == "prefix-or-id" or name == "tunnel-id-present" or name == "tunnel-interface" or name == "tx-bytes" or name == "tx-packets"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "label-information-next-hop-protocol"):
                                        self.label_information_next_hop_protocol = value
                                        self.label_information_next_hop_protocol.value_namespace = name_space
                                        self.label_information_next_hop_protocol.value_namespace_prefix = name_space_prefix
                                    if(value_path == "label-information-next-hop-string"):
                                        self.label_information_next_hop_string = value
                                        self.label_information_next_hop_string.value_namespace = name_space
                                        self.label_information_next_hop_string.value_namespace_prefix = name_space_prefix
                                    if(value_path == "label-information-next-hop-type"):
                                        self.label_information_next_hop_type = value
                                        self.label_information_next_hop_type.value_namespace = name_space
                                        self.label_information_next_hop_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "label-information-path-index"):
                                        self.label_information_path_index = value
                                        self.label_information_path_index.value_namespace = name_space
                                        self.label_information_path_index.value_namespace_prefix = name_space_prefix
                                    if(value_path == "label-information-route-version"):
                                        self.label_information_route_version = value
                                        self.label_information_route_version.value_namespace = name_space
                                        self.label_information_route_version.value_namespace_prefix = name_space_prefix
                                    if(value_path == "label-information-time-in-milli-seconds"):
                                        self.label_information_time_in_milli_seconds = value
                                        self.label_information_time_in_milli_seconds.value_namespace = name_space
                                        self.label_information_time_in_milli_seconds.value_namespace_prefix = name_space_prefix
                                    if(value_path == "label-information-type"):
                                        self.label_information_type = value
                                        self.label_information_type.value_namespace = name_space
                                        self.label_information_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "local-label"):
                                        self.local_label = value
                                        self.local_label.value_namespace = name_space
                                        self.local_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "mpls-adjacency-flags"):
                                        self.mpls_adjacency_flags = value
                                        self.mpls_adjacency_flags.value_namespace = name_space
                                        self.mpls_adjacency_flags.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-interface"):
                                        self.outgoing_interface = value
                                        self.outgoing_interface.value_namespace = name_space
                                        self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-interface-string"):
                                        self.outgoing_interface_string = value
                                        self.outgoing_interface_string.value_namespace = name_space
                                        self.outgoing_interface_string.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-label"):
                                        self.outgoing_label = value
                                        self.outgoing_label.value_namespace = name_space
                                        self.outgoing_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-label-string"):
                                        self.outgoing_label_string = value
                                        self.outgoing_label_string.value_namespace = name_space
                                        self.outgoing_label_string.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-physical-interface"):
                                        self.outgoing_physical_interface = value
                                        self.outgoing_physical_interface.value_namespace = name_space
                                        self.outgoing_physical_interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "prefix-or-id"):
                                        self.prefix_or_id = value
                                        self.prefix_or_id.value_namespace = name_space
                                        self.prefix_or_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tunnel-id-present"):
                                        self.tunnel_id_present = value
                                        self.tunnel_id_present.value_namespace = name_space
                                        self.tunnel_id_present.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tunnel-interface"):
                                        self.tunnel_interface = value
                                        self.tunnel_interface.value_namespace = name_space
                                        self.tunnel_interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tx-bytes"):
                                        self.tx_bytes = value
                                        self.tx_bytes.value_namespace = name_space
                                        self.tx_bytes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tx-packets"):
                                        self.tx_packets = value
                                        self.tx_packets.value_namespace = name_space
                                        self.tx_packets.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.label_information:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.afi_table_id.is_set or
                                    self.eos_bit.is_set or
                                    self.hardware_information.is_set or
                                    self.ldi_flags.is_set or
                                    self.ldi_pointer.is_set or
                                    self.ldi_referance_count.is_set or
                                    self.ldi_type.is_set or
                                    self.leaf_flags.is_set or
                                    self.leaf_local_label.is_set or
                                    self.leaf_referance_count.is_set or
                                    self.leaf_time_in_milli_seconds.is_set or
                                    self.lspa_flags.is_set or
                                    self.lw_ldi_pointer.is_set or
                                    self.lw_ldi_refernace_count.is_set or
                                    self.lw_ldi_type.is_set or
                                    self.lw_shared_ldi_pointer.is_set or
                                    self.multicast_label.is_set or
                                    self.path_list_flags.is_set or
                                    self.path_list_referance_count.is_set or
                                    (self.ldi_information is not None and self.ldi_information.has_data()) or
                                    (self.multicast_information is not None and self.multicast_information.has_data()))

                            def has_operation(self):
                                for c in self.label_information:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.afi_table_id.yfilter != YFilter.not_set or
                                    self.eos_bit.yfilter != YFilter.not_set or
                                    self.hardware_information.yfilter != YFilter.not_set or
                                    self.ldi_flags.yfilter != YFilter.not_set or
                                    self.ldi_pointer.yfilter != YFilter.not_set or
                                    self.ldi_referance_count.yfilter != YFilter.not_set or
                                    self.ldi_type.yfilter != YFilter.not_set or
                                    self.leaf_flags.yfilter != YFilter.not_set or
                                    self.leaf_local_label.yfilter != YFilter.not_set or
                                    self.leaf_referance_count.yfilter != YFilter.not_set or
                                    self.leaf_time_in_milli_seconds.yfilter != YFilter.not_set or
                                    self.lspa_flags.yfilter != YFilter.not_set or
                                    self.lw_ldi_pointer.yfilter != YFilter.not_set or
                                    self.lw_ldi_refernace_count.yfilter != YFilter.not_set or
                                    self.lw_ldi_type.yfilter != YFilter.not_set or
                                    self.lw_shared_ldi_pointer.yfilter != YFilter.not_set or
                                    self.multicast_label.yfilter != YFilter.not_set or
                                    self.path_list_flags.yfilter != YFilter.not_set or
                                    self.path_list_referance_count.yfilter != YFilter.not_set or
                                    (self.ldi_information is not None and self.ldi_information.has_operation()) or
                                    (self.multicast_information is not None and self.multicast_information.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "fwdg" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.afi_table_id.is_set or self.afi_table_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.afi_table_id.get_name_leafdata())
                                if (self.eos_bit.is_set or self.eos_bit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.eos_bit.get_name_leafdata())
                                if (self.hardware_information.is_set or self.hardware_information.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.hardware_information.get_name_leafdata())
                                if (self.ldi_flags.is_set or self.ldi_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldi_flags.get_name_leafdata())
                                if (self.ldi_pointer.is_set or self.ldi_pointer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldi_pointer.get_name_leafdata())
                                if (self.ldi_referance_count.is_set or self.ldi_referance_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldi_referance_count.get_name_leafdata())
                                if (self.ldi_type.is_set or self.ldi_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldi_type.get_name_leafdata())
                                if (self.leaf_flags.is_set or self.leaf_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.leaf_flags.get_name_leafdata())
                                if (self.leaf_local_label.is_set or self.leaf_local_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.leaf_local_label.get_name_leafdata())
                                if (self.leaf_referance_count.is_set or self.leaf_referance_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.leaf_referance_count.get_name_leafdata())
                                if (self.leaf_time_in_milli_seconds.is_set or self.leaf_time_in_milli_seconds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.leaf_time_in_milli_seconds.get_name_leafdata())
                                if (self.lspa_flags.is_set or self.lspa_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lspa_flags.get_name_leafdata())
                                if (self.lw_ldi_pointer.is_set or self.lw_ldi_pointer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lw_ldi_pointer.get_name_leafdata())
                                if (self.lw_ldi_refernace_count.is_set or self.lw_ldi_refernace_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lw_ldi_refernace_count.get_name_leafdata())
                                if (self.lw_ldi_type.is_set or self.lw_ldi_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lw_ldi_type.get_name_leafdata())
                                if (self.lw_shared_ldi_pointer.is_set or self.lw_shared_ldi_pointer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lw_shared_ldi_pointer.get_name_leafdata())
                                if (self.multicast_label.is_set or self.multicast_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_label.get_name_leafdata())
                                if (self.path_list_flags.is_set or self.path_list_flags.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_list_flags.get_name_leafdata())
                                if (self.path_list_referance_count.is_set or self.path_list_referance_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_list_referance_count.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "label-information"):
                                    for c in self.label_information:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LabelInformation()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.label_information.append(c)
                                    return c

                                if (child_yang_name == "ldi-information"):
                                    if (self.ldi_information is None):
                                        self.ldi_information = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.LdiInformation()
                                        self.ldi_information.parent = self
                                        self._children_name_map["ldi_information"] = "ldi-information"
                                    return self.ldi_information

                                if (child_yang_name == "multicast-information"):
                                    if (self.multicast_information is None):
                                        self.multicast_information = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg.MulticastInformation()
                                        self.multicast_information.parent = self
                                        self._children_name_map["multicast_information"] = "multicast-information"
                                    return self.multicast_information

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "label-information" or name == "ldi-information" or name == "multicast-information" or name == "afi-table-id" or name == "eos-bit" or name == "hardware-information" or name == "ldi-flags" or name == "ldi-pointer" or name == "ldi-referance-count" or name == "ldi-type" or name == "leaf-flags" or name == "leaf-local-label" or name == "leaf-referance-count" or name == "leaf-time-in-milli-seconds" or name == "lspa-flags" or name == "lw-ldi-pointer" or name == "lw-ldi-refernace-count" or name == "lw-ldi-type" or name == "lw-shared-ldi-pointer" or name == "multicast-label" or name == "path-list-flags" or name == "path-list-referance-count"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "afi-table-id"):
                                    self.afi_table_id = value
                                    self.afi_table_id.value_namespace = name_space
                                    self.afi_table_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "eos-bit"):
                                    self.eos_bit = value
                                    self.eos_bit.value_namespace = name_space
                                    self.eos_bit.value_namespace_prefix = name_space_prefix
                                if(value_path == "hardware-information"):
                                    self.hardware_information = value
                                    self.hardware_information.value_namespace = name_space
                                    self.hardware_information.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldi-flags"):
                                    self.ldi_flags = value
                                    self.ldi_flags.value_namespace = name_space
                                    self.ldi_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldi-pointer"):
                                    self.ldi_pointer = value
                                    self.ldi_pointer.value_namespace = name_space
                                    self.ldi_pointer.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldi-referance-count"):
                                    self.ldi_referance_count = value
                                    self.ldi_referance_count.value_namespace = name_space
                                    self.ldi_referance_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldi-type"):
                                    self.ldi_type = value
                                    self.ldi_type.value_namespace = name_space
                                    self.ldi_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "leaf-flags"):
                                    self.leaf_flags = value
                                    self.leaf_flags.value_namespace = name_space
                                    self.leaf_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "leaf-local-label"):
                                    self.leaf_local_label = value
                                    self.leaf_local_label.value_namespace = name_space
                                    self.leaf_local_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "leaf-referance-count"):
                                    self.leaf_referance_count = value
                                    self.leaf_referance_count.value_namespace = name_space
                                    self.leaf_referance_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "leaf-time-in-milli-seconds"):
                                    self.leaf_time_in_milli_seconds = value
                                    self.leaf_time_in_milli_seconds.value_namespace = name_space
                                    self.leaf_time_in_milli_seconds.value_namespace_prefix = name_space_prefix
                                if(value_path == "lspa-flags"):
                                    self.lspa_flags = value
                                    self.lspa_flags.value_namespace = name_space
                                    self.lspa_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "lw-ldi-pointer"):
                                    self.lw_ldi_pointer = value
                                    self.lw_ldi_pointer.value_namespace = name_space
                                    self.lw_ldi_pointer.value_namespace_prefix = name_space_prefix
                                if(value_path == "lw-ldi-refernace-count"):
                                    self.lw_ldi_refernace_count = value
                                    self.lw_ldi_refernace_count.value_namespace = name_space
                                    self.lw_ldi_refernace_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "lw-ldi-type"):
                                    self.lw_ldi_type = value
                                    self.lw_ldi_type.value_namespace = name_space
                                    self.lw_ldi_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lw-shared-ldi-pointer"):
                                    self.lw_shared_ldi_pointer = value
                                    self.lw_shared_ldi_pointer.value_namespace = name_space
                                    self.lw_shared_ldi_pointer.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-label"):
                                    self.multicast_label = value
                                    self.multicast_label.value_namespace = name_space
                                    self.multicast_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-list-flags"):
                                    self.path_list_flags = value
                                    self.path_list_flags.value_namespace = name_space
                                    self.path_list_flags.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-list-referance-count"):
                                    self.path_list_referance_count = value
                                    self.path_list_referance_count.value_namespace = name_space
                                    self.path_list_referance_count.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.interface_name.is_set or
                                (self.fwdg is not None and self.fwdg.has_data()) or
                                (self.tunnel_info is not None and self.tunnel_info.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.interface_name.yfilter != YFilter.not_set or
                                (self.fwdg is not None and self.fwdg.has_operation()) or
                                (self.tunnel_info is not None and self.tunnel_info.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "forwarding-tunnel" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "fwdg"):
                                if (self.fwdg is None):
                                    self.fwdg = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.Fwdg()
                                    self.fwdg.parent = self
                                    self._children_name_map["fwdg"] = "fwdg"
                                return self.fwdg

                            if (child_yang_name == "tunnel-info"):
                                if (self.tunnel_info is None):
                                    self.tunnel_info = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel.TunnelInfo()
                                    self.tunnel_info.parent = self
                                    self._children_name_map["tunnel_info"] = "tunnel-info"
                                return self.tunnel_info

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "fwdg" or name == "tunnel-info" or name == "interface-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "interface-name"):
                                self.interface_name = value
                                self.interface_name.value_namespace = name_space
                                self.interface_name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.forwarding_tunnel:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.forwarding_tunnel:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "forwarding-tunnels" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "forwarding-tunnel"):
                            for c in self.forwarding_tunnel:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels.ForwardingTunnel()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.forwarding_tunnel.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "forwarding-tunnel"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (self.forwarding_tunnels is not None and self.forwarding_tunnels.has_data())

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.forwarding_tunnels is not None and self.forwarding_tunnels.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "tunnel" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "forwarding-tunnels"):
                        if (self.forwarding_tunnels is None):
                            self.forwarding_tunnels = MplsForwarding.Nodes.Node.Tunnel.ForwardingTunnels()
                            self.forwarding_tunnels.parent = self
                            self._children_name_map["forwarding_tunnels"] = "forwarding-tunnels"
                        return self.forwarding_tunnels

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "forwarding-tunnels"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class FrrDatabase(Entity):
                """
                MPLS forwarding FRR Database
                
                .. attribute:: frrdb_backup_interface_summaries
                
                	MPLS forwarding FRR Database Backup Interface Summary Table
                	**type**\:   :py:class:`FrrdbBackupInterfaceSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries>`
                
                .. attribute:: frrdb_protected_interface_table_summaries
                
                	MPLS forwarding FRR Database Protected Interface Summary Table
                	**type**\:   :py:class:`FrrdbProtectedInterfaceTableSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries>`
                
                .. attribute:: frrdb_summary
                
                	MPLS forwarding FRR Database Summary
                	**type**\:   :py:class:`FrrdbSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbSummary>`
                
                .. attribute:: frrdb_tunnel_head_summary
                
                	MPLS forwarding FRR Database Tunnel Head Summary
                	**type**\:   :py:class:`FrrdbTunnelHeadSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeadSummary>`
                
                .. attribute:: frrdb_tunnel_heads
                
                	MPLS forwarding FRR Database Tunnel Head Table
                	**type**\:   :py:class:`FrrdbTunnelHeads <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads>`
                
                .. attribute:: frrdb_tunnel_midpoint_summary
                
                	MPLS forwarding FRR Database Tunnel Midpoint Summary
                	**type**\:   :py:class:`FrrdbTunnelMidpointSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpointSummary>`
                
                .. attribute:: frrdb_tunnel_midpoints
                
                	MPLS forwarding FRR Database Tunnel Midpoint Table
                	**type**\:   :py:class:`FrrdbTunnelMidpoints <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints>`
                
                

                """

                _prefix = 'fib-common-oper'
                _revision = '2017-01-20'

                def __init__(self):
                    super(MplsForwarding.Nodes.Node.FrrDatabase, self).__init__()

                    self.yang_name = "frr-database"
                    self.yang_parent_name = "node"

                    self.frrdb_backup_interface_summaries = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries()
                    self.frrdb_backup_interface_summaries.parent = self
                    self._children_name_map["frrdb_backup_interface_summaries"] = "frrdb-backup-interface-summaries"
                    self._children_yang_names.add("frrdb-backup-interface-summaries")

                    self.frrdb_protected_interface_table_summaries = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries()
                    self.frrdb_protected_interface_table_summaries.parent = self
                    self._children_name_map["frrdb_protected_interface_table_summaries"] = "frrdb-protected-interface-table-summaries"
                    self._children_yang_names.add("frrdb-protected-interface-table-summaries")

                    self.frrdb_summary = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbSummary()
                    self.frrdb_summary.parent = self
                    self._children_name_map["frrdb_summary"] = "frrdb-summary"
                    self._children_yang_names.add("frrdb-summary")

                    self.frrdb_tunnel_head_summary = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeadSummary()
                    self.frrdb_tunnel_head_summary.parent = self
                    self._children_name_map["frrdb_tunnel_head_summary"] = "frrdb-tunnel-head-summary"
                    self._children_yang_names.add("frrdb-tunnel-head-summary")

                    self.frrdb_tunnel_heads = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads()
                    self.frrdb_tunnel_heads.parent = self
                    self._children_name_map["frrdb_tunnel_heads"] = "frrdb-tunnel-heads"
                    self._children_yang_names.add("frrdb-tunnel-heads")

                    self.frrdb_tunnel_midpoint_summary = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpointSummary()
                    self.frrdb_tunnel_midpoint_summary.parent = self
                    self._children_name_map["frrdb_tunnel_midpoint_summary"] = "frrdb-tunnel-midpoint-summary"
                    self._children_yang_names.add("frrdb-tunnel-midpoint-summary")

                    self.frrdb_tunnel_midpoints = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints()
                    self.frrdb_tunnel_midpoints.parent = self
                    self._children_name_map["frrdb_tunnel_midpoints"] = "frrdb-tunnel-midpoints"
                    self._children_yang_names.add("frrdb-tunnel-midpoints")


                class FrrdbSummary(Entity):
                    """
                    MPLS forwarding FRR Database Summary
                    
                    .. attribute:: active
                    
                    	Number of FRR rewrites in Active state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: other
                    
                    	Number of FRR rewrites in an unrecognized state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: partial
                    
                    	Number of FRR rewrites in Partial state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ready
                    
                    	Number of FRR rewrites in Ready state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbSummary, self).__init__()

                        self.yang_name = "frrdb-summary"
                        self.yang_parent_name = "frr-database"

                        self.active = YLeaf(YType.uint32, "active")

                        self.other = YLeaf(YType.uint32, "other")

                        self.partial = YLeaf(YType.uint32, "partial")

                        self.ready = YLeaf(YType.uint32, "ready")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("active",
                                        "other",
                                        "partial",
                                        "ready") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbSummary, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbSummary, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.active.is_set or
                            self.other.is_set or
                            self.partial.is_set or
                            self.ready.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.active.yfilter != YFilter.not_set or
                            self.other.yfilter != YFilter.not_set or
                            self.partial.yfilter != YFilter.not_set or
                            self.ready.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "frrdb-summary" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.active.is_set or self.active.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.active.get_name_leafdata())
                        if (self.other.is_set or self.other.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.other.get_name_leafdata())
                        if (self.partial.is_set or self.partial.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.partial.get_name_leafdata())
                        if (self.ready.is_set or self.ready.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ready.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "active" or name == "other" or name == "partial" or name == "ready"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "active"):
                            self.active = value
                            self.active.value_namespace = name_space
                            self.active.value_namespace_prefix = name_space_prefix
                        if(value_path == "other"):
                            self.other = value
                            self.other.value_namespace = name_space
                            self.other.value_namespace_prefix = name_space_prefix
                        if(value_path == "partial"):
                            self.partial = value
                            self.partial.value_namespace = name_space
                            self.partial.value_namespace_prefix = name_space_prefix
                        if(value_path == "ready"):
                            self.ready = value
                            self.ready.value_namespace = name_space
                            self.ready.value_namespace_prefix = name_space_prefix


                class FrrdbProtectedInterfaceTableSummaries(Entity):
                    """
                    MPLS forwarding FRR Database Protected
                    Interface Summary Table
                    
                    .. attribute:: frrdb_protected_interface_table_summary
                    
                    	MPLS forwarding FRR Database Protected Interface Summary
                    	**type**\: list of    :py:class:`FrrdbProtectedInterfaceTableSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries.FrrdbProtectedInterfaceTableSummary>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries, self).__init__()

                        self.yang_name = "frrdb-protected-interface-table-summaries"
                        self.yang_parent_name = "frr-database"

                        self.frrdb_protected_interface_table_summary = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries, self).__setattr__(name, value)


                    class FrrdbProtectedInterfaceTableSummary(Entity):
                        """
                        MPLS forwarding FRR Database Protected
                        Interface Summary
                        
                        .. attribute:: interface_name  <key>
                        
                        	Interface Name
                        	**type**\:  str
                        
                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                        
                        .. attribute:: active
                        
                        	Number of FRR rewrites in Active state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: other
                        
                        	Number of FRR rewrites in an unrecognized state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: partial
                        
                        	Number of FRR rewrites in Partial state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ready
                        
                        	Number of FRR rewrites in Ready state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries.FrrdbProtectedInterfaceTableSummary, self).__init__()

                            self.yang_name = "frrdb-protected-interface-table-summary"
                            self.yang_parent_name = "frrdb-protected-interface-table-summaries"

                            self.interface_name = YLeaf(YType.str, "interface-name")

                            self.active = YLeaf(YType.uint32, "active")

                            self.other = YLeaf(YType.uint32, "other")

                            self.partial = YLeaf(YType.uint32, "partial")

                            self.ready = YLeaf(YType.uint32, "ready")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("interface_name",
                                            "active",
                                            "other",
                                            "partial",
                                            "ready") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries.FrrdbProtectedInterfaceTableSummary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries.FrrdbProtectedInterfaceTableSummary, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.interface_name.is_set or
                                self.active.is_set or
                                self.other.is_set or
                                self.partial.is_set or
                                self.ready.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.interface_name.yfilter != YFilter.not_set or
                                self.active.yfilter != YFilter.not_set or
                                self.other.yfilter != YFilter.not_set or
                                self.partial.yfilter != YFilter.not_set or
                                self.ready.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "frrdb-protected-interface-table-summary" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_name.get_name_leafdata())
                            if (self.active.is_set or self.active.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.active.get_name_leafdata())
                            if (self.other.is_set or self.other.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.other.get_name_leafdata())
                            if (self.partial.is_set or self.partial.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.partial.get_name_leafdata())
                            if (self.ready.is_set or self.ready.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ready.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "interface-name" or name == "active" or name == "other" or name == "partial" or name == "ready"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "interface-name"):
                                self.interface_name = value
                                self.interface_name.value_namespace = name_space
                                self.interface_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "active"):
                                self.active = value
                                self.active.value_namespace = name_space
                                self.active.value_namespace_prefix = name_space_prefix
                            if(value_path == "other"):
                                self.other = value
                                self.other.value_namespace = name_space
                                self.other.value_namespace_prefix = name_space_prefix
                            if(value_path == "partial"):
                                self.partial = value
                                self.partial.value_namespace = name_space
                                self.partial.value_namespace_prefix = name_space_prefix
                            if(value_path == "ready"):
                                self.ready = value
                                self.ready.value_namespace = name_space
                                self.ready.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.frrdb_protected_interface_table_summary:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.frrdb_protected_interface_table_summary:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "frrdb-protected-interface-table-summaries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "frrdb-protected-interface-table-summary"):
                            for c in self.frrdb_protected_interface_table_summary:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries.FrrdbProtectedInterfaceTableSummary()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.frrdb_protected_interface_table_summary.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "frrdb-protected-interface-table-summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class FrrdbTunnelMidpointSummary(Entity):
                    """
                    MPLS forwarding FRR Database Tunnel Midpoint
                    Summary
                    
                    .. attribute:: active
                    
                    	Number of FRR rewrites in Active state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: other
                    
                    	Number of FRR rewrites in an unrecognized state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: partial
                    
                    	Number of FRR rewrites in Partial state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ready
                    
                    	Number of FRR rewrites in Ready state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpointSummary, self).__init__()

                        self.yang_name = "frrdb-tunnel-midpoint-summary"
                        self.yang_parent_name = "frr-database"

                        self.active = YLeaf(YType.uint32, "active")

                        self.other = YLeaf(YType.uint32, "other")

                        self.partial = YLeaf(YType.uint32, "partial")

                        self.ready = YLeaf(YType.uint32, "ready")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("active",
                                        "other",
                                        "partial",
                                        "ready") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpointSummary, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpointSummary, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.active.is_set or
                            self.other.is_set or
                            self.partial.is_set or
                            self.ready.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.active.yfilter != YFilter.not_set or
                            self.other.yfilter != YFilter.not_set or
                            self.partial.yfilter != YFilter.not_set or
                            self.ready.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "frrdb-tunnel-midpoint-summary" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.active.is_set or self.active.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.active.get_name_leafdata())
                        if (self.other.is_set or self.other.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.other.get_name_leafdata())
                        if (self.partial.is_set or self.partial.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.partial.get_name_leafdata())
                        if (self.ready.is_set or self.ready.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ready.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "active" or name == "other" or name == "partial" or name == "ready"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "active"):
                            self.active = value
                            self.active.value_namespace = name_space
                            self.active.value_namespace_prefix = name_space_prefix
                        if(value_path == "other"):
                            self.other = value
                            self.other.value_namespace = name_space
                            self.other.value_namespace_prefix = name_space_prefix
                        if(value_path == "partial"):
                            self.partial = value
                            self.partial.value_namespace = name_space
                            self.partial.value_namespace_prefix = name_space_prefix
                        if(value_path == "ready"):
                            self.ready = value
                            self.ready.value_namespace = name_space
                            self.ready.value_namespace_prefix = name_space_prefix


                class FrrdbTunnelMidpoints(Entity):
                    """
                    MPLS forwarding FRR Database Tunnel Midpoint
                    Table
                    
                    .. attribute:: frrdb_tunnel_midpoint
                    
                    	MPLS forwarding FRR Database Tunnel Midpoint Entry
                    	**type**\: list of    :py:class:`FrrdbTunnelMidpoint <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints, self).__init__()

                        self.yang_name = "frrdb-tunnel-midpoints"
                        self.yang_parent_name = "frr-database"

                        self.frrdb_tunnel_midpoint = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints, self).__setattr__(name, value)


                    class FrrdbTunnelMidpoint(Entity):
                        """
                        MPLS forwarding FRR Database Tunnel Midpoint
                        Entry
                        
                        .. attribute:: local_label  <key>
                        
                        	Local label value
                        	**type**\:  int
                        
                        	**range:** 16..1048575
                        
                        .. attribute:: frr_db
                        
                        	FRR DB
                        	**type**\:   :py:class:`FrrDb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb>`
                        
                        .. attribute:: frr_lable_string
                        
                        	FRR label in string format
                        	**type**\:  str
                        
                        .. attribute:: outgoing_lable_string
                        
                        	Output label in string format
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint, self).__init__()

                            self.yang_name = "frrdb-tunnel-midpoint"
                            self.yang_parent_name = "frrdb-tunnel-midpoints"

                            self.local_label = YLeaf(YType.uint32, "local-label")

                            self.frr_lable_string = YLeaf(YType.str, "frr-lable-string")

                            self.outgoing_lable_string = YLeaf(YType.str, "outgoing-lable-string")

                            self.frr_db = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb()
                            self.frr_db.parent = self
                            self._children_name_map["frr_db"] = "frr-db"
                            self._children_yang_names.add("frr-db")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("local_label",
                                            "frr_lable_string",
                                            "outgoing_lable_string") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint, self).__setattr__(name, value)


                        class FrrDb(Entity):
                            """
                            FRR DB
                            
                            .. attribute:: entry_frr_state
                            
                            	MPLS FRR entry state
                            	**type**\:   :py:class:`MgmtFibMplsFrrState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MgmtFibMplsFrrState>`
                            
                            .. attribute:: frr_entry_id
                            
                            	FRR entry ID
                            	**type**\:   :py:class:`FrrEntryId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId>`
                            
                            .. attribute:: frr_interface_name
                            
                            	FRR interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: frr_label
                            
                            	FRR output label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: frr_next_hop_ipv4_address
                            
                            	Next hop IPv4 address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: input_label
                            
                            	Input label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: is_mldp_lsp
                            
                            	MLDP or P2MP\-TE
                            	**type**\:  bool
                            
                            .. attribute:: is_multicast_tunnel
                            
                            	Multicast tunnel
                            	**type**\:  bool
                            
                            .. attribute:: multicast_leg
                            
                            	MCAST legs
                            	**type**\: list of    :py:class:`MulticastLeg <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg>`
                            
                            .. attribute:: multicast_tunnel_legs
                            
                            	Number of legs in MCAST tunnel
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_interface
                            
                            	Outgoing interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: outgoing_label
                            
                            	Outgoing label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: tunnel_interface_name
                            
                            	Tunnel interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb, self).__init__()

                                self.yang_name = "frr-db"
                                self.yang_parent_name = "frrdb-tunnel-midpoint"

                                self.entry_frr_state = YLeaf(YType.enumeration, "entry-frr-state")

                                self.frr_interface_name = YLeaf(YType.str, "frr-interface-name")

                                self.frr_label = YLeaf(YType.uint32, "frr-label")

                                self.frr_next_hop_ipv4_address = YLeaf(YType.str, "frr-next-hop-ipv4-address")

                                self.input_label = YLeaf(YType.uint32, "input-label")

                                self.is_mldp_lsp = YLeaf(YType.boolean, "is-mldp-lsp")

                                self.is_multicast_tunnel = YLeaf(YType.boolean, "is-multicast-tunnel")

                                self.multicast_tunnel_legs = YLeaf(YType.uint32, "multicast-tunnel-legs")

                                self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                self.outgoing_label = YLeaf(YType.uint32, "outgoing-label")

                                self.tunnel_interface_name = YLeaf(YType.str, "tunnel-interface-name")

                                self.frr_entry_id = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId()
                                self.frr_entry_id.parent = self
                                self._children_name_map["frr_entry_id"] = "frr-entry-id"
                                self._children_yang_names.add("frr-entry-id")

                                self.multicast_leg = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry_frr_state",
                                                "frr_interface_name",
                                                "frr_label",
                                                "frr_next_hop_ipv4_address",
                                                "input_label",
                                                "is_mldp_lsp",
                                                "is_multicast_tunnel",
                                                "multicast_tunnel_legs",
                                                "outgoing_interface",
                                                "outgoing_label",
                                                "tunnel_interface_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb, self).__setattr__(name, value)


                            class FrrEntryId(Entity):
                                """
                                FRR entry ID
                                
                                .. attribute:: head
                                
                                	head
                                	**type**\:   :py:class:`Head <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Head>`
                                
                                .. attribute:: midpoint
                                
                                	midpoint
                                	**type**\:   :py:class:`Midpoint <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Midpoint>`
                                
                                .. attribute:: role
                                
                                	Role
                                	**type**\:   :py:class:`MgmtFibMplsLspRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MgmtFibMplsLspRole>`
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId, self).__init__()

                                    self.yang_name = "frr-entry-id"
                                    self.yang_parent_name = "frr-db"

                                    self.role = YLeaf(YType.enumeration, "role")

                                    self.head = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Head()
                                    self.head.parent = self
                                    self._children_name_map["head"] = "head"
                                    self._children_yang_names.add("head")

                                    self.midpoint = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Midpoint()
                                    self.midpoint.parent = self
                                    self._children_name_map["midpoint"] = "midpoint"
                                    self._children_yang_names.add("midpoint")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("role") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId, self).__setattr__(name, value)


                                class Head(Entity):
                                    """
                                    head
                                    
                                    .. attribute:: destination_prefix
                                    
                                    	Destination prefix
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: destination_prefix_length
                                    
                                    	Destination prefix length
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Head, self).__init__()

                                        self.yang_name = "head"
                                        self.yang_parent_name = "frr-entry-id"

                                        self.destination_prefix = YLeaf(YType.str, "destination-prefix")

                                        self.destination_prefix_length = YLeaf(YType.uint32, "destination-prefix-length")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("destination_prefix",
                                                        "destination_prefix_length") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Head, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Head, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.destination_prefix.is_set or
                                            self.destination_prefix_length.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.destination_prefix.yfilter != YFilter.not_set or
                                            self.destination_prefix_length.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "head" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.destination_prefix.is_set or self.destination_prefix.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.destination_prefix.get_name_leafdata())
                                        if (self.destination_prefix_length.is_set or self.destination_prefix_length.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.destination_prefix_length.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "destination-prefix" or name == "destination-prefix-length"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "destination-prefix"):
                                            self.destination_prefix = value
                                            self.destination_prefix.value_namespace = name_space
                                            self.destination_prefix.value_namespace_prefix = name_space_prefix
                                        if(value_path == "destination-prefix-length"):
                                            self.destination_prefix_length = value
                                            self.destination_prefix_length.value_namespace = name_space
                                            self.destination_prefix_length.value_namespace_prefix = name_space_prefix


                                class Midpoint(Entity):
                                    """
                                    midpoint
                                    
                                    .. attribute:: lspid
                                    
                                    	LSP ID
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: source_address
                                    
                                    	Source IPv4 address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: tunnel_id
                                    
                                    	Tunnel ID
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Midpoint, self).__init__()

                                        self.yang_name = "midpoint"
                                        self.yang_parent_name = "frr-entry-id"

                                        self.lspid = YLeaf(YType.uint32, "lspid")

                                        self.source_address = YLeaf(YType.str, "source-address")

                                        self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("lspid",
                                                        "source_address",
                                                        "tunnel_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Midpoint, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Midpoint, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.lspid.is_set or
                                            self.source_address.is_set or
                                            self.tunnel_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.lspid.yfilter != YFilter.not_set or
                                            self.source_address.yfilter != YFilter.not_set or
                                            self.tunnel_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "midpoint" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.lspid.is_set or self.lspid.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.lspid.get_name_leafdata())
                                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.source_address.get_name_leafdata())
                                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "lspid" or name == "source-address" or name == "tunnel-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "lspid"):
                                            self.lspid = value
                                            self.lspid.value_namespace = name_space
                                            self.lspid.value_namespace_prefix = name_space_prefix
                                        if(value_path == "source-address"):
                                            self.source_address = value
                                            self.source_address.value_namespace = name_space
                                            self.source_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tunnel-id"):
                                            self.tunnel_id = value
                                            self.tunnel_id.value_namespace = name_space
                                            self.tunnel_id.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.role.is_set or
                                        (self.head is not None and self.head.has_data()) or
                                        (self.midpoint is not None and self.midpoint.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.role.yfilter != YFilter.not_set or
                                        (self.head is not None and self.head.has_operation()) or
                                        (self.midpoint is not None and self.midpoint.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-entry-id" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.role.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "head"):
                                        if (self.head is None):
                                            self.head = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Head()
                                            self.head.parent = self
                                            self._children_name_map["head"] = "head"
                                        return self.head

                                    if (child_yang_name == "midpoint"):
                                        if (self.midpoint is None):
                                            self.midpoint = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId.Midpoint()
                                            self.midpoint.parent = self
                                            self._children_name_map["midpoint"] = "midpoint"
                                        return self.midpoint

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "head" or name == "midpoint" or name == "role"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "role"):
                                        self.role = value
                                        self.role.value_namespace = name_space
                                        self.role.value_namespace_prefix = name_space_prefix


                            class MulticastLeg(Entity):
                                """
                                MCAST legs
                                
                                .. attribute:: entry_frr_state
                                
                                	MPLS FRR entry state
                                	**type**\:   :py:class:`MgmtFibMplsFrrState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MgmtFibMplsFrrState>`
                                
                                .. attribute:: frr_entry_id
                                
                                	FRR entry ID
                                	**type**\:   :py:class:`FrrEntryId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId>`
                                
                                .. attribute:: frr_interface_name
                                
                                	FRR interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: frr_label
                                
                                	FRR output label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: frr_next_hop_ipv4_address
                                
                                	Next hop IPv4 address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: input_label
                                
                                	Input label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: is_mldp_lsp
                                
                                	MLDP or P2MP\-TE
                                	**type**\:  bool
                                
                                .. attribute:: outgoing_interface
                                
                                	Outgoing interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: outgoing_label
                                
                                	Outgoing label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: tunnel_interface_name
                                
                                	Tunnel interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg, self).__init__()

                                    self.yang_name = "multicast-leg"
                                    self.yang_parent_name = "frr-db"

                                    self.entry_frr_state = YLeaf(YType.enumeration, "entry-frr-state")

                                    self.frr_interface_name = YLeaf(YType.str, "frr-interface-name")

                                    self.frr_label = YLeaf(YType.uint32, "frr-label")

                                    self.frr_next_hop_ipv4_address = YLeaf(YType.str, "frr-next-hop-ipv4-address")

                                    self.input_label = YLeaf(YType.uint32, "input-label")

                                    self.is_mldp_lsp = YLeaf(YType.boolean, "is-mldp-lsp")

                                    self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                    self.outgoing_label = YLeaf(YType.uint32, "outgoing-label")

                                    self.tunnel_interface_name = YLeaf(YType.str, "tunnel-interface-name")

                                    self.frr_entry_id = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId()
                                    self.frr_entry_id.parent = self
                                    self._children_name_map["frr_entry_id"] = "frr-entry-id"
                                    self._children_yang_names.add("frr-entry-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry_frr_state",
                                                    "frr_interface_name",
                                                    "frr_label",
                                                    "frr_next_hop_ipv4_address",
                                                    "input_label",
                                                    "is_mldp_lsp",
                                                    "outgoing_interface",
                                                    "outgoing_label",
                                                    "tunnel_interface_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg, self).__setattr__(name, value)


                                class FrrEntryId(Entity):
                                    """
                                    FRR entry ID
                                    
                                    .. attribute:: head
                                    
                                    	head
                                    	**type**\:   :py:class:`Head <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Head>`
                                    
                                    .. attribute:: midpoint
                                    
                                    	midpoint
                                    	**type**\:   :py:class:`Midpoint <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Midpoint>`
                                    
                                    .. attribute:: role
                                    
                                    	Role
                                    	**type**\:   :py:class:`MgmtFibMplsLspRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MgmtFibMplsLspRole>`
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId, self).__init__()

                                        self.yang_name = "frr-entry-id"
                                        self.yang_parent_name = "multicast-leg"

                                        self.role = YLeaf(YType.enumeration, "role")

                                        self.head = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Head()
                                        self.head.parent = self
                                        self._children_name_map["head"] = "head"
                                        self._children_yang_names.add("head")

                                        self.midpoint = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Midpoint()
                                        self.midpoint.parent = self
                                        self._children_name_map["midpoint"] = "midpoint"
                                        self._children_yang_names.add("midpoint")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("role") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId, self).__setattr__(name, value)


                                    class Head(Entity):
                                        """
                                        head
                                        
                                        .. attribute:: destination_prefix
                                        
                                        	Destination prefix
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: destination_prefix_length
                                        
                                        	Destination prefix length
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Head, self).__init__()

                                            self.yang_name = "head"
                                            self.yang_parent_name = "frr-entry-id"

                                            self.destination_prefix = YLeaf(YType.str, "destination-prefix")

                                            self.destination_prefix_length = YLeaf(YType.uint32, "destination-prefix-length")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("destination_prefix",
                                                            "destination_prefix_length") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Head, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Head, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.destination_prefix.is_set or
                                                self.destination_prefix_length.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.destination_prefix.yfilter != YFilter.not_set or
                                                self.destination_prefix_length.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "head" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.destination_prefix.is_set or self.destination_prefix.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.destination_prefix.get_name_leafdata())
                                            if (self.destination_prefix_length.is_set or self.destination_prefix_length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.destination_prefix_length.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "destination-prefix" or name == "destination-prefix-length"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "destination-prefix"):
                                                self.destination_prefix = value
                                                self.destination_prefix.value_namespace = name_space
                                                self.destination_prefix.value_namespace_prefix = name_space_prefix
                                            if(value_path == "destination-prefix-length"):
                                                self.destination_prefix_length = value
                                                self.destination_prefix_length.value_namespace = name_space
                                                self.destination_prefix_length.value_namespace_prefix = name_space_prefix


                                    class Midpoint(Entity):
                                        """
                                        midpoint
                                        
                                        .. attribute:: lspid
                                        
                                        	LSP ID
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: source_address
                                        
                                        	Source IPv4 address
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: tunnel_id
                                        
                                        	Tunnel ID
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Midpoint, self).__init__()

                                            self.yang_name = "midpoint"
                                            self.yang_parent_name = "frr-entry-id"

                                            self.lspid = YLeaf(YType.uint32, "lspid")

                                            self.source_address = YLeaf(YType.str, "source-address")

                                            self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("lspid",
                                                            "source_address",
                                                            "tunnel_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Midpoint, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Midpoint, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.lspid.is_set or
                                                self.source_address.is_set or
                                                self.tunnel_id.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.lspid.yfilter != YFilter.not_set or
                                                self.source_address.yfilter != YFilter.not_set or
                                                self.tunnel_id.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "midpoint" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.lspid.is_set or self.lspid.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.lspid.get_name_leafdata())
                                            if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.source_address.get_name_leafdata())
                                            if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "lspid" or name == "source-address" or name == "tunnel-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "lspid"):
                                                self.lspid = value
                                                self.lspid.value_namespace = name_space
                                                self.lspid.value_namespace_prefix = name_space_prefix
                                            if(value_path == "source-address"):
                                                self.source_address = value
                                                self.source_address.value_namespace = name_space
                                                self.source_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "tunnel-id"):
                                                self.tunnel_id = value
                                                self.tunnel_id.value_namespace = name_space
                                                self.tunnel_id.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.role.is_set or
                                            (self.head is not None and self.head.has_data()) or
                                            (self.midpoint is not None and self.midpoint.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.role.yfilter != YFilter.not_set or
                                            (self.head is not None and self.head.has_operation()) or
                                            (self.midpoint is not None and self.midpoint.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-entry-id" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.role.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "head"):
                                            if (self.head is None):
                                                self.head = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Head()
                                                self.head.parent = self
                                                self._children_name_map["head"] = "head"
                                            return self.head

                                        if (child_yang_name == "midpoint"):
                                            if (self.midpoint is None):
                                                self.midpoint = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId.Midpoint()
                                                self.midpoint.parent = self
                                                self._children_name_map["midpoint"] = "midpoint"
                                            return self.midpoint

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "head" or name == "midpoint" or name == "role"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "role"):
                                            self.role = value
                                            self.role.value_namespace = name_space
                                            self.role.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.entry_frr_state.is_set or
                                        self.frr_interface_name.is_set or
                                        self.frr_label.is_set or
                                        self.frr_next_hop_ipv4_address.is_set or
                                        self.input_label.is_set or
                                        self.is_mldp_lsp.is_set or
                                        self.outgoing_interface.is_set or
                                        self.outgoing_label.is_set or
                                        self.tunnel_interface_name.is_set or
                                        (self.frr_entry_id is not None and self.frr_entry_id.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry_frr_state.yfilter != YFilter.not_set or
                                        self.frr_interface_name.yfilter != YFilter.not_set or
                                        self.frr_label.yfilter != YFilter.not_set or
                                        self.frr_next_hop_ipv4_address.yfilter != YFilter.not_set or
                                        self.input_label.yfilter != YFilter.not_set or
                                        self.is_mldp_lsp.yfilter != YFilter.not_set or
                                        self.outgoing_interface.yfilter != YFilter.not_set or
                                        self.outgoing_label.yfilter != YFilter.not_set or
                                        self.tunnel_interface_name.yfilter != YFilter.not_set or
                                        (self.frr_entry_id is not None and self.frr_entry_id.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "multicast-leg" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry_frr_state.is_set or self.entry_frr_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry_frr_state.get_name_leafdata())
                                    if (self.frr_interface_name.is_set or self.frr_interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.frr_interface_name.get_name_leafdata())
                                    if (self.frr_label.is_set or self.frr_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.frr_label.get_name_leafdata())
                                    if (self.frr_next_hop_ipv4_address.is_set or self.frr_next_hop_ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.frr_next_hop_ipv4_address.get_name_leafdata())
                                    if (self.input_label.is_set or self.input_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.input_label.get_name_leafdata())
                                    if (self.is_mldp_lsp.is_set or self.is_mldp_lsp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_mldp_lsp.get_name_leafdata())
                                    if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                    if (self.outgoing_label.is_set or self.outgoing_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_label.get_name_leafdata())
                                    if (self.tunnel_interface_name.is_set or self.tunnel_interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tunnel_interface_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-entry-id"):
                                        if (self.frr_entry_id is None):
                                            self.frr_entry_id = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg.FrrEntryId()
                                            self.frr_entry_id.parent = self
                                            self._children_name_map["frr_entry_id"] = "frr-entry-id"
                                        return self.frr_entry_id

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-entry-id" or name == "entry-frr-state" or name == "frr-interface-name" or name == "frr-label" or name == "frr-next-hop-ipv4-address" or name == "input-label" or name == "is-mldp-lsp" or name == "outgoing-interface" or name == "outgoing-label" or name == "tunnel-interface-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry-frr-state"):
                                        self.entry_frr_state = value
                                        self.entry_frr_state.value_namespace = name_space
                                        self.entry_frr_state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "frr-interface-name"):
                                        self.frr_interface_name = value
                                        self.frr_interface_name.value_namespace = name_space
                                        self.frr_interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "frr-label"):
                                        self.frr_label = value
                                        self.frr_label.value_namespace = name_space
                                        self.frr_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "frr-next-hop-ipv4-address"):
                                        self.frr_next_hop_ipv4_address = value
                                        self.frr_next_hop_ipv4_address.value_namespace = name_space
                                        self.frr_next_hop_ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "input-label"):
                                        self.input_label = value
                                        self.input_label.value_namespace = name_space
                                        self.input_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "is-mldp-lsp"):
                                        self.is_mldp_lsp = value
                                        self.is_mldp_lsp.value_namespace = name_space
                                        self.is_mldp_lsp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-interface"):
                                        self.outgoing_interface = value
                                        self.outgoing_interface.value_namespace = name_space
                                        self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-label"):
                                        self.outgoing_label = value
                                        self.outgoing_label.value_namespace = name_space
                                        self.outgoing_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tunnel-interface-name"):
                                        self.tunnel_interface_name = value
                                        self.tunnel_interface_name.value_namespace = name_space
                                        self.tunnel_interface_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.multicast_leg:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.entry_frr_state.is_set or
                                    self.frr_interface_name.is_set or
                                    self.frr_label.is_set or
                                    self.frr_next_hop_ipv4_address.is_set or
                                    self.input_label.is_set or
                                    self.is_mldp_lsp.is_set or
                                    self.is_multicast_tunnel.is_set or
                                    self.multicast_tunnel_legs.is_set or
                                    self.outgoing_interface.is_set or
                                    self.outgoing_label.is_set or
                                    self.tunnel_interface_name.is_set or
                                    (self.frr_entry_id is not None and self.frr_entry_id.has_data()))

                            def has_operation(self):
                                for c in self.multicast_leg:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry_frr_state.yfilter != YFilter.not_set or
                                    self.frr_interface_name.yfilter != YFilter.not_set or
                                    self.frr_label.yfilter != YFilter.not_set or
                                    self.frr_next_hop_ipv4_address.yfilter != YFilter.not_set or
                                    self.input_label.yfilter != YFilter.not_set or
                                    self.is_mldp_lsp.yfilter != YFilter.not_set or
                                    self.is_multicast_tunnel.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_legs.yfilter != YFilter.not_set or
                                    self.outgoing_interface.yfilter != YFilter.not_set or
                                    self.outgoing_label.yfilter != YFilter.not_set or
                                    self.tunnel_interface_name.yfilter != YFilter.not_set or
                                    (self.frr_entry_id is not None and self.frr_entry_id.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "frr-db" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry_frr_state.is_set or self.entry_frr_state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry_frr_state.get_name_leafdata())
                                if (self.frr_interface_name.is_set or self.frr_interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.frr_interface_name.get_name_leafdata())
                                if (self.frr_label.is_set or self.frr_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.frr_label.get_name_leafdata())
                                if (self.frr_next_hop_ipv4_address.is_set or self.frr_next_hop_ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.frr_next_hop_ipv4_address.get_name_leafdata())
                                if (self.input_label.is_set or self.input_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.input_label.get_name_leafdata())
                                if (self.is_mldp_lsp.is_set or self.is_mldp_lsp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_mldp_lsp.get_name_leafdata())
                                if (self.is_multicast_tunnel.is_set or self.is_multicast_tunnel.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_multicast_tunnel.get_name_leafdata())
                                if (self.multicast_tunnel_legs.is_set or self.multicast_tunnel_legs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_legs.get_name_leafdata())
                                if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                if (self.outgoing_label.is_set or self.outgoing_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_label.get_name_leafdata())
                                if (self.tunnel_interface_name.is_set or self.tunnel_interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_interface_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "frr-entry-id"):
                                    if (self.frr_entry_id is None):
                                        self.frr_entry_id = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.FrrEntryId()
                                        self.frr_entry_id.parent = self
                                        self._children_name_map["frr_entry_id"] = "frr-entry-id"
                                    return self.frr_entry_id

                                if (child_yang_name == "multicast-leg"):
                                    for c in self.multicast_leg:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb.MulticastLeg()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.multicast_leg.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "frr-entry-id" or name == "multicast-leg" or name == "entry-frr-state" or name == "frr-interface-name" or name == "frr-label" or name == "frr-next-hop-ipv4-address" or name == "input-label" or name == "is-mldp-lsp" or name == "is-multicast-tunnel" or name == "multicast-tunnel-legs" or name == "outgoing-interface" or name == "outgoing-label" or name == "tunnel-interface-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry-frr-state"):
                                    self.entry_frr_state = value
                                    self.entry_frr_state.value_namespace = name_space
                                    self.entry_frr_state.value_namespace_prefix = name_space_prefix
                                if(value_path == "frr-interface-name"):
                                    self.frr_interface_name = value
                                    self.frr_interface_name.value_namespace = name_space
                                    self.frr_interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "frr-label"):
                                    self.frr_label = value
                                    self.frr_label.value_namespace = name_space
                                    self.frr_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "frr-next-hop-ipv4-address"):
                                    self.frr_next_hop_ipv4_address = value
                                    self.frr_next_hop_ipv4_address.value_namespace = name_space
                                    self.frr_next_hop_ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "input-label"):
                                    self.input_label = value
                                    self.input_label.value_namespace = name_space
                                    self.input_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-mldp-lsp"):
                                    self.is_mldp_lsp = value
                                    self.is_mldp_lsp.value_namespace = name_space
                                    self.is_mldp_lsp.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-multicast-tunnel"):
                                    self.is_multicast_tunnel = value
                                    self.is_multicast_tunnel.value_namespace = name_space
                                    self.is_multicast_tunnel.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-legs"):
                                    self.multicast_tunnel_legs = value
                                    self.multicast_tunnel_legs.value_namespace = name_space
                                    self.multicast_tunnel_legs.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-interface"):
                                    self.outgoing_interface = value
                                    self.outgoing_interface.value_namespace = name_space
                                    self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-label"):
                                    self.outgoing_label = value
                                    self.outgoing_label.value_namespace = name_space
                                    self.outgoing_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-interface-name"):
                                    self.tunnel_interface_name = value
                                    self.tunnel_interface_name.value_namespace = name_space
                                    self.tunnel_interface_name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.local_label.is_set or
                                self.frr_lable_string.is_set or
                                self.outgoing_lable_string.is_set or
                                (self.frr_db is not None and self.frr_db.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.local_label.yfilter != YFilter.not_set or
                                self.frr_lable_string.yfilter != YFilter.not_set or
                                self.outgoing_lable_string.yfilter != YFilter.not_set or
                                (self.frr_db is not None and self.frr_db.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "frrdb-tunnel-midpoint" + "[local-label='" + self.local_label.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.local_label.is_set or self.local_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.local_label.get_name_leafdata())
                            if (self.frr_lable_string.is_set or self.frr_lable_string.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.frr_lable_string.get_name_leafdata())
                            if (self.outgoing_lable_string.is_set or self.outgoing_lable_string.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_lable_string.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "frr-db"):
                                if (self.frr_db is None):
                                    self.frr_db = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint.FrrDb()
                                    self.frr_db.parent = self
                                    self._children_name_map["frr_db"] = "frr-db"
                                return self.frr_db

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "frr-db" or name == "local-label" or name == "frr-lable-string" or name == "outgoing-lable-string"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "local-label"):
                                self.local_label = value
                                self.local_label.value_namespace = name_space
                                self.local_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "frr-lable-string"):
                                self.frr_lable_string = value
                                self.frr_lable_string.value_namespace = name_space
                                self.frr_lable_string.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-lable-string"):
                                self.outgoing_lable_string = value
                                self.outgoing_lable_string.value_namespace = name_space
                                self.outgoing_lable_string.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.frrdb_tunnel_midpoint:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.frrdb_tunnel_midpoint:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "frrdb-tunnel-midpoints" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "frrdb-tunnel-midpoint"):
                            for c in self.frrdb_tunnel_midpoint:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints.FrrdbTunnelMidpoint()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.frrdb_tunnel_midpoint.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "frrdb-tunnel-midpoint"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class FrrdbTunnelHeads(Entity):
                    """
                    MPLS forwarding FRR Database Tunnel Head
                    Table
                    
                    .. attribute:: frrdb_tunnel_head
                    
                    	MPLS forwarding FRR Database Tunnel Head Entry
                    	**type**\: list of    :py:class:`FrrdbTunnelHead <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads, self).__init__()

                        self.yang_name = "frrdb-tunnel-heads"
                        self.yang_parent_name = "frr-database"

                        self.frrdb_tunnel_head = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads, self).__setattr__(name, value)


                    class FrrdbTunnelHead(Entity):
                        """
                        MPLS forwarding FRR Database Tunnel Head
                        Entry
                        
                        .. attribute:: interface_name  <key>
                        
                        	Interface Name
                        	**type**\:  str
                        
                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                        
                        .. attribute:: frr_db
                        
                        	FRR DB
                        	**type**\:   :py:class:`FrrDb <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb>`
                        
                        .. attribute:: frr_lable_string
                        
                        	FRR label in string format
                        	**type**\:  str
                        
                        .. attribute:: outgoing_lable_string
                        
                        	Output label in string format
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead, self).__init__()

                            self.yang_name = "frrdb-tunnel-head"
                            self.yang_parent_name = "frrdb-tunnel-heads"

                            self.interface_name = YLeaf(YType.str, "interface-name")

                            self.frr_lable_string = YLeaf(YType.str, "frr-lable-string")

                            self.outgoing_lable_string = YLeaf(YType.str, "outgoing-lable-string")

                            self.frr_db = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb()
                            self.frr_db.parent = self
                            self._children_name_map["frr_db"] = "frr-db"
                            self._children_yang_names.add("frr-db")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("interface_name",
                                            "frr_lable_string",
                                            "outgoing_lable_string") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead, self).__setattr__(name, value)


                        class FrrDb(Entity):
                            """
                            FRR DB
                            
                            .. attribute:: entry_frr_state
                            
                            	MPLS FRR entry state
                            	**type**\:   :py:class:`MgmtFibMplsFrrState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MgmtFibMplsFrrState>`
                            
                            .. attribute:: frr_entry_id
                            
                            	FRR entry ID
                            	**type**\:   :py:class:`FrrEntryId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId>`
                            
                            .. attribute:: frr_interface_name
                            
                            	FRR interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: frr_label
                            
                            	FRR output label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: frr_next_hop_ipv4_address
                            
                            	Next hop IPv4 address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: input_label
                            
                            	Input label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: is_mldp_lsp
                            
                            	MLDP or P2MP\-TE
                            	**type**\:  bool
                            
                            .. attribute:: is_multicast_tunnel
                            
                            	Multicast tunnel
                            	**type**\:  bool
                            
                            .. attribute:: multicast_leg
                            
                            	MCAST legs
                            	**type**\: list of    :py:class:`MulticastLeg <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg>`
                            
                            .. attribute:: multicast_tunnel_legs
                            
                            	Number of legs in MCAST tunnel
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: outgoing_interface
                            
                            	Outgoing interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: outgoing_label
                            
                            	Outgoing label
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: tunnel_interface_name
                            
                            	Tunnel interface
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            

                            """

                            _prefix = 'fib-common-oper'
                            _revision = '2017-01-20'

                            def __init__(self):
                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb, self).__init__()

                                self.yang_name = "frr-db"
                                self.yang_parent_name = "frrdb-tunnel-head"

                                self.entry_frr_state = YLeaf(YType.enumeration, "entry-frr-state")

                                self.frr_interface_name = YLeaf(YType.str, "frr-interface-name")

                                self.frr_label = YLeaf(YType.uint32, "frr-label")

                                self.frr_next_hop_ipv4_address = YLeaf(YType.str, "frr-next-hop-ipv4-address")

                                self.input_label = YLeaf(YType.uint32, "input-label")

                                self.is_mldp_lsp = YLeaf(YType.boolean, "is-mldp-lsp")

                                self.is_multicast_tunnel = YLeaf(YType.boolean, "is-multicast-tunnel")

                                self.multicast_tunnel_legs = YLeaf(YType.uint32, "multicast-tunnel-legs")

                                self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                self.outgoing_label = YLeaf(YType.uint32, "outgoing-label")

                                self.tunnel_interface_name = YLeaf(YType.str, "tunnel-interface-name")

                                self.frr_entry_id = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId()
                                self.frr_entry_id.parent = self
                                self._children_name_map["frr_entry_id"] = "frr-entry-id"
                                self._children_yang_names.add("frr-entry-id")

                                self.multicast_leg = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("entry_frr_state",
                                                "frr_interface_name",
                                                "frr_label",
                                                "frr_next_hop_ipv4_address",
                                                "input_label",
                                                "is_mldp_lsp",
                                                "is_multicast_tunnel",
                                                "multicast_tunnel_legs",
                                                "outgoing_interface",
                                                "outgoing_label",
                                                "tunnel_interface_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb, self).__setattr__(name, value)


                            class FrrEntryId(Entity):
                                """
                                FRR entry ID
                                
                                .. attribute:: head
                                
                                	head
                                	**type**\:   :py:class:`Head <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Head>`
                                
                                .. attribute:: midpoint
                                
                                	midpoint
                                	**type**\:   :py:class:`Midpoint <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Midpoint>`
                                
                                .. attribute:: role
                                
                                	Role
                                	**type**\:   :py:class:`MgmtFibMplsLspRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MgmtFibMplsLspRole>`
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId, self).__init__()

                                    self.yang_name = "frr-entry-id"
                                    self.yang_parent_name = "frr-db"

                                    self.role = YLeaf(YType.enumeration, "role")

                                    self.head = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Head()
                                    self.head.parent = self
                                    self._children_name_map["head"] = "head"
                                    self._children_yang_names.add("head")

                                    self.midpoint = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Midpoint()
                                    self.midpoint.parent = self
                                    self._children_name_map["midpoint"] = "midpoint"
                                    self._children_yang_names.add("midpoint")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("role") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId, self).__setattr__(name, value)


                                class Head(Entity):
                                    """
                                    head
                                    
                                    .. attribute:: destination_prefix
                                    
                                    	Destination prefix
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: destination_prefix_length
                                    
                                    	Destination prefix length
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Head, self).__init__()

                                        self.yang_name = "head"
                                        self.yang_parent_name = "frr-entry-id"

                                        self.destination_prefix = YLeaf(YType.str, "destination-prefix")

                                        self.destination_prefix_length = YLeaf(YType.uint32, "destination-prefix-length")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("destination_prefix",
                                                        "destination_prefix_length") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Head, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Head, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.destination_prefix.is_set or
                                            self.destination_prefix_length.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.destination_prefix.yfilter != YFilter.not_set or
                                            self.destination_prefix_length.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "head" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.destination_prefix.is_set or self.destination_prefix.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.destination_prefix.get_name_leafdata())
                                        if (self.destination_prefix_length.is_set or self.destination_prefix_length.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.destination_prefix_length.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "destination-prefix" or name == "destination-prefix-length"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "destination-prefix"):
                                            self.destination_prefix = value
                                            self.destination_prefix.value_namespace = name_space
                                            self.destination_prefix.value_namespace_prefix = name_space_prefix
                                        if(value_path == "destination-prefix-length"):
                                            self.destination_prefix_length = value
                                            self.destination_prefix_length.value_namespace = name_space
                                            self.destination_prefix_length.value_namespace_prefix = name_space_prefix


                                class Midpoint(Entity):
                                    """
                                    midpoint
                                    
                                    .. attribute:: lspid
                                    
                                    	LSP ID
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: source_address
                                    
                                    	Source IPv4 address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: tunnel_id
                                    
                                    	Tunnel ID
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Midpoint, self).__init__()

                                        self.yang_name = "midpoint"
                                        self.yang_parent_name = "frr-entry-id"

                                        self.lspid = YLeaf(YType.uint32, "lspid")

                                        self.source_address = YLeaf(YType.str, "source-address")

                                        self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("lspid",
                                                        "source_address",
                                                        "tunnel_id") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Midpoint, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Midpoint, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.lspid.is_set or
                                            self.source_address.is_set or
                                            self.tunnel_id.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.lspid.yfilter != YFilter.not_set or
                                            self.source_address.yfilter != YFilter.not_set or
                                            self.tunnel_id.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "midpoint" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.lspid.is_set or self.lspid.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.lspid.get_name_leafdata())
                                        if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.source_address.get_name_leafdata())
                                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "lspid" or name == "source-address" or name == "tunnel-id"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "lspid"):
                                            self.lspid = value
                                            self.lspid.value_namespace = name_space
                                            self.lspid.value_namespace_prefix = name_space_prefix
                                        if(value_path == "source-address"):
                                            self.source_address = value
                                            self.source_address.value_namespace = name_space
                                            self.source_address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tunnel-id"):
                                            self.tunnel_id = value
                                            self.tunnel_id.value_namespace = name_space
                                            self.tunnel_id.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.role.is_set or
                                        (self.head is not None and self.head.has_data()) or
                                        (self.midpoint is not None and self.midpoint.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.role.yfilter != YFilter.not_set or
                                        (self.head is not None and self.head.has_operation()) or
                                        (self.midpoint is not None and self.midpoint.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "frr-entry-id" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.role.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "head"):
                                        if (self.head is None):
                                            self.head = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Head()
                                            self.head.parent = self
                                            self._children_name_map["head"] = "head"
                                        return self.head

                                    if (child_yang_name == "midpoint"):
                                        if (self.midpoint is None):
                                            self.midpoint = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId.Midpoint()
                                            self.midpoint.parent = self
                                            self._children_name_map["midpoint"] = "midpoint"
                                        return self.midpoint

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "head" or name == "midpoint" or name == "role"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "role"):
                                        self.role = value
                                        self.role.value_namespace = name_space
                                        self.role.value_namespace_prefix = name_space_prefix


                            class MulticastLeg(Entity):
                                """
                                MCAST legs
                                
                                .. attribute:: entry_frr_state
                                
                                	MPLS FRR entry state
                                	**type**\:   :py:class:`MgmtFibMplsFrrState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MgmtFibMplsFrrState>`
                                
                                .. attribute:: frr_entry_id
                                
                                	FRR entry ID
                                	**type**\:   :py:class:`FrrEntryId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId>`
                                
                                .. attribute:: frr_interface_name
                                
                                	FRR interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: frr_label
                                
                                	FRR output label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: frr_next_hop_ipv4_address
                                
                                	Next hop IPv4 address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: input_label
                                
                                	Input label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: is_mldp_lsp
                                
                                	MLDP or P2MP\-TE
                                	**type**\:  bool
                                
                                .. attribute:: outgoing_interface
                                
                                	Outgoing interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                .. attribute:: outgoing_label
                                
                                	Outgoing label
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: tunnel_interface_name
                                
                                	Tunnel interface
                                	**type**\:  str
                                
                                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                                
                                

                                """

                                _prefix = 'fib-common-oper'
                                _revision = '2017-01-20'

                                def __init__(self):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg, self).__init__()

                                    self.yang_name = "multicast-leg"
                                    self.yang_parent_name = "frr-db"

                                    self.entry_frr_state = YLeaf(YType.enumeration, "entry-frr-state")

                                    self.frr_interface_name = YLeaf(YType.str, "frr-interface-name")

                                    self.frr_label = YLeaf(YType.uint32, "frr-label")

                                    self.frr_next_hop_ipv4_address = YLeaf(YType.str, "frr-next-hop-ipv4-address")

                                    self.input_label = YLeaf(YType.uint32, "input-label")

                                    self.is_mldp_lsp = YLeaf(YType.boolean, "is-mldp-lsp")

                                    self.outgoing_interface = YLeaf(YType.str, "outgoing-interface")

                                    self.outgoing_label = YLeaf(YType.uint32, "outgoing-label")

                                    self.tunnel_interface_name = YLeaf(YType.str, "tunnel-interface-name")

                                    self.frr_entry_id = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId()
                                    self.frr_entry_id.parent = self
                                    self._children_name_map["frr_entry_id"] = "frr-entry-id"
                                    self._children_yang_names.add("frr-entry-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("entry_frr_state",
                                                    "frr_interface_name",
                                                    "frr_label",
                                                    "frr_next_hop_ipv4_address",
                                                    "input_label",
                                                    "is_mldp_lsp",
                                                    "outgoing_interface",
                                                    "outgoing_label",
                                                    "tunnel_interface_name") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg, self).__setattr__(name, value)


                                class FrrEntryId(Entity):
                                    """
                                    FRR entry ID
                                    
                                    .. attribute:: head
                                    
                                    	head
                                    	**type**\:   :py:class:`Head <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Head>`
                                    
                                    .. attribute:: midpoint
                                    
                                    	midpoint
                                    	**type**\:   :py:class:`Midpoint <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Midpoint>`
                                    
                                    .. attribute:: role
                                    
                                    	Role
                                    	**type**\:   :py:class:`MgmtFibMplsLspRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MgmtFibMplsLspRole>`
                                    
                                    

                                    """

                                    _prefix = 'fib-common-oper'
                                    _revision = '2017-01-20'

                                    def __init__(self):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId, self).__init__()

                                        self.yang_name = "frr-entry-id"
                                        self.yang_parent_name = "multicast-leg"

                                        self.role = YLeaf(YType.enumeration, "role")

                                        self.head = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Head()
                                        self.head.parent = self
                                        self._children_name_map["head"] = "head"
                                        self._children_yang_names.add("head")

                                        self.midpoint = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Midpoint()
                                        self.midpoint.parent = self
                                        self._children_name_map["midpoint"] = "midpoint"
                                        self._children_yang_names.add("midpoint")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("role") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId, self).__setattr__(name, value)


                                    class Head(Entity):
                                        """
                                        head
                                        
                                        .. attribute:: destination_prefix
                                        
                                        	Destination prefix
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: destination_prefix_length
                                        
                                        	Destination prefix length
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Head, self).__init__()

                                            self.yang_name = "head"
                                            self.yang_parent_name = "frr-entry-id"

                                            self.destination_prefix = YLeaf(YType.str, "destination-prefix")

                                            self.destination_prefix_length = YLeaf(YType.uint32, "destination-prefix-length")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("destination_prefix",
                                                            "destination_prefix_length") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Head, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Head, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.destination_prefix.is_set or
                                                self.destination_prefix_length.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.destination_prefix.yfilter != YFilter.not_set or
                                                self.destination_prefix_length.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "head" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.destination_prefix.is_set or self.destination_prefix.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.destination_prefix.get_name_leafdata())
                                            if (self.destination_prefix_length.is_set or self.destination_prefix_length.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.destination_prefix_length.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "destination-prefix" or name == "destination-prefix-length"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "destination-prefix"):
                                                self.destination_prefix = value
                                                self.destination_prefix.value_namespace = name_space
                                                self.destination_prefix.value_namespace_prefix = name_space_prefix
                                            if(value_path == "destination-prefix-length"):
                                                self.destination_prefix_length = value
                                                self.destination_prefix_length.value_namespace = name_space
                                                self.destination_prefix_length.value_namespace_prefix = name_space_prefix


                                    class Midpoint(Entity):
                                        """
                                        midpoint
                                        
                                        .. attribute:: lspid
                                        
                                        	LSP ID
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: source_address
                                        
                                        	Source IPv4 address
                                        	**type**\:  str
                                        
                                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                        
                                        .. attribute:: tunnel_id
                                        
                                        	Tunnel ID
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'fib-common-oper'
                                        _revision = '2017-01-20'

                                        def __init__(self):
                                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Midpoint, self).__init__()

                                            self.yang_name = "midpoint"
                                            self.yang_parent_name = "frr-entry-id"

                                            self.lspid = YLeaf(YType.uint32, "lspid")

                                            self.source_address = YLeaf(YType.str, "source-address")

                                            self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("lspid",
                                                            "source_address",
                                                            "tunnel_id") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Midpoint, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Midpoint, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.lspid.is_set or
                                                self.source_address.is_set or
                                                self.tunnel_id.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.lspid.yfilter != YFilter.not_set or
                                                self.source_address.yfilter != YFilter.not_set or
                                                self.tunnel_id.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "midpoint" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.lspid.is_set or self.lspid.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.lspid.get_name_leafdata())
                                            if (self.source_address.is_set or self.source_address.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.source_address.get_name_leafdata())
                                            if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "lspid" or name == "source-address" or name == "tunnel-id"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "lspid"):
                                                self.lspid = value
                                                self.lspid.value_namespace = name_space
                                                self.lspid.value_namespace_prefix = name_space_prefix
                                            if(value_path == "source-address"):
                                                self.source_address = value
                                                self.source_address.value_namespace = name_space
                                                self.source_address.value_namespace_prefix = name_space_prefix
                                            if(value_path == "tunnel-id"):
                                                self.tunnel_id = value
                                                self.tunnel_id.value_namespace = name_space
                                                self.tunnel_id.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.role.is_set or
                                            (self.head is not None and self.head.has_data()) or
                                            (self.midpoint is not None and self.midpoint.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.role.yfilter != YFilter.not_set or
                                            (self.head is not None and self.head.has_operation()) or
                                            (self.midpoint is not None and self.midpoint.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-entry-id" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.role.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "head"):
                                            if (self.head is None):
                                                self.head = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Head()
                                                self.head.parent = self
                                                self._children_name_map["head"] = "head"
                                            return self.head

                                        if (child_yang_name == "midpoint"):
                                            if (self.midpoint is None):
                                                self.midpoint = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId.Midpoint()
                                                self.midpoint.parent = self
                                                self._children_name_map["midpoint"] = "midpoint"
                                            return self.midpoint

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "head" or name == "midpoint" or name == "role"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "role"):
                                            self.role = value
                                            self.role.value_namespace = name_space
                                            self.role.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    return (
                                        self.entry_frr_state.is_set or
                                        self.frr_interface_name.is_set or
                                        self.frr_label.is_set or
                                        self.frr_next_hop_ipv4_address.is_set or
                                        self.input_label.is_set or
                                        self.is_mldp_lsp.is_set or
                                        self.outgoing_interface.is_set or
                                        self.outgoing_label.is_set or
                                        self.tunnel_interface_name.is_set or
                                        (self.frr_entry_id is not None and self.frr_entry_id.has_data()))

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.entry_frr_state.yfilter != YFilter.not_set or
                                        self.frr_interface_name.yfilter != YFilter.not_set or
                                        self.frr_label.yfilter != YFilter.not_set or
                                        self.frr_next_hop_ipv4_address.yfilter != YFilter.not_set or
                                        self.input_label.yfilter != YFilter.not_set or
                                        self.is_mldp_lsp.yfilter != YFilter.not_set or
                                        self.outgoing_interface.yfilter != YFilter.not_set or
                                        self.outgoing_label.yfilter != YFilter.not_set or
                                        self.tunnel_interface_name.yfilter != YFilter.not_set or
                                        (self.frr_entry_id is not None and self.frr_entry_id.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "multicast-leg" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.entry_frr_state.is_set or self.entry_frr_state.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.entry_frr_state.get_name_leafdata())
                                    if (self.frr_interface_name.is_set or self.frr_interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.frr_interface_name.get_name_leafdata())
                                    if (self.frr_label.is_set or self.frr_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.frr_label.get_name_leafdata())
                                    if (self.frr_next_hop_ipv4_address.is_set or self.frr_next_hop_ipv4_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.frr_next_hop_ipv4_address.get_name_leafdata())
                                    if (self.input_label.is_set or self.input_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.input_label.get_name_leafdata())
                                    if (self.is_mldp_lsp.is_set or self.is_mldp_lsp.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.is_mldp_lsp.get_name_leafdata())
                                    if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                    if (self.outgoing_label.is_set or self.outgoing_label.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.outgoing_label.get_name_leafdata())
                                    if (self.tunnel_interface_name.is_set or self.tunnel_interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tunnel_interface_name.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-entry-id"):
                                        if (self.frr_entry_id is None):
                                            self.frr_entry_id = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg.FrrEntryId()
                                            self.frr_entry_id.parent = self
                                            self._children_name_map["frr_entry_id"] = "frr-entry-id"
                                        return self.frr_entry_id

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-entry-id" or name == "entry-frr-state" or name == "frr-interface-name" or name == "frr-label" or name == "frr-next-hop-ipv4-address" or name == "input-label" or name == "is-mldp-lsp" or name == "outgoing-interface" or name == "outgoing-label" or name == "tunnel-interface-name"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "entry-frr-state"):
                                        self.entry_frr_state = value
                                        self.entry_frr_state.value_namespace = name_space
                                        self.entry_frr_state.value_namespace_prefix = name_space_prefix
                                    if(value_path == "frr-interface-name"):
                                        self.frr_interface_name = value
                                        self.frr_interface_name.value_namespace = name_space
                                        self.frr_interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "frr-label"):
                                        self.frr_label = value
                                        self.frr_label.value_namespace = name_space
                                        self.frr_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "frr-next-hop-ipv4-address"):
                                        self.frr_next_hop_ipv4_address = value
                                        self.frr_next_hop_ipv4_address.value_namespace = name_space
                                        self.frr_next_hop_ipv4_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "input-label"):
                                        self.input_label = value
                                        self.input_label.value_namespace = name_space
                                        self.input_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "is-mldp-lsp"):
                                        self.is_mldp_lsp = value
                                        self.is_mldp_lsp.value_namespace = name_space
                                        self.is_mldp_lsp.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-interface"):
                                        self.outgoing_interface = value
                                        self.outgoing_interface.value_namespace = name_space
                                        self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                    if(value_path == "outgoing-label"):
                                        self.outgoing_label = value
                                        self.outgoing_label.value_namespace = name_space
                                        self.outgoing_label.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tunnel-interface-name"):
                                        self.tunnel_interface_name = value
                                        self.tunnel_interface_name.value_namespace = name_space
                                        self.tunnel_interface_name.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.multicast_leg:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.entry_frr_state.is_set or
                                    self.frr_interface_name.is_set or
                                    self.frr_label.is_set or
                                    self.frr_next_hop_ipv4_address.is_set or
                                    self.input_label.is_set or
                                    self.is_mldp_lsp.is_set or
                                    self.is_multicast_tunnel.is_set or
                                    self.multicast_tunnel_legs.is_set or
                                    self.outgoing_interface.is_set or
                                    self.outgoing_label.is_set or
                                    self.tunnel_interface_name.is_set or
                                    (self.frr_entry_id is not None and self.frr_entry_id.has_data()))

                            def has_operation(self):
                                for c in self.multicast_leg:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.entry_frr_state.yfilter != YFilter.not_set or
                                    self.frr_interface_name.yfilter != YFilter.not_set or
                                    self.frr_label.yfilter != YFilter.not_set or
                                    self.frr_next_hop_ipv4_address.yfilter != YFilter.not_set or
                                    self.input_label.yfilter != YFilter.not_set or
                                    self.is_mldp_lsp.yfilter != YFilter.not_set or
                                    self.is_multicast_tunnel.yfilter != YFilter.not_set or
                                    self.multicast_tunnel_legs.yfilter != YFilter.not_set or
                                    self.outgoing_interface.yfilter != YFilter.not_set or
                                    self.outgoing_label.yfilter != YFilter.not_set or
                                    self.tunnel_interface_name.yfilter != YFilter.not_set or
                                    (self.frr_entry_id is not None and self.frr_entry_id.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "frr-db" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.entry_frr_state.is_set or self.entry_frr_state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.entry_frr_state.get_name_leafdata())
                                if (self.frr_interface_name.is_set or self.frr_interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.frr_interface_name.get_name_leafdata())
                                if (self.frr_label.is_set or self.frr_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.frr_label.get_name_leafdata())
                                if (self.frr_next_hop_ipv4_address.is_set or self.frr_next_hop_ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.frr_next_hop_ipv4_address.get_name_leafdata())
                                if (self.input_label.is_set or self.input_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.input_label.get_name_leafdata())
                                if (self.is_mldp_lsp.is_set or self.is_mldp_lsp.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_mldp_lsp.get_name_leafdata())
                                if (self.is_multicast_tunnel.is_set or self.is_multicast_tunnel.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_multicast_tunnel.get_name_leafdata())
                                if (self.multicast_tunnel_legs.is_set or self.multicast_tunnel_legs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.multicast_tunnel_legs.get_name_leafdata())
                                if (self.outgoing_interface.is_set or self.outgoing_interface.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_interface.get_name_leafdata())
                                if (self.outgoing_label.is_set or self.outgoing_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_label.get_name_leafdata())
                                if (self.tunnel_interface_name.is_set or self.tunnel_interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.tunnel_interface_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "frr-entry-id"):
                                    if (self.frr_entry_id is None):
                                        self.frr_entry_id = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.FrrEntryId()
                                        self.frr_entry_id.parent = self
                                        self._children_name_map["frr_entry_id"] = "frr-entry-id"
                                    return self.frr_entry_id

                                if (child_yang_name == "multicast-leg"):
                                    for c in self.multicast_leg:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb.MulticastLeg()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.multicast_leg.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "frr-entry-id" or name == "multicast-leg" or name == "entry-frr-state" or name == "frr-interface-name" or name == "frr-label" or name == "frr-next-hop-ipv4-address" or name == "input-label" or name == "is-mldp-lsp" or name == "is-multicast-tunnel" or name == "multicast-tunnel-legs" or name == "outgoing-interface" or name == "outgoing-label" or name == "tunnel-interface-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "entry-frr-state"):
                                    self.entry_frr_state = value
                                    self.entry_frr_state.value_namespace = name_space
                                    self.entry_frr_state.value_namespace_prefix = name_space_prefix
                                if(value_path == "frr-interface-name"):
                                    self.frr_interface_name = value
                                    self.frr_interface_name.value_namespace = name_space
                                    self.frr_interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "frr-label"):
                                    self.frr_label = value
                                    self.frr_label.value_namespace = name_space
                                    self.frr_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "frr-next-hop-ipv4-address"):
                                    self.frr_next_hop_ipv4_address = value
                                    self.frr_next_hop_ipv4_address.value_namespace = name_space
                                    self.frr_next_hop_ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "input-label"):
                                    self.input_label = value
                                    self.input_label.value_namespace = name_space
                                    self.input_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-mldp-lsp"):
                                    self.is_mldp_lsp = value
                                    self.is_mldp_lsp.value_namespace = name_space
                                    self.is_mldp_lsp.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-multicast-tunnel"):
                                    self.is_multicast_tunnel = value
                                    self.is_multicast_tunnel.value_namespace = name_space
                                    self.is_multicast_tunnel.value_namespace_prefix = name_space_prefix
                                if(value_path == "multicast-tunnel-legs"):
                                    self.multicast_tunnel_legs = value
                                    self.multicast_tunnel_legs.value_namespace = name_space
                                    self.multicast_tunnel_legs.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-interface"):
                                    self.outgoing_interface = value
                                    self.outgoing_interface.value_namespace = name_space
                                    self.outgoing_interface.value_namespace_prefix = name_space_prefix
                                if(value_path == "outgoing-label"):
                                    self.outgoing_label = value
                                    self.outgoing_label.value_namespace = name_space
                                    self.outgoing_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "tunnel-interface-name"):
                                    self.tunnel_interface_name = value
                                    self.tunnel_interface_name.value_namespace = name_space
                                    self.tunnel_interface_name.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.interface_name.is_set or
                                self.frr_lable_string.is_set or
                                self.outgoing_lable_string.is_set or
                                (self.frr_db is not None and self.frr_db.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.interface_name.yfilter != YFilter.not_set or
                                self.frr_lable_string.yfilter != YFilter.not_set or
                                self.outgoing_lable_string.yfilter != YFilter.not_set or
                                (self.frr_db is not None and self.frr_db.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "frrdb-tunnel-head" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_name.get_name_leafdata())
                            if (self.frr_lable_string.is_set or self.frr_lable_string.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.frr_lable_string.get_name_leafdata())
                            if (self.outgoing_lable_string.is_set or self.outgoing_lable_string.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.outgoing_lable_string.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "frr-db"):
                                if (self.frr_db is None):
                                    self.frr_db = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead.FrrDb()
                                    self.frr_db.parent = self
                                    self._children_name_map["frr_db"] = "frr-db"
                                return self.frr_db

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "frr-db" or name == "interface-name" or name == "frr-lable-string" or name == "outgoing-lable-string"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "interface-name"):
                                self.interface_name = value
                                self.interface_name.value_namespace = name_space
                                self.interface_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "frr-lable-string"):
                                self.frr_lable_string = value
                                self.frr_lable_string.value_namespace = name_space
                                self.frr_lable_string.value_namespace_prefix = name_space_prefix
                            if(value_path == "outgoing-lable-string"):
                                self.outgoing_lable_string = value
                                self.outgoing_lable_string.value_namespace = name_space
                                self.outgoing_lable_string.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.frrdb_tunnel_head:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.frrdb_tunnel_head:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "frrdb-tunnel-heads" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "frrdb-tunnel-head"):
                            for c in self.frrdb_tunnel_head:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads.FrrdbTunnelHead()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.frrdb_tunnel_head.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "frrdb-tunnel-head"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class FrrdbTunnelHeadSummary(Entity):
                    """
                    MPLS forwarding FRR Database Tunnel Head
                    Summary
                    
                    .. attribute:: active
                    
                    	Number of FRR rewrites in Active state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: other
                    
                    	Number of FRR rewrites in an unrecognized state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: partial
                    
                    	Number of FRR rewrites in Partial state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: ready
                    
                    	Number of FRR rewrites in Ready state
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeadSummary, self).__init__()

                        self.yang_name = "frrdb-tunnel-head-summary"
                        self.yang_parent_name = "frr-database"

                        self.active = YLeaf(YType.uint32, "active")

                        self.other = YLeaf(YType.uint32, "other")

                        self.partial = YLeaf(YType.uint32, "partial")

                        self.ready = YLeaf(YType.uint32, "ready")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("active",
                                        "other",
                                        "partial",
                                        "ready") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeadSummary, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeadSummary, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.active.is_set or
                            self.other.is_set or
                            self.partial.is_set or
                            self.ready.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.active.yfilter != YFilter.not_set or
                            self.other.yfilter != YFilter.not_set or
                            self.partial.yfilter != YFilter.not_set or
                            self.ready.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "frrdb-tunnel-head-summary" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.active.is_set or self.active.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.active.get_name_leafdata())
                        if (self.other.is_set or self.other.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.other.get_name_leafdata())
                        if (self.partial.is_set or self.partial.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.partial.get_name_leafdata())
                        if (self.ready.is_set or self.ready.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ready.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "active" or name == "other" or name == "partial" or name == "ready"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "active"):
                            self.active = value
                            self.active.value_namespace = name_space
                            self.active.value_namespace_prefix = name_space_prefix
                        if(value_path == "other"):
                            self.other = value
                            self.other.value_namespace = name_space
                            self.other.value_namespace_prefix = name_space_prefix
                        if(value_path == "partial"):
                            self.partial = value
                            self.partial.value_namespace = name_space
                            self.partial.value_namespace_prefix = name_space_prefix
                        if(value_path == "ready"):
                            self.ready = value
                            self.ready.value_namespace = name_space
                            self.ready.value_namespace_prefix = name_space_prefix


                class FrrdbBackupInterfaceSummaries(Entity):
                    """
                    MPLS forwarding FRR Database Backup Interface
                    Summary Table
                    
                    .. attribute:: frrdb_backup_interface_summary
                    
                    	MPLS forwarding FRR Database Backup Interface Summary
                    	**type**\: list of    :py:class:`FrrdbBackupInterfaceSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_fib_common_oper.MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries.FrrdbBackupInterfaceSummary>`
                    
                    

                    """

                    _prefix = 'fib-common-oper'
                    _revision = '2017-01-20'

                    def __init__(self):
                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries, self).__init__()

                        self.yang_name = "frrdb-backup-interface-summaries"
                        self.yang_parent_name = "frr-database"

                        self.frrdb_backup_interface_summary = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries, self).__setattr__(name, value)


                    class FrrdbBackupInterfaceSummary(Entity):
                        """
                        MPLS forwarding FRR Database Backup
                        Interface Summary
                        
                        .. attribute:: interface_name  <key>
                        
                        	Interface Name
                        	**type**\:  str
                        
                        	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                        
                        .. attribute:: active
                        
                        	Number of FRR rewrites in Active state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: other
                        
                        	Number of FRR rewrites in an unrecognized state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: partial
                        
                        	Number of FRR rewrites in Partial state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ready
                        
                        	Number of FRR rewrites in Ready state
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'fib-common-oper'
                        _revision = '2017-01-20'

                        def __init__(self):
                            super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries.FrrdbBackupInterfaceSummary, self).__init__()

                            self.yang_name = "frrdb-backup-interface-summary"
                            self.yang_parent_name = "frrdb-backup-interface-summaries"

                            self.interface_name = YLeaf(YType.str, "interface-name")

                            self.active = YLeaf(YType.uint32, "active")

                            self.other = YLeaf(YType.uint32, "other")

                            self.partial = YLeaf(YType.uint32, "partial")

                            self.ready = YLeaf(YType.uint32, "ready")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("interface_name",
                                            "active",
                                            "other",
                                            "partial",
                                            "ready") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries.FrrdbBackupInterfaceSummary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries.FrrdbBackupInterfaceSummary, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.interface_name.is_set or
                                self.active.is_set or
                                self.other.is_set or
                                self.partial.is_set or
                                self.ready.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.interface_name.yfilter != YFilter.not_set or
                                self.active.yfilter != YFilter.not_set or
                                self.other.yfilter != YFilter.not_set or
                                self.partial.yfilter != YFilter.not_set or
                                self.ready.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "frrdb-backup-interface-summary" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.interface_name.get_name_leafdata())
                            if (self.active.is_set or self.active.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.active.get_name_leafdata())
                            if (self.other.is_set or self.other.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.other.get_name_leafdata())
                            if (self.partial.is_set or self.partial.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.partial.get_name_leafdata())
                            if (self.ready.is_set or self.ready.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ready.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "interface-name" or name == "active" or name == "other" or name == "partial" or name == "ready"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "interface-name"):
                                self.interface_name = value
                                self.interface_name.value_namespace = name_space
                                self.interface_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "active"):
                                self.active = value
                                self.active.value_namespace = name_space
                                self.active.value_namespace_prefix = name_space_prefix
                            if(value_path == "other"):
                                self.other = value
                                self.other.value_namespace = name_space
                                self.other.value_namespace_prefix = name_space_prefix
                            if(value_path == "partial"):
                                self.partial = value
                                self.partial.value_namespace = name_space
                                self.partial.value_namespace_prefix = name_space_prefix
                            if(value_path == "ready"):
                                self.ready = value
                                self.ready.value_namespace = name_space
                                self.ready.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.frrdb_backup_interface_summary:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.frrdb_backup_interface_summary:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "frrdb-backup-interface-summaries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "frrdb-backup-interface-summary"):
                            for c in self.frrdb_backup_interface_summary:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries.FrrdbBackupInterfaceSummary()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.frrdb_backup_interface_summary.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "frrdb-backup-interface-summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.frrdb_backup_interface_summaries is not None and self.frrdb_backup_interface_summaries.has_data()) or
                        (self.frrdb_protected_interface_table_summaries is not None and self.frrdb_protected_interface_table_summaries.has_data()) or
                        (self.frrdb_summary is not None and self.frrdb_summary.has_data()) or
                        (self.frrdb_tunnel_head_summary is not None and self.frrdb_tunnel_head_summary.has_data()) or
                        (self.frrdb_tunnel_heads is not None and self.frrdb_tunnel_heads.has_data()) or
                        (self.frrdb_tunnel_midpoint_summary is not None and self.frrdb_tunnel_midpoint_summary.has_data()) or
                        (self.frrdb_tunnel_midpoints is not None and self.frrdb_tunnel_midpoints.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.frrdb_backup_interface_summaries is not None and self.frrdb_backup_interface_summaries.has_operation()) or
                        (self.frrdb_protected_interface_table_summaries is not None and self.frrdb_protected_interface_table_summaries.has_operation()) or
                        (self.frrdb_summary is not None and self.frrdb_summary.has_operation()) or
                        (self.frrdb_tunnel_head_summary is not None and self.frrdb_tunnel_head_summary.has_operation()) or
                        (self.frrdb_tunnel_heads is not None and self.frrdb_tunnel_heads.has_operation()) or
                        (self.frrdb_tunnel_midpoint_summary is not None and self.frrdb_tunnel_midpoint_summary.has_operation()) or
                        (self.frrdb_tunnel_midpoints is not None and self.frrdb_tunnel_midpoints.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "frr-database" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "frrdb-backup-interface-summaries"):
                        if (self.frrdb_backup_interface_summaries is None):
                            self.frrdb_backup_interface_summaries = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbBackupInterfaceSummaries()
                            self.frrdb_backup_interface_summaries.parent = self
                            self._children_name_map["frrdb_backup_interface_summaries"] = "frrdb-backup-interface-summaries"
                        return self.frrdb_backup_interface_summaries

                    if (child_yang_name == "frrdb-protected-interface-table-summaries"):
                        if (self.frrdb_protected_interface_table_summaries is None):
                            self.frrdb_protected_interface_table_summaries = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbProtectedInterfaceTableSummaries()
                            self.frrdb_protected_interface_table_summaries.parent = self
                            self._children_name_map["frrdb_protected_interface_table_summaries"] = "frrdb-protected-interface-table-summaries"
                        return self.frrdb_protected_interface_table_summaries

                    if (child_yang_name == "frrdb-summary"):
                        if (self.frrdb_summary is None):
                            self.frrdb_summary = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbSummary()
                            self.frrdb_summary.parent = self
                            self._children_name_map["frrdb_summary"] = "frrdb-summary"
                        return self.frrdb_summary

                    if (child_yang_name == "frrdb-tunnel-head-summary"):
                        if (self.frrdb_tunnel_head_summary is None):
                            self.frrdb_tunnel_head_summary = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeadSummary()
                            self.frrdb_tunnel_head_summary.parent = self
                            self._children_name_map["frrdb_tunnel_head_summary"] = "frrdb-tunnel-head-summary"
                        return self.frrdb_tunnel_head_summary

                    if (child_yang_name == "frrdb-tunnel-heads"):
                        if (self.frrdb_tunnel_heads is None):
                            self.frrdb_tunnel_heads = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelHeads()
                            self.frrdb_tunnel_heads.parent = self
                            self._children_name_map["frrdb_tunnel_heads"] = "frrdb-tunnel-heads"
                        return self.frrdb_tunnel_heads

                    if (child_yang_name == "frrdb-tunnel-midpoint-summary"):
                        if (self.frrdb_tunnel_midpoint_summary is None):
                            self.frrdb_tunnel_midpoint_summary = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpointSummary()
                            self.frrdb_tunnel_midpoint_summary.parent = self
                            self._children_name_map["frrdb_tunnel_midpoint_summary"] = "frrdb-tunnel-midpoint-summary"
                        return self.frrdb_tunnel_midpoint_summary

                    if (child_yang_name == "frrdb-tunnel-midpoints"):
                        if (self.frrdb_tunnel_midpoints is None):
                            self.frrdb_tunnel_midpoints = MplsForwarding.Nodes.Node.FrrDatabase.FrrdbTunnelMidpoints()
                            self.frrdb_tunnel_midpoints.parent = self
                            self._children_name_map["frrdb_tunnel_midpoints"] = "frrdb-tunnel-midpoints"
                        return self.frrdb_tunnel_midpoints

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "frrdb-backup-interface-summaries" or name == "frrdb-protected-interface-table-summaries" or name == "frrdb-summary" or name == "frrdb-tunnel-head-summary" or name == "frrdb-tunnel-heads" or name == "frrdb-tunnel-midpoint-summary" or name == "frrdb-tunnel-midpoints"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.node_name.is_set or
                    (self.forwarding_summary is not None and self.forwarding_summary.has_data()) or
                    (self.frr_database is not None and self.frr_database.has_data()) or
                    (self.frr_logs is not None and self.frr_logs.has_data()) or
                    (self.label_fib is not None and self.label_fib.has_data()) or
                    (self.tunnel is not None and self.tunnel.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.node_name.yfilter != YFilter.not_set or
                    (self.forwarding_summary is not None and self.forwarding_summary.has_operation()) or
                    (self.frr_database is not None and self.frr_database.has_operation()) or
                    (self.frr_logs is not None and self.frr_logs.has_operation()) or
                    (self.label_fib is not None and self.label_fib.has_operation()) or
                    (self.tunnel is not None and self.tunnel.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node" + "[node-name='" + self.node_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-fib-common-oper:mpls-forwarding/nodes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "forwarding-summary"):
                    if (self.forwarding_summary is None):
                        self.forwarding_summary = MplsForwarding.Nodes.Node.ForwardingSummary()
                        self.forwarding_summary.parent = self
                        self._children_name_map["forwarding_summary"] = "forwarding-summary"
                    return self.forwarding_summary

                if (child_yang_name == "frr-database"):
                    if (self.frr_database is None):
                        self.frr_database = MplsForwarding.Nodes.Node.FrrDatabase()
                        self.frr_database.parent = self
                        self._children_name_map["frr_database"] = "frr-database"
                    return self.frr_database

                if (child_yang_name == "frr-logs"):
                    if (self.frr_logs is None):
                        self.frr_logs = MplsForwarding.Nodes.Node.FrrLogs()
                        self.frr_logs.parent = self
                        self._children_name_map["frr_logs"] = "frr-logs"
                    return self.frr_logs

                if (child_yang_name == "label-fib"):
                    if (self.label_fib is None):
                        self.label_fib = MplsForwarding.Nodes.Node.LabelFib()
                        self.label_fib.parent = self
                        self._children_name_map["label_fib"] = "label-fib"
                    return self.label_fib

                if (child_yang_name == "tunnel"):
                    if (self.tunnel is None):
                        self.tunnel = MplsForwarding.Nodes.Node.Tunnel()
                        self.tunnel.parent = self
                        self._children_name_map["tunnel"] = "tunnel"
                    return self.tunnel

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "forwarding-summary" or name == "frr-database" or name == "frr-logs" or name == "label-fib" or name == "tunnel" or name == "node-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "node-name"):
                    self.node_name = value
                    self.node_name.value_namespace = name_space
                    self.node_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "nodes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-fib-common-oper:mpls-forwarding/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node"):
                for c in self.node:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = MplsForwarding.Nodes.Node()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (self.nodes is not None and self.nodes.has_data())

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.nodes is not None and self.nodes.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-fib-common-oper:mpls-forwarding" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "nodes"):
            if (self.nodes is None):
                self.nodes = MplsForwarding.Nodes()
                self.nodes.parent = self
                self._children_name_map["nodes"] = "nodes"
            return self.nodes

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "nodes"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = MplsForwarding()
        return self._top_entity

