""" Cisco_IOS_XR_infra_rcmd_oper 

This module contains a collection of YANG definitions
for Cisco IOS\-XR infra\-rcmd package operational data.

This module contains definitions
for the following management objects\:
  rcmd\: Show command for Route Convergence Monitoring &
    Diagnostics

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class RcmdBagEnableDisable(Enum):
    """
    RcmdBagEnableDisable

    status enum

    .. data:: disable = 0

    	Disabled

    .. data:: enable = 1

    	Enabled

    """

    disable = Enum.YLeaf(0, "disable")

    enable = Enum.YLeaf(1, "enable")


class RcmdBagEnblDsbl(Enum):
    """
    RcmdBagEnblDsbl

    status enum

    .. data:: dsbl = 0

    	Disabled

    .. data:: enbl = 1

    	Enabled

    """

    dsbl = Enum.YLeaf(0, "dsbl")

    enbl = Enum.YLeaf(1, "enbl")


class RcmdBoolYesNo(Enum):
    """
    RcmdBoolYesNo

    Boolean enum

    .. data:: no = 0

    	No

    .. data:: yes = 1

    	Yes

    """

    no = Enum.YLeaf(0, "no")

    yes = Enum.YLeaf(1, "yes")


class RcmdChange(Enum):
    """
    RcmdChange

    Type of change

    .. data:: none = 0

    	Invalid

    .. data:: add = 1

    	Added

    .. data:: delete = 2

    	Deleted

    .. data:: modify = 3

    	Modified

    .. data:: no_change = 4

    	No Change

    """

    none = Enum.YLeaf(0, "none")

    add = Enum.YLeaf(1, "add")

    delete = Enum.YLeaf(2, "delete")

    modify = Enum.YLeaf(3, "modify")

    no_change = Enum.YLeaf(4, "no-change")


class RcmdIsisLvl(Enum):
    """
    RcmdIsisLvl

    Type of an ISIS Level

    .. data:: l1 = 0

    	Level 1

    .. data:: l2 = 1

    	Level 2

    """

    l1 = Enum.YLeaf(0, "l1")

    l2 = Enum.YLeaf(1, "l2")


class RcmdIsisSpf(Enum):
    """
    RcmdIsisSpf

    Type of an ISIS SPF run

    .. data:: full = 0

    	Full

    .. data:: incremental = 1

    	Incremental

    .. data:: next_hop = 2

    	Next hop calculation

    .. data:: partial_route = 3

    	Partial route calculation

    """

    full = Enum.YLeaf(0, "full")

    incremental = Enum.YLeaf(1, "incremental")

    next_hop = Enum.YLeaf(2, "next-hop")

    partial_route = Enum.YLeaf(3, "partial-route")


class RcmdLdpEvent(Enum):
    """
    RcmdLdpEvent

    Type of LDP Event

    .. data:: neighbor = 1

    	Neighbor Event

    .. data:: adjacency = 2

    	Adjacency Event

    """

    neighbor = Enum.YLeaf(1, "neighbor")

    adjacency = Enum.YLeaf(2, "adjacency")


class RcmdLinecardSpeed(Enum):
    """
    RcmdLinecardSpeed

    Comparative speed of programming on linecard

    .. data:: other = 0

    	Other linecard

    .. data:: fastest = 1

    	Fastest linecard

    .. data:: slowest = 2

    	Slowest linecard

    """

    other = Enum.YLeaf(0, "other")

    fastest = Enum.YLeaf(1, "fastest")

    slowest = Enum.YLeaf(2, "slowest")


class RcmdLsChange(Enum):
    """
    RcmdLsChange

    Type of change

    .. data:: new = 0

    	Added

    .. data:: delete = 1

    	Deleted

    .. data:: modify = 2

    	Modified

    .. data:: noop = 3

    	No operation

    """

    new = Enum.YLeaf(0, "new")

    delete = Enum.YLeaf(1, "delete")

    modify = Enum.YLeaf(2, "modify")

    noop = Enum.YLeaf(3, "noop")


class RcmdLsa(Enum):
    """
    RcmdLsa

    Type of LSA

    .. data:: unknown = 0

    	Invalid LSA

    .. data:: router = 1

    	Router LSA

    .. data:: network = 2

    	Network LSA

    .. data:: summary = 3

    	Summary LSA

    .. data:: asbr = 4

    	ASBR LSA

    .. data:: external = 5

    	External LSA

    .. data:: multicast = 6

    	Multicast LSA

    .. data:: nssa = 7

    	NSSA LSA

    """

    unknown = Enum.YLeaf(0, "unknown")

    router = Enum.YLeaf(1, "router")

    network = Enum.YLeaf(2, "network")

    summary = Enum.YLeaf(3, "summary")

    asbr = Enum.YLeaf(4, "asbr")

    external = Enum.YLeaf(5, "external")

    multicast = Enum.YLeaf(6, "multicast")

    nssa = Enum.YLeaf(7, "nssa")


class RcmdPriorityLevel(Enum):
    """
    RcmdPriorityLevel

    Level of priority

    .. data:: critical = 0

    	Critical

    .. data:: high = 1

    	High

    .. data:: medium = 2

    	Medium

    .. data:: low = 3

    	Low

    """

    critical = Enum.YLeaf(0, "critical")

    high = Enum.YLeaf(1, "high")

    medium = Enum.YLeaf(2, "medium")

    low = Enum.YLeaf(3, "low")


class RcmdProtocolId(Enum):
    """
    RcmdProtocolId

    Protocol Info

    .. data:: ospf = 0

    	OSPF protocol

    .. data:: isis = 1

    	ISIS Prrotocol

    .. data:: na = 2

    	Max NA

    """

    ospf = Enum.YLeaf(0, "ospf")

    isis = Enum.YLeaf(1, "isis")

    na = Enum.YLeaf(2, "na")


class RcmdShowCompId(Enum):
    """
    RcmdShowCompId

    Component Info

    .. data:: ospf = 0

    	OSPF component

    .. data:: isis = 1

    	ISIS component

    .. data:: un_known = 2

    	Max NA

    """

    ospf = Enum.YLeaf(0, "ospf")

    isis = Enum.YLeaf(1, "isis")

    un_known = Enum.YLeaf(2, "un-known")


class RcmdShowInstState(Enum):
    """
    RcmdShowInstState

    instance state

    .. data:: unknown = 0

    	Unknown state

    .. data:: active = 1

    	Active state

    .. data:: in_active = 2

    	InActive state

    .. data:: na = 3

    	Max state

    """

    unknown = Enum.YLeaf(0, "unknown")

    active = Enum.YLeaf(1, "active")

    in_active = Enum.YLeaf(2, "in-active")

    na = Enum.YLeaf(3, "na")


class RcmdShowIntfEvent(Enum):
    """
    RcmdShowIntfEvent

    Rcmd show intf event

    .. data:: create = 1

    	Create

    .. data:: delete = 2

    	Delete

    .. data:: link_up = 3

    	LinkUp

    .. data:: link_down = 4

    	LinkDown

    .. data:: primary_address = 5

    	PrimaryAddress

    .. data:: secondary_address = 6

    	SecondaryAddress

    .. data:: ipv6_link_local_address = 7

    	Ipv6LinkLocalAddress

    .. data:: ipv6_global_address = 8

    	Ipv6GlobalAddress

    .. data:: mtu = 9

    	MTU

    .. data:: band_width = 10

    	BandWidth

    .. data:: ldp_sync = 11

    	LDPSync

    .. data:: forward_reference = 12

    	ForwardReference

    .. data:: ldp_no_sync = 13

    	LDPNoSync

    """

    create = Enum.YLeaf(1, "create")

    delete = Enum.YLeaf(2, "delete")

    link_up = Enum.YLeaf(3, "link-up")

    link_down = Enum.YLeaf(4, "link-down")

    primary_address = Enum.YLeaf(5, "primary-address")

    secondary_address = Enum.YLeaf(6, "secondary-address")

    ipv6_link_local_address = Enum.YLeaf(7, "ipv6-link-local-address")

    ipv6_global_address = Enum.YLeaf(8, "ipv6-global-address")

    mtu = Enum.YLeaf(9, "mtu")

    band_width = Enum.YLeaf(10, "band-width")

    ldp_sync = Enum.YLeaf(11, "ldp-sync")

    forward_reference = Enum.YLeaf(12, "forward-reference")

    ldp_no_sync = Enum.YLeaf(13, "ldp-no-sync")


class RcmdShowIpfrrLfa(Enum):
    """
    RcmdShowIpfrrLfa

    IP Frr LFA Types

    .. data:: none = 0

    	No IP Frr LFA Type 

    .. data:: local = 1

    	IP Frr Local LFA

    .. data:: remote = 2

    	IP Frr Remote LFA

    """

    none = Enum.YLeaf(0, "none")

    local = Enum.YLeaf(1, "local")

    remote = Enum.YLeaf(2, "remote")


class RcmdShowLdpConvState(Enum):
    """
    RcmdShowLdpConvState

    LDP Convergence States

    .. data:: not_full = 0

    	Not Fully Covered

    .. data:: fully_covered = 1

    	Fully Covered

    .. data:: coverage_above_threshold = 2

    	Backup Coverage Above Threshold

    .. data:: coverage_below_threshold = 3

    	Backup Coverage Below Threshold

    .. data:: coverage_flapping = 4

    	Backup Coverage is Flappping

    """

    not_full = Enum.YLeaf(0, "not-full")

    fully_covered = Enum.YLeaf(1, "fully-covered")

    coverage_above_threshold = Enum.YLeaf(2, "coverage-above-threshold")

    coverage_below_threshold = Enum.YLeaf(3, "coverage-below-threshold")

    coverage_flapping = Enum.YLeaf(4, "coverage-flapping")


class RcmdShowLdpNeighbourStatus(Enum):
    """
    RcmdShowLdpNeighbourStatus

    LDP Adjacency Session Status

    .. data:: down = 0

    	Down State

    .. data:: up = 1

    	Up State

    """

    down = Enum.YLeaf(0, "down")

    up = Enum.YLeaf(1, "up")


class RcmdShowLdpSessionState(Enum):
    """
    RcmdShowLdpSessionState

    LDP Session State

    .. data:: gr_down = 0

    	GR Down State

    .. data:: gr_converging = 1

    	GR Converging State

    .. data:: establishing = 2

    	Establishing State

    .. data:: converging = 3

    	Converging State

    .. data:: converged = 4

    	Converged State

    .. data:: retrying = 5

    	Retrying State

    .. data:: total = 6

    	Cumulative Coverage for all the States

    """

    gr_down = Enum.YLeaf(0, "gr-down")

    gr_converging = Enum.YLeaf(1, "gr-converging")

    establishing = Enum.YLeaf(2, "establishing")

    converging = Enum.YLeaf(3, "converging")

    converged = Enum.YLeaf(4, "converged")

    retrying = Enum.YLeaf(5, "retrying")

    total = Enum.YLeaf(6, "total")


class RcmdShowMem(Enum):
    """
    RcmdShowMem

    RCMD Memory Manager type

    .. data:: standard = 0

    	Standard type

    .. data:: chunk = 1

    	Chunk type

    .. data:: edm = 2

    	EDM type

    .. data:: string = 3

    	String type

    .. data:: static = 4

    	Static type

    .. data:: unknown = 5

    	Unknown type

    """

    standard = Enum.YLeaf(0, "standard")

    chunk = Enum.YLeaf(1, "chunk")

    edm = Enum.YLeaf(2, "edm")

    string = Enum.YLeaf(3, "string")

    static = Enum.YLeaf(4, "static")

    unknown = Enum.YLeaf(5, "unknown")


class RcmdShowNode(Enum):
    """
    RcmdShowNode

    Type of Node

    .. data:: unknown = 0

    	Unknown Type

    .. data:: lc = 1

    	LC Type

    .. data:: rp = 2

    	RP Type

    """

    unknown = Enum.YLeaf(0, "unknown")

    lc = Enum.YLeaf(1, "lc")

    rp = Enum.YLeaf(2, "rp")


class RcmdShowPrcsState(Enum):
    """
    RcmdShowPrcsState

    Post Processing Info

    .. data:: success = 0

    	Success

    .. data:: cpu = 1

    	Cpu overload

    .. data:: memory = 2

    	Memory overload

    """

    success = Enum.YLeaf(0, "success")

    cpu = Enum.YLeaf(1, "cpu")

    memory = Enum.YLeaf(2, "memory")


class RcmdShowRoute(Enum):
    """
    RcmdShowRoute

    Route Types

    .. data:: ospf = 0

    	OSPF route init

    .. data:: intra = 1

    	OSPF Intra route

    .. data:: inter = 2

    	OSPF Inter route

    .. data:: ext_1 = 3

    	OSPF External Type-1 Route

    .. data:: ext_2 = 4

    	OSPF External Type-2 Route

    .. data:: nssa_1 = 5

    	OSPF NSSA Type-1 Route

    .. data:: nssa_2 = 6

    	OSPF NSSA Type-2 Route

    .. data:: isis = 7

    	ISIS route init

    .. data:: l1_summary = 8

    	ISIS L1 Summary

    .. data:: l1 = 9

    	ISIS L1

    .. data:: l2_summary = 10

    	ISIS L2 Summary

    .. data:: l2 = 11

    	ISIS L2

    .. data:: inter_area_summary = 12

    	ISIS Inter Area Summary

    .. data:: inter_area = 13

    	ISIS Inter Area

    .. data:: default_attached = 14

    	ISIS Default Route Attached

    """

    ospf = Enum.YLeaf(0, "ospf")

    intra = Enum.YLeaf(1, "intra")

    inter = Enum.YLeaf(2, "inter")

    ext_1 = Enum.YLeaf(3, "ext-1")

    ext_2 = Enum.YLeaf(4, "ext-2")

    nssa_1 = Enum.YLeaf(5, "nssa-1")

    nssa_2 = Enum.YLeaf(6, "nssa-2")

    isis = Enum.YLeaf(7, "isis")

    l1_summary = Enum.YLeaf(8, "l1-summary")

    l1 = Enum.YLeaf(9, "l1")

    l2_summary = Enum.YLeaf(10, "l2-summary")

    l2 = Enum.YLeaf(11, "l2")

    inter_area_summary = Enum.YLeaf(12, "inter-area-summary")

    inter_area = Enum.YLeaf(13, "inter-area")

    default_attached = Enum.YLeaf(14, "default-attached")


class RcmdShowRoutePathChange(Enum):
    """
    RcmdShowRoutePathChange

    Type of route change

    .. data:: primary = 0

    	Primary path is changed

    .. data:: backup = 1

    	Backup path is changed

    """

    primary = Enum.YLeaf(0, "primary")

    backup = Enum.YLeaf(1, "backup")


class RcmdSpfState(Enum):
    """
    RcmdSpfState

    Type of an ISIS Level

    .. data:: complete = 0

    	Complete

    .. data:: in_complete = 1

    	InComplete

    .. data:: collecting = 2

    	Collecting data

    .. data:: no_route_change = 3

    	No Route Change

    """

    complete = Enum.YLeaf(0, "complete")

    in_complete = Enum.YLeaf(1, "in-complete")

    collecting = Enum.YLeaf(2, "collecting")

    no_route_change = Enum.YLeaf(3, "no-route-change")



class Rcmd(Entity):
    """
    Show command for Route Convergence Monitoring &
    Diagnostics
    
    .. attribute:: intf
    
    	Interface data
    	**type**\:   :py:class:`Intf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Intf>`
    
    .. attribute:: isis
    
    	Operational data for ISIS
    	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis>`
    
    .. attribute:: ldp
    
    	LDP data
    	**type**\:   :py:class:`Ldp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp>`
    
    .. attribute:: memory
    
    	Memory Info
    	**type**\:   :py:class:`Memory <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Memory>`
    
    .. attribute:: node
    
    	Node Info
    	**type**\:   :py:class:`Node <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Node>`
    
    .. attribute:: ospf
    
    	Operational data for OSPF
    	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf>`
    
    .. attribute:: process
    
    	Process information
    	**type**\:   :py:class:`Process <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process>`
    
    .. attribute:: server
    
    	Server Info
    	**type**\:   :py:class:`Server <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server>`
    
    

    """

    _prefix = 'infra-rcmd-oper'
    _revision = '2015-11-09'

    def __init__(self):
        super(Rcmd, self).__init__()
        self._top_entity = None

        self.yang_name = "rcmd"
        self.yang_parent_name = "Cisco-IOS-XR-infra-rcmd-oper"

        self.intf = Rcmd.Intf()
        self.intf.parent = self
        self._children_name_map["intf"] = "intf"
        self._children_yang_names.add("intf")

        self.isis = Rcmd.Isis()
        self.isis.parent = self
        self._children_name_map["isis"] = "isis"
        self._children_yang_names.add("isis")

        self.ldp = Rcmd.Ldp()
        self.ldp.parent = self
        self._children_name_map["ldp"] = "ldp"
        self._children_yang_names.add("ldp")

        self.memory = Rcmd.Memory()
        self.memory.parent = self
        self._children_name_map["memory"] = "memory"
        self._children_yang_names.add("memory")

        self.node = Rcmd.Node()
        self.node.parent = self
        self._children_name_map["node"] = "node"
        self._children_yang_names.add("node")

        self.ospf = Rcmd.Ospf()
        self.ospf.parent = self
        self._children_name_map["ospf"] = "ospf"
        self._children_yang_names.add("ospf")

        self.process = Rcmd.Process()
        self.process.parent = self
        self._children_name_map["process"] = "process"
        self._children_yang_names.add("process")

        self.server = Rcmd.Server()
        self.server.parent = self
        self._children_name_map["server"] = "server"
        self._children_yang_names.add("server")


    class Ospf(Entity):
        """
        Operational data for OSPF
        
        .. attribute:: instances
        
        	Operational data
        	**type**\:   :py:class:`Instances <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances>`
        
        

        """

        _prefix = 'infra-rcmd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Rcmd.Ospf, self).__init__()

            self.yang_name = "ospf"
            self.yang_parent_name = "rcmd"

            self.instances = Rcmd.Ospf.Instances()
            self.instances.parent = self
            self._children_name_map["instances"] = "instances"
            self._children_yang_names.add("instances")


        class Instances(Entity):
            """
            Operational data
            
            .. attribute:: instance
            
            	Operational data for a particular instance
            	**type**\: list of    :py:class:`Instance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Ospf.Instances, self).__init__()

                self.yang_name = "instances"
                self.yang_parent_name = "ospf"

                self.instance = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Ospf.Instances, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Ospf.Instances, self).__setattr__(name, value)


            class Instance(Entity):
                """
                Operational data for a particular instance
                
                .. attribute:: instance_name  <key>
                
                	Operational data for a particular instance
                	**type**\:  str
                
                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                
                .. attribute:: ipfrr_event_offlines
                
                	OSPF IP\-FRR Event offline data
                	**type**\:   :py:class:`IpfrrEventOfflines <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines>`
                
                .. attribute:: ipfrr_event_summaries
                
                	OSPF IP\-FRR events summary data
                	**type**\:   :py:class:`IpfrrEventSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries>`
                
                .. attribute:: prefix_event_offlines
                
                	OSPF Prefix events offline data
                	**type**\:   :py:class:`PrefixEventOfflines <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines>`
                
                .. attribute:: prefix_event_statistics
                
                	OSPF Prefix events summary data
                	**type**\:   :py:class:`PrefixEventStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventStatistics>`
                
                .. attribute:: prefix_event_summaries
                
                	OSPF Prefix events summary data
                	**type**\:   :py:class:`PrefixEventSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries>`
                
                .. attribute:: spf_run_offlines
                
                	OSPF SPF run offline data
                	**type**\:   :py:class:`SpfRunOfflines <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines>`
                
                .. attribute:: spf_run_summaries
                
                	OSPF SPF run summary data
                	**type**\:   :py:class:`SpfRunSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries>`
                
                .. attribute:: summary_external_event_offlines
                
                	OSPF Summary\-External Prefix events offline data
                	**type**\:   :py:class:`SummaryExternalEventOfflines <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines>`
                
                .. attribute:: summary_external_event_statistics
                
                	Summary\-External prefix monitoring statistics
                	**type**\:   :py:class:`SummaryExternalEventStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventStatistics>`
                
                .. attribute:: summary_external_event_summaries
                
                	OSPF Summary\-External Prefix events summary data
                	**type**\:   :py:class:`SummaryExternalEventSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Ospf.Instances.Instance, self).__init__()

                    self.yang_name = "instance"
                    self.yang_parent_name = "instances"

                    self.instance_name = YLeaf(YType.str, "instance-name")

                    self.ipfrr_event_offlines = Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines()
                    self.ipfrr_event_offlines.parent = self
                    self._children_name_map["ipfrr_event_offlines"] = "ipfrr-event-offlines"
                    self._children_yang_names.add("ipfrr-event-offlines")

                    self.ipfrr_event_summaries = Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries()
                    self.ipfrr_event_summaries.parent = self
                    self._children_name_map["ipfrr_event_summaries"] = "ipfrr-event-summaries"
                    self._children_yang_names.add("ipfrr-event-summaries")

                    self.prefix_event_offlines = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines()
                    self.prefix_event_offlines.parent = self
                    self._children_name_map["prefix_event_offlines"] = "prefix-event-offlines"
                    self._children_yang_names.add("prefix-event-offlines")

                    self.prefix_event_statistics = Rcmd.Ospf.Instances.Instance.PrefixEventStatistics()
                    self.prefix_event_statistics.parent = self
                    self._children_name_map["prefix_event_statistics"] = "prefix-event-statistics"
                    self._children_yang_names.add("prefix-event-statistics")

                    self.prefix_event_summaries = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries()
                    self.prefix_event_summaries.parent = self
                    self._children_name_map["prefix_event_summaries"] = "prefix-event-summaries"
                    self._children_yang_names.add("prefix-event-summaries")

                    self.spf_run_offlines = Rcmd.Ospf.Instances.Instance.SpfRunOfflines()
                    self.spf_run_offlines.parent = self
                    self._children_name_map["spf_run_offlines"] = "spf-run-offlines"
                    self._children_yang_names.add("spf-run-offlines")

                    self.spf_run_summaries = Rcmd.Ospf.Instances.Instance.SpfRunSummaries()
                    self.spf_run_summaries.parent = self
                    self._children_name_map["spf_run_summaries"] = "spf-run-summaries"
                    self._children_yang_names.add("spf-run-summaries")

                    self.summary_external_event_offlines = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines()
                    self.summary_external_event_offlines.parent = self
                    self._children_name_map["summary_external_event_offlines"] = "summary-external-event-offlines"
                    self._children_yang_names.add("summary-external-event-offlines")

                    self.summary_external_event_statistics = Rcmd.Ospf.Instances.Instance.SummaryExternalEventStatistics()
                    self.summary_external_event_statistics.parent = self
                    self._children_name_map["summary_external_event_statistics"] = "summary-external-event-statistics"
                    self._children_yang_names.add("summary-external-event-statistics")

                    self.summary_external_event_summaries = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries()
                    self.summary_external_event_summaries.parent = self
                    self._children_name_map["summary_external_event_summaries"] = "summary-external-event-summaries"
                    self._children_yang_names.add("summary-external-event-summaries")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("instance_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Ospf.Instances.Instance, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Ospf.Instances.Instance, self).__setattr__(name, value)


                class IpfrrEventSummaries(Entity):
                    """
                    OSPF IP\-FRR events summary data
                    
                    .. attribute:: ipfrr_event_summary
                    
                    	IP\-FRR Event data
                    	**type**\: list of    :py:class:`IpfrrEventSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries, self).__init__()

                        self.yang_name = "ipfrr-event-summaries"
                        self.yang_parent_name = "instance"

                        self.ipfrr_event_summary = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries, self).__setattr__(name, value)


                    class IpfrrEventSummary(Entity):
                        """
                        IP\-FRR Event data
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific IP\-FRR Event
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: completed_spf_run
                        
                        	IP\-Frr Completed reference SPF Run Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: coverage
                        
                        	Coverage in percentage for all priorities
                        	**type**\:  str
                        
                        	**units**\: percentage
                        
                        .. attribute:: duration
                        
                        	Duration for the calculation (in milliseconds)
                        	**type**\:  str
                        
                        	**units**\: millisecond
                        
                        .. attribute:: event_id_xr
                        
                        	IP\-Frr Event ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: fully_protected_routes
                        
                        	Cumulative Number of Fully Protected Routes
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ipfrr_statistic
                        
                        	IP\-Frr Statistics categorized by priority
                        	**type**\: list of    :py:class:`IpfrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic>`
                        
                        .. attribute:: partially_protected_routes
                        
                        	Cumulative Number of Partially Protected Routes
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_node
                        
                        	Remote Node Information
                        	**type**\: list of    :py:class:`RemoteNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode>`
                        
                        .. attribute:: start_time_offset
                        
                        	Start Time offset from trigger time (in milliseconds)
                        	**type**\:  str
                        
                        	**units**\: millisecond
                        
                        .. attribute:: total_routes
                        
                        	Cumulative Number of Routes for all priorities
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: trigger_spf_run
                        
                        	IP\-Frr Triggered reference SPF Run Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: trigger_time
                        
                        	Trigger time  (eg\: Apr 24 13\:16\:04.961)
                        	**type**\:  str
                        
                        .. attribute:: wait_time
                        
                        	Waiting Time (in milliseconds)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary, self).__init__()

                            self.yang_name = "ipfrr-event-summary"
                            self.yang_parent_name = "ipfrr-event-summaries"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.completed_spf_run = YLeaf(YType.uint32, "completed-spf-run")

                            self.coverage = YLeaf(YType.str, "coverage")

                            self.duration = YLeaf(YType.str, "duration")

                            self.event_id_xr = YLeaf(YType.uint32, "event-id-xr")

                            self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                            self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                            self.start_time_offset = YLeaf(YType.str, "start-time-offset")

                            self.total_routes = YLeaf(YType.uint32, "total-routes")

                            self.trigger_spf_run = YLeaf(YType.uint32, "trigger-spf-run")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.wait_time = YLeaf(YType.uint32, "wait-time")

                            self.ipfrr_statistic = YList(self)
                            self.remote_node = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "completed_spf_run",
                                            "coverage",
                                            "duration",
                                            "event_id_xr",
                                            "fully_protected_routes",
                                            "partially_protected_routes",
                                            "start_time_offset",
                                            "total_routes",
                                            "trigger_spf_run",
                                            "trigger_time",
                                            "wait_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary, self).__setattr__(name, value)


                        class IpfrrStatistic(Entity):
                            """
                            IP\-Frr Statistics categorized by priority
                            
                            .. attribute:: below_threshold
                            
                            	Covearge is below Configured Threshold
                            	**type**\:  bool
                            
                            .. attribute:: coverage
                            
                            	Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: fully_protected_routes
                            
                            	Fully Protected Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_lfa_coverage
                            
                            	Local LFA Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: partially_protected_routes
                            
                            	Partially Protected Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: priority
                            
                            	Priority
                            	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                            
                            .. attribute:: remote_lfa_coverage
                            
                            	Remote LFA Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: total_routes
                            
                            	Total Number of Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic, self).__init__()

                                self.yang_name = "ipfrr-statistic"
                                self.yang_parent_name = "ipfrr-event-summary"

                                self.below_threshold = YLeaf(YType.boolean, "below-threshold")

                                self.coverage = YLeaf(YType.str, "coverage")

                                self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                self.local_lfa_coverage = YLeaf(YType.str, "local-lfa-coverage")

                                self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                self.priority = YLeaf(YType.enumeration, "priority")

                                self.remote_lfa_coverage = YLeaf(YType.str, "remote-lfa-coverage")

                                self.total_routes = YLeaf(YType.uint32, "total-routes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("below_threshold",
                                                "coverage",
                                                "fully_protected_routes",
                                                "local_lfa_coverage",
                                                "partially_protected_routes",
                                                "priority",
                                                "remote_lfa_coverage",
                                                "total_routes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.below_threshold.is_set or
                                    self.coverage.is_set or
                                    self.fully_protected_routes.is_set or
                                    self.local_lfa_coverage.is_set or
                                    self.partially_protected_routes.is_set or
                                    self.priority.is_set or
                                    self.remote_lfa_coverage.is_set or
                                    self.total_routes.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.below_threshold.yfilter != YFilter.not_set or
                                    self.coverage.yfilter != YFilter.not_set or
                                    self.fully_protected_routes.yfilter != YFilter.not_set or
                                    self.local_lfa_coverage.yfilter != YFilter.not_set or
                                    self.partially_protected_routes.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set or
                                    self.remote_lfa_coverage.yfilter != YFilter.not_set or
                                    self.total_routes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ipfrr-statistic" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.below_threshold.is_set or self.below_threshold.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.below_threshold.get_name_leafdata())
                                if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.coverage.get_name_leafdata())
                                if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                if (self.local_lfa_coverage.is_set or self.local_lfa_coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_lfa_coverage.get_name_leafdata())
                                if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())
                                if (self.remote_lfa_coverage.is_set or self.remote_lfa_coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_lfa_coverage.get_name_leafdata())
                                if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_routes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "below-threshold" or name == "coverage" or name == "fully-protected-routes" or name == "local-lfa-coverage" or name == "partially-protected-routes" or name == "priority" or name == "remote-lfa-coverage" or name == "total-routes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "below-threshold"):
                                    self.below_threshold = value
                                    self.below_threshold.value_namespace = name_space
                                    self.below_threshold.value_namespace_prefix = name_space_prefix
                                if(value_path == "coverage"):
                                    self.coverage = value
                                    self.coverage.value_namespace = name_space
                                    self.coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "fully-protected-routes"):
                                    self.fully_protected_routes = value
                                    self.fully_protected_routes.value_namespace = name_space
                                    self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-lfa-coverage"):
                                    self.local_lfa_coverage = value
                                    self.local_lfa_coverage.value_namespace = name_space
                                    self.local_lfa_coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "partially-protected-routes"):
                                    self.partially_protected_routes = value
                                    self.partially_protected_routes.value_namespace = name_space
                                    self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-lfa-coverage"):
                                    self.remote_lfa_coverage = value
                                    self.remote_lfa_coverage.value_namespace = name_space
                                    self.remote_lfa_coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-routes"):
                                    self.total_routes = value
                                    self.total_routes.value_namespace = name_space
                                    self.total_routes.value_namespace_prefix = name_space_prefix


                        class RemoteNode(Entity):
                            """
                            Remote Node Information
                            
                            .. attribute:: in_use_time
                            
                            	Inuse time of the Remote Node (eg\: Apr 24 13\:16 \:04.961)
                            	**type**\:  str
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_count
                            
                            	Number of paths protected by this Remote Node
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: primary_path
                            
                            	Protected Primary Paths
                            	**type**\: list of    :py:class:`PrimaryPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath>`
                            
                            .. attribute:: remote_node_id
                            
                            	Remote\-LFA Node ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode, self).__init__()

                                self.yang_name = "remote-node"
                                self.yang_parent_name = "ipfrr-event-summary"

                                self.in_use_time = YLeaf(YType.str, "in-use-time")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_count = YLeaf(YType.uint32, "path-count")

                                self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                self.primary_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("in_use_time",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_count",
                                                "remote_node_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode, self).__setattr__(name, value)


                            class PrimaryPath(Entity):
                                """
                                Protected Primary Paths
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath, self).__init__()

                                    self.yang_name = "primary-path"
                                    self.yang_parent_name = "remote-node"

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface_name",
                                                    "neighbour_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.interface_name.is_set or
                                        self.neighbour_address.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "primary-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface-name" or name == "neighbour-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.primary_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.in_use_time.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_count.is_set or
                                    self.remote_node_id.is_set)

                            def has_operation(self):
                                for c in self.primary_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.in_use_time.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_count.yfilter != YFilter.not_set or
                                    self.remote_node_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "remote-node" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.in_use_time.is_set or self.in_use_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_use_time.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_count.is_set or self.path_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_count.get_name_leafdata())
                                if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "primary-path"):
                                    for c in self.primary_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.primary_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "primary-path" or name == "in-use-time" or name == "interface-name" or name == "neighbour-address" or name == "path-count" or name == "remote-node-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "in-use-time"):
                                    self.in_use_time = value
                                    self.in_use_time.value_namespace = name_space
                                    self.in_use_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-count"):
                                    self.path_count = value
                                    self.path_count.value_namespace = name_space
                                    self.path_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-node-id"):
                                    self.remote_node_id = value
                                    self.remote_node_id.value_namespace = name_space
                                    self.remote_node_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.ipfrr_statistic:
                                if (c.has_data()):
                                    return True
                            for c in self.remote_node:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.completed_spf_run.is_set or
                                self.coverage.is_set or
                                self.duration.is_set or
                                self.event_id_xr.is_set or
                                self.fully_protected_routes.is_set or
                                self.partially_protected_routes.is_set or
                                self.start_time_offset.is_set or
                                self.total_routes.is_set or
                                self.trigger_spf_run.is_set or
                                self.trigger_time.is_set or
                                self.wait_time.is_set)

                        def has_operation(self):
                            for c in self.ipfrr_statistic:
                                if (c.has_operation()):
                                    return True
                            for c in self.remote_node:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.completed_spf_run.yfilter != YFilter.not_set or
                                self.coverage.yfilter != YFilter.not_set or
                                self.duration.yfilter != YFilter.not_set or
                                self.event_id_xr.yfilter != YFilter.not_set or
                                self.fully_protected_routes.yfilter != YFilter.not_set or
                                self.partially_protected_routes.yfilter != YFilter.not_set or
                                self.start_time_offset.yfilter != YFilter.not_set or
                                self.total_routes.yfilter != YFilter.not_set or
                                self.trigger_spf_run.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                self.wait_time.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipfrr-event-summary" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.completed_spf_run.is_set or self.completed_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.completed_spf_run.get_name_leafdata())
                            if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.coverage.get_name_leafdata())
                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.duration.get_name_leafdata())
                            if (self.event_id_xr.is_set or self.event_id_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id_xr.get_name_leafdata())
                            if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                            if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                            if (self.start_time_offset.is_set or self.start_time_offset.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_time_offset.get_name_leafdata())
                            if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_routes.get_name_leafdata())
                            if (self.trigger_spf_run.is_set or self.trigger_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_spf_run.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())
                            if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wait_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ipfrr-statistic"):
                                for c in self.ipfrr_statistic:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.ipfrr_statistic.append(c)
                                return c

                            if (child_yang_name == "remote-node"):
                                for c in self.remote_node:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.remote_node.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ipfrr-statistic" or name == "remote-node" or name == "event-id" or name == "completed-spf-run" or name == "coverage" or name == "duration" or name == "event-id-xr" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "start-time-offset" or name == "total-routes" or name == "trigger-spf-run" or name == "trigger-time" or name == "wait-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "completed-spf-run"):
                                self.completed_spf_run = value
                                self.completed_spf_run.value_namespace = name_space
                                self.completed_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "coverage"):
                                self.coverage = value
                                self.coverage.value_namespace = name_space
                                self.coverage.value_namespace_prefix = name_space_prefix
                            if(value_path == "duration"):
                                self.duration = value
                                self.duration.value_namespace = name_space
                                self.duration.value_namespace_prefix = name_space_prefix
                            if(value_path == "event-id-xr"):
                                self.event_id_xr = value
                                self.event_id_xr.value_namespace = name_space
                                self.event_id_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "fully-protected-routes"):
                                self.fully_protected_routes = value
                                self.fully_protected_routes.value_namespace = name_space
                                self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "partially-protected-routes"):
                                self.partially_protected_routes = value
                                self.partially_protected_routes.value_namespace = name_space
                                self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-time-offset"):
                                self.start_time_offset = value
                                self.start_time_offset.value_namespace = name_space
                                self.start_time_offset.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-routes"):
                                self.total_routes = value
                                self.total_routes.value_namespace = name_space
                                self.total_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-spf-run"):
                                self.trigger_spf_run = value
                                self.trigger_spf_run.value_namespace = name_space
                                self.trigger_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "wait-time"):
                                self.wait_time = value
                                self.wait_time.value_namespace = name_space
                                self.wait_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.ipfrr_event_summary:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.ipfrr_event_summary:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipfrr-event-summaries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ipfrr-event-summary"):
                            for c in self.ipfrr_event_summary:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.ipfrr_event_summary.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ipfrr-event-summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class PrefixEventStatistics(Entity):
                    """
                    OSPF Prefix events summary data
                    
                    .. attribute:: prefix_event_statistic
                    
                    	Prefix Event statistics
                    	**type**\: list of    :py:class:`PrefixEventStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.PrefixEventStatistics, self).__init__()

                        self.yang_name = "prefix-event-statistics"
                        self.yang_parent_name = "instance"

                        self.prefix_event_statistic = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventStatistics, self).__setattr__(name, value)


                    class PrefixEventStatistic(Entity):
                        """
                        Prefix Event statistics
                        
                        .. attribute:: prefix_info  <key>
                        
                        	Events with Prefix
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                        
                        
                        ----
                        .. attribute:: add_count
                        
                        	No. of times route gets Added
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: critical_priority
                        
                        	No. of times processed under Critical Priority
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: delete_count
                        
                        	No. of times route gets Deleted
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: high_priority
                        
                        	No. of times processed under High Priority
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: last_change_type
                        
                        	Last event Add/Delete
                        	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                        
                        .. attribute:: last_cost
                        
                        	Last Known Cost
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: last_event_time
                        
                        	Last event trigger time
                        	**type**\:  str
                        
                        .. attribute:: last_priority
                        
                        	Last event processed priority
                        	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                        
                        .. attribute:: last_route_type
                        
                        	Last event Route Type
                        	**type**\:   :py:class:`RcmdShowRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoute>`
                        
                        .. attribute:: low_priority
                        
                        	No. of times processed under Low Priority
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: medium_priority
                        
                        	No. of times processed under Medium Priority
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: modify_count
                        
                        	No. of times route gets Deleted
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: prefix
                        
                        	Prefix
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_lenth
                        
                        	Prefix length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: threshold_exceed_count
                        
                        	No. of times threshold got exceeded
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Ospf.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic, self).__init__()

                            self.yang_name = "prefix-event-statistic"
                            self.yang_parent_name = "prefix-event-statistics"

                            self.prefix_info = YLeaf(YType.str, "prefix-info")

                            self.add_count = YLeaf(YType.uint32, "add-count")

                            self.critical_priority = YLeaf(YType.uint32, "critical-priority")

                            self.delete_count = YLeaf(YType.uint32, "delete-count")

                            self.high_priority = YLeaf(YType.uint32, "high-priority")

                            self.last_change_type = YLeaf(YType.enumeration, "last-change-type")

                            self.last_cost = YLeaf(YType.uint32, "last-cost")

                            self.last_event_time = YLeaf(YType.str, "last-event-time")

                            self.last_priority = YLeaf(YType.enumeration, "last-priority")

                            self.last_route_type = YLeaf(YType.enumeration, "last-route-type")

                            self.low_priority = YLeaf(YType.uint32, "low-priority")

                            self.medium_priority = YLeaf(YType.uint32, "medium-priority")

                            self.modify_count = YLeaf(YType.uint32, "modify-count")

                            self.prefix = YLeaf(YType.str, "prefix")

                            self.prefix_lenth = YLeaf(YType.uint32, "prefix-lenth")

                            self.threshold_exceed_count = YLeaf(YType.uint32, "threshold-exceed-count")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("prefix_info",
                                            "add_count",
                                            "critical_priority",
                                            "delete_count",
                                            "high_priority",
                                            "last_change_type",
                                            "last_cost",
                                            "last_event_time",
                                            "last_priority",
                                            "last_route_type",
                                            "low_priority",
                                            "medium_priority",
                                            "modify_count",
                                            "prefix",
                                            "prefix_lenth",
                                            "threshold_exceed_count") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.prefix_info.is_set or
                                self.add_count.is_set or
                                self.critical_priority.is_set or
                                self.delete_count.is_set or
                                self.high_priority.is_set or
                                self.last_change_type.is_set or
                                self.last_cost.is_set or
                                self.last_event_time.is_set or
                                self.last_priority.is_set or
                                self.last_route_type.is_set or
                                self.low_priority.is_set or
                                self.medium_priority.is_set or
                                self.modify_count.is_set or
                                self.prefix.is_set or
                                self.prefix_lenth.is_set or
                                self.threshold_exceed_count.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.prefix_info.yfilter != YFilter.not_set or
                                self.add_count.yfilter != YFilter.not_set or
                                self.critical_priority.yfilter != YFilter.not_set or
                                self.delete_count.yfilter != YFilter.not_set or
                                self.high_priority.yfilter != YFilter.not_set or
                                self.last_change_type.yfilter != YFilter.not_set or
                                self.last_cost.yfilter != YFilter.not_set or
                                self.last_event_time.yfilter != YFilter.not_set or
                                self.last_priority.yfilter != YFilter.not_set or
                                self.last_route_type.yfilter != YFilter.not_set or
                                self.low_priority.yfilter != YFilter.not_set or
                                self.medium_priority.yfilter != YFilter.not_set or
                                self.modify_count.yfilter != YFilter.not_set or
                                self.prefix.yfilter != YFilter.not_set or
                                self.prefix_lenth.yfilter != YFilter.not_set or
                                self.threshold_exceed_count.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-event-statistic" + "[prefix-info='" + self.prefix_info.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.prefix_info.is_set or self.prefix_info.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_info.get_name_leafdata())
                            if (self.add_count.is_set or self.add_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.add_count.get_name_leafdata())
                            if (self.critical_priority.is_set or self.critical_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.critical_priority.get_name_leafdata())
                            if (self.delete_count.is_set or self.delete_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.delete_count.get_name_leafdata())
                            if (self.high_priority.is_set or self.high_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.high_priority.get_name_leafdata())
                            if (self.last_change_type.is_set or self.last_change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_change_type.get_name_leafdata())
                            if (self.last_cost.is_set or self.last_cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_cost.get_name_leafdata())
                            if (self.last_event_time.is_set or self.last_event_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_event_time.get_name_leafdata())
                            if (self.last_priority.is_set or self.last_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_priority.get_name_leafdata())
                            if (self.last_route_type.is_set or self.last_route_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_route_type.get_name_leafdata())
                            if (self.low_priority.is_set or self.low_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.low_priority.get_name_leafdata())
                            if (self.medium_priority.is_set or self.medium_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.medium_priority.get_name_leafdata())
                            if (self.modify_count.is_set or self.modify_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.modify_count.get_name_leafdata())
                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix.get_name_leafdata())
                            if (self.prefix_lenth.is_set or self.prefix_lenth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_lenth.get_name_leafdata())
                            if (self.threshold_exceed_count.is_set or self.threshold_exceed_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_exceed_count.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-info" or name == "add-count" or name == "critical-priority" or name == "delete-count" or name == "high-priority" or name == "last-change-type" or name == "last-cost" or name == "last-event-time" or name == "last-priority" or name == "last-route-type" or name == "low-priority" or name == "medium-priority" or name == "modify-count" or name == "prefix" or name == "prefix-lenth" or name == "threshold-exceed-count"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "prefix-info"):
                                self.prefix_info = value
                                self.prefix_info.value_namespace = name_space
                                self.prefix_info.value_namespace_prefix = name_space_prefix
                            if(value_path == "add-count"):
                                self.add_count = value
                                self.add_count.value_namespace = name_space
                                self.add_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "critical-priority"):
                                self.critical_priority = value
                                self.critical_priority.value_namespace = name_space
                                self.critical_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "delete-count"):
                                self.delete_count = value
                                self.delete_count.value_namespace = name_space
                                self.delete_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "high-priority"):
                                self.high_priority = value
                                self.high_priority.value_namespace = name_space
                                self.high_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-change-type"):
                                self.last_change_type = value
                                self.last_change_type.value_namespace = name_space
                                self.last_change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-cost"):
                                self.last_cost = value
                                self.last_cost.value_namespace = name_space
                                self.last_cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-event-time"):
                                self.last_event_time = value
                                self.last_event_time.value_namespace = name_space
                                self.last_event_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-priority"):
                                self.last_priority = value
                                self.last_priority.value_namespace = name_space
                                self.last_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-route-type"):
                                self.last_route_type = value
                                self.last_route_type.value_namespace = name_space
                                self.last_route_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "low-priority"):
                                self.low_priority = value
                                self.low_priority.value_namespace = name_space
                                self.low_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "medium-priority"):
                                self.medium_priority = value
                                self.medium_priority.value_namespace = name_space
                                self.medium_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "modify-count"):
                                self.modify_count = value
                                self.modify_count.value_namespace = name_space
                                self.modify_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix"):
                                self.prefix = value
                                self.prefix.value_namespace = name_space
                                self.prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-lenth"):
                                self.prefix_lenth = value
                                self.prefix_lenth.value_namespace = name_space
                                self.prefix_lenth.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-exceed-count"):
                                self.threshold_exceed_count = value
                                self.threshold_exceed_count.value_namespace = name_space
                                self.threshold_exceed_count.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.prefix_event_statistic:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.prefix_event_statistic:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "prefix-event-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-event-statistic"):
                            for c in self.prefix_event_statistic:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Ospf.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.prefix_event_statistic.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-event-statistic"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SpfRunSummaries(Entity):
                    """
                    OSPF SPF run summary data
                    
                    .. attribute:: spf_run_summary
                    
                    	SPF Event data
                    	**type**\: list of    :py:class:`SpfRunSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries, self).__init__()

                        self.yang_name = "spf-run-summaries"
                        self.yang_parent_name = "instance"

                        self.spf_run_summary = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries, self).__setattr__(name, value)


                    class SpfRunSummary(Entity):
                        """
                        SPF Event data
                        
                        .. attribute:: spf_run_number  <key>
                        
                        	Specific SPF run
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: dijkstra_run
                        
                        	List of Dijkstra runs
                        	**type**\: list of    :py:class:`DijkstraRun <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun>`
                        
                        .. attribute:: inter_area_and_external
                        
                        	Inter\-area & external calculation information
                        	**type**\: list of    :py:class:`InterAreaAndExternal <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal>`
                        
                        .. attribute:: spf_summary
                        
                        	SPF summary information
                        	**type**\:   :py:class:`SpfSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary>`
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary, self).__init__()

                            self.yang_name = "spf-run-summary"
                            self.yang_parent_name = "spf-run-summaries"

                            self.spf_run_number = YLeaf(YType.int32, "spf-run-number")

                            self.spf_summary = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary()
                            self.spf_summary.parent = self
                            self._children_name_map["spf_summary"] = "spf-summary"
                            self._children_yang_names.add("spf-summary")

                            self.dijkstra_run = YList(self)
                            self.inter_area_and_external = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("spf_run_number") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary, self).__setattr__(name, value)


                        class SpfSummary(Entity):
                            """
                            SPF summary information
                            
                            .. attribute:: duration
                            
                            	Duration of complete SPF calculation (in ss .msec)
                            	**type**\:  str
                            
                            .. attribute:: is_data_complete
                            
                            	Whether the event has all information
                            	**type**\:  bool
                            
                            .. attribute:: priority_summary
                            
                            	Convergence information summary on per\-priority basis
                            	**type**\: list of    :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary>`
                            
                            .. attribute:: start_time
                            
                            	Start time (offset from event trigger time in ss .msec)
                            	**type**\:  str
                            
                            .. attribute:: state
                            
                            	SPF state
                            	**type**\:   :py:class:`RcmdSpfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdSpfState>`
                            
                            .. attribute:: threshold_exceeded
                            
                            	Threshold exceeded
                            	**type**\:  bool
                            
                            .. attribute:: total_dijkstra_runs
                            
                            	Total number of Dijkstra runs
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: total_inter_area_and_external_batches
                            
                            	Total number of inter\-area/external computation batches
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: total_type12lsa_changes
                            
                            	Total number of Type 1/2 LSA changes processed
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: total_type357lsa_changes
                            
                            	Total number of Type 3/5/7 LSA changes processed
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: trigger_time
                            
                            	Trigger time (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary, self).__init__()

                                self.yang_name = "spf-summary"
                                self.yang_parent_name = "spf-run-summary"

                                self.duration = YLeaf(YType.str, "duration")

                                self.is_data_complete = YLeaf(YType.boolean, "is-data-complete")

                                self.start_time = YLeaf(YType.str, "start-time")

                                self.state = YLeaf(YType.enumeration, "state")

                                self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                self.total_dijkstra_runs = YLeaf(YType.uint16, "total-dijkstra-runs")

                                self.total_inter_area_and_external_batches = YLeaf(YType.uint16, "total-inter-area-and-external-batches")

                                self.total_type12lsa_changes = YLeaf(YType.uint16, "total-type12lsa-changes")

                                self.total_type357lsa_changes = YLeaf(YType.uint16, "total-type357lsa-changes")

                                self.trigger_time = YLeaf(YType.str, "trigger-time")

                                self.priority_summary = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("duration",
                                                "is_data_complete",
                                                "start_time",
                                                "state",
                                                "threshold_exceeded",
                                                "total_dijkstra_runs",
                                                "total_inter_area_and_external_batches",
                                                "total_type12lsa_changes",
                                                "total_type357lsa_changes",
                                                "trigger_time") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary, self).__setattr__(name, value)


                            class PrioritySummary(Entity):
                                """
                                Convergence information summary on per\-priority
                                basis
                                
                                .. attribute:: frr_statistic
                                
                                	Fast Re\-Route Statistics
                                	**type**\: list of    :py:class:`FrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic>`
                                
                                .. attribute:: ip_convergence_time
                                
                                	Convergence time for IP route programming
                                	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime>`
                                
                                .. attribute:: level
                                
                                	Critical, High, Medium or Low
                                	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                
                                .. attribute:: mpls_convergence_time
                                
                                	Convergence time for MPLS label programming
                                	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime>`
                                
                                .. attribute:: route_statistics
                                
                                	Route statistics
                                	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics>`
                                
                                .. attribute:: threshold_exceeded
                                
                                	Threshold exceeded
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary, self).__init__()

                                    self.yang_name = "priority-summary"
                                    self.yang_parent_name = "spf-summary"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                    self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                    self._children_yang_names.add("ip-convergence-time")

                                    self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                    self._children_yang_names.add("mpls-convergence-time")

                                    self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics()
                                    self.route_statistics.parent = self
                                    self._children_name_map["route_statistics"] = "route-statistics"
                                    self._children_yang_names.add("route-statistics")

                                    self.frr_statistic = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "threshold_exceeded") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary, self).__setattr__(name, value)


                                class RouteStatistics(Entity):
                                    """
                                    Route statistics
                                    
                                    .. attribute:: adds
                                    
                                    	Added
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: deletes
                                    
                                    	Deleted
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: modifies
                                    
                                    	Modified
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: reachables
                                    
                                    	Reachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: touches
                                    
                                    	Touched
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: unreachables
                                    
                                    	Unreachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics, self).__init__()

                                        self.yang_name = "route-statistics"
                                        self.yang_parent_name = "priority-summary"

                                        self.adds = YLeaf(YType.uint32, "adds")

                                        self.deletes = YLeaf(YType.uint32, "deletes")

                                        self.modifies = YLeaf(YType.uint32, "modifies")

                                        self.reachables = YLeaf(YType.uint32, "reachables")

                                        self.touches = YLeaf(YType.uint32, "touches")

                                        self.unreachables = YLeaf(YType.uint32, "unreachables")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("adds",
                                                        "deletes",
                                                        "modifies",
                                                        "reachables",
                                                        "touches",
                                                        "unreachables") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.adds.is_set or
                                            self.deletes.is_set or
                                            self.modifies.is_set or
                                            self.reachables.is_set or
                                            self.touches.is_set or
                                            self.unreachables.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.adds.yfilter != YFilter.not_set or
                                            self.deletes.yfilter != YFilter.not_set or
                                            self.modifies.yfilter != YFilter.not_set or
                                            self.reachables.yfilter != YFilter.not_set or
                                            self.touches.yfilter != YFilter.not_set or
                                            self.unreachables.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "route-statistics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.adds.get_name_leafdata())
                                        if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.deletes.get_name_leafdata())
                                        if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.modifies.get_name_leafdata())
                                        if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.reachables.get_name_leafdata())
                                        if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.touches.get_name_leafdata())
                                        if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.unreachables.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "adds"):
                                            self.adds = value
                                            self.adds.value_namespace = name_space
                                            self.adds.value_namespace_prefix = name_space_prefix
                                        if(value_path == "deletes"):
                                            self.deletes = value
                                            self.deletes.value_namespace = name_space
                                            self.deletes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "modifies"):
                                            self.modifies = value
                                            self.modifies.value_namespace = name_space
                                            self.modifies.value_namespace_prefix = name_space_prefix
                                        if(value_path == "reachables"):
                                            self.reachables = value
                                            self.reachables.value_namespace = name_space
                                            self.reachables.value_namespace_prefix = name_space_prefix
                                        if(value_path == "touches"):
                                            self.touches = value
                                            self.touches.value_namespace = name_space
                                            self.touches.value_namespace_prefix = name_space_prefix
                                        if(value_path == "unreachables"):
                                            self.unreachables = value
                                            self.unreachables.value_namespace = name_space
                                            self.unreachables.value_namespace_prefix = name_space_prefix


                                class IpConvergenceTime(Entity):
                                    """
                                    Convergence time for IP route programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime, self).__init__()

                                        self.yang_name = "ip-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ip-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class MplsConvergenceTime(Entity):
                                    """
                                    Convergence time for MPLS label programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__init__()

                                        self.yang_name = "mpls-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mpls-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class FrrStatistic(Entity):
                                    """
                                    Fast Re\-Route Statistics
                                    
                                    .. attribute:: coverage
                                    
                                    	Coverage in percentage
                                    	**type**\:  str
                                    
                                    	**units**\: percentage
                                    
                                    .. attribute:: fully_protected_routes
                                    
                                    	Fully Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: partially_protected_routes
                                    
                                    	Partially Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_routes
                                    
                                    	Total Number of Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic, self).__init__()

                                        self.yang_name = "frr-statistic"
                                        self.yang_parent_name = "priority-summary"

                                        self.coverage = YLeaf(YType.str, "coverage")

                                        self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                        self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                        self.total_routes = YLeaf(YType.uint32, "total-routes")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("coverage",
                                                        "fully_protected_routes",
                                                        "partially_protected_routes",
                                                        "total_routes") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.coverage.is_set or
                                            self.fully_protected_routes.is_set or
                                            self.partially_protected_routes.is_set or
                                            self.total_routes.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.coverage.yfilter != YFilter.not_set or
                                            self.fully_protected_routes.yfilter != YFilter.not_set or
                                            self.partially_protected_routes.yfilter != YFilter.not_set or
                                            self.total_routes.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-statistic" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.coverage.get_name_leafdata())
                                        if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                        if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                        if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_routes.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "coverage" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "total-routes"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "coverage"):
                                            self.coverage = value
                                            self.coverage.value_namespace = name_space
                                            self.coverage.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fully-protected-routes"):
                                            self.fully_protected_routes = value
                                            self.fully_protected_routes.value_namespace = name_space
                                            self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "partially-protected-routes"):
                                            self.partially_protected_routes = value
                                            self.partially_protected_routes.value_namespace = name_space
                                            self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-routes"):
                                            self.total_routes = value
                                            self.total_routes.value_namespace = name_space
                                            self.total_routes.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_statistic:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.level.is_set or
                                        self.threshold_exceeded.is_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                        (self.route_statistics is not None and self.route_statistics.has_data()))

                                def has_operation(self):
                                    for c in self.frr_statistic:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.threshold_exceeded.yfilter != YFilter.not_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                        (self.route_statistics is not None and self.route_statistics.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority-summary" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-statistic"):
                                        for c in self.frr_statistic:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_statistic.append(c)
                                        return c

                                    if (child_yang_name == "ip-convergence-time"):
                                        if (self.ip_convergence_time is None):
                                            self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime()
                                            self.ip_convergence_time.parent = self
                                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        return self.ip_convergence_time

                                    if (child_yang_name == "mpls-convergence-time"):
                                        if (self.mpls_convergence_time is None):
                                            self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime()
                                            self.mpls_convergence_time.parent = self
                                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        return self.mpls_convergence_time

                                    if (child_yang_name == "route-statistics"):
                                        if (self.route_statistics is None):
                                            self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics()
                                            self.route_statistics.parent = self
                                            self._children_name_map["route_statistics"] = "route-statistics"
                                        return self.route_statistics

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-statistic" or name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "threshold-exceeded"):
                                        self.threshold_exceeded = value
                                        self.threshold_exceeded.value_namespace = name_space
                                        self.threshold_exceeded.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.priority_summary:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.duration.is_set or
                                    self.is_data_complete.is_set or
                                    self.start_time.is_set or
                                    self.state.is_set or
                                    self.threshold_exceeded.is_set or
                                    self.total_dijkstra_runs.is_set or
                                    self.total_inter_area_and_external_batches.is_set or
                                    self.total_type12lsa_changes.is_set or
                                    self.total_type357lsa_changes.is_set or
                                    self.trigger_time.is_set)

                            def has_operation(self):
                                for c in self.priority_summary:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.duration.yfilter != YFilter.not_set or
                                    self.is_data_complete.yfilter != YFilter.not_set or
                                    self.start_time.yfilter != YFilter.not_set or
                                    self.state.yfilter != YFilter.not_set or
                                    self.threshold_exceeded.yfilter != YFilter.not_set or
                                    self.total_dijkstra_runs.yfilter != YFilter.not_set or
                                    self.total_inter_area_and_external_batches.yfilter != YFilter.not_set or
                                    self.total_type12lsa_changes.yfilter != YFilter.not_set or
                                    self.total_type357lsa_changes.yfilter != YFilter.not_set or
                                    self.trigger_time.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-summary" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                if (self.is_data_complete.is_set or self.is_data_complete.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_data_complete.get_name_leafdata())
                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_time.get_name_leafdata())
                                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.state.get_name_leafdata())
                                if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                                if (self.total_dijkstra_runs.is_set or self.total_dijkstra_runs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_dijkstra_runs.get_name_leafdata())
                                if (self.total_inter_area_and_external_batches.is_set or self.total_inter_area_and_external_batches.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_inter_area_and_external_batches.get_name_leafdata())
                                if (self.total_type12lsa_changes.is_set or self.total_type12lsa_changes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_type12lsa_changes.get_name_leafdata())
                                if (self.total_type357lsa_changes.is_set or self.total_type357lsa_changes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_type357lsa_changes.get_name_leafdata())
                                if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.trigger_time.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "priority-summary"):
                                    for c in self.priority_summary:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.priority_summary.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "priority-summary" or name == "duration" or name == "is-data-complete" or name == "start-time" or name == "state" or name == "threshold-exceeded" or name == "total-dijkstra-runs" or name == "total-inter-area-and-external-batches" or name == "total-type12lsa-changes" or name == "total-type357lsa-changes" or name == "trigger-time"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "duration"):
                                    self.duration = value
                                    self.duration.value_namespace = name_space
                                    self.duration.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-data-complete"):
                                    self.is_data_complete = value
                                    self.is_data_complete.value_namespace = name_space
                                    self.is_data_complete.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-time"):
                                    self.start_time = value
                                    self.start_time.value_namespace = name_space
                                    self.start_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "state"):
                                    self.state = value
                                    self.state.value_namespace = name_space
                                    self.state.value_namespace_prefix = name_space_prefix
                                if(value_path == "threshold-exceeded"):
                                    self.threshold_exceeded = value
                                    self.threshold_exceeded.value_namespace = name_space
                                    self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-dijkstra-runs"):
                                    self.total_dijkstra_runs = value
                                    self.total_dijkstra_runs.value_namespace = name_space
                                    self.total_dijkstra_runs.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-inter-area-and-external-batches"):
                                    self.total_inter_area_and_external_batches = value
                                    self.total_inter_area_and_external_batches.value_namespace = name_space
                                    self.total_inter_area_and_external_batches.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-type12lsa-changes"):
                                    self.total_type12lsa_changes = value
                                    self.total_type12lsa_changes.value_namespace = name_space
                                    self.total_type12lsa_changes.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-type357lsa-changes"):
                                    self.total_type357lsa_changes = value
                                    self.total_type357lsa_changes.value_namespace = name_space
                                    self.total_type357lsa_changes.value_namespace_prefix = name_space_prefix
                                if(value_path == "trigger-time"):
                                    self.trigger_time = value
                                    self.trigger_time.value_namespace = name_space
                                    self.trigger_time.value_namespace_prefix = name_space_prefix


                        class DijkstraRun(Entity):
                            """
                            List of Dijkstra runs
                            
                            .. attribute:: area_id
                            
                            	Area ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: dijkstra_run_number
                            
                            	Area Dijkstra run number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: duration
                            
                            	Duration of Dijktra calculation (in ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: lsa_processed
                            
                            	List of type 1/2 LSA changes processed
                            	**type**\: list of    :py:class:`LsaProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.LsaProcessed>`
                            
                            .. attribute:: priority
                            
                            	Convergence information on per\-priority basis
                            	**type**\: list of    :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority>`
                            
                            .. attribute:: start_time
                            
                            	Start time (offset from event trigger time in ss .msec)
                            	**type**\:  str
                            
                            .. attribute:: threshold_exceeded
                            
                            	Threshold exceeded
                            	**type**\:  bool
                            
                            .. attribute:: trigger_lsa
                            
                            	LSA that triggered the Dijkstra run
                            	**type**\: list of    :py:class:`TriggerLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.TriggerLsa>`
                            
                            .. attribute:: trigger_time
                            
                            	Trigger time (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: wait_time
                            
                            	Wait time (offset from event trigger time in ss .msec)
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun, self).__init__()

                                self.yang_name = "dijkstra-run"
                                self.yang_parent_name = "spf-run-summary"

                                self.area_id = YLeaf(YType.str, "area-id")

                                self.dijkstra_run_number = YLeaf(YType.uint32, "dijkstra-run-number")

                                self.duration = YLeaf(YType.str, "duration")

                                self.start_time = YLeaf(YType.str, "start-time")

                                self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                self.trigger_time = YLeaf(YType.str, "trigger-time")

                                self.wait_time = YLeaf(YType.uint32, "wait-time")

                                self.lsa_processed = YList(self)
                                self.priority = YList(self)
                                self.trigger_lsa = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area_id",
                                                "dijkstra_run_number",
                                                "duration",
                                                "start_time",
                                                "threshold_exceeded",
                                                "trigger_time",
                                                "wait_time") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun, self).__setattr__(name, value)


                            class TriggerLsa(Entity):
                                """
                                LSA that triggered the Dijkstra run
                                
                                .. attribute:: change_type
                                
                                	Add, Delete, Modify
                                	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                                
                                .. attribute:: lsa_id
                                
                                	LSA ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: lsa_type
                                
                                	LSA type
                                	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                                
                                .. attribute:: origin_router_id
                                
                                	Originating Router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: reception_time
                                
                                	Reception Time on router (in hh\:mm\:ss.msec)
                                	**type**\:  str
                                
                                .. attribute:: sequence_number
                                
                                	Sequence Number
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.TriggerLsa, self).__init__()

                                    self.yang_name = "trigger-lsa"
                                    self.yang_parent_name = "dijkstra-run"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.lsa_id = YLeaf(YType.str, "lsa-id")

                                    self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                    self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                    self.reception_time = YLeaf(YType.str, "reception-time")

                                    self.sequence_number = YLeaf(YType.str, "sequence-number")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "lsa_id",
                                                    "lsa_type",
                                                    "origin_router_id",
                                                    "reception_time",
                                                    "sequence_number") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.TriggerLsa, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.TriggerLsa, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.lsa_id.is_set or
                                        self.lsa_type.is_set or
                                        self.origin_router_id.is_set or
                                        self.reception_time.is_set or
                                        self.sequence_number.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.lsa_id.yfilter != YFilter.not_set or
                                        self.lsa_type.yfilter != YFilter.not_set or
                                        self.origin_router_id.yfilter != YFilter.not_set or
                                        self.reception_time.yfilter != YFilter.not_set or
                                        self.sequence_number.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "trigger-lsa" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                    if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                    if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                    if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.reception_time.get_name_leafdata())
                                    if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsa-id"):
                                        self.lsa_id = value
                                        self.lsa_id.value_namespace = name_space
                                        self.lsa_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsa-type"):
                                        self.lsa_type = value
                                        self.lsa_type.value_namespace = name_space
                                        self.lsa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "origin-router-id"):
                                        self.origin_router_id = value
                                        self.origin_router_id.value_namespace = name_space
                                        self.origin_router_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "reception-time"):
                                        self.reception_time = value
                                        self.reception_time.value_namespace = name_space
                                        self.reception_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "sequence-number"):
                                        self.sequence_number = value
                                        self.sequence_number.value_namespace = name_space
                                        self.sequence_number.value_namespace_prefix = name_space_prefix


                            class Priority(Entity):
                                """
                                Convergence information on per\-priority basis
                                
                                .. attribute:: convergence_timeline
                                
                                	Convergence timeline details
                                	**type**\: list of    :py:class:`ConvergenceTimeline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline>`
                                
                                .. attribute:: leaf_networks_added
                                
                                	List of Leaf Networks Added
                                	**type**\: list of    :py:class:`LeafNetworksAdded <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksAdded>`
                                
                                .. attribute:: leaf_networks_deleted
                                
                                	List of Leaf Networks Deleted
                                	**type**\: list of    :py:class:`LeafNetworksDeleted <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksDeleted>`
                                
                                .. attribute:: priority_summary
                                
                                	Summary of the priority
                                	**type**\:   :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority, self).__init__()

                                    self.yang_name = "priority"
                                    self.yang_parent_name = "dijkstra-run"

                                    self.priority_summary = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary()
                                    self.priority_summary.parent = self
                                    self._children_name_map["priority_summary"] = "priority-summary"
                                    self._children_yang_names.add("priority-summary")

                                    self.convergence_timeline = YList(self)
                                    self.leaf_networks_added = YList(self)
                                    self.leaf_networks_deleted = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority, self).__setattr__(name, value)


                                class PrioritySummary(Entity):
                                    """
                                    Summary of the priority
                                    
                                    .. attribute:: frr_statistic
                                    
                                    	Fast Re\-Route Statistics
                                    	**type**\: list of    :py:class:`FrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.FrrStatistic>`
                                    
                                    .. attribute:: ip_convergence_time
                                    
                                    	Convergence time for IP route programming
                                    	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime>`
                                    
                                    .. attribute:: level
                                    
                                    	Critical, High, Medium or Low
                                    	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                    
                                    .. attribute:: mpls_convergence_time
                                    
                                    	Convergence time for MPLS label programming
                                    	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime>`
                                    
                                    .. attribute:: route_statistics
                                    
                                    	Route statistics
                                    	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.RouteStatistics>`
                                    
                                    .. attribute:: threshold_exceeded
                                    
                                    	Threshold exceeded
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary, self).__init__()

                                        self.yang_name = "priority-summary"
                                        self.yang_parent_name = "priority"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                        self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime()
                                        self.ip_convergence_time.parent = self
                                        self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        self._children_yang_names.add("ip-convergence-time")

                                        self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime()
                                        self.mpls_convergence_time.parent = self
                                        self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        self._children_yang_names.add("mpls-convergence-time")

                                        self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.RouteStatistics()
                                        self.route_statistics.parent = self
                                        self._children_name_map["route_statistics"] = "route-statistics"
                                        self._children_yang_names.add("route-statistics")

                                        self.frr_statistic = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "threshold_exceeded") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary, self).__setattr__(name, value)


                                    class RouteStatistics(Entity):
                                        """
                                        Route statistics
                                        
                                        .. attribute:: adds
                                        
                                        	Added
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: deletes
                                        
                                        	Deleted
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: modifies
                                        
                                        	Modified
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: reachables
                                        
                                        	Reachable
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: touches
                                        
                                        	Touched
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: unreachables
                                        
                                        	Unreachable
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.RouteStatistics, self).__init__()

                                            self.yang_name = "route-statistics"
                                            self.yang_parent_name = "priority-summary"

                                            self.adds = YLeaf(YType.uint32, "adds")

                                            self.deletes = YLeaf(YType.uint32, "deletes")

                                            self.modifies = YLeaf(YType.uint32, "modifies")

                                            self.reachables = YLeaf(YType.uint32, "reachables")

                                            self.touches = YLeaf(YType.uint32, "touches")

                                            self.unreachables = YLeaf(YType.uint32, "unreachables")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("adds",
                                                            "deletes",
                                                            "modifies",
                                                            "reachables",
                                                            "touches",
                                                            "unreachables") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.adds.is_set or
                                                self.deletes.is_set or
                                                self.modifies.is_set or
                                                self.reachables.is_set or
                                                self.touches.is_set or
                                                self.unreachables.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.adds.yfilter != YFilter.not_set or
                                                self.deletes.yfilter != YFilter.not_set or
                                                self.modifies.yfilter != YFilter.not_set or
                                                self.reachables.yfilter != YFilter.not_set or
                                                self.touches.yfilter != YFilter.not_set or
                                                self.unreachables.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-statistics" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adds.get_name_leafdata())
                                            if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.deletes.get_name_leafdata())
                                            if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.modifies.get_name_leafdata())
                                            if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.reachables.get_name_leafdata())
                                            if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.touches.get_name_leafdata())
                                            if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.unreachables.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "adds"):
                                                self.adds = value
                                                self.adds.value_namespace = name_space
                                                self.adds.value_namespace_prefix = name_space_prefix
                                            if(value_path == "deletes"):
                                                self.deletes = value
                                                self.deletes.value_namespace = name_space
                                                self.deletes.value_namespace_prefix = name_space_prefix
                                            if(value_path == "modifies"):
                                                self.modifies = value
                                                self.modifies.value_namespace = name_space
                                                self.modifies.value_namespace_prefix = name_space_prefix
                                            if(value_path == "reachables"):
                                                self.reachables = value
                                                self.reachables.value_namespace = name_space
                                                self.reachables.value_namespace_prefix = name_space_prefix
                                            if(value_path == "touches"):
                                                self.touches = value
                                                self.touches.value_namespace = name_space
                                                self.touches.value_namespace_prefix = name_space_prefix
                                            if(value_path == "unreachables"):
                                                self.unreachables = value
                                                self.unreachables.value_namespace = name_space
                                                self.unreachables.value_namespace_prefix = name_space_prefix


                                    class IpConvergenceTime(Entity):
                                        """
                                        Convergence time for IP route programming
                                        
                                        .. attribute:: fastest_node_name
                                        
                                        	Linecard node name which took the minimum time
                                        	**type**\:  str
                                        
                                        .. attribute:: maximum_time
                                        
                                        	Maximum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: minimum_time
                                        
                                        	Minimum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: slowest_node_name
                                        
                                        	Linecard node name which took the maximum time
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime, self).__init__()

                                            self.yang_name = "ip-convergence-time"
                                            self.yang_parent_name = "priority-summary"

                                            self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                            self.maximum_time = YLeaf(YType.str, "maximum-time")

                                            self.minimum_time = YLeaf(YType.str, "minimum-time")

                                            self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fastest_node_name",
                                                            "maximum_time",
                                                            "minimum_time",
                                                            "slowest_node_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.fastest_node_name.is_set or
                                                self.maximum_time.is_set or
                                                self.minimum_time.is_set or
                                                self.slowest_node_name.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fastest_node_name.yfilter != YFilter.not_set or
                                                self.maximum_time.yfilter != YFilter.not_set or
                                                self.minimum_time.yfilter != YFilter.not_set or
                                                self.slowest_node_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ip-convergence-time" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                            if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                            if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                            if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fastest-node-name"):
                                                self.fastest_node_name = value
                                                self.fastest_node_name.value_namespace = name_space
                                                self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "maximum-time"):
                                                self.maximum_time = value
                                                self.maximum_time.value_namespace = name_space
                                                self.maximum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "minimum-time"):
                                                self.minimum_time = value
                                                self.minimum_time.value_namespace = name_space
                                                self.minimum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "slowest-node-name"):
                                                self.slowest_node_name = value
                                                self.slowest_node_name.value_namespace = name_space
                                                self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                    class MplsConvergenceTime(Entity):
                                        """
                                        Convergence time for MPLS label programming
                                        
                                        .. attribute:: fastest_node_name
                                        
                                        	Linecard node name which took the minimum time
                                        	**type**\:  str
                                        
                                        .. attribute:: maximum_time
                                        
                                        	Maximum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: minimum_time
                                        
                                        	Minimum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: slowest_node_name
                                        
                                        	Linecard node name which took the maximum time
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime, self).__init__()

                                            self.yang_name = "mpls-convergence-time"
                                            self.yang_parent_name = "priority-summary"

                                            self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                            self.maximum_time = YLeaf(YType.str, "maximum-time")

                                            self.minimum_time = YLeaf(YType.str, "minimum-time")

                                            self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fastest_node_name",
                                                            "maximum_time",
                                                            "minimum_time",
                                                            "slowest_node_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.fastest_node_name.is_set or
                                                self.maximum_time.is_set or
                                                self.minimum_time.is_set or
                                                self.slowest_node_name.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fastest_node_name.yfilter != YFilter.not_set or
                                                self.maximum_time.yfilter != YFilter.not_set or
                                                self.minimum_time.yfilter != YFilter.not_set or
                                                self.slowest_node_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "mpls-convergence-time" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                            if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                            if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                            if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fastest-node-name"):
                                                self.fastest_node_name = value
                                                self.fastest_node_name.value_namespace = name_space
                                                self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "maximum-time"):
                                                self.maximum_time = value
                                                self.maximum_time.value_namespace = name_space
                                                self.maximum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "minimum-time"):
                                                self.minimum_time = value
                                                self.minimum_time.value_namespace = name_space
                                                self.minimum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "slowest-node-name"):
                                                self.slowest_node_name = value
                                                self.slowest_node_name.value_namespace = name_space
                                                self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                    class FrrStatistic(Entity):
                                        """
                                        Fast Re\-Route Statistics
                                        
                                        .. attribute:: coverage
                                        
                                        	Coverage in percentage
                                        	**type**\:  str
                                        
                                        	**units**\: percentage
                                        
                                        .. attribute:: fully_protected_routes
                                        
                                        	Fully Protected Routes
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: partially_protected_routes
                                        
                                        	Partially Protected Routes
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: total_routes
                                        
                                        	Total Number of Routes
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.FrrStatistic, self).__init__()

                                            self.yang_name = "frr-statistic"
                                            self.yang_parent_name = "priority-summary"

                                            self.coverage = YLeaf(YType.str, "coverage")

                                            self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                            self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                            self.total_routes = YLeaf(YType.uint32, "total-routes")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("coverage",
                                                            "fully_protected_routes",
                                                            "partially_protected_routes",
                                                            "total_routes") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.FrrStatistic, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.FrrStatistic, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.coverage.is_set or
                                                self.fully_protected_routes.is_set or
                                                self.partially_protected_routes.is_set or
                                                self.total_routes.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.coverage.yfilter != YFilter.not_set or
                                                self.fully_protected_routes.yfilter != YFilter.not_set or
                                                self.partially_protected_routes.yfilter != YFilter.not_set or
                                                self.total_routes.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-statistic" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.coverage.get_name_leafdata())
                                            if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                            if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                            if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.total_routes.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "coverage" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "total-routes"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "coverage"):
                                                self.coverage = value
                                                self.coverage.value_namespace = name_space
                                                self.coverage.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fully-protected-routes"):
                                                self.fully_protected_routes = value
                                                self.fully_protected_routes.value_namespace = name_space
                                                self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                            if(value_path == "partially-protected-routes"):
                                                self.partially_protected_routes = value
                                                self.partially_protected_routes.value_namespace = name_space
                                                self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                            if(value_path == "total-routes"):
                                                self.total_routes = value
                                                self.total_routes.value_namespace = name_space
                                                self.total_routes.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.frr_statistic:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.level.is_set or
                                            self.threshold_exceeded.is_set or
                                            (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                            (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                            (self.route_statistics is not None and self.route_statistics.has_data()))

                                    def has_operation(self):
                                        for c in self.frr_statistic:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.threshold_exceeded.yfilter != YFilter.not_set or
                                            (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                            (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                            (self.route_statistics is not None and self.route_statistics.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "priority-summary" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "frr-statistic"):
                                            for c in self.frr_statistic:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.FrrStatistic()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.frr_statistic.append(c)
                                            return c

                                        if (child_yang_name == "ip-convergence-time"):
                                            if (self.ip_convergence_time is None):
                                                self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime()
                                                self.ip_convergence_time.parent = self
                                                self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                            return self.ip_convergence_time

                                        if (child_yang_name == "mpls-convergence-time"):
                                            if (self.mpls_convergence_time is None):
                                                self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime()
                                                self.mpls_convergence_time.parent = self
                                                self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                            return self.mpls_convergence_time

                                        if (child_yang_name == "route-statistics"):
                                            if (self.route_statistics is None):
                                                self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary.RouteStatistics()
                                                self.route_statistics.parent = self
                                                self._children_name_map["route_statistics"] = "route-statistics"
                                            return self.route_statistics

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "frr-statistic" or name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "threshold-exceeded"):
                                            self.threshold_exceeded = value
                                            self.threshold_exceeded.value_namespace = name_space
                                            self.threshold_exceeded.value_namespace_prefix = name_space_prefix


                                class ConvergenceTimeline(Entity):
                                    """
                                    Convergence timeline details
                                    
                                    .. attribute:: lc_ip
                                    
                                    	List of Linecards' completion point for IP routes
                                    	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp>`
                                    
                                    .. attribute:: lc_mpls
                                    
                                    	List of Linecards' completion point for MPLS labels
                                    	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls>`
                                    
                                    .. attribute:: ldp_enter
                                    
                                    	Entry point of LDP
                                    	**type**\:   :py:class:`LdpEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter>`
                                    
                                    .. attribute:: ldp_exit
                                    
                                    	Exit point of LDP to LSD
                                    	**type**\:   :py:class:`LdpExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpExit>`
                                    
                                    .. attribute:: lsd_enter
                                    
                                    	Entry point of LSD
                                    	**type**\:   :py:class:`LsdEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter>`
                                    
                                    .. attribute:: lsd_exit
                                    
                                    	Exit point of LSD to FIBs
                                    	**type**\:   :py:class:`LsdExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdExit>`
                                    
                                    .. attribute:: ri_bv4_enter
                                    
                                    	Entry point of IPv4 RIB
                                    	**type**\:   :py:class:`RiBv4Enter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter>`
                                    
                                    .. attribute:: ri_bv4_exit
                                    
                                    	Exit point from IPv4 RIB to FIBs
                                    	**type**\:   :py:class:`RiBv4Exit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit>`
                                    
                                    .. attribute:: ri_bv4_redistribute
                                    
                                    	Route Redistribute point from IPv4 RIB to LDP
                                    	**type**\:   :py:class:`RiBv4Redistribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute>`
                                    
                                    .. attribute:: route_origin
                                    
                                    	Route origin (routing protocol)
                                    	**type**\:   :py:class:`RouteOrigin <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin>`
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline, self).__init__()

                                        self.yang_name = "convergence-timeline"
                                        self.yang_parent_name = "priority"

                                        self.ldp_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter()
                                        self.ldp_enter.parent = self
                                        self._children_name_map["ldp_enter"] = "ldp-enter"
                                        self._children_yang_names.add("ldp-enter")

                                        self.ldp_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpExit()
                                        self.ldp_exit.parent = self
                                        self._children_name_map["ldp_exit"] = "ldp-exit"
                                        self._children_yang_names.add("ldp-exit")

                                        self.lsd_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter()
                                        self.lsd_enter.parent = self
                                        self._children_name_map["lsd_enter"] = "lsd-enter"
                                        self._children_yang_names.add("lsd-enter")

                                        self.lsd_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdExit()
                                        self.lsd_exit.parent = self
                                        self._children_name_map["lsd_exit"] = "lsd-exit"
                                        self._children_yang_names.add("lsd-exit")

                                        self.ri_bv4_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter()
                                        self.ri_bv4_enter.parent = self
                                        self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                        self._children_yang_names.add("ri-bv4-enter")

                                        self.ri_bv4_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit()
                                        self.ri_bv4_exit.parent = self
                                        self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                        self._children_yang_names.add("ri-bv4-exit")

                                        self.ri_bv4_redistribute = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                        self.ri_bv4_redistribute.parent = self
                                        self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                        self._children_yang_names.add("ri-bv4-redistribute")

                                        self.route_origin = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin()
                                        self.route_origin.parent = self
                                        self._children_name_map["route_origin"] = "route-origin"
                                        self._children_yang_names.add("route-origin")

                                        self.lc_ip = YList(self)
                                        self.lc_mpls = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline, self).__setattr__(name, value)


                                    class RouteOrigin(Entity):
                                        """
                                        Route origin (routing protocol)
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin, self).__init__()

                                            self.yang_name = "route-origin"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-origin" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Enter(Entity):
                                        """
                                        Entry point of IPv4 RIB
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter, self).__init__()

                                            self.yang_name = "ri-bv4-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Exit(Entity):
                                        """
                                        Exit point from IPv4 RIB to FIBs
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit, self).__init__()

                                            self.yang_name = "ri-bv4-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Redistribute(Entity):
                                        """
                                        Route Redistribute point from IPv4 RIB to LDP
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__init__()

                                            self.yang_name = "ri-bv4-redistribute"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-redistribute" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LdpEnter(Entity):
                                        """
                                        Entry point of LDP
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter, self).__init__()

                                            self.yang_name = "ldp-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ldp-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LdpExit(Entity):
                                        """
                                        Exit point of LDP to LSD
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpExit, self).__init__()

                                            self.yang_name = "ldp-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ldp-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LsdEnter(Entity):
                                        """
                                        Entry point of LSD
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter, self).__init__()

                                            self.yang_name = "lsd-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lsd-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LsdExit(Entity):
                                        """
                                        Exit point of LSD to FIBs
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdExit, self).__init__()

                                            self.yang_name = "lsd-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lsd-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LcIp(Entity):
                                        """
                                        List of Linecards' completion point for IP
                                        routes
                                        
                                        .. attribute:: fib_complete
                                        
                                        	Completion point of FIB
                                        	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete>`
                                        
                                        .. attribute:: node_name
                                        
                                        	Linecard node name
                                        	**type**\:  str
                                        
                                        .. attribute:: speed
                                        
                                        	Relative convergence speed
                                        	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp, self).__init__()

                                            self.yang_name = "lc-ip"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.node_name = YLeaf(YType.str, "node-name")

                                            self.speed = YLeaf(YType.enumeration, "speed")

                                            self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                            self.fib_complete.parent = self
                                            self._children_name_map["fib_complete"] = "fib-complete"
                                            self._children_yang_names.add("fib-complete")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("node_name",
                                                            "speed") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)


                                        class FibComplete(Entity):
                                            """
                                            Completion point of FIB
                                            
                                            .. attribute:: duration
                                            
                                            	Duration of processing (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: end_time
                                            
                                            	Last route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: start_time
                                            
                                            	First route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'infra-rcmd-oper'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__init__()

                                                self.yang_name = "fib-complete"
                                                self.yang_parent_name = "lc-ip"

                                                self.duration = YLeaf(YType.str, "duration")

                                                self.end_time = YLeaf(YType.str, "end-time")

                                                self.start_time = YLeaf(YType.str, "start-time")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("duration",
                                                                "end_time",
                                                                "start_time") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.duration.is_set or
                                                    self.end_time.is_set or
                                                    self.start_time.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.duration.yfilter != YFilter.not_set or
                                                    self.end_time.yfilter != YFilter.not_set or
                                                    self.start_time.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-complete" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                                if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.end_time.get_name_leafdata())
                                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.start_time.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "duration" or name == "end-time" or name == "start-time"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "duration"):
                                                    self.duration = value
                                                    self.duration.value_namespace = name_space
                                                    self.duration.value_namespace_prefix = name_space_prefix
                                                if(value_path == "end-time"):
                                                    self.end_time = value
                                                    self.end_time.value_namespace = name_space
                                                    self.end_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "start-time"):
                                                    self.start_time = value
                                                    self.start_time.value_namespace = name_space
                                                    self.start_time.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.node_name.is_set or
                                                self.speed.is_set or
                                                (self.fib_complete is not None and self.fib_complete.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.node_name.yfilter != YFilter.not_set or
                                                self.speed.yfilter != YFilter.not_set or
                                                (self.fib_complete is not None and self.fib_complete.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lc-ip" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_name.get_name_leafdata())
                                            if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.speed.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-complete"):
                                                if (self.fib_complete is None):
                                                    self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                                    self.fib_complete.parent = self
                                                    self._children_name_map["fib_complete"] = "fib-complete"
                                                return self.fib_complete

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "node-name"):
                                                self.node_name = value
                                                self.node_name.value_namespace = name_space
                                                self.node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "speed"):
                                                self.speed = value
                                                self.speed.value_namespace = name_space
                                                self.speed.value_namespace_prefix = name_space_prefix


                                    class LcMpls(Entity):
                                        """
                                        List of Linecards' completion point for MPLS
                                        labels
                                        
                                        .. attribute:: fib_complete
                                        
                                        	Completion point of FIB
                                        	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete>`
                                        
                                        .. attribute:: node_name
                                        
                                        	Linecard node name
                                        	**type**\:  str
                                        
                                        .. attribute:: speed
                                        
                                        	Relative convergence speed
                                        	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls, self).__init__()

                                            self.yang_name = "lc-mpls"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.node_name = YLeaf(YType.str, "node-name")

                                            self.speed = YLeaf(YType.enumeration, "speed")

                                            self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                            self.fib_complete.parent = self
                                            self._children_name_map["fib_complete"] = "fib-complete"
                                            self._children_yang_names.add("fib-complete")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("node_name",
                                                            "speed") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)


                                        class FibComplete(Entity):
                                            """
                                            Completion point of FIB
                                            
                                            .. attribute:: duration
                                            
                                            	Duration of processing (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: end_time
                                            
                                            	Last route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: start_time
                                            
                                            	First route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'infra-rcmd-oper'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__init__()

                                                self.yang_name = "fib-complete"
                                                self.yang_parent_name = "lc-mpls"

                                                self.duration = YLeaf(YType.str, "duration")

                                                self.end_time = YLeaf(YType.str, "end-time")

                                                self.start_time = YLeaf(YType.str, "start-time")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("duration",
                                                                "end_time",
                                                                "start_time") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.duration.is_set or
                                                    self.end_time.is_set or
                                                    self.start_time.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.duration.yfilter != YFilter.not_set or
                                                    self.end_time.yfilter != YFilter.not_set or
                                                    self.start_time.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-complete" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                                if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.end_time.get_name_leafdata())
                                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.start_time.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "duration" or name == "end-time" or name == "start-time"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "duration"):
                                                    self.duration = value
                                                    self.duration.value_namespace = name_space
                                                    self.duration.value_namespace_prefix = name_space_prefix
                                                if(value_path == "end-time"):
                                                    self.end_time = value
                                                    self.end_time.value_namespace = name_space
                                                    self.end_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "start-time"):
                                                    self.start_time = value
                                                    self.start_time.value_namespace = name_space
                                                    self.start_time.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.node_name.is_set or
                                                self.speed.is_set or
                                                (self.fib_complete is not None and self.fib_complete.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.node_name.yfilter != YFilter.not_set or
                                                self.speed.yfilter != YFilter.not_set or
                                                (self.fib_complete is not None and self.fib_complete.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lc-mpls" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_name.get_name_leafdata())
                                            if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.speed.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-complete"):
                                                if (self.fib_complete is None):
                                                    self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                                    self.fib_complete.parent = self
                                                    self._children_name_map["fib_complete"] = "fib-complete"
                                                return self.fib_complete

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "node-name"):
                                                self.node_name = value
                                                self.node_name.value_namespace = name_space
                                                self.node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "speed"):
                                                self.speed = value
                                                self.speed.value_namespace = name_space
                                                self.speed.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.lc_ip:
                                            if (c.has_data()):
                                                return True
                                        for c in self.lc_mpls:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            (self.ldp_enter is not None and self.ldp_enter.has_data()) or
                                            (self.ldp_exit is not None and self.ldp_exit.has_data()) or
                                            (self.lsd_enter is not None and self.lsd_enter.has_data()) or
                                            (self.lsd_exit is not None and self.lsd_exit.has_data()) or
                                            (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_data()) or
                                            (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_data()) or
                                            (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_data()) or
                                            (self.route_origin is not None and self.route_origin.has_data()))

                                    def has_operation(self):
                                        for c in self.lc_ip:
                                            if (c.has_operation()):
                                                return True
                                        for c in self.lc_mpls:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.ldp_enter is not None and self.ldp_enter.has_operation()) or
                                            (self.ldp_exit is not None and self.ldp_exit.has_operation()) or
                                            (self.lsd_enter is not None and self.lsd_enter.has_operation()) or
                                            (self.lsd_exit is not None and self.lsd_exit.has_operation()) or
                                            (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_operation()) or
                                            (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_operation()) or
                                            (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_operation()) or
                                            (self.route_origin is not None and self.route_origin.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "convergence-timeline" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "lc-ip"):
                                            for c in self.lc_ip:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcIp()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.lc_ip.append(c)
                                            return c

                                        if (child_yang_name == "lc-mpls"):
                                            for c in self.lc_mpls:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LcMpls()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.lc_mpls.append(c)
                                            return c

                                        if (child_yang_name == "ldp-enter"):
                                            if (self.ldp_enter is None):
                                                self.ldp_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter()
                                                self.ldp_enter.parent = self
                                                self._children_name_map["ldp_enter"] = "ldp-enter"
                                            return self.ldp_enter

                                        if (child_yang_name == "ldp-exit"):
                                            if (self.ldp_exit is None):
                                                self.ldp_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LdpExit()
                                                self.ldp_exit.parent = self
                                                self._children_name_map["ldp_exit"] = "ldp-exit"
                                            return self.ldp_exit

                                        if (child_yang_name == "lsd-enter"):
                                            if (self.lsd_enter is None):
                                                self.lsd_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter()
                                                self.lsd_enter.parent = self
                                                self._children_name_map["lsd_enter"] = "lsd-enter"
                                            return self.lsd_enter

                                        if (child_yang_name == "lsd-exit"):
                                            if (self.lsd_exit is None):
                                                self.lsd_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.LsdExit()
                                                self.lsd_exit.parent = self
                                                self._children_name_map["lsd_exit"] = "lsd-exit"
                                            return self.lsd_exit

                                        if (child_yang_name == "ri-bv4-enter"):
                                            if (self.ri_bv4_enter is None):
                                                self.ri_bv4_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter()
                                                self.ri_bv4_enter.parent = self
                                                self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                            return self.ri_bv4_enter

                                        if (child_yang_name == "ri-bv4-exit"):
                                            if (self.ri_bv4_exit is None):
                                                self.ri_bv4_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit()
                                                self.ri_bv4_exit.parent = self
                                                self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                            return self.ri_bv4_exit

                                        if (child_yang_name == "ri-bv4-redistribute"):
                                            if (self.ri_bv4_redistribute is None):
                                                self.ri_bv4_redistribute = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                                self.ri_bv4_redistribute.parent = self
                                                self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                            return self.ri_bv4_redistribute

                                        if (child_yang_name == "route-origin"):
                                            if (self.route_origin is None):
                                                self.route_origin = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin()
                                                self.route_origin.parent = self
                                                self._children_name_map["route_origin"] = "route-origin"
                                            return self.route_origin

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class LeafNetworksAdded(Entity):
                                    """
                                    List of Leaf Networks Added
                                    
                                    .. attribute:: address
                                    
                                    	IP address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: net_mask
                                    
                                    	Mask
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksAdded, self).__init__()

                                        self.yang_name = "leaf-networks-added"
                                        self.yang_parent_name = "priority"

                                        self.address = YLeaf(YType.str, "address")

                                        self.net_mask = YLeaf(YType.uint8, "net-mask")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("address",
                                                        "net_mask") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksAdded, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksAdded, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.address.is_set or
                                            self.net_mask.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.net_mask.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "leaf-networks-added" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.net_mask.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "address" or name == "net-mask"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "net-mask"):
                                            self.net_mask = value
                                            self.net_mask.value_namespace = name_space
                                            self.net_mask.value_namespace_prefix = name_space_prefix


                                class LeafNetworksDeleted(Entity):
                                    """
                                    List of Leaf Networks Deleted
                                    
                                    .. attribute:: address
                                    
                                    	IP address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: net_mask
                                    
                                    	Mask
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksDeleted, self).__init__()

                                        self.yang_name = "leaf-networks-deleted"
                                        self.yang_parent_name = "priority"

                                        self.address = YLeaf(YType.str, "address")

                                        self.net_mask = YLeaf(YType.uint8, "net-mask")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("address",
                                                        "net_mask") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksDeleted, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksDeleted, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.address.is_set or
                                            self.net_mask.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.net_mask.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "leaf-networks-deleted" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.net_mask.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "address" or name == "net-mask"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "net-mask"):
                                            self.net_mask = value
                                            self.net_mask.value_namespace = name_space
                                            self.net_mask.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.convergence_timeline:
                                        if (c.has_data()):
                                            return True
                                    for c in self.leaf_networks_added:
                                        if (c.has_data()):
                                            return True
                                    for c in self.leaf_networks_deleted:
                                        if (c.has_data()):
                                            return True
                                    return (self.priority_summary is not None and self.priority_summary.has_data())

                                def has_operation(self):
                                    for c in self.convergence_timeline:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.leaf_networks_added:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.leaf_networks_deleted:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.priority_summary is not None and self.priority_summary.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "convergence-timeline"):
                                        for c in self.convergence_timeline:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.ConvergenceTimeline()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.convergence_timeline.append(c)
                                        return c

                                    if (child_yang_name == "leaf-networks-added"):
                                        for c in self.leaf_networks_added:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksAdded()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.leaf_networks_added.append(c)
                                        return c

                                    if (child_yang_name == "leaf-networks-deleted"):
                                        for c in self.leaf_networks_deleted:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.LeafNetworksDeleted()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.leaf_networks_deleted.append(c)
                                        return c

                                    if (child_yang_name == "priority-summary"):
                                        if (self.priority_summary is None):
                                            self.priority_summary = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority.PrioritySummary()
                                            self.priority_summary.parent = self
                                            self._children_name_map["priority_summary"] = "priority-summary"
                                        return self.priority_summary

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "convergence-timeline" or name == "leaf-networks-added" or name == "leaf-networks-deleted" or name == "priority-summary"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class LsaProcessed(Entity):
                                """
                                List of type 1/2 LSA changes processed
                                
                                .. attribute:: change_type
                                
                                	Add, Delete, Modify
                                	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                                
                                .. attribute:: lsa_id
                                
                                	LSA ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: lsa_type
                                
                                	LSA type
                                	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                                
                                .. attribute:: origin_router_id
                                
                                	Originating Router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: reception_time
                                
                                	Reception Time on router (in hh\:mm\:ss.msec)
                                	**type**\:  str
                                
                                .. attribute:: sequence_number
                                
                                	Sequence Number
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.LsaProcessed, self).__init__()

                                    self.yang_name = "lsa-processed"
                                    self.yang_parent_name = "dijkstra-run"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.lsa_id = YLeaf(YType.str, "lsa-id")

                                    self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                    self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                    self.reception_time = YLeaf(YType.str, "reception-time")

                                    self.sequence_number = YLeaf(YType.str, "sequence-number")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "lsa_id",
                                                    "lsa_type",
                                                    "origin_router_id",
                                                    "reception_time",
                                                    "sequence_number") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.LsaProcessed, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.LsaProcessed, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.lsa_id.is_set or
                                        self.lsa_type.is_set or
                                        self.origin_router_id.is_set or
                                        self.reception_time.is_set or
                                        self.sequence_number.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.lsa_id.yfilter != YFilter.not_set or
                                        self.lsa_type.yfilter != YFilter.not_set or
                                        self.origin_router_id.yfilter != YFilter.not_set or
                                        self.reception_time.yfilter != YFilter.not_set or
                                        self.sequence_number.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lsa-processed" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                    if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                    if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                    if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.reception_time.get_name_leafdata())
                                    if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsa-id"):
                                        self.lsa_id = value
                                        self.lsa_id.value_namespace = name_space
                                        self.lsa_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsa-type"):
                                        self.lsa_type = value
                                        self.lsa_type.value_namespace = name_space
                                        self.lsa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "origin-router-id"):
                                        self.origin_router_id = value
                                        self.origin_router_id.value_namespace = name_space
                                        self.origin_router_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "reception-time"):
                                        self.reception_time = value
                                        self.reception_time.value_namespace = name_space
                                        self.reception_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "sequence-number"):
                                        self.sequence_number = value
                                        self.sequence_number.value_namespace = name_space
                                        self.sequence_number.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lsa_processed:
                                    if (c.has_data()):
                                        return True
                                for c in self.priority:
                                    if (c.has_data()):
                                        return True
                                for c in self.trigger_lsa:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.area_id.is_set or
                                    self.dijkstra_run_number.is_set or
                                    self.duration.is_set or
                                    self.start_time.is_set or
                                    self.threshold_exceeded.is_set or
                                    self.trigger_time.is_set or
                                    self.wait_time.is_set)

                            def has_operation(self):
                                for c in self.lsa_processed:
                                    if (c.has_operation()):
                                        return True
                                for c in self.priority:
                                    if (c.has_operation()):
                                        return True
                                for c in self.trigger_lsa:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area_id.yfilter != YFilter.not_set or
                                    self.dijkstra_run_number.yfilter != YFilter.not_set or
                                    self.duration.yfilter != YFilter.not_set or
                                    self.start_time.yfilter != YFilter.not_set or
                                    self.threshold_exceeded.yfilter != YFilter.not_set or
                                    self.trigger_time.yfilter != YFilter.not_set or
                                    self.wait_time.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dijkstra-run" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area_id.get_name_leafdata())
                                if (self.dijkstra_run_number.is_set or self.dijkstra_run_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dijkstra_run_number.get_name_leafdata())
                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_time.get_name_leafdata())
                                if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                                if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.trigger_time.get_name_leafdata())
                                if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wait_time.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lsa-processed"):
                                    for c in self.lsa_processed:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.LsaProcessed()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lsa_processed.append(c)
                                    return c

                                if (child_yang_name == "priority"):
                                    for c in self.priority:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.Priority()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.priority.append(c)
                                    return c

                                if (child_yang_name == "trigger-lsa"):
                                    for c in self.trigger_lsa:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun.TriggerLsa()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.trigger_lsa.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lsa-processed" or name == "priority" or name == "trigger-lsa" or name == "area-id" or name == "dijkstra-run-number" or name == "duration" or name == "start-time" or name == "threshold-exceeded" or name == "trigger-time" or name == "wait-time"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area-id"):
                                    self.area_id = value
                                    self.area_id.value_namespace = name_space
                                    self.area_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "dijkstra-run-number"):
                                    self.dijkstra_run_number = value
                                    self.dijkstra_run_number.value_namespace = name_space
                                    self.dijkstra_run_number.value_namespace_prefix = name_space_prefix
                                if(value_path == "duration"):
                                    self.duration = value
                                    self.duration.value_namespace = name_space
                                    self.duration.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-time"):
                                    self.start_time = value
                                    self.start_time.value_namespace = name_space
                                    self.start_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "threshold-exceeded"):
                                    self.threshold_exceeded = value
                                    self.threshold_exceeded.value_namespace = name_space
                                    self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                                if(value_path == "trigger-time"):
                                    self.trigger_time = value
                                    self.trigger_time.value_namespace = name_space
                                    self.trigger_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "wait-time"):
                                    self.wait_time = value
                                    self.wait_time.value_namespace = name_space
                                    self.wait_time.value_namespace_prefix = name_space_prefix


                        class InterAreaAndExternal(Entity):
                            """
                            Inter\-area & external calculation information
                            
                            .. attribute:: priority
                            
                            	Convergence information on a per\-priority basis
                            	**type**\: list of    :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority>`
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal, self).__init__()

                                self.yang_name = "inter-area-and-external"
                                self.yang_parent_name = "spf-run-summary"

                                self.priority = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal, self).__setattr__(name, value)


                            class Priority(Entity):
                                """
                                Convergence information on a per\-priority basis
                                
                                .. attribute:: convergence_timeline
                                
                                	Convergence timeline details
                                	**type**\: list of    :py:class:`ConvergenceTimeline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline>`
                                
                                .. attribute:: leaf_networks_added
                                
                                	List of Leaf Networks Added
                                	**type**\: list of    :py:class:`LeafNetworksAdded <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksAdded>`
                                
                                .. attribute:: leaf_networks_deleted
                                
                                	List of Leaf Networks Deleted
                                	**type**\: list of    :py:class:`LeafNetworksDeleted <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksDeleted>`
                                
                                .. attribute:: priority_summary
                                
                                	Summary of the priority
                                	**type**\:   :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority, self).__init__()

                                    self.yang_name = "priority"
                                    self.yang_parent_name = "inter-area-and-external"

                                    self.priority_summary = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary()
                                    self.priority_summary.parent = self
                                    self._children_name_map["priority_summary"] = "priority-summary"
                                    self._children_yang_names.add("priority-summary")

                                    self.convergence_timeline = YList(self)
                                    self.leaf_networks_added = YList(self)
                                    self.leaf_networks_deleted = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority, self).__setattr__(name, value)


                                class PrioritySummary(Entity):
                                    """
                                    Summary of the priority
                                    
                                    .. attribute:: ip_convergence_time
                                    
                                    	Convergence time for IP route programming
                                    	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime>`
                                    
                                    .. attribute:: level
                                    
                                    	Critical, High, Medium or Low
                                    	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                    
                                    .. attribute:: mpls_convergence_time
                                    
                                    	Convergence time for MPLS label programming
                                    	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime>`
                                    
                                    .. attribute:: route_statistics
                                    
                                    	Route statistics
                                    	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics>`
                                    
                                    .. attribute:: threshold_exceeded
                                    
                                    	Threshold exceeded
                                    	**type**\:  bool
                                    
                                    .. attribute:: type3ls_as
                                    
                                    	Number of Type 3 LSA
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: type4ls_as
                                    
                                    	Number of Type 4 LSA
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: type57ls_as
                                    
                                    	Number of Type 5/7 LSA
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary, self).__init__()

                                        self.yang_name = "priority-summary"
                                        self.yang_parent_name = "priority"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                        self.type3ls_as = YLeaf(YType.uint32, "type3ls-as")

                                        self.type4ls_as = YLeaf(YType.uint32, "type4ls-as")

                                        self.type57ls_as = YLeaf(YType.uint32, "type57ls-as")

                                        self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime()
                                        self.ip_convergence_time.parent = self
                                        self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        self._children_yang_names.add("ip-convergence-time")

                                        self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime()
                                        self.mpls_convergence_time.parent = self
                                        self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        self._children_yang_names.add("mpls-convergence-time")

                                        self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics()
                                        self.route_statistics.parent = self
                                        self._children_name_map["route_statistics"] = "route-statistics"
                                        self._children_yang_names.add("route-statistics")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "threshold_exceeded",
                                                        "type3ls_as",
                                                        "type4ls_as",
                                                        "type57ls_as") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary, self).__setattr__(name, value)


                                    class RouteStatistics(Entity):
                                        """
                                        Route statistics
                                        
                                        .. attribute:: adds
                                        
                                        	Added
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: deletes
                                        
                                        	Deleted
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: modifies
                                        
                                        	Modified
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: reachables
                                        
                                        	Reachable
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: touches
                                        
                                        	Touched
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: unreachables
                                        
                                        	Unreachable
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics, self).__init__()

                                            self.yang_name = "route-statistics"
                                            self.yang_parent_name = "priority-summary"

                                            self.adds = YLeaf(YType.uint32, "adds")

                                            self.deletes = YLeaf(YType.uint32, "deletes")

                                            self.modifies = YLeaf(YType.uint32, "modifies")

                                            self.reachables = YLeaf(YType.uint32, "reachables")

                                            self.touches = YLeaf(YType.uint32, "touches")

                                            self.unreachables = YLeaf(YType.uint32, "unreachables")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("adds",
                                                            "deletes",
                                                            "modifies",
                                                            "reachables",
                                                            "touches",
                                                            "unreachables") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.adds.is_set or
                                                self.deletes.is_set or
                                                self.modifies.is_set or
                                                self.reachables.is_set or
                                                self.touches.is_set or
                                                self.unreachables.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.adds.yfilter != YFilter.not_set or
                                                self.deletes.yfilter != YFilter.not_set or
                                                self.modifies.yfilter != YFilter.not_set or
                                                self.reachables.yfilter != YFilter.not_set or
                                                self.touches.yfilter != YFilter.not_set or
                                                self.unreachables.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-statistics" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adds.get_name_leafdata())
                                            if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.deletes.get_name_leafdata())
                                            if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.modifies.get_name_leafdata())
                                            if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.reachables.get_name_leafdata())
                                            if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.touches.get_name_leafdata())
                                            if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.unreachables.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "adds"):
                                                self.adds = value
                                                self.adds.value_namespace = name_space
                                                self.adds.value_namespace_prefix = name_space_prefix
                                            if(value_path == "deletes"):
                                                self.deletes = value
                                                self.deletes.value_namespace = name_space
                                                self.deletes.value_namespace_prefix = name_space_prefix
                                            if(value_path == "modifies"):
                                                self.modifies = value
                                                self.modifies.value_namespace = name_space
                                                self.modifies.value_namespace_prefix = name_space_prefix
                                            if(value_path == "reachables"):
                                                self.reachables = value
                                                self.reachables.value_namespace = name_space
                                                self.reachables.value_namespace_prefix = name_space_prefix
                                            if(value_path == "touches"):
                                                self.touches = value
                                                self.touches.value_namespace = name_space
                                                self.touches.value_namespace_prefix = name_space_prefix
                                            if(value_path == "unreachables"):
                                                self.unreachables = value
                                                self.unreachables.value_namespace = name_space
                                                self.unreachables.value_namespace_prefix = name_space_prefix


                                    class IpConvergenceTime(Entity):
                                        """
                                        Convergence time for IP route programming
                                        
                                        .. attribute:: fastest_node_name
                                        
                                        	Linecard node name which took the minimum time
                                        	**type**\:  str
                                        
                                        .. attribute:: maximum_time
                                        
                                        	Maximum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: minimum_time
                                        
                                        	Minimum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: slowest_node_name
                                        
                                        	Linecard node name which took the maximum time
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime, self).__init__()

                                            self.yang_name = "ip-convergence-time"
                                            self.yang_parent_name = "priority-summary"

                                            self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                            self.maximum_time = YLeaf(YType.str, "maximum-time")

                                            self.minimum_time = YLeaf(YType.str, "minimum-time")

                                            self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fastest_node_name",
                                                            "maximum_time",
                                                            "minimum_time",
                                                            "slowest_node_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.fastest_node_name.is_set or
                                                self.maximum_time.is_set or
                                                self.minimum_time.is_set or
                                                self.slowest_node_name.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fastest_node_name.yfilter != YFilter.not_set or
                                                self.maximum_time.yfilter != YFilter.not_set or
                                                self.minimum_time.yfilter != YFilter.not_set or
                                                self.slowest_node_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ip-convergence-time" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                            if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                            if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                            if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fastest-node-name"):
                                                self.fastest_node_name = value
                                                self.fastest_node_name.value_namespace = name_space
                                                self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "maximum-time"):
                                                self.maximum_time = value
                                                self.maximum_time.value_namespace = name_space
                                                self.maximum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "minimum-time"):
                                                self.minimum_time = value
                                                self.minimum_time.value_namespace = name_space
                                                self.minimum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "slowest-node-name"):
                                                self.slowest_node_name = value
                                                self.slowest_node_name.value_namespace = name_space
                                                self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                    class MplsConvergenceTime(Entity):
                                        """
                                        Convergence time for MPLS label programming
                                        
                                        .. attribute:: fastest_node_name
                                        
                                        	Linecard node name which took the minimum time
                                        	**type**\:  str
                                        
                                        .. attribute:: maximum_time
                                        
                                        	Maximum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: minimum_time
                                        
                                        	Minimum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: slowest_node_name
                                        
                                        	Linecard node name which took the maximum time
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime, self).__init__()

                                            self.yang_name = "mpls-convergence-time"
                                            self.yang_parent_name = "priority-summary"

                                            self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                            self.maximum_time = YLeaf(YType.str, "maximum-time")

                                            self.minimum_time = YLeaf(YType.str, "minimum-time")

                                            self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fastest_node_name",
                                                            "maximum_time",
                                                            "minimum_time",
                                                            "slowest_node_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.fastest_node_name.is_set or
                                                self.maximum_time.is_set or
                                                self.minimum_time.is_set or
                                                self.slowest_node_name.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fastest_node_name.yfilter != YFilter.not_set or
                                                self.maximum_time.yfilter != YFilter.not_set or
                                                self.minimum_time.yfilter != YFilter.not_set or
                                                self.slowest_node_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "mpls-convergence-time" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                            if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                            if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                            if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fastest-node-name"):
                                                self.fastest_node_name = value
                                                self.fastest_node_name.value_namespace = name_space
                                                self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "maximum-time"):
                                                self.maximum_time = value
                                                self.maximum_time.value_namespace = name_space
                                                self.maximum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "minimum-time"):
                                                self.minimum_time = value
                                                self.minimum_time.value_namespace = name_space
                                                self.minimum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "slowest-node-name"):
                                                self.slowest_node_name = value
                                                self.slowest_node_name.value_namespace = name_space
                                                self.slowest_node_name.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.threshold_exceeded.is_set or
                                            self.type3ls_as.is_set or
                                            self.type4ls_as.is_set or
                                            self.type57ls_as.is_set or
                                            (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                            (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                            (self.route_statistics is not None and self.route_statistics.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.threshold_exceeded.yfilter != YFilter.not_set or
                                            self.type3ls_as.yfilter != YFilter.not_set or
                                            self.type4ls_as.yfilter != YFilter.not_set or
                                            self.type57ls_as.yfilter != YFilter.not_set or
                                            (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                            (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                            (self.route_statistics is not None and self.route_statistics.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "priority-summary" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                                        if (self.type3ls_as.is_set or self.type3ls_as.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type3ls_as.get_name_leafdata())
                                        if (self.type4ls_as.is_set or self.type4ls_as.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type4ls_as.get_name_leafdata())
                                        if (self.type57ls_as.is_set or self.type57ls_as.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type57ls_as.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "ip-convergence-time"):
                                            if (self.ip_convergence_time is None):
                                                self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime()
                                                self.ip_convergence_time.parent = self
                                                self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                            return self.ip_convergence_time

                                        if (child_yang_name == "mpls-convergence-time"):
                                            if (self.mpls_convergence_time is None):
                                                self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime()
                                                self.mpls_convergence_time.parent = self
                                                self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                            return self.mpls_convergence_time

                                        if (child_yang_name == "route-statistics"):
                                            if (self.route_statistics is None):
                                                self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics()
                                                self.route_statistics.parent = self
                                                self._children_name_map["route_statistics"] = "route-statistics"
                                            return self.route_statistics

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded" or name == "type3ls-as" or name == "type4ls-as" or name == "type57ls-as"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "threshold-exceeded"):
                                            self.threshold_exceeded = value
                                            self.threshold_exceeded.value_namespace = name_space
                                            self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type3ls-as"):
                                            self.type3ls_as = value
                                            self.type3ls_as.value_namespace = name_space
                                            self.type3ls_as.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type4ls-as"):
                                            self.type4ls_as = value
                                            self.type4ls_as.value_namespace = name_space
                                            self.type4ls_as.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type57ls-as"):
                                            self.type57ls_as = value
                                            self.type57ls_as.value_namespace = name_space
                                            self.type57ls_as.value_namespace_prefix = name_space_prefix


                                class ConvergenceTimeline(Entity):
                                    """
                                    Convergence timeline details
                                    
                                    .. attribute:: lc_ip
                                    
                                    	List of Linecards' completion point for IP routes
                                    	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp>`
                                    
                                    .. attribute:: lc_mpls
                                    
                                    	List of Linecards' completion point for MPLS labels
                                    	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls>`
                                    
                                    .. attribute:: ldp_enter
                                    
                                    	Entry point of LDP
                                    	**type**\:   :py:class:`LdpEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter>`
                                    
                                    .. attribute:: ldp_exit
                                    
                                    	Exit point of LDP to LSD
                                    	**type**\:   :py:class:`LdpExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit>`
                                    
                                    .. attribute:: lsd_enter
                                    
                                    	Entry point of LSD
                                    	**type**\:   :py:class:`LsdEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter>`
                                    
                                    .. attribute:: lsd_exit
                                    
                                    	Exit point of LSD to FIBs
                                    	**type**\:   :py:class:`LsdExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit>`
                                    
                                    .. attribute:: ri_bv4_enter
                                    
                                    	Entry point of IPv4 RIB
                                    	**type**\:   :py:class:`RiBv4Enter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter>`
                                    
                                    .. attribute:: ri_bv4_exit
                                    
                                    	Exit point from IPv4 RIB to FIBs
                                    	**type**\:   :py:class:`RiBv4Exit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit>`
                                    
                                    .. attribute:: ri_bv4_redistribute
                                    
                                    	Route Redistribute point from IPv4 RIB to LDP
                                    	**type**\:   :py:class:`RiBv4Redistribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute>`
                                    
                                    .. attribute:: route_origin
                                    
                                    	Route origin (routing protocol)
                                    	**type**\:   :py:class:`RouteOrigin <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin>`
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline, self).__init__()

                                        self.yang_name = "convergence-timeline"
                                        self.yang_parent_name = "priority"

                                        self.ldp_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter()
                                        self.ldp_enter.parent = self
                                        self._children_name_map["ldp_enter"] = "ldp-enter"
                                        self._children_yang_names.add("ldp-enter")

                                        self.ldp_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit()
                                        self.ldp_exit.parent = self
                                        self._children_name_map["ldp_exit"] = "ldp-exit"
                                        self._children_yang_names.add("ldp-exit")

                                        self.lsd_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter()
                                        self.lsd_enter.parent = self
                                        self._children_name_map["lsd_enter"] = "lsd-enter"
                                        self._children_yang_names.add("lsd-enter")

                                        self.lsd_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit()
                                        self.lsd_exit.parent = self
                                        self._children_name_map["lsd_exit"] = "lsd-exit"
                                        self._children_yang_names.add("lsd-exit")

                                        self.ri_bv4_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter()
                                        self.ri_bv4_enter.parent = self
                                        self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                        self._children_yang_names.add("ri-bv4-enter")

                                        self.ri_bv4_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit()
                                        self.ri_bv4_exit.parent = self
                                        self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                        self._children_yang_names.add("ri-bv4-exit")

                                        self.ri_bv4_redistribute = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                        self.ri_bv4_redistribute.parent = self
                                        self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                        self._children_yang_names.add("ri-bv4-redistribute")

                                        self.route_origin = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin()
                                        self.route_origin.parent = self
                                        self._children_name_map["route_origin"] = "route-origin"
                                        self._children_yang_names.add("route-origin")

                                        self.lc_ip = YList(self)
                                        self.lc_mpls = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline, self).__setattr__(name, value)


                                    class RouteOrigin(Entity):
                                        """
                                        Route origin (routing protocol)
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin, self).__init__()

                                            self.yang_name = "route-origin"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-origin" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Enter(Entity):
                                        """
                                        Entry point of IPv4 RIB
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter, self).__init__()

                                            self.yang_name = "ri-bv4-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Exit(Entity):
                                        """
                                        Exit point from IPv4 RIB to FIBs
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit, self).__init__()

                                            self.yang_name = "ri-bv4-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Redistribute(Entity):
                                        """
                                        Route Redistribute point from IPv4 RIB to LDP
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__init__()

                                            self.yang_name = "ri-bv4-redistribute"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-redistribute" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LdpEnter(Entity):
                                        """
                                        Entry point of LDP
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter, self).__init__()

                                            self.yang_name = "ldp-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ldp-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LdpExit(Entity):
                                        """
                                        Exit point of LDP to LSD
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit, self).__init__()

                                            self.yang_name = "ldp-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ldp-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LsdEnter(Entity):
                                        """
                                        Entry point of LSD
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter, self).__init__()

                                            self.yang_name = "lsd-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lsd-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LsdExit(Entity):
                                        """
                                        Exit point of LSD to FIBs
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit, self).__init__()

                                            self.yang_name = "lsd-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lsd-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LcIp(Entity):
                                        """
                                        List of Linecards' completion point for IP
                                        routes
                                        
                                        .. attribute:: fib_complete
                                        
                                        	Completion point of FIB
                                        	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete>`
                                        
                                        .. attribute:: node_name
                                        
                                        	Linecard node name
                                        	**type**\:  str
                                        
                                        .. attribute:: speed
                                        
                                        	Relative convergence speed
                                        	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp, self).__init__()

                                            self.yang_name = "lc-ip"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.node_name = YLeaf(YType.str, "node-name")

                                            self.speed = YLeaf(YType.enumeration, "speed")

                                            self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                            self.fib_complete.parent = self
                                            self._children_name_map["fib_complete"] = "fib-complete"
                                            self._children_yang_names.add("fib-complete")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("node_name",
                                                            "speed") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)


                                        class FibComplete(Entity):
                                            """
                                            Completion point of FIB
                                            
                                            .. attribute:: duration
                                            
                                            	Duration of processing (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: end_time
                                            
                                            	Last route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: start_time
                                            
                                            	First route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'infra-rcmd-oper'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__init__()

                                                self.yang_name = "fib-complete"
                                                self.yang_parent_name = "lc-ip"

                                                self.duration = YLeaf(YType.str, "duration")

                                                self.end_time = YLeaf(YType.str, "end-time")

                                                self.start_time = YLeaf(YType.str, "start-time")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("duration",
                                                                "end_time",
                                                                "start_time") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.duration.is_set or
                                                    self.end_time.is_set or
                                                    self.start_time.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.duration.yfilter != YFilter.not_set or
                                                    self.end_time.yfilter != YFilter.not_set or
                                                    self.start_time.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-complete" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                                if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.end_time.get_name_leafdata())
                                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.start_time.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "duration" or name == "end-time" or name == "start-time"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "duration"):
                                                    self.duration = value
                                                    self.duration.value_namespace = name_space
                                                    self.duration.value_namespace_prefix = name_space_prefix
                                                if(value_path == "end-time"):
                                                    self.end_time = value
                                                    self.end_time.value_namespace = name_space
                                                    self.end_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "start-time"):
                                                    self.start_time = value
                                                    self.start_time.value_namespace = name_space
                                                    self.start_time.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.node_name.is_set or
                                                self.speed.is_set or
                                                (self.fib_complete is not None and self.fib_complete.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.node_name.yfilter != YFilter.not_set or
                                                self.speed.yfilter != YFilter.not_set or
                                                (self.fib_complete is not None and self.fib_complete.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lc-ip" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_name.get_name_leafdata())
                                            if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.speed.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-complete"):
                                                if (self.fib_complete is None):
                                                    self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                                    self.fib_complete.parent = self
                                                    self._children_name_map["fib_complete"] = "fib-complete"
                                                return self.fib_complete

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "node-name"):
                                                self.node_name = value
                                                self.node_name.value_namespace = name_space
                                                self.node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "speed"):
                                                self.speed = value
                                                self.speed.value_namespace = name_space
                                                self.speed.value_namespace_prefix = name_space_prefix


                                    class LcMpls(Entity):
                                        """
                                        List of Linecards' completion point for MPLS
                                        labels
                                        
                                        .. attribute:: fib_complete
                                        
                                        	Completion point of FIB
                                        	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete>`
                                        
                                        .. attribute:: node_name
                                        
                                        	Linecard node name
                                        	**type**\:  str
                                        
                                        .. attribute:: speed
                                        
                                        	Relative convergence speed
                                        	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls, self).__init__()

                                            self.yang_name = "lc-mpls"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.node_name = YLeaf(YType.str, "node-name")

                                            self.speed = YLeaf(YType.enumeration, "speed")

                                            self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                            self.fib_complete.parent = self
                                            self._children_name_map["fib_complete"] = "fib-complete"
                                            self._children_yang_names.add("fib-complete")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("node_name",
                                                            "speed") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)


                                        class FibComplete(Entity):
                                            """
                                            Completion point of FIB
                                            
                                            .. attribute:: duration
                                            
                                            	Duration of processing (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: end_time
                                            
                                            	Last route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: start_time
                                            
                                            	First route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'infra-rcmd-oper'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__init__()

                                                self.yang_name = "fib-complete"
                                                self.yang_parent_name = "lc-mpls"

                                                self.duration = YLeaf(YType.str, "duration")

                                                self.end_time = YLeaf(YType.str, "end-time")

                                                self.start_time = YLeaf(YType.str, "start-time")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("duration",
                                                                "end_time",
                                                                "start_time") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.duration.is_set or
                                                    self.end_time.is_set or
                                                    self.start_time.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.duration.yfilter != YFilter.not_set or
                                                    self.end_time.yfilter != YFilter.not_set or
                                                    self.start_time.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-complete" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                                if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.end_time.get_name_leafdata())
                                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.start_time.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "duration" or name == "end-time" or name == "start-time"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "duration"):
                                                    self.duration = value
                                                    self.duration.value_namespace = name_space
                                                    self.duration.value_namespace_prefix = name_space_prefix
                                                if(value_path == "end-time"):
                                                    self.end_time = value
                                                    self.end_time.value_namespace = name_space
                                                    self.end_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "start-time"):
                                                    self.start_time = value
                                                    self.start_time.value_namespace = name_space
                                                    self.start_time.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.node_name.is_set or
                                                self.speed.is_set or
                                                (self.fib_complete is not None and self.fib_complete.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.node_name.yfilter != YFilter.not_set or
                                                self.speed.yfilter != YFilter.not_set or
                                                (self.fib_complete is not None and self.fib_complete.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lc-mpls" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_name.get_name_leafdata())
                                            if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.speed.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-complete"):
                                                if (self.fib_complete is None):
                                                    self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                                    self.fib_complete.parent = self
                                                    self._children_name_map["fib_complete"] = "fib-complete"
                                                return self.fib_complete

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "node-name"):
                                                self.node_name = value
                                                self.node_name.value_namespace = name_space
                                                self.node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "speed"):
                                                self.speed = value
                                                self.speed.value_namespace = name_space
                                                self.speed.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.lc_ip:
                                            if (c.has_data()):
                                                return True
                                        for c in self.lc_mpls:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            (self.ldp_enter is not None and self.ldp_enter.has_data()) or
                                            (self.ldp_exit is not None and self.ldp_exit.has_data()) or
                                            (self.lsd_enter is not None and self.lsd_enter.has_data()) or
                                            (self.lsd_exit is not None and self.lsd_exit.has_data()) or
                                            (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_data()) or
                                            (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_data()) or
                                            (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_data()) or
                                            (self.route_origin is not None and self.route_origin.has_data()))

                                    def has_operation(self):
                                        for c in self.lc_ip:
                                            if (c.has_operation()):
                                                return True
                                        for c in self.lc_mpls:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.ldp_enter is not None and self.ldp_enter.has_operation()) or
                                            (self.ldp_exit is not None and self.ldp_exit.has_operation()) or
                                            (self.lsd_enter is not None and self.lsd_enter.has_operation()) or
                                            (self.lsd_exit is not None and self.lsd_exit.has_operation()) or
                                            (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_operation()) or
                                            (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_operation()) or
                                            (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_operation()) or
                                            (self.route_origin is not None and self.route_origin.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "convergence-timeline" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "lc-ip"):
                                            for c in self.lc_ip:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.lc_ip.append(c)
                                            return c

                                        if (child_yang_name == "lc-mpls"):
                                            for c in self.lc_mpls:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.lc_mpls.append(c)
                                            return c

                                        if (child_yang_name == "ldp-enter"):
                                            if (self.ldp_enter is None):
                                                self.ldp_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter()
                                                self.ldp_enter.parent = self
                                                self._children_name_map["ldp_enter"] = "ldp-enter"
                                            return self.ldp_enter

                                        if (child_yang_name == "ldp-exit"):
                                            if (self.ldp_exit is None):
                                                self.ldp_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit()
                                                self.ldp_exit.parent = self
                                                self._children_name_map["ldp_exit"] = "ldp-exit"
                                            return self.ldp_exit

                                        if (child_yang_name == "lsd-enter"):
                                            if (self.lsd_enter is None):
                                                self.lsd_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter()
                                                self.lsd_enter.parent = self
                                                self._children_name_map["lsd_enter"] = "lsd-enter"
                                            return self.lsd_enter

                                        if (child_yang_name == "lsd-exit"):
                                            if (self.lsd_exit is None):
                                                self.lsd_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit()
                                                self.lsd_exit.parent = self
                                                self._children_name_map["lsd_exit"] = "lsd-exit"
                                            return self.lsd_exit

                                        if (child_yang_name == "ri-bv4-enter"):
                                            if (self.ri_bv4_enter is None):
                                                self.ri_bv4_enter = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter()
                                                self.ri_bv4_enter.parent = self
                                                self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                            return self.ri_bv4_enter

                                        if (child_yang_name == "ri-bv4-exit"):
                                            if (self.ri_bv4_exit is None):
                                                self.ri_bv4_exit = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit()
                                                self.ri_bv4_exit.parent = self
                                                self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                            return self.ri_bv4_exit

                                        if (child_yang_name == "ri-bv4-redistribute"):
                                            if (self.ri_bv4_redistribute is None):
                                                self.ri_bv4_redistribute = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                                self.ri_bv4_redistribute.parent = self
                                                self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                            return self.ri_bv4_redistribute

                                        if (child_yang_name == "route-origin"):
                                            if (self.route_origin is None):
                                                self.route_origin = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin()
                                                self.route_origin.parent = self
                                                self._children_name_map["route_origin"] = "route-origin"
                                            return self.route_origin

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class LeafNetworksAdded(Entity):
                                    """
                                    List of Leaf Networks Added
                                    
                                    .. attribute:: address
                                    
                                    	IP address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: net_mask
                                    
                                    	Mask
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksAdded, self).__init__()

                                        self.yang_name = "leaf-networks-added"
                                        self.yang_parent_name = "priority"

                                        self.address = YLeaf(YType.str, "address")

                                        self.net_mask = YLeaf(YType.uint8, "net-mask")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("address",
                                                        "net_mask") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksAdded, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksAdded, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.address.is_set or
                                            self.net_mask.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.net_mask.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "leaf-networks-added" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.net_mask.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "address" or name == "net-mask"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "net-mask"):
                                            self.net_mask = value
                                            self.net_mask.value_namespace = name_space
                                            self.net_mask.value_namespace_prefix = name_space_prefix


                                class LeafNetworksDeleted(Entity):
                                    """
                                    List of Leaf Networks Deleted
                                    
                                    .. attribute:: address
                                    
                                    	IP address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: net_mask
                                    
                                    	Mask
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksDeleted, self).__init__()

                                        self.yang_name = "leaf-networks-deleted"
                                        self.yang_parent_name = "priority"

                                        self.address = YLeaf(YType.str, "address")

                                        self.net_mask = YLeaf(YType.uint8, "net-mask")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("address",
                                                        "net_mask") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksDeleted, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksDeleted, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.address.is_set or
                                            self.net_mask.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.net_mask.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "leaf-networks-deleted" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.net_mask.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "address" or name == "net-mask"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "net-mask"):
                                            self.net_mask = value
                                            self.net_mask.value_namespace = name_space
                                            self.net_mask.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.convergence_timeline:
                                        if (c.has_data()):
                                            return True
                                    for c in self.leaf_networks_added:
                                        if (c.has_data()):
                                            return True
                                    for c in self.leaf_networks_deleted:
                                        if (c.has_data()):
                                            return True
                                    return (self.priority_summary is not None and self.priority_summary.has_data())

                                def has_operation(self):
                                    for c in self.convergence_timeline:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.leaf_networks_added:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.leaf_networks_deleted:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.priority_summary is not None and self.priority_summary.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "convergence-timeline"):
                                        for c in self.convergence_timeline:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.ConvergenceTimeline()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.convergence_timeline.append(c)
                                        return c

                                    if (child_yang_name == "leaf-networks-added"):
                                        for c in self.leaf_networks_added:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksAdded()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.leaf_networks_added.append(c)
                                        return c

                                    if (child_yang_name == "leaf-networks-deleted"):
                                        for c in self.leaf_networks_deleted:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.LeafNetworksDeleted()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.leaf_networks_deleted.append(c)
                                        return c

                                    if (child_yang_name == "priority-summary"):
                                        if (self.priority_summary is None):
                                            self.priority_summary = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority.PrioritySummary()
                                            self.priority_summary.parent = self
                                            self._children_name_map["priority_summary"] = "priority-summary"
                                        return self.priority_summary

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "convergence-timeline" or name == "leaf-networks-added" or name == "leaf-networks-deleted" or name == "priority-summary"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                for c in self.priority:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.priority:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "inter-area-and-external" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "priority"):
                                    for c in self.priority:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal.Priority()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.priority.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "priority"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            for c in self.dijkstra_run:
                                if (c.has_data()):
                                    return True
                            for c in self.inter_area_and_external:
                                if (c.has_data()):
                                    return True
                            return (
                                self.spf_run_number.is_set or
                                (self.spf_summary is not None and self.spf_summary.has_data()))

                        def has_operation(self):
                            for c in self.dijkstra_run:
                                if (c.has_operation()):
                                    return True
                            for c in self.inter_area_and_external:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.spf_run_number.yfilter != YFilter.not_set or
                                (self.spf_summary is not None and self.spf_summary.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "spf-run-summary" + "[spf-run-number='" + self.spf_run_number.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.spf_run_number.is_set or self.spf_run_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_number.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dijkstra-run"):
                                for c in self.dijkstra_run:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.DijkstraRun()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.dijkstra_run.append(c)
                                return c

                            if (child_yang_name == "inter-area-and-external"):
                                for c in self.inter_area_and_external:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.InterAreaAndExternal()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.inter_area_and_external.append(c)
                                return c

                            if (child_yang_name == "spf-summary"):
                                if (self.spf_summary is None):
                                    self.spf_summary = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary()
                                    self.spf_summary.parent = self
                                    self._children_name_map["spf_summary"] = "spf-summary"
                                return self.spf_summary

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dijkstra-run" or name == "inter-area-and-external" or name == "spf-summary" or name == "spf-run-number"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "spf-run-number"):
                                self.spf_run_number = value
                                self.spf_run_number.value_namespace = name_space
                                self.spf_run_number.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.spf_run_summary:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.spf_run_summary:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "spf-run-summaries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "spf-run-summary"):
                            for c in self.spf_run_summary:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Ospf.Instances.Instance.SpfRunSummaries.SpfRunSummary()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.spf_run_summary.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "spf-run-summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class IpfrrEventOfflines(Entity):
                    """
                    OSPF IP\-FRR Event offline data
                    
                    .. attribute:: ipfrr_event_offline
                    
                    	Offline operational data for particular OSPF IP\-FRR Event
                    	**type**\: list of    :py:class:`IpfrrEventOffline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines, self).__init__()

                        self.yang_name = "ipfrr-event-offlines"
                        self.yang_parent_name = "instance"

                        self.ipfrr_event_offline = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines, self).__setattr__(name, value)


                    class IpfrrEventOffline(Entity):
                        """
                        Offline operational data for particular OSPF
                        IP\-FRR Event
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific IP\-FRR Event
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: completed_spf_run
                        
                        	IP\-Frr Completed reference SPF Run Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: coverage
                        
                        	Coverage in percentage for all priorities
                        	**type**\:  str
                        
                        	**units**\: percentage
                        
                        .. attribute:: duration
                        
                        	Duration for the calculation (in milliseconds)
                        	**type**\:  str
                        
                        	**units**\: millisecond
                        
                        .. attribute:: event_id_xr
                        
                        	IP\-Frr Event ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: fully_protected_routes
                        
                        	Cumulative Number of Fully Protected Routes
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ipfrr_statistic
                        
                        	IP\-Frr Statistics categorized by priority
                        	**type**\: list of    :py:class:`IpfrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic>`
                        
                        .. attribute:: partially_protected_routes
                        
                        	Cumulative Number of Partially Protected Routes
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_node
                        
                        	Remote Node Information
                        	**type**\: list of    :py:class:`RemoteNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode>`
                        
                        .. attribute:: start_time_offset
                        
                        	Start Time offset from trigger time (in milliseconds)
                        	**type**\:  str
                        
                        	**units**\: millisecond
                        
                        .. attribute:: total_routes
                        
                        	Cumulative Number of Routes for all priorities
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: trigger_spf_run
                        
                        	IP\-Frr Triggered reference SPF Run Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: trigger_time
                        
                        	Trigger time  (eg\: Apr 24 13\:16\:04.961)
                        	**type**\:  str
                        
                        .. attribute:: wait_time
                        
                        	Waiting Time (in milliseconds)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline, self).__init__()

                            self.yang_name = "ipfrr-event-offline"
                            self.yang_parent_name = "ipfrr-event-offlines"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.completed_spf_run = YLeaf(YType.uint32, "completed-spf-run")

                            self.coverage = YLeaf(YType.str, "coverage")

                            self.duration = YLeaf(YType.str, "duration")

                            self.event_id_xr = YLeaf(YType.uint32, "event-id-xr")

                            self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                            self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                            self.start_time_offset = YLeaf(YType.str, "start-time-offset")

                            self.total_routes = YLeaf(YType.uint32, "total-routes")

                            self.trigger_spf_run = YLeaf(YType.uint32, "trigger-spf-run")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.wait_time = YLeaf(YType.uint32, "wait-time")

                            self.ipfrr_statistic = YList(self)
                            self.remote_node = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "completed_spf_run",
                                            "coverage",
                                            "duration",
                                            "event_id_xr",
                                            "fully_protected_routes",
                                            "partially_protected_routes",
                                            "start_time_offset",
                                            "total_routes",
                                            "trigger_spf_run",
                                            "trigger_time",
                                            "wait_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline, self).__setattr__(name, value)


                        class IpfrrStatistic(Entity):
                            """
                            IP\-Frr Statistics categorized by priority
                            
                            .. attribute:: below_threshold
                            
                            	Covearge is below Configured Threshold
                            	**type**\:  bool
                            
                            .. attribute:: coverage
                            
                            	Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: fully_protected_routes
                            
                            	Fully Protected Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_lfa_coverage
                            
                            	Local LFA Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: partially_protected_routes
                            
                            	Partially Protected Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: priority
                            
                            	Priority
                            	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                            
                            .. attribute:: remote_lfa_coverage
                            
                            	Remote LFA Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: total_routes
                            
                            	Total Number of Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic, self).__init__()

                                self.yang_name = "ipfrr-statistic"
                                self.yang_parent_name = "ipfrr-event-offline"

                                self.below_threshold = YLeaf(YType.boolean, "below-threshold")

                                self.coverage = YLeaf(YType.str, "coverage")

                                self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                self.local_lfa_coverage = YLeaf(YType.str, "local-lfa-coverage")

                                self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                self.priority = YLeaf(YType.enumeration, "priority")

                                self.remote_lfa_coverage = YLeaf(YType.str, "remote-lfa-coverage")

                                self.total_routes = YLeaf(YType.uint32, "total-routes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("below_threshold",
                                                "coverage",
                                                "fully_protected_routes",
                                                "local_lfa_coverage",
                                                "partially_protected_routes",
                                                "priority",
                                                "remote_lfa_coverage",
                                                "total_routes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.below_threshold.is_set or
                                    self.coverage.is_set or
                                    self.fully_protected_routes.is_set or
                                    self.local_lfa_coverage.is_set or
                                    self.partially_protected_routes.is_set or
                                    self.priority.is_set or
                                    self.remote_lfa_coverage.is_set or
                                    self.total_routes.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.below_threshold.yfilter != YFilter.not_set or
                                    self.coverage.yfilter != YFilter.not_set or
                                    self.fully_protected_routes.yfilter != YFilter.not_set or
                                    self.local_lfa_coverage.yfilter != YFilter.not_set or
                                    self.partially_protected_routes.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set or
                                    self.remote_lfa_coverage.yfilter != YFilter.not_set or
                                    self.total_routes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ipfrr-statistic" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.below_threshold.is_set or self.below_threshold.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.below_threshold.get_name_leafdata())
                                if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.coverage.get_name_leafdata())
                                if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                if (self.local_lfa_coverage.is_set or self.local_lfa_coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_lfa_coverage.get_name_leafdata())
                                if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())
                                if (self.remote_lfa_coverage.is_set or self.remote_lfa_coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_lfa_coverage.get_name_leafdata())
                                if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_routes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "below-threshold" or name == "coverage" or name == "fully-protected-routes" or name == "local-lfa-coverage" or name == "partially-protected-routes" or name == "priority" or name == "remote-lfa-coverage" or name == "total-routes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "below-threshold"):
                                    self.below_threshold = value
                                    self.below_threshold.value_namespace = name_space
                                    self.below_threshold.value_namespace_prefix = name_space_prefix
                                if(value_path == "coverage"):
                                    self.coverage = value
                                    self.coverage.value_namespace = name_space
                                    self.coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "fully-protected-routes"):
                                    self.fully_protected_routes = value
                                    self.fully_protected_routes.value_namespace = name_space
                                    self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-lfa-coverage"):
                                    self.local_lfa_coverage = value
                                    self.local_lfa_coverage.value_namespace = name_space
                                    self.local_lfa_coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "partially-protected-routes"):
                                    self.partially_protected_routes = value
                                    self.partially_protected_routes.value_namespace = name_space
                                    self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-lfa-coverage"):
                                    self.remote_lfa_coverage = value
                                    self.remote_lfa_coverage.value_namespace = name_space
                                    self.remote_lfa_coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-routes"):
                                    self.total_routes = value
                                    self.total_routes.value_namespace = name_space
                                    self.total_routes.value_namespace_prefix = name_space_prefix


                        class RemoteNode(Entity):
                            """
                            Remote Node Information
                            
                            .. attribute:: in_use_time
                            
                            	Inuse time of the Remote Node (eg\: Apr 24 13\:16 \:04.961)
                            	**type**\:  str
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_count
                            
                            	Number of paths protected by this Remote Node
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: primary_path
                            
                            	Protected Primary Paths
                            	**type**\: list of    :py:class:`PrimaryPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath>`
                            
                            .. attribute:: remote_node_id
                            
                            	Remote\-LFA Node ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode, self).__init__()

                                self.yang_name = "remote-node"
                                self.yang_parent_name = "ipfrr-event-offline"

                                self.in_use_time = YLeaf(YType.str, "in-use-time")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_count = YLeaf(YType.uint32, "path-count")

                                self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                self.primary_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("in_use_time",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_count",
                                                "remote_node_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode, self).__setattr__(name, value)


                            class PrimaryPath(Entity):
                                """
                                Protected Primary Paths
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath, self).__init__()

                                    self.yang_name = "primary-path"
                                    self.yang_parent_name = "remote-node"

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface_name",
                                                    "neighbour_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.interface_name.is_set or
                                        self.neighbour_address.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "primary-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface-name" or name == "neighbour-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.primary_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.in_use_time.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_count.is_set or
                                    self.remote_node_id.is_set)

                            def has_operation(self):
                                for c in self.primary_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.in_use_time.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_count.yfilter != YFilter.not_set or
                                    self.remote_node_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "remote-node" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.in_use_time.is_set or self.in_use_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_use_time.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_count.is_set or self.path_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_count.get_name_leafdata())
                                if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "primary-path"):
                                    for c in self.primary_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.primary_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "primary-path" or name == "in-use-time" or name == "interface-name" or name == "neighbour-address" or name == "path-count" or name == "remote-node-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "in-use-time"):
                                    self.in_use_time = value
                                    self.in_use_time.value_namespace = name_space
                                    self.in_use_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-count"):
                                    self.path_count = value
                                    self.path_count.value_namespace = name_space
                                    self.path_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-node-id"):
                                    self.remote_node_id = value
                                    self.remote_node_id.value_namespace = name_space
                                    self.remote_node_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.ipfrr_statistic:
                                if (c.has_data()):
                                    return True
                            for c in self.remote_node:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.completed_spf_run.is_set or
                                self.coverage.is_set or
                                self.duration.is_set or
                                self.event_id_xr.is_set or
                                self.fully_protected_routes.is_set or
                                self.partially_protected_routes.is_set or
                                self.start_time_offset.is_set or
                                self.total_routes.is_set or
                                self.trigger_spf_run.is_set or
                                self.trigger_time.is_set or
                                self.wait_time.is_set)

                        def has_operation(self):
                            for c in self.ipfrr_statistic:
                                if (c.has_operation()):
                                    return True
                            for c in self.remote_node:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.completed_spf_run.yfilter != YFilter.not_set or
                                self.coverage.yfilter != YFilter.not_set or
                                self.duration.yfilter != YFilter.not_set or
                                self.event_id_xr.yfilter != YFilter.not_set or
                                self.fully_protected_routes.yfilter != YFilter.not_set or
                                self.partially_protected_routes.yfilter != YFilter.not_set or
                                self.start_time_offset.yfilter != YFilter.not_set or
                                self.total_routes.yfilter != YFilter.not_set or
                                self.trigger_spf_run.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                self.wait_time.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipfrr-event-offline" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.completed_spf_run.is_set or self.completed_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.completed_spf_run.get_name_leafdata())
                            if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.coverage.get_name_leafdata())
                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.duration.get_name_leafdata())
                            if (self.event_id_xr.is_set or self.event_id_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id_xr.get_name_leafdata())
                            if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                            if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                            if (self.start_time_offset.is_set or self.start_time_offset.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_time_offset.get_name_leafdata())
                            if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_routes.get_name_leafdata())
                            if (self.trigger_spf_run.is_set or self.trigger_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_spf_run.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())
                            if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wait_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ipfrr-statistic"):
                                for c in self.ipfrr_statistic:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.ipfrr_statistic.append(c)
                                return c

                            if (child_yang_name == "remote-node"):
                                for c in self.remote_node:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.remote_node.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ipfrr-statistic" or name == "remote-node" or name == "event-id" or name == "completed-spf-run" or name == "coverage" or name == "duration" or name == "event-id-xr" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "start-time-offset" or name == "total-routes" or name == "trigger-spf-run" or name == "trigger-time" or name == "wait-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "completed-spf-run"):
                                self.completed_spf_run = value
                                self.completed_spf_run.value_namespace = name_space
                                self.completed_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "coverage"):
                                self.coverage = value
                                self.coverage.value_namespace = name_space
                                self.coverage.value_namespace_prefix = name_space_prefix
                            if(value_path == "duration"):
                                self.duration = value
                                self.duration.value_namespace = name_space
                                self.duration.value_namespace_prefix = name_space_prefix
                            if(value_path == "event-id-xr"):
                                self.event_id_xr = value
                                self.event_id_xr.value_namespace = name_space
                                self.event_id_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "fully-protected-routes"):
                                self.fully_protected_routes = value
                                self.fully_protected_routes.value_namespace = name_space
                                self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "partially-protected-routes"):
                                self.partially_protected_routes = value
                                self.partially_protected_routes.value_namespace = name_space
                                self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-time-offset"):
                                self.start_time_offset = value
                                self.start_time_offset.value_namespace = name_space
                                self.start_time_offset.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-routes"):
                                self.total_routes = value
                                self.total_routes.value_namespace = name_space
                                self.total_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-spf-run"):
                                self.trigger_spf_run = value
                                self.trigger_spf_run.value_namespace = name_space
                                self.trigger_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "wait-time"):
                                self.wait_time = value
                                self.wait_time.value_namespace = name_space
                                self.wait_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.ipfrr_event_offline:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.ipfrr_event_offline:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipfrr-event-offlines" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ipfrr-event-offline"):
                            for c in self.ipfrr_event_offline:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.ipfrr_event_offline.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ipfrr-event-offline"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SpfRunOfflines(Entity):
                    """
                    OSPF SPF run offline data
                    
                    .. attribute:: spf_run_offline
                    
                    	Offline operational data for particular OSPF SPF run
                    	**type**\: list of    :py:class:`SpfRunOffline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines, self).__init__()

                        self.yang_name = "spf-run-offlines"
                        self.yang_parent_name = "instance"

                        self.spf_run_offline = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines, self).__setattr__(name, value)


                    class SpfRunOffline(Entity):
                        """
                        Offline operational data for particular OSPF
                        SPF run
                        
                        .. attribute:: spf_run_number  <key>
                        
                        	Specific SPF run
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: dijkstra_run
                        
                        	List of Dijkstra runs
                        	**type**\: list of    :py:class:`DijkstraRun <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun>`
                        
                        .. attribute:: inter_area_and_external
                        
                        	Inter\-area & external calculation information
                        	**type**\: list of    :py:class:`InterAreaAndExternal <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal>`
                        
                        .. attribute:: spf_summary
                        
                        	SPF summary information
                        	**type**\:   :py:class:`SpfSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary>`
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline, self).__init__()

                            self.yang_name = "spf-run-offline"
                            self.yang_parent_name = "spf-run-offlines"

                            self.spf_run_number = YLeaf(YType.int32, "spf-run-number")

                            self.spf_summary = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary()
                            self.spf_summary.parent = self
                            self._children_name_map["spf_summary"] = "spf-summary"
                            self._children_yang_names.add("spf-summary")

                            self.dijkstra_run = YList(self)
                            self.inter_area_and_external = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("spf_run_number") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline, self).__setattr__(name, value)


                        class SpfSummary(Entity):
                            """
                            SPF summary information
                            
                            .. attribute:: duration
                            
                            	Duration of complete SPF calculation (in ss .msec)
                            	**type**\:  str
                            
                            .. attribute:: is_data_complete
                            
                            	Whether the event has all information
                            	**type**\:  bool
                            
                            .. attribute:: priority_summary
                            
                            	Convergence information summary on per\-priority basis
                            	**type**\: list of    :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary>`
                            
                            .. attribute:: start_time
                            
                            	Start time (offset from event trigger time in ss .msec)
                            	**type**\:  str
                            
                            .. attribute:: state
                            
                            	SPF state
                            	**type**\:   :py:class:`RcmdSpfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdSpfState>`
                            
                            .. attribute:: threshold_exceeded
                            
                            	Threshold exceeded
                            	**type**\:  bool
                            
                            .. attribute:: total_dijkstra_runs
                            
                            	Total number of Dijkstra runs
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: total_inter_area_and_external_batches
                            
                            	Total number of inter\-area/external computation batches
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: total_type12lsa_changes
                            
                            	Total number of Type 1/2 LSA changes processed
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: total_type357lsa_changes
                            
                            	Total number of Type 3/5/7 LSA changes processed
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: trigger_time
                            
                            	Trigger time (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary, self).__init__()

                                self.yang_name = "spf-summary"
                                self.yang_parent_name = "spf-run-offline"

                                self.duration = YLeaf(YType.str, "duration")

                                self.is_data_complete = YLeaf(YType.boolean, "is-data-complete")

                                self.start_time = YLeaf(YType.str, "start-time")

                                self.state = YLeaf(YType.enumeration, "state")

                                self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                self.total_dijkstra_runs = YLeaf(YType.uint16, "total-dijkstra-runs")

                                self.total_inter_area_and_external_batches = YLeaf(YType.uint16, "total-inter-area-and-external-batches")

                                self.total_type12lsa_changes = YLeaf(YType.uint16, "total-type12lsa-changes")

                                self.total_type357lsa_changes = YLeaf(YType.uint16, "total-type357lsa-changes")

                                self.trigger_time = YLeaf(YType.str, "trigger-time")

                                self.priority_summary = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("duration",
                                                "is_data_complete",
                                                "start_time",
                                                "state",
                                                "threshold_exceeded",
                                                "total_dijkstra_runs",
                                                "total_inter_area_and_external_batches",
                                                "total_type12lsa_changes",
                                                "total_type357lsa_changes",
                                                "trigger_time") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary, self).__setattr__(name, value)


                            class PrioritySummary(Entity):
                                """
                                Convergence information summary on per\-priority
                                basis
                                
                                .. attribute:: frr_statistic
                                
                                	Fast Re\-Route Statistics
                                	**type**\: list of    :py:class:`FrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic>`
                                
                                .. attribute:: ip_convergence_time
                                
                                	Convergence time for IP route programming
                                	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime>`
                                
                                .. attribute:: level
                                
                                	Critical, High, Medium or Low
                                	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                
                                .. attribute:: mpls_convergence_time
                                
                                	Convergence time for MPLS label programming
                                	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime>`
                                
                                .. attribute:: route_statistics
                                
                                	Route statistics
                                	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics>`
                                
                                .. attribute:: threshold_exceeded
                                
                                	Threshold exceeded
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary, self).__init__()

                                    self.yang_name = "priority-summary"
                                    self.yang_parent_name = "spf-summary"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                    self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                    self._children_yang_names.add("ip-convergence-time")

                                    self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                    self._children_yang_names.add("mpls-convergence-time")

                                    self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics()
                                    self.route_statistics.parent = self
                                    self._children_name_map["route_statistics"] = "route-statistics"
                                    self._children_yang_names.add("route-statistics")

                                    self.frr_statistic = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "threshold_exceeded") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary, self).__setattr__(name, value)


                                class RouteStatistics(Entity):
                                    """
                                    Route statistics
                                    
                                    .. attribute:: adds
                                    
                                    	Added
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: deletes
                                    
                                    	Deleted
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: modifies
                                    
                                    	Modified
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: reachables
                                    
                                    	Reachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: touches
                                    
                                    	Touched
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: unreachables
                                    
                                    	Unreachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics, self).__init__()

                                        self.yang_name = "route-statistics"
                                        self.yang_parent_name = "priority-summary"

                                        self.adds = YLeaf(YType.uint32, "adds")

                                        self.deletes = YLeaf(YType.uint32, "deletes")

                                        self.modifies = YLeaf(YType.uint32, "modifies")

                                        self.reachables = YLeaf(YType.uint32, "reachables")

                                        self.touches = YLeaf(YType.uint32, "touches")

                                        self.unreachables = YLeaf(YType.uint32, "unreachables")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("adds",
                                                        "deletes",
                                                        "modifies",
                                                        "reachables",
                                                        "touches",
                                                        "unreachables") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.adds.is_set or
                                            self.deletes.is_set or
                                            self.modifies.is_set or
                                            self.reachables.is_set or
                                            self.touches.is_set or
                                            self.unreachables.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.adds.yfilter != YFilter.not_set or
                                            self.deletes.yfilter != YFilter.not_set or
                                            self.modifies.yfilter != YFilter.not_set or
                                            self.reachables.yfilter != YFilter.not_set or
                                            self.touches.yfilter != YFilter.not_set or
                                            self.unreachables.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "route-statistics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.adds.get_name_leafdata())
                                        if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.deletes.get_name_leafdata())
                                        if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.modifies.get_name_leafdata())
                                        if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.reachables.get_name_leafdata())
                                        if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.touches.get_name_leafdata())
                                        if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.unreachables.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "adds"):
                                            self.adds = value
                                            self.adds.value_namespace = name_space
                                            self.adds.value_namespace_prefix = name_space_prefix
                                        if(value_path == "deletes"):
                                            self.deletes = value
                                            self.deletes.value_namespace = name_space
                                            self.deletes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "modifies"):
                                            self.modifies = value
                                            self.modifies.value_namespace = name_space
                                            self.modifies.value_namespace_prefix = name_space_prefix
                                        if(value_path == "reachables"):
                                            self.reachables = value
                                            self.reachables.value_namespace = name_space
                                            self.reachables.value_namespace_prefix = name_space_prefix
                                        if(value_path == "touches"):
                                            self.touches = value
                                            self.touches.value_namespace = name_space
                                            self.touches.value_namespace_prefix = name_space_prefix
                                        if(value_path == "unreachables"):
                                            self.unreachables = value
                                            self.unreachables.value_namespace = name_space
                                            self.unreachables.value_namespace_prefix = name_space_prefix


                                class IpConvergenceTime(Entity):
                                    """
                                    Convergence time for IP route programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime, self).__init__()

                                        self.yang_name = "ip-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ip-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class MplsConvergenceTime(Entity):
                                    """
                                    Convergence time for MPLS label programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__init__()

                                        self.yang_name = "mpls-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mpls-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class FrrStatistic(Entity):
                                    """
                                    Fast Re\-Route Statistics
                                    
                                    .. attribute:: coverage
                                    
                                    	Coverage in percentage
                                    	**type**\:  str
                                    
                                    	**units**\: percentage
                                    
                                    .. attribute:: fully_protected_routes
                                    
                                    	Fully Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: partially_protected_routes
                                    
                                    	Partially Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_routes
                                    
                                    	Total Number of Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic, self).__init__()

                                        self.yang_name = "frr-statistic"
                                        self.yang_parent_name = "priority-summary"

                                        self.coverage = YLeaf(YType.str, "coverage")

                                        self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                        self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                        self.total_routes = YLeaf(YType.uint32, "total-routes")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("coverage",
                                                        "fully_protected_routes",
                                                        "partially_protected_routes",
                                                        "total_routes") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.coverage.is_set or
                                            self.fully_protected_routes.is_set or
                                            self.partially_protected_routes.is_set or
                                            self.total_routes.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.coverage.yfilter != YFilter.not_set or
                                            self.fully_protected_routes.yfilter != YFilter.not_set or
                                            self.partially_protected_routes.yfilter != YFilter.not_set or
                                            self.total_routes.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-statistic" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.coverage.get_name_leafdata())
                                        if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                        if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                        if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_routes.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "coverage" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "total-routes"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "coverage"):
                                            self.coverage = value
                                            self.coverage.value_namespace = name_space
                                            self.coverage.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fully-protected-routes"):
                                            self.fully_protected_routes = value
                                            self.fully_protected_routes.value_namespace = name_space
                                            self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "partially-protected-routes"):
                                            self.partially_protected_routes = value
                                            self.partially_protected_routes.value_namespace = name_space
                                            self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-routes"):
                                            self.total_routes = value
                                            self.total_routes.value_namespace = name_space
                                            self.total_routes.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_statistic:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.level.is_set or
                                        self.threshold_exceeded.is_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                        (self.route_statistics is not None and self.route_statistics.has_data()))

                                def has_operation(self):
                                    for c in self.frr_statistic:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.threshold_exceeded.yfilter != YFilter.not_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                        (self.route_statistics is not None and self.route_statistics.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority-summary" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-statistic"):
                                        for c in self.frr_statistic:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_statistic.append(c)
                                        return c

                                    if (child_yang_name == "ip-convergence-time"):
                                        if (self.ip_convergence_time is None):
                                            self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime()
                                            self.ip_convergence_time.parent = self
                                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        return self.ip_convergence_time

                                    if (child_yang_name == "mpls-convergence-time"):
                                        if (self.mpls_convergence_time is None):
                                            self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime()
                                            self.mpls_convergence_time.parent = self
                                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        return self.mpls_convergence_time

                                    if (child_yang_name == "route-statistics"):
                                        if (self.route_statistics is None):
                                            self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics()
                                            self.route_statistics.parent = self
                                            self._children_name_map["route_statistics"] = "route-statistics"
                                        return self.route_statistics

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-statistic" or name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "threshold-exceeded"):
                                        self.threshold_exceeded = value
                                        self.threshold_exceeded.value_namespace = name_space
                                        self.threshold_exceeded.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.priority_summary:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.duration.is_set or
                                    self.is_data_complete.is_set or
                                    self.start_time.is_set or
                                    self.state.is_set or
                                    self.threshold_exceeded.is_set or
                                    self.total_dijkstra_runs.is_set or
                                    self.total_inter_area_and_external_batches.is_set or
                                    self.total_type12lsa_changes.is_set or
                                    self.total_type357lsa_changes.is_set or
                                    self.trigger_time.is_set)

                            def has_operation(self):
                                for c in self.priority_summary:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.duration.yfilter != YFilter.not_set or
                                    self.is_data_complete.yfilter != YFilter.not_set or
                                    self.start_time.yfilter != YFilter.not_set or
                                    self.state.yfilter != YFilter.not_set or
                                    self.threshold_exceeded.yfilter != YFilter.not_set or
                                    self.total_dijkstra_runs.yfilter != YFilter.not_set or
                                    self.total_inter_area_and_external_batches.yfilter != YFilter.not_set or
                                    self.total_type12lsa_changes.yfilter != YFilter.not_set or
                                    self.total_type357lsa_changes.yfilter != YFilter.not_set or
                                    self.trigger_time.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-summary" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                if (self.is_data_complete.is_set or self.is_data_complete.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_data_complete.get_name_leafdata())
                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_time.get_name_leafdata())
                                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.state.get_name_leafdata())
                                if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                                if (self.total_dijkstra_runs.is_set or self.total_dijkstra_runs.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_dijkstra_runs.get_name_leafdata())
                                if (self.total_inter_area_and_external_batches.is_set or self.total_inter_area_and_external_batches.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_inter_area_and_external_batches.get_name_leafdata())
                                if (self.total_type12lsa_changes.is_set or self.total_type12lsa_changes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_type12lsa_changes.get_name_leafdata())
                                if (self.total_type357lsa_changes.is_set or self.total_type357lsa_changes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_type357lsa_changes.get_name_leafdata())
                                if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.trigger_time.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "priority-summary"):
                                    for c in self.priority_summary:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.priority_summary.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "priority-summary" or name == "duration" or name == "is-data-complete" or name == "start-time" or name == "state" or name == "threshold-exceeded" or name == "total-dijkstra-runs" or name == "total-inter-area-and-external-batches" or name == "total-type12lsa-changes" or name == "total-type357lsa-changes" or name == "trigger-time"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "duration"):
                                    self.duration = value
                                    self.duration.value_namespace = name_space
                                    self.duration.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-data-complete"):
                                    self.is_data_complete = value
                                    self.is_data_complete.value_namespace = name_space
                                    self.is_data_complete.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-time"):
                                    self.start_time = value
                                    self.start_time.value_namespace = name_space
                                    self.start_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "state"):
                                    self.state = value
                                    self.state.value_namespace = name_space
                                    self.state.value_namespace_prefix = name_space_prefix
                                if(value_path == "threshold-exceeded"):
                                    self.threshold_exceeded = value
                                    self.threshold_exceeded.value_namespace = name_space
                                    self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-dijkstra-runs"):
                                    self.total_dijkstra_runs = value
                                    self.total_dijkstra_runs.value_namespace = name_space
                                    self.total_dijkstra_runs.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-inter-area-and-external-batches"):
                                    self.total_inter_area_and_external_batches = value
                                    self.total_inter_area_and_external_batches.value_namespace = name_space
                                    self.total_inter_area_and_external_batches.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-type12lsa-changes"):
                                    self.total_type12lsa_changes = value
                                    self.total_type12lsa_changes.value_namespace = name_space
                                    self.total_type12lsa_changes.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-type357lsa-changes"):
                                    self.total_type357lsa_changes = value
                                    self.total_type357lsa_changes.value_namespace = name_space
                                    self.total_type357lsa_changes.value_namespace_prefix = name_space_prefix
                                if(value_path == "trigger-time"):
                                    self.trigger_time = value
                                    self.trigger_time.value_namespace = name_space
                                    self.trigger_time.value_namespace_prefix = name_space_prefix


                        class DijkstraRun(Entity):
                            """
                            List of Dijkstra runs
                            
                            .. attribute:: area_id
                            
                            	Area ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: dijkstra_run_number
                            
                            	Area Dijkstra run number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: duration
                            
                            	Duration of Dijktra calculation (in ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: lsa_processed
                            
                            	List of type 1/2 LSA changes processed
                            	**type**\: list of    :py:class:`LsaProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.LsaProcessed>`
                            
                            .. attribute:: priority
                            
                            	Convergence information on per\-priority basis
                            	**type**\: list of    :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority>`
                            
                            .. attribute:: start_time
                            
                            	Start time (offset from event trigger time in ss .msec)
                            	**type**\:  str
                            
                            .. attribute:: threshold_exceeded
                            
                            	Threshold exceeded
                            	**type**\:  bool
                            
                            .. attribute:: trigger_lsa
                            
                            	LSA that triggered the Dijkstra run
                            	**type**\: list of    :py:class:`TriggerLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.TriggerLsa>`
                            
                            .. attribute:: trigger_time
                            
                            	Trigger time (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: wait_time
                            
                            	Wait time (offset from event trigger time in ss .msec)
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun, self).__init__()

                                self.yang_name = "dijkstra-run"
                                self.yang_parent_name = "spf-run-offline"

                                self.area_id = YLeaf(YType.str, "area-id")

                                self.dijkstra_run_number = YLeaf(YType.uint32, "dijkstra-run-number")

                                self.duration = YLeaf(YType.str, "duration")

                                self.start_time = YLeaf(YType.str, "start-time")

                                self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                self.trigger_time = YLeaf(YType.str, "trigger-time")

                                self.wait_time = YLeaf(YType.uint32, "wait-time")

                                self.lsa_processed = YList(self)
                                self.priority = YList(self)
                                self.trigger_lsa = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("area_id",
                                                "dijkstra_run_number",
                                                "duration",
                                                "start_time",
                                                "threshold_exceeded",
                                                "trigger_time",
                                                "wait_time") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun, self).__setattr__(name, value)


                            class TriggerLsa(Entity):
                                """
                                LSA that triggered the Dijkstra run
                                
                                .. attribute:: change_type
                                
                                	Add, Delete, Modify
                                	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                                
                                .. attribute:: lsa_id
                                
                                	LSA ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: lsa_type
                                
                                	LSA type
                                	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                                
                                .. attribute:: origin_router_id
                                
                                	Originating Router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: reception_time
                                
                                	Reception Time on router (in hh\:mm\:ss.msec)
                                	**type**\:  str
                                
                                .. attribute:: sequence_number
                                
                                	Sequence Number
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.TriggerLsa, self).__init__()

                                    self.yang_name = "trigger-lsa"
                                    self.yang_parent_name = "dijkstra-run"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.lsa_id = YLeaf(YType.str, "lsa-id")

                                    self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                    self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                    self.reception_time = YLeaf(YType.str, "reception-time")

                                    self.sequence_number = YLeaf(YType.str, "sequence-number")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "lsa_id",
                                                    "lsa_type",
                                                    "origin_router_id",
                                                    "reception_time",
                                                    "sequence_number") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.TriggerLsa, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.TriggerLsa, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.lsa_id.is_set or
                                        self.lsa_type.is_set or
                                        self.origin_router_id.is_set or
                                        self.reception_time.is_set or
                                        self.sequence_number.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.lsa_id.yfilter != YFilter.not_set or
                                        self.lsa_type.yfilter != YFilter.not_set or
                                        self.origin_router_id.yfilter != YFilter.not_set or
                                        self.reception_time.yfilter != YFilter.not_set or
                                        self.sequence_number.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "trigger-lsa" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                    if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                    if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                    if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.reception_time.get_name_leafdata())
                                    if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsa-id"):
                                        self.lsa_id = value
                                        self.lsa_id.value_namespace = name_space
                                        self.lsa_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsa-type"):
                                        self.lsa_type = value
                                        self.lsa_type.value_namespace = name_space
                                        self.lsa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "origin-router-id"):
                                        self.origin_router_id = value
                                        self.origin_router_id.value_namespace = name_space
                                        self.origin_router_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "reception-time"):
                                        self.reception_time = value
                                        self.reception_time.value_namespace = name_space
                                        self.reception_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "sequence-number"):
                                        self.sequence_number = value
                                        self.sequence_number.value_namespace = name_space
                                        self.sequence_number.value_namespace_prefix = name_space_prefix


                            class Priority(Entity):
                                """
                                Convergence information on per\-priority basis
                                
                                .. attribute:: convergence_timeline
                                
                                	Convergence timeline details
                                	**type**\: list of    :py:class:`ConvergenceTimeline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline>`
                                
                                .. attribute:: leaf_networks_added
                                
                                	List of Leaf Networks Added
                                	**type**\: list of    :py:class:`LeafNetworksAdded <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksAdded>`
                                
                                .. attribute:: leaf_networks_deleted
                                
                                	List of Leaf Networks Deleted
                                	**type**\: list of    :py:class:`LeafNetworksDeleted <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksDeleted>`
                                
                                .. attribute:: priority_summary
                                
                                	Summary of the priority
                                	**type**\:   :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority, self).__init__()

                                    self.yang_name = "priority"
                                    self.yang_parent_name = "dijkstra-run"

                                    self.priority_summary = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary()
                                    self.priority_summary.parent = self
                                    self._children_name_map["priority_summary"] = "priority-summary"
                                    self._children_yang_names.add("priority-summary")

                                    self.convergence_timeline = YList(self)
                                    self.leaf_networks_added = YList(self)
                                    self.leaf_networks_deleted = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority, self).__setattr__(name, value)


                                class PrioritySummary(Entity):
                                    """
                                    Summary of the priority
                                    
                                    .. attribute:: frr_statistic
                                    
                                    	Fast Re\-Route Statistics
                                    	**type**\: list of    :py:class:`FrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.FrrStatistic>`
                                    
                                    .. attribute:: ip_convergence_time
                                    
                                    	Convergence time for IP route programming
                                    	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime>`
                                    
                                    .. attribute:: level
                                    
                                    	Critical, High, Medium or Low
                                    	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                    
                                    .. attribute:: mpls_convergence_time
                                    
                                    	Convergence time for MPLS label programming
                                    	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime>`
                                    
                                    .. attribute:: route_statistics
                                    
                                    	Route statistics
                                    	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.RouteStatistics>`
                                    
                                    .. attribute:: threshold_exceeded
                                    
                                    	Threshold exceeded
                                    	**type**\:  bool
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary, self).__init__()

                                        self.yang_name = "priority-summary"
                                        self.yang_parent_name = "priority"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                        self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime()
                                        self.ip_convergence_time.parent = self
                                        self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        self._children_yang_names.add("ip-convergence-time")

                                        self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime()
                                        self.mpls_convergence_time.parent = self
                                        self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        self._children_yang_names.add("mpls-convergence-time")

                                        self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.RouteStatistics()
                                        self.route_statistics.parent = self
                                        self._children_name_map["route_statistics"] = "route-statistics"
                                        self._children_yang_names.add("route-statistics")

                                        self.frr_statistic = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "threshold_exceeded") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary, self).__setattr__(name, value)


                                    class RouteStatistics(Entity):
                                        """
                                        Route statistics
                                        
                                        .. attribute:: adds
                                        
                                        	Added
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: deletes
                                        
                                        	Deleted
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: modifies
                                        
                                        	Modified
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: reachables
                                        
                                        	Reachable
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: touches
                                        
                                        	Touched
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: unreachables
                                        
                                        	Unreachable
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.RouteStatistics, self).__init__()

                                            self.yang_name = "route-statistics"
                                            self.yang_parent_name = "priority-summary"

                                            self.adds = YLeaf(YType.uint32, "adds")

                                            self.deletes = YLeaf(YType.uint32, "deletes")

                                            self.modifies = YLeaf(YType.uint32, "modifies")

                                            self.reachables = YLeaf(YType.uint32, "reachables")

                                            self.touches = YLeaf(YType.uint32, "touches")

                                            self.unreachables = YLeaf(YType.uint32, "unreachables")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("adds",
                                                            "deletes",
                                                            "modifies",
                                                            "reachables",
                                                            "touches",
                                                            "unreachables") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.adds.is_set or
                                                self.deletes.is_set or
                                                self.modifies.is_set or
                                                self.reachables.is_set or
                                                self.touches.is_set or
                                                self.unreachables.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.adds.yfilter != YFilter.not_set or
                                                self.deletes.yfilter != YFilter.not_set or
                                                self.modifies.yfilter != YFilter.not_set or
                                                self.reachables.yfilter != YFilter.not_set or
                                                self.touches.yfilter != YFilter.not_set or
                                                self.unreachables.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-statistics" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adds.get_name_leafdata())
                                            if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.deletes.get_name_leafdata())
                                            if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.modifies.get_name_leafdata())
                                            if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.reachables.get_name_leafdata())
                                            if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.touches.get_name_leafdata())
                                            if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.unreachables.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "adds"):
                                                self.adds = value
                                                self.adds.value_namespace = name_space
                                                self.adds.value_namespace_prefix = name_space_prefix
                                            if(value_path == "deletes"):
                                                self.deletes = value
                                                self.deletes.value_namespace = name_space
                                                self.deletes.value_namespace_prefix = name_space_prefix
                                            if(value_path == "modifies"):
                                                self.modifies = value
                                                self.modifies.value_namespace = name_space
                                                self.modifies.value_namespace_prefix = name_space_prefix
                                            if(value_path == "reachables"):
                                                self.reachables = value
                                                self.reachables.value_namespace = name_space
                                                self.reachables.value_namespace_prefix = name_space_prefix
                                            if(value_path == "touches"):
                                                self.touches = value
                                                self.touches.value_namespace = name_space
                                                self.touches.value_namespace_prefix = name_space_prefix
                                            if(value_path == "unreachables"):
                                                self.unreachables = value
                                                self.unreachables.value_namespace = name_space
                                                self.unreachables.value_namespace_prefix = name_space_prefix


                                    class IpConvergenceTime(Entity):
                                        """
                                        Convergence time for IP route programming
                                        
                                        .. attribute:: fastest_node_name
                                        
                                        	Linecard node name which took the minimum time
                                        	**type**\:  str
                                        
                                        .. attribute:: maximum_time
                                        
                                        	Maximum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: minimum_time
                                        
                                        	Minimum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: slowest_node_name
                                        
                                        	Linecard node name which took the maximum time
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime, self).__init__()

                                            self.yang_name = "ip-convergence-time"
                                            self.yang_parent_name = "priority-summary"

                                            self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                            self.maximum_time = YLeaf(YType.str, "maximum-time")

                                            self.minimum_time = YLeaf(YType.str, "minimum-time")

                                            self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fastest_node_name",
                                                            "maximum_time",
                                                            "minimum_time",
                                                            "slowest_node_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.fastest_node_name.is_set or
                                                self.maximum_time.is_set or
                                                self.minimum_time.is_set or
                                                self.slowest_node_name.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fastest_node_name.yfilter != YFilter.not_set or
                                                self.maximum_time.yfilter != YFilter.not_set or
                                                self.minimum_time.yfilter != YFilter.not_set or
                                                self.slowest_node_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ip-convergence-time" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                            if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                            if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                            if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fastest-node-name"):
                                                self.fastest_node_name = value
                                                self.fastest_node_name.value_namespace = name_space
                                                self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "maximum-time"):
                                                self.maximum_time = value
                                                self.maximum_time.value_namespace = name_space
                                                self.maximum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "minimum-time"):
                                                self.minimum_time = value
                                                self.minimum_time.value_namespace = name_space
                                                self.minimum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "slowest-node-name"):
                                                self.slowest_node_name = value
                                                self.slowest_node_name.value_namespace = name_space
                                                self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                    class MplsConvergenceTime(Entity):
                                        """
                                        Convergence time for MPLS label programming
                                        
                                        .. attribute:: fastest_node_name
                                        
                                        	Linecard node name which took the minimum time
                                        	**type**\:  str
                                        
                                        .. attribute:: maximum_time
                                        
                                        	Maximum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: minimum_time
                                        
                                        	Minimum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: slowest_node_name
                                        
                                        	Linecard node name which took the maximum time
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime, self).__init__()

                                            self.yang_name = "mpls-convergence-time"
                                            self.yang_parent_name = "priority-summary"

                                            self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                            self.maximum_time = YLeaf(YType.str, "maximum-time")

                                            self.minimum_time = YLeaf(YType.str, "minimum-time")

                                            self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fastest_node_name",
                                                            "maximum_time",
                                                            "minimum_time",
                                                            "slowest_node_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.fastest_node_name.is_set or
                                                self.maximum_time.is_set or
                                                self.minimum_time.is_set or
                                                self.slowest_node_name.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fastest_node_name.yfilter != YFilter.not_set or
                                                self.maximum_time.yfilter != YFilter.not_set or
                                                self.minimum_time.yfilter != YFilter.not_set or
                                                self.slowest_node_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "mpls-convergence-time" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                            if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                            if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                            if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fastest-node-name"):
                                                self.fastest_node_name = value
                                                self.fastest_node_name.value_namespace = name_space
                                                self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "maximum-time"):
                                                self.maximum_time = value
                                                self.maximum_time.value_namespace = name_space
                                                self.maximum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "minimum-time"):
                                                self.minimum_time = value
                                                self.minimum_time.value_namespace = name_space
                                                self.minimum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "slowest-node-name"):
                                                self.slowest_node_name = value
                                                self.slowest_node_name.value_namespace = name_space
                                                self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                    class FrrStatistic(Entity):
                                        """
                                        Fast Re\-Route Statistics
                                        
                                        .. attribute:: coverage
                                        
                                        	Coverage in percentage
                                        	**type**\:  str
                                        
                                        	**units**\: percentage
                                        
                                        .. attribute:: fully_protected_routes
                                        
                                        	Fully Protected Routes
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: partially_protected_routes
                                        
                                        	Partially Protected Routes
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: total_routes
                                        
                                        	Total Number of Routes
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.FrrStatistic, self).__init__()

                                            self.yang_name = "frr-statistic"
                                            self.yang_parent_name = "priority-summary"

                                            self.coverage = YLeaf(YType.str, "coverage")

                                            self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                            self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                            self.total_routes = YLeaf(YType.uint32, "total-routes")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("coverage",
                                                            "fully_protected_routes",
                                                            "partially_protected_routes",
                                                            "total_routes") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.FrrStatistic, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.FrrStatistic, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.coverage.is_set or
                                                self.fully_protected_routes.is_set or
                                                self.partially_protected_routes.is_set or
                                                self.total_routes.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.coverage.yfilter != YFilter.not_set or
                                                self.fully_protected_routes.yfilter != YFilter.not_set or
                                                self.partially_protected_routes.yfilter != YFilter.not_set or
                                                self.total_routes.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "frr-statistic" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.coverage.get_name_leafdata())
                                            if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                            if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                            if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.total_routes.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "coverage" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "total-routes"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "coverage"):
                                                self.coverage = value
                                                self.coverage.value_namespace = name_space
                                                self.coverage.value_namespace_prefix = name_space_prefix
                                            if(value_path == "fully-protected-routes"):
                                                self.fully_protected_routes = value
                                                self.fully_protected_routes.value_namespace = name_space
                                                self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                            if(value_path == "partially-protected-routes"):
                                                self.partially_protected_routes = value
                                                self.partially_protected_routes.value_namespace = name_space
                                                self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                            if(value_path == "total-routes"):
                                                self.total_routes = value
                                                self.total_routes.value_namespace = name_space
                                                self.total_routes.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.frr_statistic:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            self.level.is_set or
                                            self.threshold_exceeded.is_set or
                                            (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                            (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                            (self.route_statistics is not None and self.route_statistics.has_data()))

                                    def has_operation(self):
                                        for c in self.frr_statistic:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.threshold_exceeded.yfilter != YFilter.not_set or
                                            (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                            (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                            (self.route_statistics is not None and self.route_statistics.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "priority-summary" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "frr-statistic"):
                                            for c in self.frr_statistic:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.FrrStatistic()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.frr_statistic.append(c)
                                            return c

                                        if (child_yang_name == "ip-convergence-time"):
                                            if (self.ip_convergence_time is None):
                                                self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.IpConvergenceTime()
                                                self.ip_convergence_time.parent = self
                                                self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                            return self.ip_convergence_time

                                        if (child_yang_name == "mpls-convergence-time"):
                                            if (self.mpls_convergence_time is None):
                                                self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.MplsConvergenceTime()
                                                self.mpls_convergence_time.parent = self
                                                self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                            return self.mpls_convergence_time

                                        if (child_yang_name == "route-statistics"):
                                            if (self.route_statistics is None):
                                                self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary.RouteStatistics()
                                                self.route_statistics.parent = self
                                                self._children_name_map["route_statistics"] = "route-statistics"
                                            return self.route_statistics

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "frr-statistic" or name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "threshold-exceeded"):
                                            self.threshold_exceeded = value
                                            self.threshold_exceeded.value_namespace = name_space
                                            self.threshold_exceeded.value_namespace_prefix = name_space_prefix


                                class ConvergenceTimeline(Entity):
                                    """
                                    Convergence timeline details
                                    
                                    .. attribute:: lc_ip
                                    
                                    	List of Linecards' completion point for IP routes
                                    	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp>`
                                    
                                    .. attribute:: lc_mpls
                                    
                                    	List of Linecards' completion point for MPLS labels
                                    	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls>`
                                    
                                    .. attribute:: ldp_enter
                                    
                                    	Entry point of LDP
                                    	**type**\:   :py:class:`LdpEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter>`
                                    
                                    .. attribute:: ldp_exit
                                    
                                    	Exit point of LDP to LSD
                                    	**type**\:   :py:class:`LdpExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpExit>`
                                    
                                    .. attribute:: lsd_enter
                                    
                                    	Entry point of LSD
                                    	**type**\:   :py:class:`LsdEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter>`
                                    
                                    .. attribute:: lsd_exit
                                    
                                    	Exit point of LSD to FIBs
                                    	**type**\:   :py:class:`LsdExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdExit>`
                                    
                                    .. attribute:: ri_bv4_enter
                                    
                                    	Entry point of IPv4 RIB
                                    	**type**\:   :py:class:`RiBv4Enter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter>`
                                    
                                    .. attribute:: ri_bv4_exit
                                    
                                    	Exit point from IPv4 RIB to FIBs
                                    	**type**\:   :py:class:`RiBv4Exit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit>`
                                    
                                    .. attribute:: ri_bv4_redistribute
                                    
                                    	Route Redistribute point from IPv4 RIB to LDP
                                    	**type**\:   :py:class:`RiBv4Redistribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute>`
                                    
                                    .. attribute:: route_origin
                                    
                                    	Route origin (routing protocol)
                                    	**type**\:   :py:class:`RouteOrigin <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin>`
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline, self).__init__()

                                        self.yang_name = "convergence-timeline"
                                        self.yang_parent_name = "priority"

                                        self.ldp_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter()
                                        self.ldp_enter.parent = self
                                        self._children_name_map["ldp_enter"] = "ldp-enter"
                                        self._children_yang_names.add("ldp-enter")

                                        self.ldp_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpExit()
                                        self.ldp_exit.parent = self
                                        self._children_name_map["ldp_exit"] = "ldp-exit"
                                        self._children_yang_names.add("ldp-exit")

                                        self.lsd_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter()
                                        self.lsd_enter.parent = self
                                        self._children_name_map["lsd_enter"] = "lsd-enter"
                                        self._children_yang_names.add("lsd-enter")

                                        self.lsd_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdExit()
                                        self.lsd_exit.parent = self
                                        self._children_name_map["lsd_exit"] = "lsd-exit"
                                        self._children_yang_names.add("lsd-exit")

                                        self.ri_bv4_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter()
                                        self.ri_bv4_enter.parent = self
                                        self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                        self._children_yang_names.add("ri-bv4-enter")

                                        self.ri_bv4_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit()
                                        self.ri_bv4_exit.parent = self
                                        self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                        self._children_yang_names.add("ri-bv4-exit")

                                        self.ri_bv4_redistribute = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                        self.ri_bv4_redistribute.parent = self
                                        self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                        self._children_yang_names.add("ri-bv4-redistribute")

                                        self.route_origin = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin()
                                        self.route_origin.parent = self
                                        self._children_name_map["route_origin"] = "route-origin"
                                        self._children_yang_names.add("route-origin")

                                        self.lc_ip = YList(self)
                                        self.lc_mpls = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline, self).__setattr__(name, value)


                                    class RouteOrigin(Entity):
                                        """
                                        Route origin (routing protocol)
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin, self).__init__()

                                            self.yang_name = "route-origin"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-origin" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Enter(Entity):
                                        """
                                        Entry point of IPv4 RIB
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter, self).__init__()

                                            self.yang_name = "ri-bv4-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Exit(Entity):
                                        """
                                        Exit point from IPv4 RIB to FIBs
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit, self).__init__()

                                            self.yang_name = "ri-bv4-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Redistribute(Entity):
                                        """
                                        Route Redistribute point from IPv4 RIB to LDP
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__init__()

                                            self.yang_name = "ri-bv4-redistribute"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-redistribute" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LdpEnter(Entity):
                                        """
                                        Entry point of LDP
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter, self).__init__()

                                            self.yang_name = "ldp-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ldp-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LdpExit(Entity):
                                        """
                                        Exit point of LDP to LSD
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpExit, self).__init__()

                                            self.yang_name = "ldp-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ldp-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LsdEnter(Entity):
                                        """
                                        Entry point of LSD
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter, self).__init__()

                                            self.yang_name = "lsd-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lsd-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LsdExit(Entity):
                                        """
                                        Exit point of LSD to FIBs
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdExit, self).__init__()

                                            self.yang_name = "lsd-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lsd-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LcIp(Entity):
                                        """
                                        List of Linecards' completion point for IP
                                        routes
                                        
                                        .. attribute:: fib_complete
                                        
                                        	Completion point of FIB
                                        	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete>`
                                        
                                        .. attribute:: node_name
                                        
                                        	Linecard node name
                                        	**type**\:  str
                                        
                                        .. attribute:: speed
                                        
                                        	Relative convergence speed
                                        	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp, self).__init__()

                                            self.yang_name = "lc-ip"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.node_name = YLeaf(YType.str, "node-name")

                                            self.speed = YLeaf(YType.enumeration, "speed")

                                            self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                            self.fib_complete.parent = self
                                            self._children_name_map["fib_complete"] = "fib-complete"
                                            self._children_yang_names.add("fib-complete")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("node_name",
                                                            "speed") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)


                                        class FibComplete(Entity):
                                            """
                                            Completion point of FIB
                                            
                                            .. attribute:: duration
                                            
                                            	Duration of processing (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: end_time
                                            
                                            	Last route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: start_time
                                            
                                            	First route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'infra-rcmd-oper'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__init__()

                                                self.yang_name = "fib-complete"
                                                self.yang_parent_name = "lc-ip"

                                                self.duration = YLeaf(YType.str, "duration")

                                                self.end_time = YLeaf(YType.str, "end-time")

                                                self.start_time = YLeaf(YType.str, "start-time")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("duration",
                                                                "end_time",
                                                                "start_time") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.duration.is_set or
                                                    self.end_time.is_set or
                                                    self.start_time.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.duration.yfilter != YFilter.not_set or
                                                    self.end_time.yfilter != YFilter.not_set or
                                                    self.start_time.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-complete" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                                if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.end_time.get_name_leafdata())
                                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.start_time.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "duration" or name == "end-time" or name == "start-time"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "duration"):
                                                    self.duration = value
                                                    self.duration.value_namespace = name_space
                                                    self.duration.value_namespace_prefix = name_space_prefix
                                                if(value_path == "end-time"):
                                                    self.end_time = value
                                                    self.end_time.value_namespace = name_space
                                                    self.end_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "start-time"):
                                                    self.start_time = value
                                                    self.start_time.value_namespace = name_space
                                                    self.start_time.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.node_name.is_set or
                                                self.speed.is_set or
                                                (self.fib_complete is not None and self.fib_complete.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.node_name.yfilter != YFilter.not_set or
                                                self.speed.yfilter != YFilter.not_set or
                                                (self.fib_complete is not None and self.fib_complete.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lc-ip" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_name.get_name_leafdata())
                                            if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.speed.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-complete"):
                                                if (self.fib_complete is None):
                                                    self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                                    self.fib_complete.parent = self
                                                    self._children_name_map["fib_complete"] = "fib-complete"
                                                return self.fib_complete

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "node-name"):
                                                self.node_name = value
                                                self.node_name.value_namespace = name_space
                                                self.node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "speed"):
                                                self.speed = value
                                                self.speed.value_namespace = name_space
                                                self.speed.value_namespace_prefix = name_space_prefix


                                    class LcMpls(Entity):
                                        """
                                        List of Linecards' completion point for MPLS
                                        labels
                                        
                                        .. attribute:: fib_complete
                                        
                                        	Completion point of FIB
                                        	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete>`
                                        
                                        .. attribute:: node_name
                                        
                                        	Linecard node name
                                        	**type**\:  str
                                        
                                        .. attribute:: speed
                                        
                                        	Relative convergence speed
                                        	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls, self).__init__()

                                            self.yang_name = "lc-mpls"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.node_name = YLeaf(YType.str, "node-name")

                                            self.speed = YLeaf(YType.enumeration, "speed")

                                            self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                            self.fib_complete.parent = self
                                            self._children_name_map["fib_complete"] = "fib-complete"
                                            self._children_yang_names.add("fib-complete")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("node_name",
                                                            "speed") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)


                                        class FibComplete(Entity):
                                            """
                                            Completion point of FIB
                                            
                                            .. attribute:: duration
                                            
                                            	Duration of processing (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: end_time
                                            
                                            	Last route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: start_time
                                            
                                            	First route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'infra-rcmd-oper'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__init__()

                                                self.yang_name = "fib-complete"
                                                self.yang_parent_name = "lc-mpls"

                                                self.duration = YLeaf(YType.str, "duration")

                                                self.end_time = YLeaf(YType.str, "end-time")

                                                self.start_time = YLeaf(YType.str, "start-time")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("duration",
                                                                "end_time",
                                                                "start_time") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.duration.is_set or
                                                    self.end_time.is_set or
                                                    self.start_time.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.duration.yfilter != YFilter.not_set or
                                                    self.end_time.yfilter != YFilter.not_set or
                                                    self.start_time.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-complete" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                                if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.end_time.get_name_leafdata())
                                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.start_time.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "duration" or name == "end-time" or name == "start-time"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "duration"):
                                                    self.duration = value
                                                    self.duration.value_namespace = name_space
                                                    self.duration.value_namespace_prefix = name_space_prefix
                                                if(value_path == "end-time"):
                                                    self.end_time = value
                                                    self.end_time.value_namespace = name_space
                                                    self.end_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "start-time"):
                                                    self.start_time = value
                                                    self.start_time.value_namespace = name_space
                                                    self.start_time.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.node_name.is_set or
                                                self.speed.is_set or
                                                (self.fib_complete is not None and self.fib_complete.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.node_name.yfilter != YFilter.not_set or
                                                self.speed.yfilter != YFilter.not_set or
                                                (self.fib_complete is not None and self.fib_complete.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lc-mpls" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_name.get_name_leafdata())
                                            if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.speed.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-complete"):
                                                if (self.fib_complete is None):
                                                    self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                                    self.fib_complete.parent = self
                                                    self._children_name_map["fib_complete"] = "fib-complete"
                                                return self.fib_complete

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "node-name"):
                                                self.node_name = value
                                                self.node_name.value_namespace = name_space
                                                self.node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "speed"):
                                                self.speed = value
                                                self.speed.value_namespace = name_space
                                                self.speed.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.lc_ip:
                                            if (c.has_data()):
                                                return True
                                        for c in self.lc_mpls:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            (self.ldp_enter is not None and self.ldp_enter.has_data()) or
                                            (self.ldp_exit is not None and self.ldp_exit.has_data()) or
                                            (self.lsd_enter is not None and self.lsd_enter.has_data()) or
                                            (self.lsd_exit is not None and self.lsd_exit.has_data()) or
                                            (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_data()) or
                                            (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_data()) or
                                            (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_data()) or
                                            (self.route_origin is not None and self.route_origin.has_data()))

                                    def has_operation(self):
                                        for c in self.lc_ip:
                                            if (c.has_operation()):
                                                return True
                                        for c in self.lc_mpls:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.ldp_enter is not None and self.ldp_enter.has_operation()) or
                                            (self.ldp_exit is not None and self.ldp_exit.has_operation()) or
                                            (self.lsd_enter is not None and self.lsd_enter.has_operation()) or
                                            (self.lsd_exit is not None and self.lsd_exit.has_operation()) or
                                            (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_operation()) or
                                            (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_operation()) or
                                            (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_operation()) or
                                            (self.route_origin is not None and self.route_origin.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "convergence-timeline" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "lc-ip"):
                                            for c in self.lc_ip:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcIp()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.lc_ip.append(c)
                                            return c

                                        if (child_yang_name == "lc-mpls"):
                                            for c in self.lc_mpls:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LcMpls()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.lc_mpls.append(c)
                                            return c

                                        if (child_yang_name == "ldp-enter"):
                                            if (self.ldp_enter is None):
                                                self.ldp_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpEnter()
                                                self.ldp_enter.parent = self
                                                self._children_name_map["ldp_enter"] = "ldp-enter"
                                            return self.ldp_enter

                                        if (child_yang_name == "ldp-exit"):
                                            if (self.ldp_exit is None):
                                                self.ldp_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LdpExit()
                                                self.ldp_exit.parent = self
                                                self._children_name_map["ldp_exit"] = "ldp-exit"
                                            return self.ldp_exit

                                        if (child_yang_name == "lsd-enter"):
                                            if (self.lsd_enter is None):
                                                self.lsd_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdEnter()
                                                self.lsd_enter.parent = self
                                                self._children_name_map["lsd_enter"] = "lsd-enter"
                                            return self.lsd_enter

                                        if (child_yang_name == "lsd-exit"):
                                            if (self.lsd_exit is None):
                                                self.lsd_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.LsdExit()
                                                self.lsd_exit.parent = self
                                                self._children_name_map["lsd_exit"] = "lsd-exit"
                                            return self.lsd_exit

                                        if (child_yang_name == "ri-bv4-enter"):
                                            if (self.ri_bv4_enter is None):
                                                self.ri_bv4_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Enter()
                                                self.ri_bv4_enter.parent = self
                                                self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                            return self.ri_bv4_enter

                                        if (child_yang_name == "ri-bv4-exit"):
                                            if (self.ri_bv4_exit is None):
                                                self.ri_bv4_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Exit()
                                                self.ri_bv4_exit.parent = self
                                                self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                            return self.ri_bv4_exit

                                        if (child_yang_name == "ri-bv4-redistribute"):
                                            if (self.ri_bv4_redistribute is None):
                                                self.ri_bv4_redistribute = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                                self.ri_bv4_redistribute.parent = self
                                                self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                            return self.ri_bv4_redistribute

                                        if (child_yang_name == "route-origin"):
                                            if (self.route_origin is None):
                                                self.route_origin = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline.RouteOrigin()
                                                self.route_origin.parent = self
                                                self._children_name_map["route_origin"] = "route-origin"
                                            return self.route_origin

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class LeafNetworksAdded(Entity):
                                    """
                                    List of Leaf Networks Added
                                    
                                    .. attribute:: address
                                    
                                    	IP address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: net_mask
                                    
                                    	Mask
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksAdded, self).__init__()

                                        self.yang_name = "leaf-networks-added"
                                        self.yang_parent_name = "priority"

                                        self.address = YLeaf(YType.str, "address")

                                        self.net_mask = YLeaf(YType.uint8, "net-mask")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("address",
                                                        "net_mask") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksAdded, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksAdded, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.address.is_set or
                                            self.net_mask.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.net_mask.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "leaf-networks-added" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.net_mask.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "address" or name == "net-mask"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "net-mask"):
                                            self.net_mask = value
                                            self.net_mask.value_namespace = name_space
                                            self.net_mask.value_namespace_prefix = name_space_prefix


                                class LeafNetworksDeleted(Entity):
                                    """
                                    List of Leaf Networks Deleted
                                    
                                    .. attribute:: address
                                    
                                    	IP address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: net_mask
                                    
                                    	Mask
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksDeleted, self).__init__()

                                        self.yang_name = "leaf-networks-deleted"
                                        self.yang_parent_name = "priority"

                                        self.address = YLeaf(YType.str, "address")

                                        self.net_mask = YLeaf(YType.uint8, "net-mask")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("address",
                                                        "net_mask") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksDeleted, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksDeleted, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.address.is_set or
                                            self.net_mask.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.net_mask.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "leaf-networks-deleted" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.net_mask.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "address" or name == "net-mask"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "net-mask"):
                                            self.net_mask = value
                                            self.net_mask.value_namespace = name_space
                                            self.net_mask.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.convergence_timeline:
                                        if (c.has_data()):
                                            return True
                                    for c in self.leaf_networks_added:
                                        if (c.has_data()):
                                            return True
                                    for c in self.leaf_networks_deleted:
                                        if (c.has_data()):
                                            return True
                                    return (self.priority_summary is not None and self.priority_summary.has_data())

                                def has_operation(self):
                                    for c in self.convergence_timeline:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.leaf_networks_added:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.leaf_networks_deleted:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.priority_summary is not None and self.priority_summary.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "convergence-timeline"):
                                        for c in self.convergence_timeline:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.ConvergenceTimeline()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.convergence_timeline.append(c)
                                        return c

                                    if (child_yang_name == "leaf-networks-added"):
                                        for c in self.leaf_networks_added:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksAdded()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.leaf_networks_added.append(c)
                                        return c

                                    if (child_yang_name == "leaf-networks-deleted"):
                                        for c in self.leaf_networks_deleted:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.LeafNetworksDeleted()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.leaf_networks_deleted.append(c)
                                        return c

                                    if (child_yang_name == "priority-summary"):
                                        if (self.priority_summary is None):
                                            self.priority_summary = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority.PrioritySummary()
                                            self.priority_summary.parent = self
                                            self._children_name_map["priority_summary"] = "priority-summary"
                                        return self.priority_summary

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "convergence-timeline" or name == "leaf-networks-added" or name == "leaf-networks-deleted" or name == "priority-summary"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class LsaProcessed(Entity):
                                """
                                List of type 1/2 LSA changes processed
                                
                                .. attribute:: change_type
                                
                                	Add, Delete, Modify
                                	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                                
                                .. attribute:: lsa_id
                                
                                	LSA ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: lsa_type
                                
                                	LSA type
                                	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                                
                                .. attribute:: origin_router_id
                                
                                	Originating Router ID
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: reception_time
                                
                                	Reception Time on router (in hh\:mm\:ss.msec)
                                	**type**\:  str
                                
                                .. attribute:: sequence_number
                                
                                	Sequence Number
                                	**type**\:  str
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.LsaProcessed, self).__init__()

                                    self.yang_name = "lsa-processed"
                                    self.yang_parent_name = "dijkstra-run"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.lsa_id = YLeaf(YType.str, "lsa-id")

                                    self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                    self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                    self.reception_time = YLeaf(YType.str, "reception-time")

                                    self.sequence_number = YLeaf(YType.str, "sequence-number")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "lsa_id",
                                                    "lsa_type",
                                                    "origin_router_id",
                                                    "reception_time",
                                                    "sequence_number") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.LsaProcessed, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.LsaProcessed, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.lsa_id.is_set or
                                        self.lsa_type.is_set or
                                        self.origin_router_id.is_set or
                                        self.reception_time.is_set or
                                        self.sequence_number.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.lsa_id.yfilter != YFilter.not_set or
                                        self.lsa_type.yfilter != YFilter.not_set or
                                        self.origin_router_id.yfilter != YFilter.not_set or
                                        self.reception_time.yfilter != YFilter.not_set or
                                        self.sequence_number.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lsa-processed" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                    if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                    if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                    if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.reception_time.get_name_leafdata())
                                    if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsa-id"):
                                        self.lsa_id = value
                                        self.lsa_id.value_namespace = name_space
                                        self.lsa_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lsa-type"):
                                        self.lsa_type = value
                                        self.lsa_type.value_namespace = name_space
                                        self.lsa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "origin-router-id"):
                                        self.origin_router_id = value
                                        self.origin_router_id.value_namespace = name_space
                                        self.origin_router_id.value_namespace_prefix = name_space_prefix
                                    if(value_path == "reception-time"):
                                        self.reception_time = value
                                        self.reception_time.value_namespace = name_space
                                        self.reception_time.value_namespace_prefix = name_space_prefix
                                    if(value_path == "sequence-number"):
                                        self.sequence_number = value
                                        self.sequence_number.value_namespace = name_space
                                        self.sequence_number.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lsa_processed:
                                    if (c.has_data()):
                                        return True
                                for c in self.priority:
                                    if (c.has_data()):
                                        return True
                                for c in self.trigger_lsa:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.area_id.is_set or
                                    self.dijkstra_run_number.is_set or
                                    self.duration.is_set or
                                    self.start_time.is_set or
                                    self.threshold_exceeded.is_set or
                                    self.trigger_time.is_set or
                                    self.wait_time.is_set)

                            def has_operation(self):
                                for c in self.lsa_processed:
                                    if (c.has_operation()):
                                        return True
                                for c in self.priority:
                                    if (c.has_operation()):
                                        return True
                                for c in self.trigger_lsa:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.area_id.yfilter != YFilter.not_set or
                                    self.dijkstra_run_number.yfilter != YFilter.not_set or
                                    self.duration.yfilter != YFilter.not_set or
                                    self.start_time.yfilter != YFilter.not_set or
                                    self.threshold_exceeded.yfilter != YFilter.not_set or
                                    self.trigger_time.yfilter != YFilter.not_set or
                                    self.wait_time.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "dijkstra-run" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.area_id.get_name_leafdata())
                                if (self.dijkstra_run_number.is_set or self.dijkstra_run_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dijkstra_run_number.get_name_leafdata())
                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.start_time.get_name_leafdata())
                                if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                                if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.trigger_time.get_name_leafdata())
                                if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.wait_time.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lsa-processed"):
                                    for c in self.lsa_processed:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.LsaProcessed()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lsa_processed.append(c)
                                    return c

                                if (child_yang_name == "priority"):
                                    for c in self.priority:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.Priority()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.priority.append(c)
                                    return c

                                if (child_yang_name == "trigger-lsa"):
                                    for c in self.trigger_lsa:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun.TriggerLsa()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.trigger_lsa.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lsa-processed" or name == "priority" or name == "trigger-lsa" or name == "area-id" or name == "dijkstra-run-number" or name == "duration" or name == "start-time" or name == "threshold-exceeded" or name == "trigger-time" or name == "wait-time"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "area-id"):
                                    self.area_id = value
                                    self.area_id.value_namespace = name_space
                                    self.area_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "dijkstra-run-number"):
                                    self.dijkstra_run_number = value
                                    self.dijkstra_run_number.value_namespace = name_space
                                    self.dijkstra_run_number.value_namespace_prefix = name_space_prefix
                                if(value_path == "duration"):
                                    self.duration = value
                                    self.duration.value_namespace = name_space
                                    self.duration.value_namespace_prefix = name_space_prefix
                                if(value_path == "start-time"):
                                    self.start_time = value
                                    self.start_time.value_namespace = name_space
                                    self.start_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "threshold-exceeded"):
                                    self.threshold_exceeded = value
                                    self.threshold_exceeded.value_namespace = name_space
                                    self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                                if(value_path == "trigger-time"):
                                    self.trigger_time = value
                                    self.trigger_time.value_namespace = name_space
                                    self.trigger_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "wait-time"):
                                    self.wait_time = value
                                    self.wait_time.value_namespace = name_space
                                    self.wait_time.value_namespace_prefix = name_space_prefix


                        class InterAreaAndExternal(Entity):
                            """
                            Inter\-area & external calculation information
                            
                            .. attribute:: priority
                            
                            	Convergence information on a per\-priority basis
                            	**type**\: list of    :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority>`
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal, self).__init__()

                                self.yang_name = "inter-area-and-external"
                                self.yang_parent_name = "spf-run-offline"

                                self.priority = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal, self).__setattr__(name, value)


                            class Priority(Entity):
                                """
                                Convergence information on a per\-priority basis
                                
                                .. attribute:: convergence_timeline
                                
                                	Convergence timeline details
                                	**type**\: list of    :py:class:`ConvergenceTimeline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline>`
                                
                                .. attribute:: leaf_networks_added
                                
                                	List of Leaf Networks Added
                                	**type**\: list of    :py:class:`LeafNetworksAdded <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksAdded>`
                                
                                .. attribute:: leaf_networks_deleted
                                
                                	List of Leaf Networks Deleted
                                	**type**\: list of    :py:class:`LeafNetworksDeleted <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksDeleted>`
                                
                                .. attribute:: priority_summary
                                
                                	Summary of the priority
                                	**type**\:   :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority, self).__init__()

                                    self.yang_name = "priority"
                                    self.yang_parent_name = "inter-area-and-external"

                                    self.priority_summary = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary()
                                    self.priority_summary.parent = self
                                    self._children_name_map["priority_summary"] = "priority-summary"
                                    self._children_yang_names.add("priority-summary")

                                    self.convergence_timeline = YList(self)
                                    self.leaf_networks_added = YList(self)
                                    self.leaf_networks_deleted = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority, self).__setattr__(name, value)


                                class PrioritySummary(Entity):
                                    """
                                    Summary of the priority
                                    
                                    .. attribute:: ip_convergence_time
                                    
                                    	Convergence time for IP route programming
                                    	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime>`
                                    
                                    .. attribute:: level
                                    
                                    	Critical, High, Medium or Low
                                    	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                    
                                    .. attribute:: mpls_convergence_time
                                    
                                    	Convergence time for MPLS label programming
                                    	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime>`
                                    
                                    .. attribute:: route_statistics
                                    
                                    	Route statistics
                                    	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics>`
                                    
                                    .. attribute:: threshold_exceeded
                                    
                                    	Threshold exceeded
                                    	**type**\:  bool
                                    
                                    .. attribute:: type3ls_as
                                    
                                    	Number of Type 3 LSA
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: type4ls_as
                                    
                                    	Number of Type 4 LSA
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: type57ls_as
                                    
                                    	Number of Type 5/7 LSA
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary, self).__init__()

                                        self.yang_name = "priority-summary"
                                        self.yang_parent_name = "priority"

                                        self.level = YLeaf(YType.enumeration, "level")

                                        self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                        self.type3ls_as = YLeaf(YType.uint32, "type3ls-as")

                                        self.type4ls_as = YLeaf(YType.uint32, "type4ls-as")

                                        self.type57ls_as = YLeaf(YType.uint32, "type57ls-as")

                                        self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime()
                                        self.ip_convergence_time.parent = self
                                        self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        self._children_yang_names.add("ip-convergence-time")

                                        self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime()
                                        self.mpls_convergence_time.parent = self
                                        self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        self._children_yang_names.add("mpls-convergence-time")

                                        self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics()
                                        self.route_statistics.parent = self
                                        self._children_name_map["route_statistics"] = "route-statistics"
                                        self._children_yang_names.add("route-statistics")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("level",
                                                        "threshold_exceeded",
                                                        "type3ls_as",
                                                        "type4ls_as",
                                                        "type57ls_as") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary, self).__setattr__(name, value)


                                    class RouteStatistics(Entity):
                                        """
                                        Route statistics
                                        
                                        .. attribute:: adds
                                        
                                        	Added
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: deletes
                                        
                                        	Deleted
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: modifies
                                        
                                        	Modified
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: reachables
                                        
                                        	Reachable
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: touches
                                        
                                        	Touched
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        .. attribute:: unreachables
                                        
                                        	Unreachable
                                        	**type**\:  int
                                        
                                        	**range:** 0..4294967295
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics, self).__init__()

                                            self.yang_name = "route-statistics"
                                            self.yang_parent_name = "priority-summary"

                                            self.adds = YLeaf(YType.uint32, "adds")

                                            self.deletes = YLeaf(YType.uint32, "deletes")

                                            self.modifies = YLeaf(YType.uint32, "modifies")

                                            self.reachables = YLeaf(YType.uint32, "reachables")

                                            self.touches = YLeaf(YType.uint32, "touches")

                                            self.unreachables = YLeaf(YType.uint32, "unreachables")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("adds",
                                                            "deletes",
                                                            "modifies",
                                                            "reachables",
                                                            "touches",
                                                            "unreachables") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.adds.is_set or
                                                self.deletes.is_set or
                                                self.modifies.is_set or
                                                self.reachables.is_set or
                                                self.touches.is_set or
                                                self.unreachables.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.adds.yfilter != YFilter.not_set or
                                                self.deletes.yfilter != YFilter.not_set or
                                                self.modifies.yfilter != YFilter.not_set or
                                                self.reachables.yfilter != YFilter.not_set or
                                                self.touches.yfilter != YFilter.not_set or
                                                self.unreachables.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-statistics" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.adds.get_name_leafdata())
                                            if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.deletes.get_name_leafdata())
                                            if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.modifies.get_name_leafdata())
                                            if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.reachables.get_name_leafdata())
                                            if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.touches.get_name_leafdata())
                                            if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.unreachables.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "adds"):
                                                self.adds = value
                                                self.adds.value_namespace = name_space
                                                self.adds.value_namespace_prefix = name_space_prefix
                                            if(value_path == "deletes"):
                                                self.deletes = value
                                                self.deletes.value_namespace = name_space
                                                self.deletes.value_namespace_prefix = name_space_prefix
                                            if(value_path == "modifies"):
                                                self.modifies = value
                                                self.modifies.value_namespace = name_space
                                                self.modifies.value_namespace_prefix = name_space_prefix
                                            if(value_path == "reachables"):
                                                self.reachables = value
                                                self.reachables.value_namespace = name_space
                                                self.reachables.value_namespace_prefix = name_space_prefix
                                            if(value_path == "touches"):
                                                self.touches = value
                                                self.touches.value_namespace = name_space
                                                self.touches.value_namespace_prefix = name_space_prefix
                                            if(value_path == "unreachables"):
                                                self.unreachables = value
                                                self.unreachables.value_namespace = name_space
                                                self.unreachables.value_namespace_prefix = name_space_prefix


                                    class IpConvergenceTime(Entity):
                                        """
                                        Convergence time for IP route programming
                                        
                                        .. attribute:: fastest_node_name
                                        
                                        	Linecard node name which took the minimum time
                                        	**type**\:  str
                                        
                                        .. attribute:: maximum_time
                                        
                                        	Maximum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: minimum_time
                                        
                                        	Minimum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: slowest_node_name
                                        
                                        	Linecard node name which took the maximum time
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime, self).__init__()

                                            self.yang_name = "ip-convergence-time"
                                            self.yang_parent_name = "priority-summary"

                                            self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                            self.maximum_time = YLeaf(YType.str, "maximum-time")

                                            self.minimum_time = YLeaf(YType.str, "minimum-time")

                                            self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fastest_node_name",
                                                            "maximum_time",
                                                            "minimum_time",
                                                            "slowest_node_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.fastest_node_name.is_set or
                                                self.maximum_time.is_set or
                                                self.minimum_time.is_set or
                                                self.slowest_node_name.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fastest_node_name.yfilter != YFilter.not_set or
                                                self.maximum_time.yfilter != YFilter.not_set or
                                                self.minimum_time.yfilter != YFilter.not_set or
                                                self.slowest_node_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ip-convergence-time" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                            if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                            if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                            if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fastest-node-name"):
                                                self.fastest_node_name = value
                                                self.fastest_node_name.value_namespace = name_space
                                                self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "maximum-time"):
                                                self.maximum_time = value
                                                self.maximum_time.value_namespace = name_space
                                                self.maximum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "minimum-time"):
                                                self.minimum_time = value
                                                self.minimum_time.value_namespace = name_space
                                                self.minimum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "slowest-node-name"):
                                                self.slowest_node_name = value
                                                self.slowest_node_name.value_namespace = name_space
                                                self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                    class MplsConvergenceTime(Entity):
                                        """
                                        Convergence time for MPLS label programming
                                        
                                        .. attribute:: fastest_node_name
                                        
                                        	Linecard node name which took the minimum time
                                        	**type**\:  str
                                        
                                        .. attribute:: maximum_time
                                        
                                        	Maximum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: minimum_time
                                        
                                        	Minimum time(in seconds.milliseconds)
                                        	**type**\:  str
                                        
                                        	**units**\: millisecond
                                        
                                        .. attribute:: slowest_node_name
                                        
                                        	Linecard node name which took the maximum time
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime, self).__init__()

                                            self.yang_name = "mpls-convergence-time"
                                            self.yang_parent_name = "priority-summary"

                                            self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                            self.maximum_time = YLeaf(YType.str, "maximum-time")

                                            self.minimum_time = YLeaf(YType.str, "minimum-time")

                                            self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("fastest_node_name",
                                                            "maximum_time",
                                                            "minimum_time",
                                                            "slowest_node_name") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.fastest_node_name.is_set or
                                                self.maximum_time.is_set or
                                                self.minimum_time.is_set or
                                                self.slowest_node_name.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.fastest_node_name.yfilter != YFilter.not_set or
                                                self.maximum_time.yfilter != YFilter.not_set or
                                                self.minimum_time.yfilter != YFilter.not_set or
                                                self.slowest_node_name.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "mpls-convergence-time" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                            if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                            if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                            if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "fastest-node-name"):
                                                self.fastest_node_name = value
                                                self.fastest_node_name.value_namespace = name_space
                                                self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "maximum-time"):
                                                self.maximum_time = value
                                                self.maximum_time.value_namespace = name_space
                                                self.maximum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "minimum-time"):
                                                self.minimum_time = value
                                                self.minimum_time.value_namespace = name_space
                                                self.minimum_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "slowest-node-name"):
                                                self.slowest_node_name = value
                                                self.slowest_node_name.value_namespace = name_space
                                                self.slowest_node_name.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.level.is_set or
                                            self.threshold_exceeded.is_set or
                                            self.type3ls_as.is_set or
                                            self.type4ls_as.is_set or
                                            self.type57ls_as.is_set or
                                            (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                            (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                            (self.route_statistics is not None and self.route_statistics.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.level.yfilter != YFilter.not_set or
                                            self.threshold_exceeded.yfilter != YFilter.not_set or
                                            self.type3ls_as.yfilter != YFilter.not_set or
                                            self.type4ls_as.yfilter != YFilter.not_set or
                                            self.type57ls_as.yfilter != YFilter.not_set or
                                            (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                            (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                            (self.route_statistics is not None and self.route_statistics.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "priority-summary" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.level.get_name_leafdata())
                                        if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                                        if (self.type3ls_as.is_set or self.type3ls_as.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type3ls_as.get_name_leafdata())
                                        if (self.type4ls_as.is_set or self.type4ls_as.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type4ls_as.get_name_leafdata())
                                        if (self.type57ls_as.is_set or self.type57ls_as.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.type57ls_as.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "ip-convergence-time"):
                                            if (self.ip_convergence_time is None):
                                                self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.IpConvergenceTime()
                                                self.ip_convergence_time.parent = self
                                                self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                            return self.ip_convergence_time

                                        if (child_yang_name == "mpls-convergence-time"):
                                            if (self.mpls_convergence_time is None):
                                                self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.MplsConvergenceTime()
                                                self.mpls_convergence_time.parent = self
                                                self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                            return self.mpls_convergence_time

                                        if (child_yang_name == "route-statistics"):
                                            if (self.route_statistics is None):
                                                self.route_statistics = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary.RouteStatistics()
                                                self.route_statistics.parent = self
                                                self._children_name_map["route_statistics"] = "route-statistics"
                                            return self.route_statistics

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded" or name == "type3ls-as" or name == "type4ls-as" or name == "type57ls-as"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "level"):
                                            self.level = value
                                            self.level.value_namespace = name_space
                                            self.level.value_namespace_prefix = name_space_prefix
                                        if(value_path == "threshold-exceeded"):
                                            self.threshold_exceeded = value
                                            self.threshold_exceeded.value_namespace = name_space
                                            self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type3ls-as"):
                                            self.type3ls_as = value
                                            self.type3ls_as.value_namespace = name_space
                                            self.type3ls_as.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type4ls-as"):
                                            self.type4ls_as = value
                                            self.type4ls_as.value_namespace = name_space
                                            self.type4ls_as.value_namespace_prefix = name_space_prefix
                                        if(value_path == "type57ls-as"):
                                            self.type57ls_as = value
                                            self.type57ls_as.value_namespace = name_space
                                            self.type57ls_as.value_namespace_prefix = name_space_prefix


                                class ConvergenceTimeline(Entity):
                                    """
                                    Convergence timeline details
                                    
                                    .. attribute:: lc_ip
                                    
                                    	List of Linecards' completion point for IP routes
                                    	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp>`
                                    
                                    .. attribute:: lc_mpls
                                    
                                    	List of Linecards' completion point for MPLS labels
                                    	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls>`
                                    
                                    .. attribute:: ldp_enter
                                    
                                    	Entry point of LDP
                                    	**type**\:   :py:class:`LdpEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter>`
                                    
                                    .. attribute:: ldp_exit
                                    
                                    	Exit point of LDP to LSD
                                    	**type**\:   :py:class:`LdpExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit>`
                                    
                                    .. attribute:: lsd_enter
                                    
                                    	Entry point of LSD
                                    	**type**\:   :py:class:`LsdEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter>`
                                    
                                    .. attribute:: lsd_exit
                                    
                                    	Exit point of LSD to FIBs
                                    	**type**\:   :py:class:`LsdExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit>`
                                    
                                    .. attribute:: ri_bv4_enter
                                    
                                    	Entry point of IPv4 RIB
                                    	**type**\:   :py:class:`RiBv4Enter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter>`
                                    
                                    .. attribute:: ri_bv4_exit
                                    
                                    	Exit point from IPv4 RIB to FIBs
                                    	**type**\:   :py:class:`RiBv4Exit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit>`
                                    
                                    .. attribute:: ri_bv4_redistribute
                                    
                                    	Route Redistribute point from IPv4 RIB to LDP
                                    	**type**\:   :py:class:`RiBv4Redistribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute>`
                                    
                                    .. attribute:: route_origin
                                    
                                    	Route origin (routing protocol)
                                    	**type**\:   :py:class:`RouteOrigin <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin>`
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline, self).__init__()

                                        self.yang_name = "convergence-timeline"
                                        self.yang_parent_name = "priority"

                                        self.ldp_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter()
                                        self.ldp_enter.parent = self
                                        self._children_name_map["ldp_enter"] = "ldp-enter"
                                        self._children_yang_names.add("ldp-enter")

                                        self.ldp_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit()
                                        self.ldp_exit.parent = self
                                        self._children_name_map["ldp_exit"] = "ldp-exit"
                                        self._children_yang_names.add("ldp-exit")

                                        self.lsd_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter()
                                        self.lsd_enter.parent = self
                                        self._children_name_map["lsd_enter"] = "lsd-enter"
                                        self._children_yang_names.add("lsd-enter")

                                        self.lsd_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit()
                                        self.lsd_exit.parent = self
                                        self._children_name_map["lsd_exit"] = "lsd-exit"
                                        self._children_yang_names.add("lsd-exit")

                                        self.ri_bv4_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter()
                                        self.ri_bv4_enter.parent = self
                                        self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                        self._children_yang_names.add("ri-bv4-enter")

                                        self.ri_bv4_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit()
                                        self.ri_bv4_exit.parent = self
                                        self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                        self._children_yang_names.add("ri-bv4-exit")

                                        self.ri_bv4_redistribute = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                        self.ri_bv4_redistribute.parent = self
                                        self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                        self._children_yang_names.add("ri-bv4-redistribute")

                                        self.route_origin = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin()
                                        self.route_origin.parent = self
                                        self._children_name_map["route_origin"] = "route-origin"
                                        self._children_yang_names.add("route-origin")

                                        self.lc_ip = YList(self)
                                        self.lc_mpls = YList(self)

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in () and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline, self).__setattr__(name, value)


                                    class RouteOrigin(Entity):
                                        """
                                        Route origin (routing protocol)
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin, self).__init__()

                                            self.yang_name = "route-origin"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "route-origin" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Enter(Entity):
                                        """
                                        Entry point of IPv4 RIB
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter, self).__init__()

                                            self.yang_name = "ri-bv4-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Exit(Entity):
                                        """
                                        Exit point from IPv4 RIB to FIBs
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit, self).__init__()

                                            self.yang_name = "ri-bv4-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class RiBv4Redistribute(Entity):
                                        """
                                        Route Redistribute point from IPv4 RIB to LDP
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__init__()

                                            self.yang_name = "ri-bv4-redistribute"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ri-bv4-redistribute" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LdpEnter(Entity):
                                        """
                                        Entry point of LDP
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter, self).__init__()

                                            self.yang_name = "ldp-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ldp-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LdpExit(Entity):
                                        """
                                        Exit point of LDP to LSD
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit, self).__init__()

                                            self.yang_name = "ldp-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "ldp-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LsdEnter(Entity):
                                        """
                                        Entry point of LSD
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter, self).__init__()

                                            self.yang_name = "lsd-enter"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lsd-enter" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LsdExit(Entity):
                                        """
                                        Exit point of LSD to FIBs
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit, self).__init__()

                                            self.yang_name = "lsd-exit"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lsd-exit" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix


                                    class LcIp(Entity):
                                        """
                                        List of Linecards' completion point for IP
                                        routes
                                        
                                        .. attribute:: fib_complete
                                        
                                        	Completion point of FIB
                                        	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete>`
                                        
                                        .. attribute:: node_name
                                        
                                        	Linecard node name
                                        	**type**\:  str
                                        
                                        .. attribute:: speed
                                        
                                        	Relative convergence speed
                                        	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp, self).__init__()

                                            self.yang_name = "lc-ip"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.node_name = YLeaf(YType.str, "node-name")

                                            self.speed = YLeaf(YType.enumeration, "speed")

                                            self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                            self.fib_complete.parent = self
                                            self._children_name_map["fib_complete"] = "fib-complete"
                                            self._children_yang_names.add("fib-complete")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("node_name",
                                                            "speed") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)


                                        class FibComplete(Entity):
                                            """
                                            Completion point of FIB
                                            
                                            .. attribute:: duration
                                            
                                            	Duration of processing (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: end_time
                                            
                                            	Last route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: start_time
                                            
                                            	First route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'infra-rcmd-oper'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__init__()

                                                self.yang_name = "fib-complete"
                                                self.yang_parent_name = "lc-ip"

                                                self.duration = YLeaf(YType.str, "duration")

                                                self.end_time = YLeaf(YType.str, "end-time")

                                                self.start_time = YLeaf(YType.str, "start-time")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("duration",
                                                                "end_time",
                                                                "start_time") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.duration.is_set or
                                                    self.end_time.is_set or
                                                    self.start_time.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.duration.yfilter != YFilter.not_set or
                                                    self.end_time.yfilter != YFilter.not_set or
                                                    self.start_time.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-complete" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                                if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.end_time.get_name_leafdata())
                                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.start_time.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "duration" or name == "end-time" or name == "start-time"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "duration"):
                                                    self.duration = value
                                                    self.duration.value_namespace = name_space
                                                    self.duration.value_namespace_prefix = name_space_prefix
                                                if(value_path == "end-time"):
                                                    self.end_time = value
                                                    self.end_time.value_namespace = name_space
                                                    self.end_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "start-time"):
                                                    self.start_time = value
                                                    self.start_time.value_namespace = name_space
                                                    self.start_time.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.node_name.is_set or
                                                self.speed.is_set or
                                                (self.fib_complete is not None and self.fib_complete.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.node_name.yfilter != YFilter.not_set or
                                                self.speed.yfilter != YFilter.not_set or
                                                (self.fib_complete is not None and self.fib_complete.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lc-ip" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_name.get_name_leafdata())
                                            if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.speed.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-complete"):
                                                if (self.fib_complete is None):
                                                    self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                                    self.fib_complete.parent = self
                                                    self._children_name_map["fib_complete"] = "fib-complete"
                                                return self.fib_complete

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "node-name"):
                                                self.node_name = value
                                                self.node_name.value_namespace = name_space
                                                self.node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "speed"):
                                                self.speed = value
                                                self.speed.value_namespace = name_space
                                                self.speed.value_namespace_prefix = name_space_prefix


                                    class LcMpls(Entity):
                                        """
                                        List of Linecards' completion point for MPLS
                                        labels
                                        
                                        .. attribute:: fib_complete
                                        
                                        	Completion point of FIB
                                        	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete>`
                                        
                                        .. attribute:: node_name
                                        
                                        	Linecard node name
                                        	**type**\:  str
                                        
                                        .. attribute:: speed
                                        
                                        	Relative convergence speed
                                        	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls, self).__init__()

                                            self.yang_name = "lc-mpls"
                                            self.yang_parent_name = "convergence-timeline"

                                            self.node_name = YLeaf(YType.str, "node-name")

                                            self.speed = YLeaf(YType.enumeration, "speed")

                                            self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                            self.fib_complete.parent = self
                                            self._children_name_map["fib_complete"] = "fib-complete"
                                            self._children_yang_names.add("fib-complete")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("node_name",
                                                            "speed") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)


                                        class FibComplete(Entity):
                                            """
                                            Completion point of FIB
                                            
                                            .. attribute:: duration
                                            
                                            	Duration of processing (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: end_time
                                            
                                            	Last route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            .. attribute:: start_time
                                            
                                            	First route process time relative to event trigger time (in ss.msec)
                                            	**type**\:  str
                                            
                                            

                                            """

                                            _prefix = 'infra-rcmd-oper'
                                            _revision = '2015-11-09'

                                            def __init__(self):
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__init__()

                                                self.yang_name = "fib-complete"
                                                self.yang_parent_name = "lc-mpls"

                                                self.duration = YLeaf(YType.str, "duration")

                                                self.end_time = YLeaf(YType.str, "end-time")

                                                self.start_time = YLeaf(YType.str, "start-time")

                                            def __setattr__(self, name, value):
                                                self._check_monkey_patching_error(name, value)
                                                with _handle_type_error():
                                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                            "Please use list append or extend method."
                                                                            .format(value))
                                                    if isinstance(value, Enum.YLeaf):
                                                        value = value.name
                                                    if name in ("duration",
                                                                "end_time",
                                                                "start_time") and name in self.__dict__:
                                                        if isinstance(value, YLeaf):
                                                            self.__dict__[name].set(value.get())
                                                        elif isinstance(value, YLeafList):
                                                            super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)
                                                        else:
                                                            self.__dict__[name].set(value)
                                                    else:
                                                        if hasattr(value, "parent") and name != "parent":
                                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                                value.parent = self
                                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                                value.parent = self
                                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)

                                            def has_data(self):
                                                return (
                                                    self.duration.is_set or
                                                    self.end_time.is_set or
                                                    self.start_time.is_set)

                                            def has_operation(self):
                                                return (
                                                    self.yfilter != YFilter.not_set or
                                                    self.duration.yfilter != YFilter.not_set or
                                                    self.end_time.yfilter != YFilter.not_set or
                                                    self.start_time.yfilter != YFilter.not_set)

                                            def get_segment_path(self):
                                                path_buffer = ""
                                                path_buffer = "fib-complete" + path_buffer

                                                return path_buffer

                                            def get_entity_path(self, ancestor):
                                                path_buffer = ""
                                                if (ancestor is None):
                                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                                else:
                                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                                leaf_name_data = LeafDataList()
                                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                                if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.end_time.get_name_leafdata())
                                                if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                    leaf_name_data.append(self.start_time.get_name_leafdata())

                                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                                return entity_path

                                            def get_child_by_name(self, child_yang_name, segment_path):
                                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                                if child is not None:
                                                    return child

                                                return None

                                            def has_leaf_or_child_of_name(self, name):
                                                if(name == "duration" or name == "end-time" or name == "start-time"):
                                                    return True
                                                return False

                                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                                if(value_path == "duration"):
                                                    self.duration = value
                                                    self.duration.value_namespace = name_space
                                                    self.duration.value_namespace_prefix = name_space_prefix
                                                if(value_path == "end-time"):
                                                    self.end_time = value
                                                    self.end_time.value_namespace = name_space
                                                    self.end_time.value_namespace_prefix = name_space_prefix
                                                if(value_path == "start-time"):
                                                    self.start_time = value
                                                    self.start_time.value_namespace = name_space
                                                    self.start_time.value_namespace_prefix = name_space_prefix

                                        def has_data(self):
                                            return (
                                                self.node_name.is_set or
                                                self.speed.is_set or
                                                (self.fib_complete is not None and self.fib_complete.has_data()))

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.node_name.yfilter != YFilter.not_set or
                                                self.speed.yfilter != YFilter.not_set or
                                                (self.fib_complete is not None and self.fib_complete.has_operation()))

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "lc-mpls" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.node_name.get_name_leafdata())
                                            if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.speed.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            if (child_yang_name == "fib-complete"):
                                                if (self.fib_complete is None):
                                                    self.fib_complete = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                                    self.fib_complete.parent = self
                                                    self._children_name_map["fib_complete"] = "fib-complete"
                                                return self.fib_complete

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "node-name"):
                                                self.node_name = value
                                                self.node_name.value_namespace = name_space
                                                self.node_name.value_namespace_prefix = name_space_prefix
                                            if(value_path == "speed"):
                                                self.speed = value
                                                self.speed.value_namespace = name_space
                                                self.speed.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        for c in self.lc_ip:
                                            if (c.has_data()):
                                                return True
                                        for c in self.lc_mpls:
                                            if (c.has_data()):
                                                return True
                                        return (
                                            (self.ldp_enter is not None and self.ldp_enter.has_data()) or
                                            (self.ldp_exit is not None and self.ldp_exit.has_data()) or
                                            (self.lsd_enter is not None and self.lsd_enter.has_data()) or
                                            (self.lsd_exit is not None and self.lsd_exit.has_data()) or
                                            (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_data()) or
                                            (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_data()) or
                                            (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_data()) or
                                            (self.route_origin is not None and self.route_origin.has_data()))

                                    def has_operation(self):
                                        for c in self.lc_ip:
                                            if (c.has_operation()):
                                                return True
                                        for c in self.lc_mpls:
                                            if (c.has_operation()):
                                                return True
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            (self.ldp_enter is not None and self.ldp_enter.has_operation()) or
                                            (self.ldp_exit is not None and self.ldp_exit.has_operation()) or
                                            (self.lsd_enter is not None and self.lsd_enter.has_operation()) or
                                            (self.lsd_exit is not None and self.lsd_exit.has_operation()) or
                                            (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_operation()) or
                                            (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_operation()) or
                                            (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_operation()) or
                                            (self.route_origin is not None and self.route_origin.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "convergence-timeline" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "lc-ip"):
                                            for c in self.lc_ip:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcIp()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.lc_ip.append(c)
                                            return c

                                        if (child_yang_name == "lc-mpls"):
                                            for c in self.lc_mpls:
                                                segment = c.get_segment_path()
                                                if (segment_path == segment):
                                                    return c
                                            c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LcMpls()
                                            c.parent = self
                                            local_reference_key = "ydk::seg::%s" % segment_path
                                            self._local_refs[local_reference_key] = c
                                            self.lc_mpls.append(c)
                                            return c

                                        if (child_yang_name == "ldp-enter"):
                                            if (self.ldp_enter is None):
                                                self.ldp_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpEnter()
                                                self.ldp_enter.parent = self
                                                self._children_name_map["ldp_enter"] = "ldp-enter"
                                            return self.ldp_enter

                                        if (child_yang_name == "ldp-exit"):
                                            if (self.ldp_exit is None):
                                                self.ldp_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LdpExit()
                                                self.ldp_exit.parent = self
                                                self._children_name_map["ldp_exit"] = "ldp-exit"
                                            return self.ldp_exit

                                        if (child_yang_name == "lsd-enter"):
                                            if (self.lsd_enter is None):
                                                self.lsd_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdEnter()
                                                self.lsd_enter.parent = self
                                                self._children_name_map["lsd_enter"] = "lsd-enter"
                                            return self.lsd_enter

                                        if (child_yang_name == "lsd-exit"):
                                            if (self.lsd_exit is None):
                                                self.lsd_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.LsdExit()
                                                self.lsd_exit.parent = self
                                                self._children_name_map["lsd_exit"] = "lsd-exit"
                                            return self.lsd_exit

                                        if (child_yang_name == "ri-bv4-enter"):
                                            if (self.ri_bv4_enter is None):
                                                self.ri_bv4_enter = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Enter()
                                                self.ri_bv4_enter.parent = self
                                                self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                            return self.ri_bv4_enter

                                        if (child_yang_name == "ri-bv4-exit"):
                                            if (self.ri_bv4_exit is None):
                                                self.ri_bv4_exit = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Exit()
                                                self.ri_bv4_exit.parent = self
                                                self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                            return self.ri_bv4_exit

                                        if (child_yang_name == "ri-bv4-redistribute"):
                                            if (self.ri_bv4_redistribute is None):
                                                self.ri_bv4_redistribute = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                                self.ri_bv4_redistribute.parent = self
                                                self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                            return self.ri_bv4_redistribute

                                        if (child_yang_name == "route-origin"):
                                            if (self.route_origin is None):
                                                self.route_origin = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline.RouteOrigin()
                                                self.route_origin.parent = self
                                                self._children_name_map["route_origin"] = "route-origin"
                                            return self.route_origin

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        pass


                                class LeafNetworksAdded(Entity):
                                    """
                                    List of Leaf Networks Added
                                    
                                    .. attribute:: address
                                    
                                    	IP address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: net_mask
                                    
                                    	Mask
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksAdded, self).__init__()

                                        self.yang_name = "leaf-networks-added"
                                        self.yang_parent_name = "priority"

                                        self.address = YLeaf(YType.str, "address")

                                        self.net_mask = YLeaf(YType.uint8, "net-mask")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("address",
                                                        "net_mask") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksAdded, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksAdded, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.address.is_set or
                                            self.net_mask.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.net_mask.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "leaf-networks-added" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.net_mask.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "address" or name == "net-mask"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "net-mask"):
                                            self.net_mask = value
                                            self.net_mask.value_namespace = name_space
                                            self.net_mask.value_namespace_prefix = name_space_prefix


                                class LeafNetworksDeleted(Entity):
                                    """
                                    List of Leaf Networks Deleted
                                    
                                    .. attribute:: address
                                    
                                    	IP address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: net_mask
                                    
                                    	Mask
                                    	**type**\:  int
                                    
                                    	**range:** 0..255
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksDeleted, self).__init__()

                                        self.yang_name = "leaf-networks-deleted"
                                        self.yang_parent_name = "priority"

                                        self.address = YLeaf(YType.str, "address")

                                        self.net_mask = YLeaf(YType.uint8, "net-mask")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("address",
                                                        "net_mask") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksDeleted, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksDeleted, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.address.is_set or
                                            self.net_mask.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.address.yfilter != YFilter.not_set or
                                            self.net_mask.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "leaf-networks-deleted" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.address.get_name_leafdata())
                                        if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.net_mask.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "address" or name == "net-mask"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "address"):
                                            self.address = value
                                            self.address.value_namespace = name_space
                                            self.address.value_namespace_prefix = name_space_prefix
                                        if(value_path == "net-mask"):
                                            self.net_mask = value
                                            self.net_mask.value_namespace = name_space
                                            self.net_mask.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.convergence_timeline:
                                        if (c.has_data()):
                                            return True
                                    for c in self.leaf_networks_added:
                                        if (c.has_data()):
                                            return True
                                    for c in self.leaf_networks_deleted:
                                        if (c.has_data()):
                                            return True
                                    return (self.priority_summary is not None and self.priority_summary.has_data())

                                def has_operation(self):
                                    for c in self.convergence_timeline:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.leaf_networks_added:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.leaf_networks_deleted:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.priority_summary is not None and self.priority_summary.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "convergence-timeline"):
                                        for c in self.convergence_timeline:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.ConvergenceTimeline()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.convergence_timeline.append(c)
                                        return c

                                    if (child_yang_name == "leaf-networks-added"):
                                        for c in self.leaf_networks_added:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksAdded()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.leaf_networks_added.append(c)
                                        return c

                                    if (child_yang_name == "leaf-networks-deleted"):
                                        for c in self.leaf_networks_deleted:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.LeafNetworksDeleted()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.leaf_networks_deleted.append(c)
                                        return c

                                    if (child_yang_name == "priority-summary"):
                                        if (self.priority_summary is None):
                                            self.priority_summary = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority.PrioritySummary()
                                            self.priority_summary.parent = self
                                            self._children_name_map["priority_summary"] = "priority-summary"
                                        return self.priority_summary

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "convergence-timeline" or name == "leaf-networks-added" or name == "leaf-networks-deleted" or name == "priority-summary"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                for c in self.priority:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.priority:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "inter-area-and-external" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "priority"):
                                    for c in self.priority:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal.Priority()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.priority.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "priority"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            for c in self.dijkstra_run:
                                if (c.has_data()):
                                    return True
                            for c in self.inter_area_and_external:
                                if (c.has_data()):
                                    return True
                            return (
                                self.spf_run_number.is_set or
                                (self.spf_summary is not None and self.spf_summary.has_data()))

                        def has_operation(self):
                            for c in self.dijkstra_run:
                                if (c.has_operation()):
                                    return True
                            for c in self.inter_area_and_external:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.spf_run_number.yfilter != YFilter.not_set or
                                (self.spf_summary is not None and self.spf_summary.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "spf-run-offline" + "[spf-run-number='" + self.spf_run_number.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.spf_run_number.is_set or self.spf_run_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_number.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "dijkstra-run"):
                                for c in self.dijkstra_run:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.DijkstraRun()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.dijkstra_run.append(c)
                                return c

                            if (child_yang_name == "inter-area-and-external"):
                                for c in self.inter_area_and_external:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.InterAreaAndExternal()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.inter_area_and_external.append(c)
                                return c

                            if (child_yang_name == "spf-summary"):
                                if (self.spf_summary is None):
                                    self.spf_summary = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary()
                                    self.spf_summary.parent = self
                                    self._children_name_map["spf_summary"] = "spf-summary"
                                return self.spf_summary

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "dijkstra-run" or name == "inter-area-and-external" or name == "spf-summary" or name == "spf-run-number"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "spf-run-number"):
                                self.spf_run_number = value
                                self.spf_run_number.value_namespace = name_space
                                self.spf_run_number.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.spf_run_offline:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.spf_run_offline:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "spf-run-offlines" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "spf-run-offline"):
                            for c in self.spf_run_offline:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Ospf.Instances.Instance.SpfRunOfflines.SpfRunOffline()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.spf_run_offline.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "spf-run-offline"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SummaryExternalEventSummaries(Entity):
                    """
                    OSPF Summary\-External Prefix events summary
                    data
                    
                    .. attribute:: summary_external_event_summary
                    
                    	OSPF Summary\-External Prefix Event data
                    	**type**\: list of    :py:class:`SummaryExternalEventSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries, self).__init__()

                        self.yang_name = "summary-external-event-summaries"
                        self.yang_parent_name = "instance"

                        self.summary_external_event_summary = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries, self).__setattr__(name, value)


                    class SummaryExternalEventSummary(Entity):
                        """
                        OSPF Summary\-External Prefix Event data
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific Event ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: change_type
                        
                        	Event Add/Delete
                        	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                        
                        .. attribute:: cost
                        
                        	Protocol route cost
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ip_convergence_time
                        
                        	Convergence time for IP route programming
                        	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.IpConvergenceTime>`
                        
                        .. attribute:: ipfrr_event_id
                        
                        	Referenced IP\-FRR Event ID (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lsa_processed
                        
                        	List of LSAs processed
                        	**type**\: list of    :py:class:`LsaProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.LsaProcessed>`
                        
                        .. attribute:: mpls_convergence_time
                        
                        	Convergence time for MPLS label programming
                        	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.MplsConvergenceTime>`
                        
                        .. attribute:: path
                        
                        	Path information
                        	**type**\: list of    :py:class:`Path <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path>`
                        
                        .. attribute:: prefix
                        
                        	Prefix
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_lenth
                        
                        	Prefix length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: priority
                        
                        	Event processed priority
                        	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                        
                        .. attribute:: route_path_change_type
                        
                        	Route Path Change Type
                        	**type**\:   :py:class:`RcmdShowRoutePathChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoutePathChange>`
                        
                        .. attribute:: route_type
                        
                        	Route Type intra/inter/l1/l2
                        	**type**\:   :py:class:`RcmdShowRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoute>`
                        
                        .. attribute:: spf_run_no
                        
                        	Referenced SPF Run No (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: threshold_exceeded
                        
                        	Threshold exceeded
                        	**type**\:  bool
                        
                        .. attribute:: time_line
                        
                        	Timeline information
                        	**type**\: list of    :py:class:`TimeLine <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine>`
                        
                        .. attribute:: trigger_lsa
                        
                        	LSA that triggered this event
                        	**type**\: list of    :py:class:`TriggerLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TriggerLsa>`
                        
                        .. attribute:: trigger_time
                        
                        	Event trigger time
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary, self).__init__()

                            self.yang_name = "summary-external-event-summary"
                            self.yang_parent_name = "summary-external-event-summaries"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.change_type = YLeaf(YType.enumeration, "change-type")

                            self.cost = YLeaf(YType.uint32, "cost")

                            self.ipfrr_event_id = YLeaf(YType.uint32, "ipfrr-event-id")

                            self.prefix = YLeaf(YType.str, "prefix")

                            self.prefix_lenth = YLeaf(YType.uint32, "prefix-lenth")

                            self.priority = YLeaf(YType.enumeration, "priority")

                            self.route_path_change_type = YLeaf(YType.enumeration, "route-path-change-type")

                            self.route_type = YLeaf(YType.enumeration, "route-type")

                            self.spf_run_no = YLeaf(YType.uint32, "spf-run-no")

                            self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.IpConvergenceTime()
                            self.ip_convergence_time.parent = self
                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                            self._children_yang_names.add("ip-convergence-time")

                            self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.MplsConvergenceTime()
                            self.mpls_convergence_time.parent = self
                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                            self._children_yang_names.add("mpls-convergence-time")

                            self.lsa_processed = YList(self)
                            self.path = YList(self)
                            self.time_line = YList(self)
                            self.trigger_lsa = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "change_type",
                                            "cost",
                                            "ipfrr_event_id",
                                            "prefix",
                                            "prefix_lenth",
                                            "priority",
                                            "route_path_change_type",
                                            "route_type",
                                            "spf_run_no",
                                            "threshold_exceeded",
                                            "trigger_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary, self).__setattr__(name, value)


                        class IpConvergenceTime(Entity):
                            """
                            Convergence time for IP route programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.IpConvergenceTime, self).__init__()

                                self.yang_name = "ip-convergence-time"
                                self.yang_parent_name = "summary-external-event-summary"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.IpConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.IpConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ip-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class MplsConvergenceTime(Entity):
                            """
                            Convergence time for MPLS label programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.MplsConvergenceTime, self).__init__()

                                self.yang_name = "mpls-convergence-time"
                                self.yang_parent_name = "summary-external-event-summary"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.MplsConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.MplsConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class Path(Entity):
                            """
                            Path information
                            
                            .. attribute:: change_type
                            
                            	Event Add/Delete
                            	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: lfa_path
                            
                            	Backup Path Informatoin
                            	**type**\: list of    :py:class:`LfaPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path.LfaPath>`
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_metric
                            
                            	Path Metric
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path, self).__init__()

                                self.yang_name = "path"
                                self.yang_parent_name = "summary-external-event-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_metric = YLeaf(YType.uint32, "path-metric")

                                self.lfa_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_metric") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path, self).__setattr__(name, value)


                            class LfaPath(Entity):
                                """
                                Backup Path Informatoin
                                
                                .. attribute:: change_type
                                
                                	Event Add/Delete
                                	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: lfa_type
                                
                                	Type of LFA
                                	**type**\:   :py:class:`RcmdShowIpfrrLfa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowIpfrrLfa>`
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: path_metric
                                
                                	Path Metric
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: remote_node_id
                                
                                	Remote Node ID, in case of Remote LFA
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path.LfaPath, self).__init__()

                                    self.yang_name = "lfa-path"
                                    self.yang_parent_name = "path"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.lfa_type = YLeaf(YType.enumeration, "lfa-type")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                    self.path_metric = YLeaf(YType.uint32, "path-metric")

                                    self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "interface_name",
                                                    "lfa_type",
                                                    "neighbour_address",
                                                    "path_metric",
                                                    "remote_node_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path.LfaPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path.LfaPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.interface_name.is_set or
                                        self.lfa_type.is_set or
                                        self.neighbour_address.is_set or
                                        self.path_metric.is_set or
                                        self.remote_node_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.lfa_type.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set or
                                        self.path_metric.yfilter != YFilter.not_set or
                                        self.remote_node_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lfa-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.lfa_type.is_set or self.lfa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lfa_type.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                    if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.path_metric.get_name_leafdata())
                                    if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "interface-name" or name == "lfa-type" or name == "neighbour-address" or name == "path-metric" or name == "remote-node-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lfa-type"):
                                        self.lfa_type = value
                                        self.lfa_type.value_namespace = name_space
                                        self.lfa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "path-metric"):
                                        self.path_metric = value
                                        self.path_metric.value_namespace = name_space
                                        self.path_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "remote-node-id"):
                                        self.remote_node_id = value
                                        self.remote_node_id.value_namespace = name_space
                                        self.remote_node_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lfa_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.change_type.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_metric.is_set)

                            def has_operation(self):
                                for c in self.lfa_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_metric.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_metric.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lfa-path"):
                                    for c in self.lfa_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path.LfaPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lfa_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lfa-path" or name == "change-type" or name == "interface-name" or name == "neighbour-address" or name == "path-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-metric"):
                                    self.path_metric = value
                                    self.path_metric.value_namespace = name_space
                                    self.path_metric.value_namespace_prefix = name_space_prefix


                        class TriggerLsa(Entity):
                            """
                            LSA that triggered this event
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TriggerLsa, self).__init__()

                                self.yang_name = "trigger-lsa"
                                self.yang_parent_name = "summary-external-event-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TriggerLsa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TriggerLsa, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "trigger-lsa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class TimeLine(Entity):
                            """
                            Timeline information
                            
                            .. attribute:: lc_ip
                            
                            	List of Linecards' completion point for IP routes
                            	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcIp>`
                            
                            .. attribute:: lc_mpls
                            
                            	List of Linecards' completion point for MPLS labels
                            	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcMpls>`
                            
                            .. attribute:: ldp_enter
                            
                            	Entry point of LDP
                            	**type**\:  str
                            
                            .. attribute:: ldp_exit
                            
                            	Exit point of LDP to LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_enter
                            
                            	Entry point of LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_exit
                            
                            	Exit point of LSD to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_enter
                            
                            	Entry point of IPv4 RIB
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_exit
                            
                            	Exit point from IPv4 RIB to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_redistribute
                            
                            	Route Redistribute point from IPv4 RIB to LDP
                            	**type**\:  str
                            
                            .. attribute:: route_origin
                            
                            	Route origin (routing protocol)
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine, self).__init__()

                                self.yang_name = "time-line"
                                self.yang_parent_name = "summary-external-event-summary"

                                self.ldp_enter = YLeaf(YType.str, "ldp-enter")

                                self.ldp_exit = YLeaf(YType.str, "ldp-exit")

                                self.lsd_enter = YLeaf(YType.str, "lsd-enter")

                                self.lsd_exit = YLeaf(YType.str, "lsd-exit")

                                self.ri_bv4_enter = YLeaf(YType.str, "ri-bv4-enter")

                                self.ri_bv4_exit = YLeaf(YType.str, "ri-bv4-exit")

                                self.ri_bv4_redistribute = YLeaf(YType.str, "ri-bv4-redistribute")

                                self.route_origin = YLeaf(YType.str, "route-origin")

                                self.lc_ip = YList(self)
                                self.lc_mpls = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ldp_enter",
                                                "ldp_exit",
                                                "lsd_enter",
                                                "lsd_exit",
                                                "ri_bv4_enter",
                                                "ri_bv4_exit",
                                                "ri_bv4_redistribute",
                                                "route_origin") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine, self).__setattr__(name, value)


                            class LcIp(Entity):
                                """
                                List of Linecards' completion point for IP
                                routes
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcIp, self).__init__()

                                    self.yang_name = "lc-ip"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcIp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcIp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-ip" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix


                            class LcMpls(Entity):
                                """
                                List of Linecards' completion point for MPLS
                                labels
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcMpls, self).__init__()

                                    self.yang_name = "lc-mpls"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcMpls, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcMpls, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-mpls" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lc_ip:
                                    if (c.has_data()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.ldp_enter.is_set or
                                    self.ldp_exit.is_set or
                                    self.lsd_enter.is_set or
                                    self.lsd_exit.is_set or
                                    self.ri_bv4_enter.is_set or
                                    self.ri_bv4_exit.is_set or
                                    self.ri_bv4_redistribute.is_set or
                                    self.route_origin.is_set)

                            def has_operation(self):
                                for c in self.lc_ip:
                                    if (c.has_operation()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ldp_enter.yfilter != YFilter.not_set or
                                    self.ldp_exit.yfilter != YFilter.not_set or
                                    self.lsd_enter.yfilter != YFilter.not_set or
                                    self.lsd_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_enter.yfilter != YFilter.not_set or
                                    self.ri_bv4_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_redistribute.yfilter != YFilter.not_set or
                                    self.route_origin.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "time-line" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ldp_enter.is_set or self.ldp_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_enter.get_name_leafdata())
                                if (self.ldp_exit.is_set or self.ldp_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_exit.get_name_leafdata())
                                if (self.lsd_enter.is_set or self.lsd_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_enter.get_name_leafdata())
                                if (self.lsd_exit.is_set or self.lsd_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_exit.get_name_leafdata())
                                if (self.ri_bv4_enter.is_set or self.ri_bv4_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_enter.get_name_leafdata())
                                if (self.ri_bv4_exit.is_set or self.ri_bv4_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_exit.get_name_leafdata())
                                if (self.ri_bv4_redistribute.is_set or self.ri_bv4_redistribute.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_redistribute.get_name_leafdata())
                                if (self.route_origin.is_set or self.route_origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_origin.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lc-ip"):
                                    for c in self.lc_ip:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcIp()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_ip.append(c)
                                    return c

                                if (child_yang_name == "lc-mpls"):
                                    for c in self.lc_mpls:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine.LcMpls()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_mpls.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ldp-enter"):
                                    self.ldp_enter = value
                                    self.ldp_enter.value_namespace = name_space
                                    self.ldp_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldp-exit"):
                                    self.ldp_exit = value
                                    self.ldp_exit.value_namespace = name_space
                                    self.ldp_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-enter"):
                                    self.lsd_enter = value
                                    self.lsd_enter.value_namespace = name_space
                                    self.lsd_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-exit"):
                                    self.lsd_exit = value
                                    self.lsd_exit.value_namespace = name_space
                                    self.lsd_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-enter"):
                                    self.ri_bv4_enter = value
                                    self.ri_bv4_enter.value_namespace = name_space
                                    self.ri_bv4_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-exit"):
                                    self.ri_bv4_exit = value
                                    self.ri_bv4_exit.value_namespace = name_space
                                    self.ri_bv4_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-redistribute"):
                                    self.ri_bv4_redistribute = value
                                    self.ri_bv4_redistribute.value_namespace = name_space
                                    self.ri_bv4_redistribute.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-origin"):
                                    self.route_origin = value
                                    self.route_origin.value_namespace = name_space
                                    self.route_origin.value_namespace_prefix = name_space_prefix


                        class LsaProcessed(Entity):
                            """
                            List of LSAs processed
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.LsaProcessed, self).__init__()

                                self.yang_name = "lsa-processed"
                                self.yang_parent_name = "summary-external-event-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.LsaProcessed, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.LsaProcessed, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsa-processed" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsa_processed:
                                if (c.has_data()):
                                    return True
                            for c in self.path:
                                if (c.has_data()):
                                    return True
                            for c in self.time_line:
                                if (c.has_data()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.change_type.is_set or
                                self.cost.is_set or
                                self.ipfrr_event_id.is_set or
                                self.prefix.is_set or
                                self.prefix_lenth.is_set or
                                self.priority.is_set or
                                self.route_path_change_type.is_set or
                                self.route_type.is_set or
                                self.spf_run_no.is_set or
                                self.threshold_exceeded.is_set or
                                self.trigger_time.is_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()))

                        def has_operation(self):
                            for c in self.lsa_processed:
                                if (c.has_operation()):
                                    return True
                            for c in self.path:
                                if (c.has_operation()):
                                    return True
                            for c in self.time_line:
                                if (c.has_operation()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.change_type.yfilter != YFilter.not_set or
                                self.cost.yfilter != YFilter.not_set or
                                self.ipfrr_event_id.yfilter != YFilter.not_set or
                                self.prefix.yfilter != YFilter.not_set or
                                self.prefix_lenth.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set or
                                self.route_path_change_type.yfilter != YFilter.not_set or
                                self.route_type.yfilter != YFilter.not_set or
                                self.spf_run_no.yfilter != YFilter.not_set or
                                self.threshold_exceeded.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "summary-external-event-summary" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.change_type.get_name_leafdata())
                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cost.get_name_leafdata())
                            if (self.ipfrr_event_id.is_set or self.ipfrr_event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipfrr_event_id.get_name_leafdata())
                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix.get_name_leafdata())
                            if (self.prefix_lenth.is_set or self.prefix_lenth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_lenth.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())
                            if (self.route_path_change_type.is_set or self.route_path_change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_path_change_type.get_name_leafdata())
                            if (self.route_type.is_set or self.route_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_type.get_name_leafdata())
                            if (self.spf_run_no.is_set or self.spf_run_no.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_no.get_name_leafdata())
                            if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ip-convergence-time"):
                                if (self.ip_convergence_time is None):
                                    self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                return self.ip_convergence_time

                            if (child_yang_name == "lsa-processed"):
                                for c in self.lsa_processed:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.LsaProcessed()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsa_processed.append(c)
                                return c

                            if (child_yang_name == "mpls-convergence-time"):
                                if (self.mpls_convergence_time is None):
                                    self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                return self.mpls_convergence_time

                            if (child_yang_name == "path"):
                                for c in self.path:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.Path()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path.append(c)
                                return c

                            if (child_yang_name == "time-line"):
                                for c in self.time_line:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TimeLine()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.time_line.append(c)
                                return c

                            if (child_yang_name == "trigger-lsa"):
                                for c in self.trigger_lsa:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary.TriggerLsa()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.trigger_lsa.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ip-convergence-time" or name == "lsa-processed" or name == "mpls-convergence-time" or name == "path" or name == "time-line" or name == "trigger-lsa" or name == "event-id" or name == "change-type" or name == "cost" or name == "ipfrr-event-id" or name == "prefix" or name == "prefix-lenth" or name == "priority" or name == "route-path-change-type" or name == "route-type" or name == "spf-run-no" or name == "threshold-exceeded" or name == "trigger-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "change-type"):
                                self.change_type = value
                                self.change_type.value_namespace = name_space
                                self.change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "cost"):
                                self.cost = value
                                self.cost.value_namespace = name_space
                                self.cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipfrr-event-id"):
                                self.ipfrr_event_id = value
                                self.ipfrr_event_id.value_namespace = name_space
                                self.ipfrr_event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix"):
                                self.prefix = value
                                self.prefix.value_namespace = name_space
                                self.prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-lenth"):
                                self.prefix_lenth = value
                                self.prefix_lenth.value_namespace = name_space
                                self.prefix_lenth.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-path-change-type"):
                                self.route_path_change_type = value
                                self.route_path_change_type.value_namespace = name_space
                                self.route_path_change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-type"):
                                self.route_type = value
                                self.route_type.value_namespace = name_space
                                self.route_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-run-no"):
                                self.spf_run_no = value
                                self.spf_run_no.value_namespace = name_space
                                self.spf_run_no.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-exceeded"):
                                self.threshold_exceeded = value
                                self.threshold_exceeded.value_namespace = name_space
                                self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.summary_external_event_summary:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.summary_external_event_summary:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "summary-external-event-summaries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "summary-external-event-summary"):
                            for c in self.summary_external_event_summary:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries.SummaryExternalEventSummary()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.summary_external_event_summary.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "summary-external-event-summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class PrefixEventSummaries(Entity):
                    """
                    OSPF Prefix events summary data
                    
                    .. attribute:: prefix_event_summary
                    
                    	OSPF Prefix Event data
                    	**type**\: list of    :py:class:`PrefixEventSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries, self).__init__()

                        self.yang_name = "prefix-event-summaries"
                        self.yang_parent_name = "instance"

                        self.prefix_event_summary = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries, self).__setattr__(name, value)


                    class PrefixEventSummary(Entity):
                        """
                        OSPF Prefix Event data
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific Event ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: change_type
                        
                        	Event Add/Delete
                        	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                        
                        .. attribute:: cost
                        
                        	Protocol route cost
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ip_convergence_time
                        
                        	Convergence time for IP route programming
                        	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime>`
                        
                        .. attribute:: ipfrr_event_id
                        
                        	Referenced IP\-FRR Event ID (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lsa_processed
                        
                        	List of LSAs processed
                        	**type**\: list of    :py:class:`LsaProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed>`
                        
                        .. attribute:: mpls_convergence_time
                        
                        	Convergence time for MPLS label programming
                        	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime>`
                        
                        .. attribute:: path
                        
                        	Path information
                        	**type**\: list of    :py:class:`Path <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path>`
                        
                        .. attribute:: prefix
                        
                        	Prefix
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_lenth
                        
                        	Prefix length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: priority
                        
                        	Event processed priority
                        	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                        
                        .. attribute:: route_path_change_type
                        
                        	Route Path Change Type
                        	**type**\:   :py:class:`RcmdShowRoutePathChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoutePathChange>`
                        
                        .. attribute:: route_type
                        
                        	Route Type intra/inter/l1/l2
                        	**type**\:   :py:class:`RcmdShowRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoute>`
                        
                        .. attribute:: spf_run_no
                        
                        	Referenced SPF Run No (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: threshold_exceeded
                        
                        	Threshold exceeded
                        	**type**\:  bool
                        
                        .. attribute:: time_line
                        
                        	Timeline information
                        	**type**\: list of    :py:class:`TimeLine <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine>`
                        
                        .. attribute:: trigger_lsa
                        
                        	LSA that triggered this event
                        	**type**\: list of    :py:class:`TriggerLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa>`
                        
                        .. attribute:: trigger_time
                        
                        	Event trigger time
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary, self).__init__()

                            self.yang_name = "prefix-event-summary"
                            self.yang_parent_name = "prefix-event-summaries"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.change_type = YLeaf(YType.enumeration, "change-type")

                            self.cost = YLeaf(YType.uint32, "cost")

                            self.ipfrr_event_id = YLeaf(YType.uint32, "ipfrr-event-id")

                            self.prefix = YLeaf(YType.str, "prefix")

                            self.prefix_lenth = YLeaf(YType.uint32, "prefix-lenth")

                            self.priority = YLeaf(YType.enumeration, "priority")

                            self.route_path_change_type = YLeaf(YType.enumeration, "route-path-change-type")

                            self.route_type = YLeaf(YType.enumeration, "route-type")

                            self.spf_run_no = YLeaf(YType.uint32, "spf-run-no")

                            self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime()
                            self.ip_convergence_time.parent = self
                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                            self._children_yang_names.add("ip-convergence-time")

                            self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime()
                            self.mpls_convergence_time.parent = self
                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                            self._children_yang_names.add("mpls-convergence-time")

                            self.lsa_processed = YList(self)
                            self.path = YList(self)
                            self.time_line = YList(self)
                            self.trigger_lsa = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "change_type",
                                            "cost",
                                            "ipfrr_event_id",
                                            "prefix",
                                            "prefix_lenth",
                                            "priority",
                                            "route_path_change_type",
                                            "route_type",
                                            "spf_run_no",
                                            "threshold_exceeded",
                                            "trigger_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary, self).__setattr__(name, value)


                        class IpConvergenceTime(Entity):
                            """
                            Convergence time for IP route programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime, self).__init__()

                                self.yang_name = "ip-convergence-time"
                                self.yang_parent_name = "prefix-event-summary"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ip-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class MplsConvergenceTime(Entity):
                            """
                            Convergence time for MPLS label programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime, self).__init__()

                                self.yang_name = "mpls-convergence-time"
                                self.yang_parent_name = "prefix-event-summary"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class Path(Entity):
                            """
                            Path information
                            
                            .. attribute:: change_type
                            
                            	Event Add/Delete
                            	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: lfa_path
                            
                            	Backup Path Informatoin
                            	**type**\: list of    :py:class:`LfaPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath>`
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_metric
                            
                            	Path Metric
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path, self).__init__()

                                self.yang_name = "path"
                                self.yang_parent_name = "prefix-event-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_metric = YLeaf(YType.uint32, "path-metric")

                                self.lfa_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_metric") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path, self).__setattr__(name, value)


                            class LfaPath(Entity):
                                """
                                Backup Path Informatoin
                                
                                .. attribute:: change_type
                                
                                	Event Add/Delete
                                	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: lfa_type
                                
                                	Type of LFA
                                	**type**\:   :py:class:`RcmdShowIpfrrLfa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowIpfrrLfa>`
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: path_metric
                                
                                	Path Metric
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: remote_node_id
                                
                                	Remote Node ID, in case of Remote LFA
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath, self).__init__()

                                    self.yang_name = "lfa-path"
                                    self.yang_parent_name = "path"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.lfa_type = YLeaf(YType.enumeration, "lfa-type")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                    self.path_metric = YLeaf(YType.uint32, "path-metric")

                                    self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "interface_name",
                                                    "lfa_type",
                                                    "neighbour_address",
                                                    "path_metric",
                                                    "remote_node_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.interface_name.is_set or
                                        self.lfa_type.is_set or
                                        self.neighbour_address.is_set or
                                        self.path_metric.is_set or
                                        self.remote_node_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.lfa_type.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set or
                                        self.path_metric.yfilter != YFilter.not_set or
                                        self.remote_node_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lfa-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.lfa_type.is_set or self.lfa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lfa_type.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                    if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.path_metric.get_name_leafdata())
                                    if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "interface-name" or name == "lfa-type" or name == "neighbour-address" or name == "path-metric" or name == "remote-node-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lfa-type"):
                                        self.lfa_type = value
                                        self.lfa_type.value_namespace = name_space
                                        self.lfa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "path-metric"):
                                        self.path_metric = value
                                        self.path_metric.value_namespace = name_space
                                        self.path_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "remote-node-id"):
                                        self.remote_node_id = value
                                        self.remote_node_id.value_namespace = name_space
                                        self.remote_node_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lfa_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.change_type.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_metric.is_set)

                            def has_operation(self):
                                for c in self.lfa_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_metric.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_metric.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lfa-path"):
                                    for c in self.lfa_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lfa_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lfa-path" or name == "change-type" or name == "interface-name" or name == "neighbour-address" or name == "path-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-metric"):
                                    self.path_metric = value
                                    self.path_metric.value_namespace = name_space
                                    self.path_metric.value_namespace_prefix = name_space_prefix


                        class TriggerLsa(Entity):
                            """
                            LSA that triggered this event
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa, self).__init__()

                                self.yang_name = "trigger-lsa"
                                self.yang_parent_name = "prefix-event-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "trigger-lsa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class TimeLine(Entity):
                            """
                            Timeline information
                            
                            .. attribute:: lc_ip
                            
                            	List of Linecards' completion point for IP routes
                            	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp>`
                            
                            .. attribute:: lc_mpls
                            
                            	List of Linecards' completion point for MPLS labels
                            	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls>`
                            
                            .. attribute:: ldp_enter
                            
                            	Entry point of LDP
                            	**type**\:  str
                            
                            .. attribute:: ldp_exit
                            
                            	Exit point of LDP to LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_enter
                            
                            	Entry point of LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_exit
                            
                            	Exit point of LSD to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_enter
                            
                            	Entry point of IPv4 RIB
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_exit
                            
                            	Exit point from IPv4 RIB to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_redistribute
                            
                            	Route Redistribute point from IPv4 RIB to LDP
                            	**type**\:  str
                            
                            .. attribute:: route_origin
                            
                            	Route origin (routing protocol)
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine, self).__init__()

                                self.yang_name = "time-line"
                                self.yang_parent_name = "prefix-event-summary"

                                self.ldp_enter = YLeaf(YType.str, "ldp-enter")

                                self.ldp_exit = YLeaf(YType.str, "ldp-exit")

                                self.lsd_enter = YLeaf(YType.str, "lsd-enter")

                                self.lsd_exit = YLeaf(YType.str, "lsd-exit")

                                self.ri_bv4_enter = YLeaf(YType.str, "ri-bv4-enter")

                                self.ri_bv4_exit = YLeaf(YType.str, "ri-bv4-exit")

                                self.ri_bv4_redistribute = YLeaf(YType.str, "ri-bv4-redistribute")

                                self.route_origin = YLeaf(YType.str, "route-origin")

                                self.lc_ip = YList(self)
                                self.lc_mpls = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ldp_enter",
                                                "ldp_exit",
                                                "lsd_enter",
                                                "lsd_exit",
                                                "ri_bv4_enter",
                                                "ri_bv4_exit",
                                                "ri_bv4_redistribute",
                                                "route_origin") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine, self).__setattr__(name, value)


                            class LcIp(Entity):
                                """
                                List of Linecards' completion point for IP
                                routes
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp, self).__init__()

                                    self.yang_name = "lc-ip"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-ip" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix


                            class LcMpls(Entity):
                                """
                                List of Linecards' completion point for MPLS
                                labels
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls, self).__init__()

                                    self.yang_name = "lc-mpls"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-mpls" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lc_ip:
                                    if (c.has_data()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.ldp_enter.is_set or
                                    self.ldp_exit.is_set or
                                    self.lsd_enter.is_set or
                                    self.lsd_exit.is_set or
                                    self.ri_bv4_enter.is_set or
                                    self.ri_bv4_exit.is_set or
                                    self.ri_bv4_redistribute.is_set or
                                    self.route_origin.is_set)

                            def has_operation(self):
                                for c in self.lc_ip:
                                    if (c.has_operation()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ldp_enter.yfilter != YFilter.not_set or
                                    self.ldp_exit.yfilter != YFilter.not_set or
                                    self.lsd_enter.yfilter != YFilter.not_set or
                                    self.lsd_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_enter.yfilter != YFilter.not_set or
                                    self.ri_bv4_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_redistribute.yfilter != YFilter.not_set or
                                    self.route_origin.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "time-line" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ldp_enter.is_set or self.ldp_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_enter.get_name_leafdata())
                                if (self.ldp_exit.is_set or self.ldp_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_exit.get_name_leafdata())
                                if (self.lsd_enter.is_set or self.lsd_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_enter.get_name_leafdata())
                                if (self.lsd_exit.is_set or self.lsd_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_exit.get_name_leafdata())
                                if (self.ri_bv4_enter.is_set or self.ri_bv4_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_enter.get_name_leafdata())
                                if (self.ri_bv4_exit.is_set or self.ri_bv4_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_exit.get_name_leafdata())
                                if (self.ri_bv4_redistribute.is_set or self.ri_bv4_redistribute.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_redistribute.get_name_leafdata())
                                if (self.route_origin.is_set or self.route_origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_origin.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lc-ip"):
                                    for c in self.lc_ip:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_ip.append(c)
                                    return c

                                if (child_yang_name == "lc-mpls"):
                                    for c in self.lc_mpls:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_mpls.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ldp-enter"):
                                    self.ldp_enter = value
                                    self.ldp_enter.value_namespace = name_space
                                    self.ldp_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldp-exit"):
                                    self.ldp_exit = value
                                    self.ldp_exit.value_namespace = name_space
                                    self.ldp_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-enter"):
                                    self.lsd_enter = value
                                    self.lsd_enter.value_namespace = name_space
                                    self.lsd_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-exit"):
                                    self.lsd_exit = value
                                    self.lsd_exit.value_namespace = name_space
                                    self.lsd_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-enter"):
                                    self.ri_bv4_enter = value
                                    self.ri_bv4_enter.value_namespace = name_space
                                    self.ri_bv4_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-exit"):
                                    self.ri_bv4_exit = value
                                    self.ri_bv4_exit.value_namespace = name_space
                                    self.ri_bv4_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-redistribute"):
                                    self.ri_bv4_redistribute = value
                                    self.ri_bv4_redistribute.value_namespace = name_space
                                    self.ri_bv4_redistribute.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-origin"):
                                    self.route_origin = value
                                    self.route_origin.value_namespace = name_space
                                    self.route_origin.value_namespace_prefix = name_space_prefix


                        class LsaProcessed(Entity):
                            """
                            List of LSAs processed
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed, self).__init__()

                                self.yang_name = "lsa-processed"
                                self.yang_parent_name = "prefix-event-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsa-processed" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsa_processed:
                                if (c.has_data()):
                                    return True
                            for c in self.path:
                                if (c.has_data()):
                                    return True
                            for c in self.time_line:
                                if (c.has_data()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.change_type.is_set or
                                self.cost.is_set or
                                self.ipfrr_event_id.is_set or
                                self.prefix.is_set or
                                self.prefix_lenth.is_set or
                                self.priority.is_set or
                                self.route_path_change_type.is_set or
                                self.route_type.is_set or
                                self.spf_run_no.is_set or
                                self.threshold_exceeded.is_set or
                                self.trigger_time.is_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()))

                        def has_operation(self):
                            for c in self.lsa_processed:
                                if (c.has_operation()):
                                    return True
                            for c in self.path:
                                if (c.has_operation()):
                                    return True
                            for c in self.time_line:
                                if (c.has_operation()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.change_type.yfilter != YFilter.not_set or
                                self.cost.yfilter != YFilter.not_set or
                                self.ipfrr_event_id.yfilter != YFilter.not_set or
                                self.prefix.yfilter != YFilter.not_set or
                                self.prefix_lenth.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set or
                                self.route_path_change_type.yfilter != YFilter.not_set or
                                self.route_type.yfilter != YFilter.not_set or
                                self.spf_run_no.yfilter != YFilter.not_set or
                                self.threshold_exceeded.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-event-summary" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.change_type.get_name_leafdata())
                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cost.get_name_leafdata())
                            if (self.ipfrr_event_id.is_set or self.ipfrr_event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipfrr_event_id.get_name_leafdata())
                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix.get_name_leafdata())
                            if (self.prefix_lenth.is_set or self.prefix_lenth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_lenth.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())
                            if (self.route_path_change_type.is_set or self.route_path_change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_path_change_type.get_name_leafdata())
                            if (self.route_type.is_set or self.route_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_type.get_name_leafdata())
                            if (self.spf_run_no.is_set or self.spf_run_no.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_no.get_name_leafdata())
                            if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ip-convergence-time"):
                                if (self.ip_convergence_time is None):
                                    self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                return self.ip_convergence_time

                            if (child_yang_name == "lsa-processed"):
                                for c in self.lsa_processed:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsa_processed.append(c)
                                return c

                            if (child_yang_name == "mpls-convergence-time"):
                                if (self.mpls_convergence_time is None):
                                    self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                return self.mpls_convergence_time

                            if (child_yang_name == "path"):
                                for c in self.path:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path.append(c)
                                return c

                            if (child_yang_name == "time-line"):
                                for c in self.time_line:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.time_line.append(c)
                                return c

                            if (child_yang_name == "trigger-lsa"):
                                for c in self.trigger_lsa:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.trigger_lsa.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ip-convergence-time" or name == "lsa-processed" or name == "mpls-convergence-time" or name == "path" or name == "time-line" or name == "trigger-lsa" or name == "event-id" or name == "change-type" or name == "cost" or name == "ipfrr-event-id" or name == "prefix" or name == "prefix-lenth" or name == "priority" or name == "route-path-change-type" or name == "route-type" or name == "spf-run-no" or name == "threshold-exceeded" or name == "trigger-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "change-type"):
                                self.change_type = value
                                self.change_type.value_namespace = name_space
                                self.change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "cost"):
                                self.cost = value
                                self.cost.value_namespace = name_space
                                self.cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipfrr-event-id"):
                                self.ipfrr_event_id = value
                                self.ipfrr_event_id.value_namespace = name_space
                                self.ipfrr_event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix"):
                                self.prefix = value
                                self.prefix.value_namespace = name_space
                                self.prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-lenth"):
                                self.prefix_lenth = value
                                self.prefix_lenth.value_namespace = name_space
                                self.prefix_lenth.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-path-change-type"):
                                self.route_path_change_type = value
                                self.route_path_change_type.value_namespace = name_space
                                self.route_path_change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-type"):
                                self.route_type = value
                                self.route_type.value_namespace = name_space
                                self.route_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-run-no"):
                                self.spf_run_no = value
                                self.spf_run_no.value_namespace = name_space
                                self.spf_run_no.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-exceeded"):
                                self.threshold_exceeded = value
                                self.threshold_exceeded.value_namespace = name_space
                                self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.prefix_event_summary:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.prefix_event_summary:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "prefix-event-summaries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-event-summary"):
                            for c in self.prefix_event_summary:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries.PrefixEventSummary()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.prefix_event_summary.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-event-summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SummaryExternalEventOfflines(Entity):
                    """
                    OSPF Summary\-External Prefix events offline
                    data
                    
                    .. attribute:: summary_external_event_offline
                    
                    	Offline operational data for particular OSPF Prefix Event
                    	**type**\: list of    :py:class:`SummaryExternalEventOffline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines, self).__init__()

                        self.yang_name = "summary-external-event-offlines"
                        self.yang_parent_name = "instance"

                        self.summary_external_event_offline = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines, self).__setattr__(name, value)


                    class SummaryExternalEventOffline(Entity):
                        """
                        Offline operational data for particular OSPF
                        Prefix Event
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific Event ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: change_type
                        
                        	Event Add/Delete
                        	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                        
                        .. attribute:: cost
                        
                        	Protocol route cost
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ip_convergence_time
                        
                        	Convergence time for IP route programming
                        	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.IpConvergenceTime>`
                        
                        .. attribute:: ipfrr_event_id
                        
                        	Referenced IP\-FRR Event ID (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lsa_processed
                        
                        	List of LSAs processed
                        	**type**\: list of    :py:class:`LsaProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.LsaProcessed>`
                        
                        .. attribute:: mpls_convergence_time
                        
                        	Convergence time for MPLS label programming
                        	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.MplsConvergenceTime>`
                        
                        .. attribute:: path
                        
                        	Path information
                        	**type**\: list of    :py:class:`Path <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path>`
                        
                        .. attribute:: prefix
                        
                        	Prefix
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_lenth
                        
                        	Prefix length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: priority
                        
                        	Event processed priority
                        	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                        
                        .. attribute:: route_path_change_type
                        
                        	Route Path Change Type
                        	**type**\:   :py:class:`RcmdShowRoutePathChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoutePathChange>`
                        
                        .. attribute:: route_type
                        
                        	Route Type intra/inter/l1/l2
                        	**type**\:   :py:class:`RcmdShowRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoute>`
                        
                        .. attribute:: spf_run_no
                        
                        	Referenced SPF Run No (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: threshold_exceeded
                        
                        	Threshold exceeded
                        	**type**\:  bool
                        
                        .. attribute:: time_line
                        
                        	Timeline information
                        	**type**\: list of    :py:class:`TimeLine <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine>`
                        
                        .. attribute:: trigger_lsa
                        
                        	LSA that triggered this event
                        	**type**\: list of    :py:class:`TriggerLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TriggerLsa>`
                        
                        .. attribute:: trigger_time
                        
                        	Event trigger time
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline, self).__init__()

                            self.yang_name = "summary-external-event-offline"
                            self.yang_parent_name = "summary-external-event-offlines"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.change_type = YLeaf(YType.enumeration, "change-type")

                            self.cost = YLeaf(YType.uint32, "cost")

                            self.ipfrr_event_id = YLeaf(YType.uint32, "ipfrr-event-id")

                            self.prefix = YLeaf(YType.str, "prefix")

                            self.prefix_lenth = YLeaf(YType.uint32, "prefix-lenth")

                            self.priority = YLeaf(YType.enumeration, "priority")

                            self.route_path_change_type = YLeaf(YType.enumeration, "route-path-change-type")

                            self.route_type = YLeaf(YType.enumeration, "route-type")

                            self.spf_run_no = YLeaf(YType.uint32, "spf-run-no")

                            self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.IpConvergenceTime()
                            self.ip_convergence_time.parent = self
                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                            self._children_yang_names.add("ip-convergence-time")

                            self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.MplsConvergenceTime()
                            self.mpls_convergence_time.parent = self
                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                            self._children_yang_names.add("mpls-convergence-time")

                            self.lsa_processed = YList(self)
                            self.path = YList(self)
                            self.time_line = YList(self)
                            self.trigger_lsa = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "change_type",
                                            "cost",
                                            "ipfrr_event_id",
                                            "prefix",
                                            "prefix_lenth",
                                            "priority",
                                            "route_path_change_type",
                                            "route_type",
                                            "spf_run_no",
                                            "threshold_exceeded",
                                            "trigger_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline, self).__setattr__(name, value)


                        class IpConvergenceTime(Entity):
                            """
                            Convergence time for IP route programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.IpConvergenceTime, self).__init__()

                                self.yang_name = "ip-convergence-time"
                                self.yang_parent_name = "summary-external-event-offline"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.IpConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.IpConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ip-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class MplsConvergenceTime(Entity):
                            """
                            Convergence time for MPLS label programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.MplsConvergenceTime, self).__init__()

                                self.yang_name = "mpls-convergence-time"
                                self.yang_parent_name = "summary-external-event-offline"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.MplsConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.MplsConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class Path(Entity):
                            """
                            Path information
                            
                            .. attribute:: change_type
                            
                            	Event Add/Delete
                            	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: lfa_path
                            
                            	Backup Path Informatoin
                            	**type**\: list of    :py:class:`LfaPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path.LfaPath>`
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_metric
                            
                            	Path Metric
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path, self).__init__()

                                self.yang_name = "path"
                                self.yang_parent_name = "summary-external-event-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_metric = YLeaf(YType.uint32, "path-metric")

                                self.lfa_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_metric") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path, self).__setattr__(name, value)


                            class LfaPath(Entity):
                                """
                                Backup Path Informatoin
                                
                                .. attribute:: change_type
                                
                                	Event Add/Delete
                                	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: lfa_type
                                
                                	Type of LFA
                                	**type**\:   :py:class:`RcmdShowIpfrrLfa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowIpfrrLfa>`
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: path_metric
                                
                                	Path Metric
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: remote_node_id
                                
                                	Remote Node ID, in case of Remote LFA
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path.LfaPath, self).__init__()

                                    self.yang_name = "lfa-path"
                                    self.yang_parent_name = "path"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.lfa_type = YLeaf(YType.enumeration, "lfa-type")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                    self.path_metric = YLeaf(YType.uint32, "path-metric")

                                    self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "interface_name",
                                                    "lfa_type",
                                                    "neighbour_address",
                                                    "path_metric",
                                                    "remote_node_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path.LfaPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path.LfaPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.interface_name.is_set or
                                        self.lfa_type.is_set or
                                        self.neighbour_address.is_set or
                                        self.path_metric.is_set or
                                        self.remote_node_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.lfa_type.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set or
                                        self.path_metric.yfilter != YFilter.not_set or
                                        self.remote_node_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lfa-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.lfa_type.is_set or self.lfa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lfa_type.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                    if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.path_metric.get_name_leafdata())
                                    if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "interface-name" or name == "lfa-type" or name == "neighbour-address" or name == "path-metric" or name == "remote-node-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lfa-type"):
                                        self.lfa_type = value
                                        self.lfa_type.value_namespace = name_space
                                        self.lfa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "path-metric"):
                                        self.path_metric = value
                                        self.path_metric.value_namespace = name_space
                                        self.path_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "remote-node-id"):
                                        self.remote_node_id = value
                                        self.remote_node_id.value_namespace = name_space
                                        self.remote_node_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lfa_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.change_type.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_metric.is_set)

                            def has_operation(self):
                                for c in self.lfa_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_metric.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_metric.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lfa-path"):
                                    for c in self.lfa_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path.LfaPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lfa_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lfa-path" or name == "change-type" or name == "interface-name" or name == "neighbour-address" or name == "path-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-metric"):
                                    self.path_metric = value
                                    self.path_metric.value_namespace = name_space
                                    self.path_metric.value_namespace_prefix = name_space_prefix


                        class TriggerLsa(Entity):
                            """
                            LSA that triggered this event
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TriggerLsa, self).__init__()

                                self.yang_name = "trigger-lsa"
                                self.yang_parent_name = "summary-external-event-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TriggerLsa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TriggerLsa, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "trigger-lsa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class TimeLine(Entity):
                            """
                            Timeline information
                            
                            .. attribute:: lc_ip
                            
                            	List of Linecards' completion point for IP routes
                            	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcIp>`
                            
                            .. attribute:: lc_mpls
                            
                            	List of Linecards' completion point for MPLS labels
                            	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcMpls>`
                            
                            .. attribute:: ldp_enter
                            
                            	Entry point of LDP
                            	**type**\:  str
                            
                            .. attribute:: ldp_exit
                            
                            	Exit point of LDP to LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_enter
                            
                            	Entry point of LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_exit
                            
                            	Exit point of LSD to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_enter
                            
                            	Entry point of IPv4 RIB
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_exit
                            
                            	Exit point from IPv4 RIB to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_redistribute
                            
                            	Route Redistribute point from IPv4 RIB to LDP
                            	**type**\:  str
                            
                            .. attribute:: route_origin
                            
                            	Route origin (routing protocol)
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine, self).__init__()

                                self.yang_name = "time-line"
                                self.yang_parent_name = "summary-external-event-offline"

                                self.ldp_enter = YLeaf(YType.str, "ldp-enter")

                                self.ldp_exit = YLeaf(YType.str, "ldp-exit")

                                self.lsd_enter = YLeaf(YType.str, "lsd-enter")

                                self.lsd_exit = YLeaf(YType.str, "lsd-exit")

                                self.ri_bv4_enter = YLeaf(YType.str, "ri-bv4-enter")

                                self.ri_bv4_exit = YLeaf(YType.str, "ri-bv4-exit")

                                self.ri_bv4_redistribute = YLeaf(YType.str, "ri-bv4-redistribute")

                                self.route_origin = YLeaf(YType.str, "route-origin")

                                self.lc_ip = YList(self)
                                self.lc_mpls = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ldp_enter",
                                                "ldp_exit",
                                                "lsd_enter",
                                                "lsd_exit",
                                                "ri_bv4_enter",
                                                "ri_bv4_exit",
                                                "ri_bv4_redistribute",
                                                "route_origin") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine, self).__setattr__(name, value)


                            class LcIp(Entity):
                                """
                                List of Linecards' completion point for IP
                                routes
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcIp, self).__init__()

                                    self.yang_name = "lc-ip"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcIp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcIp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-ip" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix


                            class LcMpls(Entity):
                                """
                                List of Linecards' completion point for MPLS
                                labels
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcMpls, self).__init__()

                                    self.yang_name = "lc-mpls"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcMpls, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcMpls, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-mpls" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lc_ip:
                                    if (c.has_data()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.ldp_enter.is_set or
                                    self.ldp_exit.is_set or
                                    self.lsd_enter.is_set or
                                    self.lsd_exit.is_set or
                                    self.ri_bv4_enter.is_set or
                                    self.ri_bv4_exit.is_set or
                                    self.ri_bv4_redistribute.is_set or
                                    self.route_origin.is_set)

                            def has_operation(self):
                                for c in self.lc_ip:
                                    if (c.has_operation()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ldp_enter.yfilter != YFilter.not_set or
                                    self.ldp_exit.yfilter != YFilter.not_set or
                                    self.lsd_enter.yfilter != YFilter.not_set or
                                    self.lsd_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_enter.yfilter != YFilter.not_set or
                                    self.ri_bv4_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_redistribute.yfilter != YFilter.not_set or
                                    self.route_origin.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "time-line" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ldp_enter.is_set or self.ldp_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_enter.get_name_leafdata())
                                if (self.ldp_exit.is_set or self.ldp_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_exit.get_name_leafdata())
                                if (self.lsd_enter.is_set or self.lsd_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_enter.get_name_leafdata())
                                if (self.lsd_exit.is_set or self.lsd_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_exit.get_name_leafdata())
                                if (self.ri_bv4_enter.is_set or self.ri_bv4_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_enter.get_name_leafdata())
                                if (self.ri_bv4_exit.is_set or self.ri_bv4_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_exit.get_name_leafdata())
                                if (self.ri_bv4_redistribute.is_set or self.ri_bv4_redistribute.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_redistribute.get_name_leafdata())
                                if (self.route_origin.is_set or self.route_origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_origin.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lc-ip"):
                                    for c in self.lc_ip:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcIp()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_ip.append(c)
                                    return c

                                if (child_yang_name == "lc-mpls"):
                                    for c in self.lc_mpls:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine.LcMpls()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_mpls.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ldp-enter"):
                                    self.ldp_enter = value
                                    self.ldp_enter.value_namespace = name_space
                                    self.ldp_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldp-exit"):
                                    self.ldp_exit = value
                                    self.ldp_exit.value_namespace = name_space
                                    self.ldp_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-enter"):
                                    self.lsd_enter = value
                                    self.lsd_enter.value_namespace = name_space
                                    self.lsd_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-exit"):
                                    self.lsd_exit = value
                                    self.lsd_exit.value_namespace = name_space
                                    self.lsd_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-enter"):
                                    self.ri_bv4_enter = value
                                    self.ri_bv4_enter.value_namespace = name_space
                                    self.ri_bv4_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-exit"):
                                    self.ri_bv4_exit = value
                                    self.ri_bv4_exit.value_namespace = name_space
                                    self.ri_bv4_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-redistribute"):
                                    self.ri_bv4_redistribute = value
                                    self.ri_bv4_redistribute.value_namespace = name_space
                                    self.ri_bv4_redistribute.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-origin"):
                                    self.route_origin = value
                                    self.route_origin.value_namespace = name_space
                                    self.route_origin.value_namespace_prefix = name_space_prefix


                        class LsaProcessed(Entity):
                            """
                            List of LSAs processed
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.LsaProcessed, self).__init__()

                                self.yang_name = "lsa-processed"
                                self.yang_parent_name = "summary-external-event-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.LsaProcessed, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.LsaProcessed, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsa-processed" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsa_processed:
                                if (c.has_data()):
                                    return True
                            for c in self.path:
                                if (c.has_data()):
                                    return True
                            for c in self.time_line:
                                if (c.has_data()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.change_type.is_set or
                                self.cost.is_set or
                                self.ipfrr_event_id.is_set or
                                self.prefix.is_set or
                                self.prefix_lenth.is_set or
                                self.priority.is_set or
                                self.route_path_change_type.is_set or
                                self.route_type.is_set or
                                self.spf_run_no.is_set or
                                self.threshold_exceeded.is_set or
                                self.trigger_time.is_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()))

                        def has_operation(self):
                            for c in self.lsa_processed:
                                if (c.has_operation()):
                                    return True
                            for c in self.path:
                                if (c.has_operation()):
                                    return True
                            for c in self.time_line:
                                if (c.has_operation()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.change_type.yfilter != YFilter.not_set or
                                self.cost.yfilter != YFilter.not_set or
                                self.ipfrr_event_id.yfilter != YFilter.not_set or
                                self.prefix.yfilter != YFilter.not_set or
                                self.prefix_lenth.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set or
                                self.route_path_change_type.yfilter != YFilter.not_set or
                                self.route_type.yfilter != YFilter.not_set or
                                self.spf_run_no.yfilter != YFilter.not_set or
                                self.threshold_exceeded.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "summary-external-event-offline" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.change_type.get_name_leafdata())
                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cost.get_name_leafdata())
                            if (self.ipfrr_event_id.is_set or self.ipfrr_event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipfrr_event_id.get_name_leafdata())
                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix.get_name_leafdata())
                            if (self.prefix_lenth.is_set or self.prefix_lenth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_lenth.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())
                            if (self.route_path_change_type.is_set or self.route_path_change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_path_change_type.get_name_leafdata())
                            if (self.route_type.is_set or self.route_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_type.get_name_leafdata())
                            if (self.spf_run_no.is_set or self.spf_run_no.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_no.get_name_leafdata())
                            if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ip-convergence-time"):
                                if (self.ip_convergence_time is None):
                                    self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                return self.ip_convergence_time

                            if (child_yang_name == "lsa-processed"):
                                for c in self.lsa_processed:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.LsaProcessed()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsa_processed.append(c)
                                return c

                            if (child_yang_name == "mpls-convergence-time"):
                                if (self.mpls_convergence_time is None):
                                    self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                return self.mpls_convergence_time

                            if (child_yang_name == "path"):
                                for c in self.path:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.Path()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path.append(c)
                                return c

                            if (child_yang_name == "time-line"):
                                for c in self.time_line:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TimeLine()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.time_line.append(c)
                                return c

                            if (child_yang_name == "trigger-lsa"):
                                for c in self.trigger_lsa:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline.TriggerLsa()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.trigger_lsa.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ip-convergence-time" or name == "lsa-processed" or name == "mpls-convergence-time" or name == "path" or name == "time-line" or name == "trigger-lsa" or name == "event-id" or name == "change-type" or name == "cost" or name == "ipfrr-event-id" or name == "prefix" or name == "prefix-lenth" or name == "priority" or name == "route-path-change-type" or name == "route-type" or name == "spf-run-no" or name == "threshold-exceeded" or name == "trigger-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "change-type"):
                                self.change_type = value
                                self.change_type.value_namespace = name_space
                                self.change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "cost"):
                                self.cost = value
                                self.cost.value_namespace = name_space
                                self.cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipfrr-event-id"):
                                self.ipfrr_event_id = value
                                self.ipfrr_event_id.value_namespace = name_space
                                self.ipfrr_event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix"):
                                self.prefix = value
                                self.prefix.value_namespace = name_space
                                self.prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-lenth"):
                                self.prefix_lenth = value
                                self.prefix_lenth.value_namespace = name_space
                                self.prefix_lenth.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-path-change-type"):
                                self.route_path_change_type = value
                                self.route_path_change_type.value_namespace = name_space
                                self.route_path_change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-type"):
                                self.route_type = value
                                self.route_type.value_namespace = name_space
                                self.route_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-run-no"):
                                self.spf_run_no = value
                                self.spf_run_no.value_namespace = name_space
                                self.spf_run_no.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-exceeded"):
                                self.threshold_exceeded = value
                                self.threshold_exceeded.value_namespace = name_space
                                self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.summary_external_event_offline:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.summary_external_event_offline:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "summary-external-event-offlines" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "summary-external-event-offline"):
                            for c in self.summary_external_event_offline:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines.SummaryExternalEventOffline()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.summary_external_event_offline.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "summary-external-event-offline"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class PrefixEventOfflines(Entity):
                    """
                    OSPF Prefix events offline data
                    
                    .. attribute:: prefix_event_offline
                    
                    	Offline operational data for particular OSPF Prefix Event
                    	**type**\: list of    :py:class:`PrefixEventOffline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines, self).__init__()

                        self.yang_name = "prefix-event-offlines"
                        self.yang_parent_name = "instance"

                        self.prefix_event_offline = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines, self).__setattr__(name, value)


                    class PrefixEventOffline(Entity):
                        """
                        Offline operational data for particular OSPF
                        Prefix Event
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific Event ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: change_type
                        
                        	Event Add/Delete
                        	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                        
                        .. attribute:: cost
                        
                        	Protocol route cost
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ip_convergence_time
                        
                        	Convergence time for IP route programming
                        	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime>`
                        
                        .. attribute:: ipfrr_event_id
                        
                        	Referenced IP\-FRR Event ID (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lsa_processed
                        
                        	List of LSAs processed
                        	**type**\: list of    :py:class:`LsaProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed>`
                        
                        .. attribute:: mpls_convergence_time
                        
                        	Convergence time for MPLS label programming
                        	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime>`
                        
                        .. attribute:: path
                        
                        	Path information
                        	**type**\: list of    :py:class:`Path <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path>`
                        
                        .. attribute:: prefix
                        
                        	Prefix
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_lenth
                        
                        	Prefix length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: priority
                        
                        	Event processed priority
                        	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                        
                        .. attribute:: route_path_change_type
                        
                        	Route Path Change Type
                        	**type**\:   :py:class:`RcmdShowRoutePathChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoutePathChange>`
                        
                        .. attribute:: route_type
                        
                        	Route Type intra/inter/l1/l2
                        	**type**\:   :py:class:`RcmdShowRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoute>`
                        
                        .. attribute:: spf_run_no
                        
                        	Referenced SPF Run No (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: threshold_exceeded
                        
                        	Threshold exceeded
                        	**type**\:  bool
                        
                        .. attribute:: time_line
                        
                        	Timeline information
                        	**type**\: list of    :py:class:`TimeLine <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine>`
                        
                        .. attribute:: trigger_lsa
                        
                        	LSA that triggered this event
                        	**type**\: list of    :py:class:`TriggerLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa>`
                        
                        .. attribute:: trigger_time
                        
                        	Event trigger time
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline, self).__init__()

                            self.yang_name = "prefix-event-offline"
                            self.yang_parent_name = "prefix-event-offlines"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.change_type = YLeaf(YType.enumeration, "change-type")

                            self.cost = YLeaf(YType.uint32, "cost")

                            self.ipfrr_event_id = YLeaf(YType.uint32, "ipfrr-event-id")

                            self.prefix = YLeaf(YType.str, "prefix")

                            self.prefix_lenth = YLeaf(YType.uint32, "prefix-lenth")

                            self.priority = YLeaf(YType.enumeration, "priority")

                            self.route_path_change_type = YLeaf(YType.enumeration, "route-path-change-type")

                            self.route_type = YLeaf(YType.enumeration, "route-type")

                            self.spf_run_no = YLeaf(YType.uint32, "spf-run-no")

                            self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime()
                            self.ip_convergence_time.parent = self
                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                            self._children_yang_names.add("ip-convergence-time")

                            self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime()
                            self.mpls_convergence_time.parent = self
                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                            self._children_yang_names.add("mpls-convergence-time")

                            self.lsa_processed = YList(self)
                            self.path = YList(self)
                            self.time_line = YList(self)
                            self.trigger_lsa = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "change_type",
                                            "cost",
                                            "ipfrr_event_id",
                                            "prefix",
                                            "prefix_lenth",
                                            "priority",
                                            "route_path_change_type",
                                            "route_type",
                                            "spf_run_no",
                                            "threshold_exceeded",
                                            "trigger_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline, self).__setattr__(name, value)


                        class IpConvergenceTime(Entity):
                            """
                            Convergence time for IP route programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime, self).__init__()

                                self.yang_name = "ip-convergence-time"
                                self.yang_parent_name = "prefix-event-offline"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ip-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class MplsConvergenceTime(Entity):
                            """
                            Convergence time for MPLS label programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime, self).__init__()

                                self.yang_name = "mpls-convergence-time"
                                self.yang_parent_name = "prefix-event-offline"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class Path(Entity):
                            """
                            Path information
                            
                            .. attribute:: change_type
                            
                            	Event Add/Delete
                            	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: lfa_path
                            
                            	Backup Path Informatoin
                            	**type**\: list of    :py:class:`LfaPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath>`
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_metric
                            
                            	Path Metric
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path, self).__init__()

                                self.yang_name = "path"
                                self.yang_parent_name = "prefix-event-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_metric = YLeaf(YType.uint32, "path-metric")

                                self.lfa_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_metric") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path, self).__setattr__(name, value)


                            class LfaPath(Entity):
                                """
                                Backup Path Informatoin
                                
                                .. attribute:: change_type
                                
                                	Event Add/Delete
                                	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: lfa_type
                                
                                	Type of LFA
                                	**type**\:   :py:class:`RcmdShowIpfrrLfa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowIpfrrLfa>`
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: path_metric
                                
                                	Path Metric
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: remote_node_id
                                
                                	Remote Node ID, in case of Remote LFA
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath, self).__init__()

                                    self.yang_name = "lfa-path"
                                    self.yang_parent_name = "path"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.lfa_type = YLeaf(YType.enumeration, "lfa-type")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                    self.path_metric = YLeaf(YType.uint32, "path-metric")

                                    self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "interface_name",
                                                    "lfa_type",
                                                    "neighbour_address",
                                                    "path_metric",
                                                    "remote_node_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.interface_name.is_set or
                                        self.lfa_type.is_set or
                                        self.neighbour_address.is_set or
                                        self.path_metric.is_set or
                                        self.remote_node_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.lfa_type.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set or
                                        self.path_metric.yfilter != YFilter.not_set or
                                        self.remote_node_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lfa-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.lfa_type.is_set or self.lfa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lfa_type.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                    if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.path_metric.get_name_leafdata())
                                    if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "interface-name" or name == "lfa-type" or name == "neighbour-address" or name == "path-metric" or name == "remote-node-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lfa-type"):
                                        self.lfa_type = value
                                        self.lfa_type.value_namespace = name_space
                                        self.lfa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "path-metric"):
                                        self.path_metric = value
                                        self.path_metric.value_namespace = name_space
                                        self.path_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "remote-node-id"):
                                        self.remote_node_id = value
                                        self.remote_node_id.value_namespace = name_space
                                        self.remote_node_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lfa_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.change_type.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_metric.is_set)

                            def has_operation(self):
                                for c in self.lfa_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_metric.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_metric.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lfa-path"):
                                    for c in self.lfa_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lfa_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lfa-path" or name == "change-type" or name == "interface-name" or name == "neighbour-address" or name == "path-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-metric"):
                                    self.path_metric = value
                                    self.path_metric.value_namespace = name_space
                                    self.path_metric.value_namespace_prefix = name_space_prefix


                        class TriggerLsa(Entity):
                            """
                            LSA that triggered this event
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa, self).__init__()

                                self.yang_name = "trigger-lsa"
                                self.yang_parent_name = "prefix-event-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "trigger-lsa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class TimeLine(Entity):
                            """
                            Timeline information
                            
                            .. attribute:: lc_ip
                            
                            	List of Linecards' completion point for IP routes
                            	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp>`
                            
                            .. attribute:: lc_mpls
                            
                            	List of Linecards' completion point for MPLS labels
                            	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls>`
                            
                            .. attribute:: ldp_enter
                            
                            	Entry point of LDP
                            	**type**\:  str
                            
                            .. attribute:: ldp_exit
                            
                            	Exit point of LDP to LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_enter
                            
                            	Entry point of LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_exit
                            
                            	Exit point of LSD to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_enter
                            
                            	Entry point of IPv4 RIB
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_exit
                            
                            	Exit point from IPv4 RIB to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_redistribute
                            
                            	Route Redistribute point from IPv4 RIB to LDP
                            	**type**\:  str
                            
                            .. attribute:: route_origin
                            
                            	Route origin (routing protocol)
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine, self).__init__()

                                self.yang_name = "time-line"
                                self.yang_parent_name = "prefix-event-offline"

                                self.ldp_enter = YLeaf(YType.str, "ldp-enter")

                                self.ldp_exit = YLeaf(YType.str, "ldp-exit")

                                self.lsd_enter = YLeaf(YType.str, "lsd-enter")

                                self.lsd_exit = YLeaf(YType.str, "lsd-exit")

                                self.ri_bv4_enter = YLeaf(YType.str, "ri-bv4-enter")

                                self.ri_bv4_exit = YLeaf(YType.str, "ri-bv4-exit")

                                self.ri_bv4_redistribute = YLeaf(YType.str, "ri-bv4-redistribute")

                                self.route_origin = YLeaf(YType.str, "route-origin")

                                self.lc_ip = YList(self)
                                self.lc_mpls = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ldp_enter",
                                                "ldp_exit",
                                                "lsd_enter",
                                                "lsd_exit",
                                                "ri_bv4_enter",
                                                "ri_bv4_exit",
                                                "ri_bv4_redistribute",
                                                "route_origin") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine, self).__setattr__(name, value)


                            class LcIp(Entity):
                                """
                                List of Linecards' completion point for IP
                                routes
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp, self).__init__()

                                    self.yang_name = "lc-ip"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-ip" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix


                            class LcMpls(Entity):
                                """
                                List of Linecards' completion point for MPLS
                                labels
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls, self).__init__()

                                    self.yang_name = "lc-mpls"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-mpls" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lc_ip:
                                    if (c.has_data()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.ldp_enter.is_set or
                                    self.ldp_exit.is_set or
                                    self.lsd_enter.is_set or
                                    self.lsd_exit.is_set or
                                    self.ri_bv4_enter.is_set or
                                    self.ri_bv4_exit.is_set or
                                    self.ri_bv4_redistribute.is_set or
                                    self.route_origin.is_set)

                            def has_operation(self):
                                for c in self.lc_ip:
                                    if (c.has_operation()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ldp_enter.yfilter != YFilter.not_set or
                                    self.ldp_exit.yfilter != YFilter.not_set or
                                    self.lsd_enter.yfilter != YFilter.not_set or
                                    self.lsd_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_enter.yfilter != YFilter.not_set or
                                    self.ri_bv4_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_redistribute.yfilter != YFilter.not_set or
                                    self.route_origin.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "time-line" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ldp_enter.is_set or self.ldp_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_enter.get_name_leafdata())
                                if (self.ldp_exit.is_set or self.ldp_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_exit.get_name_leafdata())
                                if (self.lsd_enter.is_set or self.lsd_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_enter.get_name_leafdata())
                                if (self.lsd_exit.is_set or self.lsd_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_exit.get_name_leafdata())
                                if (self.ri_bv4_enter.is_set or self.ri_bv4_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_enter.get_name_leafdata())
                                if (self.ri_bv4_exit.is_set or self.ri_bv4_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_exit.get_name_leafdata())
                                if (self.ri_bv4_redistribute.is_set or self.ri_bv4_redistribute.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_redistribute.get_name_leafdata())
                                if (self.route_origin.is_set or self.route_origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_origin.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lc-ip"):
                                    for c in self.lc_ip:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_ip.append(c)
                                    return c

                                if (child_yang_name == "lc-mpls"):
                                    for c in self.lc_mpls:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_mpls.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ldp-enter"):
                                    self.ldp_enter = value
                                    self.ldp_enter.value_namespace = name_space
                                    self.ldp_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldp-exit"):
                                    self.ldp_exit = value
                                    self.ldp_exit.value_namespace = name_space
                                    self.ldp_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-enter"):
                                    self.lsd_enter = value
                                    self.lsd_enter.value_namespace = name_space
                                    self.lsd_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-exit"):
                                    self.lsd_exit = value
                                    self.lsd_exit.value_namespace = name_space
                                    self.lsd_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-enter"):
                                    self.ri_bv4_enter = value
                                    self.ri_bv4_enter.value_namespace = name_space
                                    self.ri_bv4_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-exit"):
                                    self.ri_bv4_exit = value
                                    self.ri_bv4_exit.value_namespace = name_space
                                    self.ri_bv4_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-redistribute"):
                                    self.ri_bv4_redistribute = value
                                    self.ri_bv4_redistribute.value_namespace = name_space
                                    self.ri_bv4_redistribute.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-origin"):
                                    self.route_origin = value
                                    self.route_origin.value_namespace = name_space
                                    self.route_origin.value_namespace_prefix = name_space_prefix


                        class LsaProcessed(Entity):
                            """
                            List of LSAs processed
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed, self).__init__()

                                self.yang_name = "lsa-processed"
                                self.yang_parent_name = "prefix-event-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsa-processed" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsa_processed:
                                if (c.has_data()):
                                    return True
                            for c in self.path:
                                if (c.has_data()):
                                    return True
                            for c in self.time_line:
                                if (c.has_data()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.change_type.is_set or
                                self.cost.is_set or
                                self.ipfrr_event_id.is_set or
                                self.prefix.is_set or
                                self.prefix_lenth.is_set or
                                self.priority.is_set or
                                self.route_path_change_type.is_set or
                                self.route_type.is_set or
                                self.spf_run_no.is_set or
                                self.threshold_exceeded.is_set or
                                self.trigger_time.is_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()))

                        def has_operation(self):
                            for c in self.lsa_processed:
                                if (c.has_operation()):
                                    return True
                            for c in self.path:
                                if (c.has_operation()):
                                    return True
                            for c in self.time_line:
                                if (c.has_operation()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.change_type.yfilter != YFilter.not_set or
                                self.cost.yfilter != YFilter.not_set or
                                self.ipfrr_event_id.yfilter != YFilter.not_set or
                                self.prefix.yfilter != YFilter.not_set or
                                self.prefix_lenth.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set or
                                self.route_path_change_type.yfilter != YFilter.not_set or
                                self.route_type.yfilter != YFilter.not_set or
                                self.spf_run_no.yfilter != YFilter.not_set or
                                self.threshold_exceeded.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-event-offline" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.change_type.get_name_leafdata())
                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cost.get_name_leafdata())
                            if (self.ipfrr_event_id.is_set or self.ipfrr_event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipfrr_event_id.get_name_leafdata())
                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix.get_name_leafdata())
                            if (self.prefix_lenth.is_set or self.prefix_lenth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_lenth.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())
                            if (self.route_path_change_type.is_set or self.route_path_change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_path_change_type.get_name_leafdata())
                            if (self.route_type.is_set or self.route_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_type.get_name_leafdata())
                            if (self.spf_run_no.is_set or self.spf_run_no.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_no.get_name_leafdata())
                            if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ip-convergence-time"):
                                if (self.ip_convergence_time is None):
                                    self.ip_convergence_time = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                return self.ip_convergence_time

                            if (child_yang_name == "lsa-processed"):
                                for c in self.lsa_processed:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsa_processed.append(c)
                                return c

                            if (child_yang_name == "mpls-convergence-time"):
                                if (self.mpls_convergence_time is None):
                                    self.mpls_convergence_time = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                return self.mpls_convergence_time

                            if (child_yang_name == "path"):
                                for c in self.path:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path.append(c)
                                return c

                            if (child_yang_name == "time-line"):
                                for c in self.time_line:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.time_line.append(c)
                                return c

                            if (child_yang_name == "trigger-lsa"):
                                for c in self.trigger_lsa:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.trigger_lsa.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ip-convergence-time" or name == "lsa-processed" or name == "mpls-convergence-time" or name == "path" or name == "time-line" or name == "trigger-lsa" or name == "event-id" or name == "change-type" or name == "cost" or name == "ipfrr-event-id" or name == "prefix" or name == "prefix-lenth" or name == "priority" or name == "route-path-change-type" or name == "route-type" or name == "spf-run-no" or name == "threshold-exceeded" or name == "trigger-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "change-type"):
                                self.change_type = value
                                self.change_type.value_namespace = name_space
                                self.change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "cost"):
                                self.cost = value
                                self.cost.value_namespace = name_space
                                self.cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipfrr-event-id"):
                                self.ipfrr_event_id = value
                                self.ipfrr_event_id.value_namespace = name_space
                                self.ipfrr_event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix"):
                                self.prefix = value
                                self.prefix.value_namespace = name_space
                                self.prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-lenth"):
                                self.prefix_lenth = value
                                self.prefix_lenth.value_namespace = name_space
                                self.prefix_lenth.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-path-change-type"):
                                self.route_path_change_type = value
                                self.route_path_change_type.value_namespace = name_space
                                self.route_path_change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-type"):
                                self.route_type = value
                                self.route_type.value_namespace = name_space
                                self.route_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-run-no"):
                                self.spf_run_no = value
                                self.spf_run_no.value_namespace = name_space
                                self.spf_run_no.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-exceeded"):
                                self.threshold_exceeded = value
                                self.threshold_exceeded.value_namespace = name_space
                                self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.prefix_event_offline:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.prefix_event_offline:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "prefix-event-offlines" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-event-offline"):
                            for c in self.prefix_event_offline:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines.PrefixEventOffline()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.prefix_event_offline.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-event-offline"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SummaryExternalEventStatistics(Entity):
                    """
                    Summary\-External prefix monitoring statistics
                    
                    .. attribute:: external_added
                    
                    	Total Ext Routes Added
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: external_critical
                    
                    	Total Ext Routes Critical
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: external_deleted
                    
                    	Total Ext Routes Deleted
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: external_high
                    
                    	Total Ext Routes High
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: external_low
                    
                    	Total Ext Routes Low
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: external_medium
                    
                    	Total Ext Routes Medium
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: external_modified
                    
                    	Total Ext Routes Modified
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: external_routes
                    
                    	Total External Routes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: inter_area_added
                    
                    	Total IA Routes Added
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: inter_area_critical
                    
                    	Total IA Routes Critical
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: inter_area_deleted
                    
                    	Total IA Routes Deleted
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: inter_area_high
                    
                    	Total IA Routes High
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: inter_area_low
                    
                    	Total IA Routes Low
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: inter_area_medium
                    
                    	Total IA Routes Medium
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: inter_area_modified
                    
                    	Total IA Routes Modified
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: inter_area_routes
                    
                    	Total Inter\-Area Routes
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventStatistics, self).__init__()

                        self.yang_name = "summary-external-event-statistics"
                        self.yang_parent_name = "instance"

                        self.external_added = YLeaf(YType.uint32, "external-added")

                        self.external_critical = YLeaf(YType.uint32, "external-critical")

                        self.external_deleted = YLeaf(YType.uint32, "external-deleted")

                        self.external_high = YLeaf(YType.uint32, "external-high")

                        self.external_low = YLeaf(YType.uint32, "external-low")

                        self.external_medium = YLeaf(YType.uint32, "external-medium")

                        self.external_modified = YLeaf(YType.uint32, "external-modified")

                        self.external_routes = YLeaf(YType.uint32, "external-routes")

                        self.inter_area_added = YLeaf(YType.uint32, "inter-area-added")

                        self.inter_area_critical = YLeaf(YType.uint32, "inter-area-critical")

                        self.inter_area_deleted = YLeaf(YType.uint32, "inter-area-deleted")

                        self.inter_area_high = YLeaf(YType.uint32, "inter-area-high")

                        self.inter_area_low = YLeaf(YType.uint32, "inter-area-low")

                        self.inter_area_medium = YLeaf(YType.uint32, "inter-area-medium")

                        self.inter_area_modified = YLeaf(YType.uint32, "inter-area-modified")

                        self.inter_area_routes = YLeaf(YType.uint32, "inter-area-routes")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("external_added",
                                        "external_critical",
                                        "external_deleted",
                                        "external_high",
                                        "external_low",
                                        "external_medium",
                                        "external_modified",
                                        "external_routes",
                                        "inter_area_added",
                                        "inter_area_critical",
                                        "inter_area_deleted",
                                        "inter_area_high",
                                        "inter_area_low",
                                        "inter_area_medium",
                                        "inter_area_modified",
                                        "inter_area_routes") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ospf.Instances.Instance.SummaryExternalEventStatistics, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.external_added.is_set or
                            self.external_critical.is_set or
                            self.external_deleted.is_set or
                            self.external_high.is_set or
                            self.external_low.is_set or
                            self.external_medium.is_set or
                            self.external_modified.is_set or
                            self.external_routes.is_set or
                            self.inter_area_added.is_set or
                            self.inter_area_critical.is_set or
                            self.inter_area_deleted.is_set or
                            self.inter_area_high.is_set or
                            self.inter_area_low.is_set or
                            self.inter_area_medium.is_set or
                            self.inter_area_modified.is_set or
                            self.inter_area_routes.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.external_added.yfilter != YFilter.not_set or
                            self.external_critical.yfilter != YFilter.not_set or
                            self.external_deleted.yfilter != YFilter.not_set or
                            self.external_high.yfilter != YFilter.not_set or
                            self.external_low.yfilter != YFilter.not_set or
                            self.external_medium.yfilter != YFilter.not_set or
                            self.external_modified.yfilter != YFilter.not_set or
                            self.external_routes.yfilter != YFilter.not_set or
                            self.inter_area_added.yfilter != YFilter.not_set or
                            self.inter_area_critical.yfilter != YFilter.not_set or
                            self.inter_area_deleted.yfilter != YFilter.not_set or
                            self.inter_area_high.yfilter != YFilter.not_set or
                            self.inter_area_low.yfilter != YFilter.not_set or
                            self.inter_area_medium.yfilter != YFilter.not_set or
                            self.inter_area_modified.yfilter != YFilter.not_set or
                            self.inter_area_routes.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "summary-external-event-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.external_added.is_set or self.external_added.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_added.get_name_leafdata())
                        if (self.external_critical.is_set or self.external_critical.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_critical.get_name_leafdata())
                        if (self.external_deleted.is_set or self.external_deleted.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_deleted.get_name_leafdata())
                        if (self.external_high.is_set or self.external_high.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_high.get_name_leafdata())
                        if (self.external_low.is_set or self.external_low.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_low.get_name_leafdata())
                        if (self.external_medium.is_set or self.external_medium.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_medium.get_name_leafdata())
                        if (self.external_modified.is_set or self.external_modified.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_modified.get_name_leafdata())
                        if (self.external_routes.is_set or self.external_routes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.external_routes.get_name_leafdata())
                        if (self.inter_area_added.is_set or self.inter_area_added.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inter_area_added.get_name_leafdata())
                        if (self.inter_area_critical.is_set or self.inter_area_critical.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inter_area_critical.get_name_leafdata())
                        if (self.inter_area_deleted.is_set or self.inter_area_deleted.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inter_area_deleted.get_name_leafdata())
                        if (self.inter_area_high.is_set or self.inter_area_high.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inter_area_high.get_name_leafdata())
                        if (self.inter_area_low.is_set or self.inter_area_low.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inter_area_low.get_name_leafdata())
                        if (self.inter_area_medium.is_set or self.inter_area_medium.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inter_area_medium.get_name_leafdata())
                        if (self.inter_area_modified.is_set or self.inter_area_modified.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inter_area_modified.get_name_leafdata())
                        if (self.inter_area_routes.is_set or self.inter_area_routes.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.inter_area_routes.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "external-added" or name == "external-critical" or name == "external-deleted" or name == "external-high" or name == "external-low" or name == "external-medium" or name == "external-modified" or name == "external-routes" or name == "inter-area-added" or name == "inter-area-critical" or name == "inter-area-deleted" or name == "inter-area-high" or name == "inter-area-low" or name == "inter-area-medium" or name == "inter-area-modified" or name == "inter-area-routes"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "external-added"):
                            self.external_added = value
                            self.external_added.value_namespace = name_space
                            self.external_added.value_namespace_prefix = name_space_prefix
                        if(value_path == "external-critical"):
                            self.external_critical = value
                            self.external_critical.value_namespace = name_space
                            self.external_critical.value_namespace_prefix = name_space_prefix
                        if(value_path == "external-deleted"):
                            self.external_deleted = value
                            self.external_deleted.value_namespace = name_space
                            self.external_deleted.value_namespace_prefix = name_space_prefix
                        if(value_path == "external-high"):
                            self.external_high = value
                            self.external_high.value_namespace = name_space
                            self.external_high.value_namespace_prefix = name_space_prefix
                        if(value_path == "external-low"):
                            self.external_low = value
                            self.external_low.value_namespace = name_space
                            self.external_low.value_namespace_prefix = name_space_prefix
                        if(value_path == "external-medium"):
                            self.external_medium = value
                            self.external_medium.value_namespace = name_space
                            self.external_medium.value_namespace_prefix = name_space_prefix
                        if(value_path == "external-modified"):
                            self.external_modified = value
                            self.external_modified.value_namespace = name_space
                            self.external_modified.value_namespace_prefix = name_space_prefix
                        if(value_path == "external-routes"):
                            self.external_routes = value
                            self.external_routes.value_namespace = name_space
                            self.external_routes.value_namespace_prefix = name_space_prefix
                        if(value_path == "inter-area-added"):
                            self.inter_area_added = value
                            self.inter_area_added.value_namespace = name_space
                            self.inter_area_added.value_namespace_prefix = name_space_prefix
                        if(value_path == "inter-area-critical"):
                            self.inter_area_critical = value
                            self.inter_area_critical.value_namespace = name_space
                            self.inter_area_critical.value_namespace_prefix = name_space_prefix
                        if(value_path == "inter-area-deleted"):
                            self.inter_area_deleted = value
                            self.inter_area_deleted.value_namespace = name_space
                            self.inter_area_deleted.value_namespace_prefix = name_space_prefix
                        if(value_path == "inter-area-high"):
                            self.inter_area_high = value
                            self.inter_area_high.value_namespace = name_space
                            self.inter_area_high.value_namespace_prefix = name_space_prefix
                        if(value_path == "inter-area-low"):
                            self.inter_area_low = value
                            self.inter_area_low.value_namespace = name_space
                            self.inter_area_low.value_namespace_prefix = name_space_prefix
                        if(value_path == "inter-area-medium"):
                            self.inter_area_medium = value
                            self.inter_area_medium.value_namespace = name_space
                            self.inter_area_medium.value_namespace_prefix = name_space_prefix
                        if(value_path == "inter-area-modified"):
                            self.inter_area_modified = value
                            self.inter_area_modified.value_namespace = name_space
                            self.inter_area_modified.value_namespace_prefix = name_space_prefix
                        if(value_path == "inter-area-routes"):
                            self.inter_area_routes = value
                            self.inter_area_routes.value_namespace = name_space
                            self.inter_area_routes.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.instance_name.is_set or
                        (self.ipfrr_event_offlines is not None and self.ipfrr_event_offlines.has_data()) or
                        (self.ipfrr_event_summaries is not None and self.ipfrr_event_summaries.has_data()) or
                        (self.prefix_event_offlines is not None and self.prefix_event_offlines.has_data()) or
                        (self.prefix_event_statistics is not None and self.prefix_event_statistics.has_data()) or
                        (self.prefix_event_summaries is not None and self.prefix_event_summaries.has_data()) or
                        (self.spf_run_offlines is not None and self.spf_run_offlines.has_data()) or
                        (self.spf_run_summaries is not None and self.spf_run_summaries.has_data()) or
                        (self.summary_external_event_offlines is not None and self.summary_external_event_offlines.has_data()) or
                        (self.summary_external_event_statistics is not None and self.summary_external_event_statistics.has_data()) or
                        (self.summary_external_event_summaries is not None and self.summary_external_event_summaries.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.instance_name.yfilter != YFilter.not_set or
                        (self.ipfrr_event_offlines is not None and self.ipfrr_event_offlines.has_operation()) or
                        (self.ipfrr_event_summaries is not None and self.ipfrr_event_summaries.has_operation()) or
                        (self.prefix_event_offlines is not None and self.prefix_event_offlines.has_operation()) or
                        (self.prefix_event_statistics is not None and self.prefix_event_statistics.has_operation()) or
                        (self.prefix_event_summaries is not None and self.prefix_event_summaries.has_operation()) or
                        (self.spf_run_offlines is not None and self.spf_run_offlines.has_operation()) or
                        (self.spf_run_summaries is not None and self.spf_run_summaries.has_operation()) or
                        (self.summary_external_event_offlines is not None and self.summary_external_event_offlines.has_operation()) or
                        (self.summary_external_event_statistics is not None and self.summary_external_event_statistics.has_operation()) or
                        (self.summary_external_event_summaries is not None and self.summary_external_event_summaries.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "instance" + "[instance-name='" + self.instance_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/ospf/instances/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.instance_name.is_set or self.instance_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.instance_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ipfrr-event-offlines"):
                        if (self.ipfrr_event_offlines is None):
                            self.ipfrr_event_offlines = Rcmd.Ospf.Instances.Instance.IpfrrEventOfflines()
                            self.ipfrr_event_offlines.parent = self
                            self._children_name_map["ipfrr_event_offlines"] = "ipfrr-event-offlines"
                        return self.ipfrr_event_offlines

                    if (child_yang_name == "ipfrr-event-summaries"):
                        if (self.ipfrr_event_summaries is None):
                            self.ipfrr_event_summaries = Rcmd.Ospf.Instances.Instance.IpfrrEventSummaries()
                            self.ipfrr_event_summaries.parent = self
                            self._children_name_map["ipfrr_event_summaries"] = "ipfrr-event-summaries"
                        return self.ipfrr_event_summaries

                    if (child_yang_name == "prefix-event-offlines"):
                        if (self.prefix_event_offlines is None):
                            self.prefix_event_offlines = Rcmd.Ospf.Instances.Instance.PrefixEventOfflines()
                            self.prefix_event_offlines.parent = self
                            self._children_name_map["prefix_event_offlines"] = "prefix-event-offlines"
                        return self.prefix_event_offlines

                    if (child_yang_name == "prefix-event-statistics"):
                        if (self.prefix_event_statistics is None):
                            self.prefix_event_statistics = Rcmd.Ospf.Instances.Instance.PrefixEventStatistics()
                            self.prefix_event_statistics.parent = self
                            self._children_name_map["prefix_event_statistics"] = "prefix-event-statistics"
                        return self.prefix_event_statistics

                    if (child_yang_name == "prefix-event-summaries"):
                        if (self.prefix_event_summaries is None):
                            self.prefix_event_summaries = Rcmd.Ospf.Instances.Instance.PrefixEventSummaries()
                            self.prefix_event_summaries.parent = self
                            self._children_name_map["prefix_event_summaries"] = "prefix-event-summaries"
                        return self.prefix_event_summaries

                    if (child_yang_name == "spf-run-offlines"):
                        if (self.spf_run_offlines is None):
                            self.spf_run_offlines = Rcmd.Ospf.Instances.Instance.SpfRunOfflines()
                            self.spf_run_offlines.parent = self
                            self._children_name_map["spf_run_offlines"] = "spf-run-offlines"
                        return self.spf_run_offlines

                    if (child_yang_name == "spf-run-summaries"):
                        if (self.spf_run_summaries is None):
                            self.spf_run_summaries = Rcmd.Ospf.Instances.Instance.SpfRunSummaries()
                            self.spf_run_summaries.parent = self
                            self._children_name_map["spf_run_summaries"] = "spf-run-summaries"
                        return self.spf_run_summaries

                    if (child_yang_name == "summary-external-event-offlines"):
                        if (self.summary_external_event_offlines is None):
                            self.summary_external_event_offlines = Rcmd.Ospf.Instances.Instance.SummaryExternalEventOfflines()
                            self.summary_external_event_offlines.parent = self
                            self._children_name_map["summary_external_event_offlines"] = "summary-external-event-offlines"
                        return self.summary_external_event_offlines

                    if (child_yang_name == "summary-external-event-statistics"):
                        if (self.summary_external_event_statistics is None):
                            self.summary_external_event_statistics = Rcmd.Ospf.Instances.Instance.SummaryExternalEventStatistics()
                            self.summary_external_event_statistics.parent = self
                            self._children_name_map["summary_external_event_statistics"] = "summary-external-event-statistics"
                        return self.summary_external_event_statistics

                    if (child_yang_name == "summary-external-event-summaries"):
                        if (self.summary_external_event_summaries is None):
                            self.summary_external_event_summaries = Rcmd.Ospf.Instances.Instance.SummaryExternalEventSummaries()
                            self.summary_external_event_summaries.parent = self
                            self._children_name_map["summary_external_event_summaries"] = "summary-external-event-summaries"
                        return self.summary_external_event_summaries

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ipfrr-event-offlines" or name == "ipfrr-event-summaries" or name == "prefix-event-offlines" or name == "prefix-event-statistics" or name == "prefix-event-summaries" or name == "spf-run-offlines" or name == "spf-run-summaries" or name == "summary-external-event-offlines" or name == "summary-external-event-statistics" or name == "summary-external-event-summaries" or name == "instance-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "instance-name"):
                        self.instance_name = value
                        self.instance_name.value_namespace = name_space
                        self.instance_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.instance:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.instance:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "instances" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/ospf/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "instance"):
                    for c in self.instance:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Ospf.Instances.Instance()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.instance.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "instance"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.instances is not None and self.instances.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.instances is not None and self.instances.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ospf" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "instances"):
                if (self.instances is None):
                    self.instances = Rcmd.Ospf.Instances()
                    self.instances.parent = self
                    self._children_name_map["instances"] = "instances"
                return self.instances

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "instances"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Server(Entity):
        """
        Server Info
        
        .. attribute:: detail
        
        	Server Info
        	**type**\:   :py:class:`Detail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Detail>`
        
        .. attribute:: normal
        
        	Server Info
        	**type**\:   :py:class:`Normal <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Normal>`
        
        

        """

        _prefix = 'infra-rcmd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Rcmd.Server, self).__init__()

            self.yang_name = "server"
            self.yang_parent_name = "rcmd"

            self.detail = Rcmd.Server.Detail()
            self.detail.parent = self
            self._children_name_map["detail"] = "detail"
            self._children_yang_names.add("detail")

            self.normal = Rcmd.Server.Normal()
            self.normal.parent = self
            self._children_name_map["normal"] = "normal"
            self._children_yang_names.add("normal")


        class Normal(Entity):
            """
            Server Info
            
            .. attribute:: archive_count
            
            	Archive Count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: diag_node_count
            
            	Diag Node count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: diagnostics_archive_node
            
            	Diagnostics Archival Node (Applicable for local location)
            	**type**\:  str
            
            .. attribute:: diagnostics_archive_path
            
            	Diagnostics Archival Path
            	**type**\:  str
            
            .. attribute:: disabled_node_count
            
            	Disabled Node count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: event_buffer_size
            
            	Event Buffer Size
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: host_name
            
            	Configured Hostname
            	**type**\:  str
            
            .. attribute:: in_active_node_count
            
            	Disabled Node count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_count
            
            	Interface events count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: last_archival_error
            
            	Last Archival Error
            	**type**\:  str
            
            .. attribute:: last_archival_error_time
            
            	Last Archival Status
            	**type**\:  str
            
            .. attribute:: last_archival_status
            
            	Last Archival Status
            	**type**\:  str
            
            .. attribute:: last_process_duration
            
            	Last Processing Duration
            	**type**\:  str
            
            .. attribute:: last_process_start_time
            
            	Last Processing Start Time
            	**type**\:  str
            
            .. attribute:: last_process_state
            
            	Process state
            	**type**\:   :py:class:`RcmdShowPrcsState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowPrcsState>`
            
            .. attribute:: max_events
            
            	Maximum Events
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: max_interface_count
            
            	Max Interface events count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: monitoring_interval
            
            	Configured Monitor Interval
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: next_interval
            
            	Time for next processing
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_lc_count
            
            	LC count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_rp_count
            
            	RP count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: process_count
            
            	Post Processing count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: protocol_config
            
            	Protocol level configuration
            	**type**\: list of    :py:class:`ProtocolConfig <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Normal.ProtocolConfig>`
            
            .. attribute:: reports_archive_node
            
            	Reports Archival Node (Applicable for local location)
            	**type**\:  str
            
            .. attribute:: reports_archive_path
            
            	Reports Archival Path
            	**type**\:  str
            
            .. attribute:: server_detail
            
            	Detailed Information
            	**type**\: list of    :py:class:`ServerDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Normal.ServerDetail>`
            
            .. attribute:: spf_process_count
            
            	SPF Processing count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: status
            
            	Server Status
            	**type**\:   :py:class:`RcmdBagEnableDisable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBagEnableDisable>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Server.Normal, self).__init__()

                self.yang_name = "normal"
                self.yang_parent_name = "server"

                self.archive_count = YLeaf(YType.uint32, "archive-count")

                self.diag_node_count = YLeaf(YType.uint32, "diag-node-count")

                self.diagnostics_archive_node = YLeaf(YType.str, "diagnostics-archive-node")

                self.diagnostics_archive_path = YLeaf(YType.str, "diagnostics-archive-path")

                self.disabled_node_count = YLeaf(YType.uint32, "disabled-node-count")

                self.event_buffer_size = YLeaf(YType.uint32, "event-buffer-size")

                self.host_name = YLeaf(YType.str, "host-name")

                self.in_active_node_count = YLeaf(YType.uint32, "in-active-node-count")

                self.interface_count = YLeaf(YType.uint32, "interface-count")

                self.last_archival_error = YLeaf(YType.str, "last-archival-error")

                self.last_archival_error_time = YLeaf(YType.str, "last-archival-error-time")

                self.last_archival_status = YLeaf(YType.str, "last-archival-status")

                self.last_process_duration = YLeaf(YType.str, "last-process-duration")

                self.last_process_start_time = YLeaf(YType.str, "last-process-start-time")

                self.last_process_state = YLeaf(YType.enumeration, "last-process-state")

                self.max_events = YLeaf(YType.uint32, "max-events")

                self.max_interface_count = YLeaf(YType.uint32, "max-interface-count")

                self.monitoring_interval = YLeaf(YType.uint32, "monitoring-interval")

                self.next_interval = YLeaf(YType.uint32, "next-interval")

                self.node_lc_count = YLeaf(YType.uint32, "node-lc-count")

                self.node_rp_count = YLeaf(YType.uint32, "node-rp-count")

                self.process_count = YLeaf(YType.uint32, "process-count")

                self.reports_archive_node = YLeaf(YType.str, "reports-archive-node")

                self.reports_archive_path = YLeaf(YType.str, "reports-archive-path")

                self.spf_process_count = YLeaf(YType.uint32, "spf-process-count")

                self.status = YLeaf(YType.enumeration, "status")

                self.protocol_config = YList(self)
                self.server_detail = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("archive_count",
                                "diag_node_count",
                                "diagnostics_archive_node",
                                "diagnostics_archive_path",
                                "disabled_node_count",
                                "event_buffer_size",
                                "host_name",
                                "in_active_node_count",
                                "interface_count",
                                "last_archival_error",
                                "last_archival_error_time",
                                "last_archival_status",
                                "last_process_duration",
                                "last_process_start_time",
                                "last_process_state",
                                "max_events",
                                "max_interface_count",
                                "monitoring_interval",
                                "next_interval",
                                "node_lc_count",
                                "node_rp_count",
                                "process_count",
                                "reports_archive_node",
                                "reports_archive_path",
                                "spf_process_count",
                                "status") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Server.Normal, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Server.Normal, self).__setattr__(name, value)


            class ProtocolConfig(Entity):
                """
                Protocol level configuration
                
                .. attribute:: priority
                
                	Priority level configuration
                	**type**\: list of    :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Normal.ProtocolConfig.Priority>`
                
                .. attribute:: protocol_name
                
                	Protocol Name
                	**type**\:  str
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Server.Normal.ProtocolConfig, self).__init__()

                    self.yang_name = "protocol-config"
                    self.yang_parent_name = "normal"

                    self.protocol_name = YLeaf(YType.str, "protocol-name")

                    self.priority = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("protocol_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Server.Normal.ProtocolConfig, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Server.Normal.ProtocolConfig, self).__setattr__(name, value)


                class Priority(Entity):
                    """
                    Priority level configuration
                    
                    .. attribute:: disable
                    
                    	Enable/Disable cfg
                    	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
                    
                    .. attribute:: priority_name
                    
                    	Priority Level
                    	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                    
                    .. attribute:: threshold
                    
                    	threshold value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Server.Normal.ProtocolConfig.Priority, self).__init__()

                        self.yang_name = "priority"
                        self.yang_parent_name = "protocol-config"

                        self.disable = YLeaf(YType.enumeration, "disable")

                        self.priority_name = YLeaf(YType.enumeration, "priority-name")

                        self.threshold = YLeaf(YType.uint32, "threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("disable",
                                        "priority_name",
                                        "threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Server.Normal.ProtocolConfig.Priority, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Server.Normal.ProtocolConfig.Priority, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.disable.is_set or
                            self.priority_name.is_set or
                            self.threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.disable.yfilter != YFilter.not_set or
                            self.priority_name.yfilter != YFilter.not_set or
                            self.threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "priority" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/normal/protocol-config/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable.get_name_leafdata())
                        if (self.priority_name.is_set or self.priority_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.priority_name.get_name_leafdata())
                        if (self.threshold.is_set or self.threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "disable" or name == "priority-name" or name == "threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "disable"):
                            self.disable = value
                            self.disable.value_namespace = name_space
                            self.disable.value_namespace_prefix = name_space_prefix
                        if(value_path == "priority-name"):
                            self.priority_name = value
                            self.priority_name.value_namespace = name_space
                            self.priority_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "threshold"):
                            self.threshold = value
                            self.threshold.value_namespace = name_space
                            self.threshold.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.priority:
                        if (c.has_data()):
                            return True
                    return self.protocol_name.is_set

                def has_operation(self):
                    for c in self.priority:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.protocol_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "protocol-config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/normal/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.protocol_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "priority"):
                        for c in self.priority:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Server.Normal.ProtocolConfig.Priority()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.priority.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "priority" or name == "protocol-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "protocol-name"):
                        self.protocol_name = value
                        self.protocol_name.value_namespace = name_space
                        self.protocol_name.value_namespace_prefix = name_space_prefix


            class ServerDetail(Entity):
                """
                Detailed Information
                
                .. attribute:: memory_suspend
                
                	Memory Suspend
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: overload_suspend
                
                	Overload suspend
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: trace_information
                
                	Trace Information
                	**type**\: list of    :py:class:`TraceInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Normal.ServerDetail.TraceInformation>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Server.Normal.ServerDetail, self).__init__()

                    self.yang_name = "server-detail"
                    self.yang_parent_name = "normal"

                    self.memory_suspend = YLeaf(YType.uint32, "memory-suspend")

                    self.overload_suspend = YLeaf(YType.uint32, "overload-suspend")

                    self.trace_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("memory_suspend",
                                    "overload_suspend") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Server.Normal.ServerDetail, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Server.Normal.ServerDetail, self).__setattr__(name, value)


                class TraceInformation(Entity):
                    """
                    Trace Information
                    
                    .. attribute:: error_stats
                    
                    	Server Error Status
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: last_run_stats
                    
                    	Server Last Run Status
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_stats
                    
                    	Server Total Status
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: trace_name
                    
                    	Configured Hostname
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Server.Normal.ServerDetail.TraceInformation, self).__init__()

                        self.yang_name = "trace-information"
                        self.yang_parent_name = "server-detail"

                        self.error_stats = YLeaf(YType.uint32, "error-stats")

                        self.last_run_stats = YLeaf(YType.uint32, "last-run-stats")

                        self.total_stats = YLeaf(YType.uint32, "total-stats")

                        self.trace_name = YLeaf(YType.str, "trace-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("error_stats",
                                        "last_run_stats",
                                        "total_stats",
                                        "trace_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Server.Normal.ServerDetail.TraceInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Server.Normal.ServerDetail.TraceInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.error_stats.is_set or
                            self.last_run_stats.is_set or
                            self.total_stats.is_set or
                            self.trace_name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.error_stats.yfilter != YFilter.not_set or
                            self.last_run_stats.yfilter != YFilter.not_set or
                            self.total_stats.yfilter != YFilter.not_set or
                            self.trace_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "trace-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/normal/server-detail/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.error_stats.is_set or self.error_stats.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.error_stats.get_name_leafdata())
                        if (self.last_run_stats.is_set or self.last_run_stats.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_run_stats.get_name_leafdata())
                        if (self.total_stats.is_set or self.total_stats.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_stats.get_name_leafdata())
                        if (self.trace_name.is_set or self.trace_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.trace_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "error-stats" or name == "last-run-stats" or name == "total-stats" or name == "trace-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "error-stats"):
                            self.error_stats = value
                            self.error_stats.value_namespace = name_space
                            self.error_stats.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-run-stats"):
                            self.last_run_stats = value
                            self.last_run_stats.value_namespace = name_space
                            self.last_run_stats.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-stats"):
                            self.total_stats = value
                            self.total_stats.value_namespace = name_space
                            self.total_stats.value_namespace_prefix = name_space_prefix
                        if(value_path == "trace-name"):
                            self.trace_name = value
                            self.trace_name.value_namespace = name_space
                            self.trace_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.trace_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.memory_suspend.is_set or
                        self.overload_suspend.is_set)

                def has_operation(self):
                    for c in self.trace_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.memory_suspend.yfilter != YFilter.not_set or
                        self.overload_suspend.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "server-detail" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/normal/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.memory_suspend.is_set or self.memory_suspend.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.memory_suspend.get_name_leafdata())
                    if (self.overload_suspend.is_set or self.overload_suspend.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.overload_suspend.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "trace-information"):
                        for c in self.trace_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Server.Normal.ServerDetail.TraceInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.trace_information.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "trace-information" or name == "memory-suspend" or name == "overload-suspend"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "memory-suspend"):
                        self.memory_suspend = value
                        self.memory_suspend.value_namespace = name_space
                        self.memory_suspend.value_namespace_prefix = name_space_prefix
                    if(value_path == "overload-suspend"):
                        self.overload_suspend = value
                        self.overload_suspend.value_namespace = name_space
                        self.overload_suspend.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.protocol_config:
                    if (c.has_data()):
                        return True
                for c in self.server_detail:
                    if (c.has_data()):
                        return True
                return (
                    self.archive_count.is_set or
                    self.diag_node_count.is_set or
                    self.diagnostics_archive_node.is_set or
                    self.diagnostics_archive_path.is_set or
                    self.disabled_node_count.is_set or
                    self.event_buffer_size.is_set or
                    self.host_name.is_set or
                    self.in_active_node_count.is_set or
                    self.interface_count.is_set or
                    self.last_archival_error.is_set or
                    self.last_archival_error_time.is_set or
                    self.last_archival_status.is_set or
                    self.last_process_duration.is_set or
                    self.last_process_start_time.is_set or
                    self.last_process_state.is_set or
                    self.max_events.is_set or
                    self.max_interface_count.is_set or
                    self.monitoring_interval.is_set or
                    self.next_interval.is_set or
                    self.node_lc_count.is_set or
                    self.node_rp_count.is_set or
                    self.process_count.is_set or
                    self.reports_archive_node.is_set or
                    self.reports_archive_path.is_set or
                    self.spf_process_count.is_set or
                    self.status.is_set)

            def has_operation(self):
                for c in self.protocol_config:
                    if (c.has_operation()):
                        return True
                for c in self.server_detail:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.archive_count.yfilter != YFilter.not_set or
                    self.diag_node_count.yfilter != YFilter.not_set or
                    self.diagnostics_archive_node.yfilter != YFilter.not_set or
                    self.diagnostics_archive_path.yfilter != YFilter.not_set or
                    self.disabled_node_count.yfilter != YFilter.not_set or
                    self.event_buffer_size.yfilter != YFilter.not_set or
                    self.host_name.yfilter != YFilter.not_set or
                    self.in_active_node_count.yfilter != YFilter.not_set or
                    self.interface_count.yfilter != YFilter.not_set or
                    self.last_archival_error.yfilter != YFilter.not_set or
                    self.last_archival_error_time.yfilter != YFilter.not_set or
                    self.last_archival_status.yfilter != YFilter.not_set or
                    self.last_process_duration.yfilter != YFilter.not_set or
                    self.last_process_start_time.yfilter != YFilter.not_set or
                    self.last_process_state.yfilter != YFilter.not_set or
                    self.max_events.yfilter != YFilter.not_set or
                    self.max_interface_count.yfilter != YFilter.not_set or
                    self.monitoring_interval.yfilter != YFilter.not_set or
                    self.next_interval.yfilter != YFilter.not_set or
                    self.node_lc_count.yfilter != YFilter.not_set or
                    self.node_rp_count.yfilter != YFilter.not_set or
                    self.process_count.yfilter != YFilter.not_set or
                    self.reports_archive_node.yfilter != YFilter.not_set or
                    self.reports_archive_path.yfilter != YFilter.not_set or
                    self.spf_process_count.yfilter != YFilter.not_set or
                    self.status.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "normal" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.archive_count.is_set or self.archive_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.archive_count.get_name_leafdata())
                if (self.diag_node_count.is_set or self.diag_node_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.diag_node_count.get_name_leafdata())
                if (self.diagnostics_archive_node.is_set or self.diagnostics_archive_node.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.diagnostics_archive_node.get_name_leafdata())
                if (self.diagnostics_archive_path.is_set or self.diagnostics_archive_path.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.diagnostics_archive_path.get_name_leafdata())
                if (self.disabled_node_count.is_set or self.disabled_node_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.disabled_node_count.get_name_leafdata())
                if (self.event_buffer_size.is_set or self.event_buffer_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.event_buffer_size.get_name_leafdata())
                if (self.host_name.is_set or self.host_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.host_name.get_name_leafdata())
                if (self.in_active_node_count.is_set or self.in_active_node_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.in_active_node_count.get_name_leafdata())
                if (self.interface_count.is_set or self.interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_count.get_name_leafdata())
                if (self.last_archival_error.is_set or self.last_archival_error.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_archival_error.get_name_leafdata())
                if (self.last_archival_error_time.is_set or self.last_archival_error_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_archival_error_time.get_name_leafdata())
                if (self.last_archival_status.is_set or self.last_archival_status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_archival_status.get_name_leafdata())
                if (self.last_process_duration.is_set or self.last_process_duration.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_process_duration.get_name_leafdata())
                if (self.last_process_start_time.is_set or self.last_process_start_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_process_start_time.get_name_leafdata())
                if (self.last_process_state.is_set or self.last_process_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_process_state.get_name_leafdata())
                if (self.max_events.is_set or self.max_events.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_events.get_name_leafdata())
                if (self.max_interface_count.is_set or self.max_interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_interface_count.get_name_leafdata())
                if (self.monitoring_interval.is_set or self.monitoring_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.monitoring_interval.get_name_leafdata())
                if (self.next_interval.is_set or self.next_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.next_interval.get_name_leafdata())
                if (self.node_lc_count.is_set or self.node_lc_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_lc_count.get_name_leafdata())
                if (self.node_rp_count.is_set or self.node_rp_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_rp_count.get_name_leafdata())
                if (self.process_count.is_set or self.process_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.process_count.get_name_leafdata())
                if (self.reports_archive_node.is_set or self.reports_archive_node.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.reports_archive_node.get_name_leafdata())
                if (self.reports_archive_path.is_set or self.reports_archive_path.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.reports_archive_path.get_name_leafdata())
                if (self.spf_process_count.is_set or self.spf_process_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.spf_process_count.get_name_leafdata())
                if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.status.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "protocol-config"):
                    for c in self.protocol_config:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Server.Normal.ProtocolConfig()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.protocol_config.append(c)
                    return c

                if (child_yang_name == "server-detail"):
                    for c in self.server_detail:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Server.Normal.ServerDetail()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.server_detail.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "protocol-config" or name == "server-detail" or name == "archive-count" or name == "diag-node-count" or name == "diagnostics-archive-node" or name == "diagnostics-archive-path" or name == "disabled-node-count" or name == "event-buffer-size" or name == "host-name" or name == "in-active-node-count" or name == "interface-count" or name == "last-archival-error" or name == "last-archival-error-time" or name == "last-archival-status" or name == "last-process-duration" or name == "last-process-start-time" or name == "last-process-state" or name == "max-events" or name == "max-interface-count" or name == "monitoring-interval" or name == "next-interval" or name == "node-lc-count" or name == "node-rp-count" or name == "process-count" or name == "reports-archive-node" or name == "reports-archive-path" or name == "spf-process-count" or name == "status"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "archive-count"):
                    self.archive_count = value
                    self.archive_count.value_namespace = name_space
                    self.archive_count.value_namespace_prefix = name_space_prefix
                if(value_path == "diag-node-count"):
                    self.diag_node_count = value
                    self.diag_node_count.value_namespace = name_space
                    self.diag_node_count.value_namespace_prefix = name_space_prefix
                if(value_path == "diagnostics-archive-node"):
                    self.diagnostics_archive_node = value
                    self.diagnostics_archive_node.value_namespace = name_space
                    self.diagnostics_archive_node.value_namespace_prefix = name_space_prefix
                if(value_path == "diagnostics-archive-path"):
                    self.diagnostics_archive_path = value
                    self.diagnostics_archive_path.value_namespace = name_space
                    self.diagnostics_archive_path.value_namespace_prefix = name_space_prefix
                if(value_path == "disabled-node-count"):
                    self.disabled_node_count = value
                    self.disabled_node_count.value_namespace = name_space
                    self.disabled_node_count.value_namespace_prefix = name_space_prefix
                if(value_path == "event-buffer-size"):
                    self.event_buffer_size = value
                    self.event_buffer_size.value_namespace = name_space
                    self.event_buffer_size.value_namespace_prefix = name_space_prefix
                if(value_path == "host-name"):
                    self.host_name = value
                    self.host_name.value_namespace = name_space
                    self.host_name.value_namespace_prefix = name_space_prefix
                if(value_path == "in-active-node-count"):
                    self.in_active_node_count = value
                    self.in_active_node_count.value_namespace = name_space
                    self.in_active_node_count.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-count"):
                    self.interface_count = value
                    self.interface_count.value_namespace = name_space
                    self.interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "last-archival-error"):
                    self.last_archival_error = value
                    self.last_archival_error.value_namespace = name_space
                    self.last_archival_error.value_namespace_prefix = name_space_prefix
                if(value_path == "last-archival-error-time"):
                    self.last_archival_error_time = value
                    self.last_archival_error_time.value_namespace = name_space
                    self.last_archival_error_time.value_namespace_prefix = name_space_prefix
                if(value_path == "last-archival-status"):
                    self.last_archival_status = value
                    self.last_archival_status.value_namespace = name_space
                    self.last_archival_status.value_namespace_prefix = name_space_prefix
                if(value_path == "last-process-duration"):
                    self.last_process_duration = value
                    self.last_process_duration.value_namespace = name_space
                    self.last_process_duration.value_namespace_prefix = name_space_prefix
                if(value_path == "last-process-start-time"):
                    self.last_process_start_time = value
                    self.last_process_start_time.value_namespace = name_space
                    self.last_process_start_time.value_namespace_prefix = name_space_prefix
                if(value_path == "last-process-state"):
                    self.last_process_state = value
                    self.last_process_state.value_namespace = name_space
                    self.last_process_state.value_namespace_prefix = name_space_prefix
                if(value_path == "max-events"):
                    self.max_events = value
                    self.max_events.value_namespace = name_space
                    self.max_events.value_namespace_prefix = name_space_prefix
                if(value_path == "max-interface-count"):
                    self.max_interface_count = value
                    self.max_interface_count.value_namespace = name_space
                    self.max_interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "monitoring-interval"):
                    self.monitoring_interval = value
                    self.monitoring_interval.value_namespace = name_space
                    self.monitoring_interval.value_namespace_prefix = name_space_prefix
                if(value_path == "next-interval"):
                    self.next_interval = value
                    self.next_interval.value_namespace = name_space
                    self.next_interval.value_namespace_prefix = name_space_prefix
                if(value_path == "node-lc-count"):
                    self.node_lc_count = value
                    self.node_lc_count.value_namespace = name_space
                    self.node_lc_count.value_namespace_prefix = name_space_prefix
                if(value_path == "node-rp-count"):
                    self.node_rp_count = value
                    self.node_rp_count.value_namespace = name_space
                    self.node_rp_count.value_namespace_prefix = name_space_prefix
                if(value_path == "process-count"):
                    self.process_count = value
                    self.process_count.value_namespace = name_space
                    self.process_count.value_namespace_prefix = name_space_prefix
                if(value_path == "reports-archive-node"):
                    self.reports_archive_node = value
                    self.reports_archive_node.value_namespace = name_space
                    self.reports_archive_node.value_namespace_prefix = name_space_prefix
                if(value_path == "reports-archive-path"):
                    self.reports_archive_path = value
                    self.reports_archive_path.value_namespace = name_space
                    self.reports_archive_path.value_namespace_prefix = name_space_prefix
                if(value_path == "spf-process-count"):
                    self.spf_process_count = value
                    self.spf_process_count.value_namespace = name_space
                    self.spf_process_count.value_namespace_prefix = name_space_prefix
                if(value_path == "status"):
                    self.status = value
                    self.status.value_namespace = name_space
                    self.status.value_namespace_prefix = name_space_prefix


        class Detail(Entity):
            """
            Server Info
            
            .. attribute:: archive_count
            
            	Archive Count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: diag_node_count
            
            	Diag Node count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: diagnostics_archive_node
            
            	Diagnostics Archival Node (Applicable for local location)
            	**type**\:  str
            
            .. attribute:: diagnostics_archive_path
            
            	Diagnostics Archival Path
            	**type**\:  str
            
            .. attribute:: disabled_node_count
            
            	Disabled Node count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: event_buffer_size
            
            	Event Buffer Size
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: host_name
            
            	Configured Hostname
            	**type**\:  str
            
            .. attribute:: in_active_node_count
            
            	Disabled Node count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: interface_count
            
            	Interface events count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: last_archival_error
            
            	Last Archival Error
            	**type**\:  str
            
            .. attribute:: last_archival_error_time
            
            	Last Archival Status
            	**type**\:  str
            
            .. attribute:: last_archival_status
            
            	Last Archival Status
            	**type**\:  str
            
            .. attribute:: last_process_duration
            
            	Last Processing Duration
            	**type**\:  str
            
            .. attribute:: last_process_start_time
            
            	Last Processing Start Time
            	**type**\:  str
            
            .. attribute:: last_process_state
            
            	Process state
            	**type**\:   :py:class:`RcmdShowPrcsState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowPrcsState>`
            
            .. attribute:: max_events
            
            	Maximum Events
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: max_interface_count
            
            	Max Interface events count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: monitoring_interval
            
            	Configured Monitor Interval
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: next_interval
            
            	Time for next processing
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_lc_count
            
            	LC count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_rp_count
            
            	RP count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: process_count
            
            	Post Processing count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: protocol_config
            
            	Protocol level configuration
            	**type**\: list of    :py:class:`ProtocolConfig <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Detail.ProtocolConfig>`
            
            .. attribute:: reports_archive_node
            
            	Reports Archival Node (Applicable for local location)
            	**type**\:  str
            
            .. attribute:: reports_archive_path
            
            	Reports Archival Path
            	**type**\:  str
            
            .. attribute:: server_detail
            
            	Detailed Information
            	**type**\: list of    :py:class:`ServerDetail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Detail.ServerDetail>`
            
            .. attribute:: spf_process_count
            
            	SPF Processing count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: status
            
            	Server Status
            	**type**\:   :py:class:`RcmdBagEnableDisable <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBagEnableDisable>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Server.Detail, self).__init__()

                self.yang_name = "detail"
                self.yang_parent_name = "server"

                self.archive_count = YLeaf(YType.uint32, "archive-count")

                self.diag_node_count = YLeaf(YType.uint32, "diag-node-count")

                self.diagnostics_archive_node = YLeaf(YType.str, "diagnostics-archive-node")

                self.diagnostics_archive_path = YLeaf(YType.str, "diagnostics-archive-path")

                self.disabled_node_count = YLeaf(YType.uint32, "disabled-node-count")

                self.event_buffer_size = YLeaf(YType.uint32, "event-buffer-size")

                self.host_name = YLeaf(YType.str, "host-name")

                self.in_active_node_count = YLeaf(YType.uint32, "in-active-node-count")

                self.interface_count = YLeaf(YType.uint32, "interface-count")

                self.last_archival_error = YLeaf(YType.str, "last-archival-error")

                self.last_archival_error_time = YLeaf(YType.str, "last-archival-error-time")

                self.last_archival_status = YLeaf(YType.str, "last-archival-status")

                self.last_process_duration = YLeaf(YType.str, "last-process-duration")

                self.last_process_start_time = YLeaf(YType.str, "last-process-start-time")

                self.last_process_state = YLeaf(YType.enumeration, "last-process-state")

                self.max_events = YLeaf(YType.uint32, "max-events")

                self.max_interface_count = YLeaf(YType.uint32, "max-interface-count")

                self.monitoring_interval = YLeaf(YType.uint32, "monitoring-interval")

                self.next_interval = YLeaf(YType.uint32, "next-interval")

                self.node_lc_count = YLeaf(YType.uint32, "node-lc-count")

                self.node_rp_count = YLeaf(YType.uint32, "node-rp-count")

                self.process_count = YLeaf(YType.uint32, "process-count")

                self.reports_archive_node = YLeaf(YType.str, "reports-archive-node")

                self.reports_archive_path = YLeaf(YType.str, "reports-archive-path")

                self.spf_process_count = YLeaf(YType.uint32, "spf-process-count")

                self.status = YLeaf(YType.enumeration, "status")

                self.protocol_config = YList(self)
                self.server_detail = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("archive_count",
                                "diag_node_count",
                                "diagnostics_archive_node",
                                "diagnostics_archive_path",
                                "disabled_node_count",
                                "event_buffer_size",
                                "host_name",
                                "in_active_node_count",
                                "interface_count",
                                "last_archival_error",
                                "last_archival_error_time",
                                "last_archival_status",
                                "last_process_duration",
                                "last_process_start_time",
                                "last_process_state",
                                "max_events",
                                "max_interface_count",
                                "monitoring_interval",
                                "next_interval",
                                "node_lc_count",
                                "node_rp_count",
                                "process_count",
                                "reports_archive_node",
                                "reports_archive_path",
                                "spf_process_count",
                                "status") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Server.Detail, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Server.Detail, self).__setattr__(name, value)


            class ProtocolConfig(Entity):
                """
                Protocol level configuration
                
                .. attribute:: priority
                
                	Priority level configuration
                	**type**\: list of    :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Detail.ProtocolConfig.Priority>`
                
                .. attribute:: protocol_name
                
                	Protocol Name
                	**type**\:  str
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Server.Detail.ProtocolConfig, self).__init__()

                    self.yang_name = "protocol-config"
                    self.yang_parent_name = "detail"

                    self.protocol_name = YLeaf(YType.str, "protocol-name")

                    self.priority = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("protocol_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Server.Detail.ProtocolConfig, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Server.Detail.ProtocolConfig, self).__setattr__(name, value)


                class Priority(Entity):
                    """
                    Priority level configuration
                    
                    .. attribute:: disable
                    
                    	Enable/Disable cfg
                    	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
                    
                    .. attribute:: priority_name
                    
                    	Priority Level
                    	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                    
                    .. attribute:: threshold
                    
                    	threshold value
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Server.Detail.ProtocolConfig.Priority, self).__init__()

                        self.yang_name = "priority"
                        self.yang_parent_name = "protocol-config"

                        self.disable = YLeaf(YType.enumeration, "disable")

                        self.priority_name = YLeaf(YType.enumeration, "priority-name")

                        self.threshold = YLeaf(YType.uint32, "threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("disable",
                                        "priority_name",
                                        "threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Server.Detail.ProtocolConfig.Priority, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Server.Detail.ProtocolConfig.Priority, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.disable.is_set or
                            self.priority_name.is_set or
                            self.threshold.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.disable.yfilter != YFilter.not_set or
                            self.priority_name.yfilter != YFilter.not_set or
                            self.threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "priority" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/detail/protocol-config/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable.get_name_leafdata())
                        if (self.priority_name.is_set or self.priority_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.priority_name.get_name_leafdata())
                        if (self.threshold.is_set or self.threshold.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "disable" or name == "priority-name" or name == "threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "disable"):
                            self.disable = value
                            self.disable.value_namespace = name_space
                            self.disable.value_namespace_prefix = name_space_prefix
                        if(value_path == "priority-name"):
                            self.priority_name = value
                            self.priority_name.value_namespace = name_space
                            self.priority_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "threshold"):
                            self.threshold = value
                            self.threshold.value_namespace = name_space
                            self.threshold.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.priority:
                        if (c.has_data()):
                            return True
                    return self.protocol_name.is_set

                def has_operation(self):
                    for c in self.priority:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.protocol_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "protocol-config" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.protocol_name.is_set or self.protocol_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.protocol_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "priority"):
                        for c in self.priority:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Server.Detail.ProtocolConfig.Priority()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.priority.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "priority" or name == "protocol-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "protocol-name"):
                        self.protocol_name = value
                        self.protocol_name.value_namespace = name_space
                        self.protocol_name.value_namespace_prefix = name_space_prefix


            class ServerDetail(Entity):
                """
                Detailed Information
                
                .. attribute:: memory_suspend
                
                	Memory Suspend
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: overload_suspend
                
                	Overload suspend
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: trace_information
                
                	Trace Information
                	**type**\: list of    :py:class:`TraceInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Server.Detail.ServerDetail.TraceInformation>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Server.Detail.ServerDetail, self).__init__()

                    self.yang_name = "server-detail"
                    self.yang_parent_name = "detail"

                    self.memory_suspend = YLeaf(YType.uint32, "memory-suspend")

                    self.overload_suspend = YLeaf(YType.uint32, "overload-suspend")

                    self.trace_information = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("memory_suspend",
                                    "overload_suspend") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Server.Detail.ServerDetail, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Server.Detail.ServerDetail, self).__setattr__(name, value)


                class TraceInformation(Entity):
                    """
                    Trace Information
                    
                    .. attribute:: error_stats
                    
                    	Server Error Status
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: last_run_stats
                    
                    	Server Last Run Status
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_stats
                    
                    	Server Total Status
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: trace_name
                    
                    	Configured Hostname
                    	**type**\:  str
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Server.Detail.ServerDetail.TraceInformation, self).__init__()

                        self.yang_name = "trace-information"
                        self.yang_parent_name = "server-detail"

                        self.error_stats = YLeaf(YType.uint32, "error-stats")

                        self.last_run_stats = YLeaf(YType.uint32, "last-run-stats")

                        self.total_stats = YLeaf(YType.uint32, "total-stats")

                        self.trace_name = YLeaf(YType.str, "trace-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("error_stats",
                                        "last_run_stats",
                                        "total_stats",
                                        "trace_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Server.Detail.ServerDetail.TraceInformation, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Server.Detail.ServerDetail.TraceInformation, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.error_stats.is_set or
                            self.last_run_stats.is_set or
                            self.total_stats.is_set or
                            self.trace_name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.error_stats.yfilter != YFilter.not_set or
                            self.last_run_stats.yfilter != YFilter.not_set or
                            self.total_stats.yfilter != YFilter.not_set or
                            self.trace_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "trace-information" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/detail/server-detail/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.error_stats.is_set or self.error_stats.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.error_stats.get_name_leafdata())
                        if (self.last_run_stats.is_set or self.last_run_stats.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_run_stats.get_name_leafdata())
                        if (self.total_stats.is_set or self.total_stats.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_stats.get_name_leafdata())
                        if (self.trace_name.is_set or self.trace_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.trace_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "error-stats" or name == "last-run-stats" or name == "total-stats" or name == "trace-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "error-stats"):
                            self.error_stats = value
                            self.error_stats.value_namespace = name_space
                            self.error_stats.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-run-stats"):
                            self.last_run_stats = value
                            self.last_run_stats.value_namespace = name_space
                            self.last_run_stats.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-stats"):
                            self.total_stats = value
                            self.total_stats.value_namespace = name_space
                            self.total_stats.value_namespace_prefix = name_space_prefix
                        if(value_path == "trace-name"):
                            self.trace_name = value
                            self.trace_name.value_namespace = name_space
                            self.trace_name.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.trace_information:
                        if (c.has_data()):
                            return True
                    return (
                        self.memory_suspend.is_set or
                        self.overload_suspend.is_set)

                def has_operation(self):
                    for c in self.trace_information:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.memory_suspend.yfilter != YFilter.not_set or
                        self.overload_suspend.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "server-detail" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/detail/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.memory_suspend.is_set or self.memory_suspend.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.memory_suspend.get_name_leafdata())
                    if (self.overload_suspend.is_set or self.overload_suspend.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.overload_suspend.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "trace-information"):
                        for c in self.trace_information:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Server.Detail.ServerDetail.TraceInformation()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.trace_information.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "trace-information" or name == "memory-suspend" or name == "overload-suspend"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "memory-suspend"):
                        self.memory_suspend = value
                        self.memory_suspend.value_namespace = name_space
                        self.memory_suspend.value_namespace_prefix = name_space_prefix
                    if(value_path == "overload-suspend"):
                        self.overload_suspend = value
                        self.overload_suspend.value_namespace = name_space
                        self.overload_suspend.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.protocol_config:
                    if (c.has_data()):
                        return True
                for c in self.server_detail:
                    if (c.has_data()):
                        return True
                return (
                    self.archive_count.is_set or
                    self.diag_node_count.is_set or
                    self.diagnostics_archive_node.is_set or
                    self.diagnostics_archive_path.is_set or
                    self.disabled_node_count.is_set or
                    self.event_buffer_size.is_set or
                    self.host_name.is_set or
                    self.in_active_node_count.is_set or
                    self.interface_count.is_set or
                    self.last_archival_error.is_set or
                    self.last_archival_error_time.is_set or
                    self.last_archival_status.is_set or
                    self.last_process_duration.is_set or
                    self.last_process_start_time.is_set or
                    self.last_process_state.is_set or
                    self.max_events.is_set or
                    self.max_interface_count.is_set or
                    self.monitoring_interval.is_set or
                    self.next_interval.is_set or
                    self.node_lc_count.is_set or
                    self.node_rp_count.is_set or
                    self.process_count.is_set or
                    self.reports_archive_node.is_set or
                    self.reports_archive_path.is_set or
                    self.spf_process_count.is_set or
                    self.status.is_set)

            def has_operation(self):
                for c in self.protocol_config:
                    if (c.has_operation()):
                        return True
                for c in self.server_detail:
                    if (c.has_operation()):
                        return True
                return (
                    self.yfilter != YFilter.not_set or
                    self.archive_count.yfilter != YFilter.not_set or
                    self.diag_node_count.yfilter != YFilter.not_set or
                    self.diagnostics_archive_node.yfilter != YFilter.not_set or
                    self.diagnostics_archive_path.yfilter != YFilter.not_set or
                    self.disabled_node_count.yfilter != YFilter.not_set or
                    self.event_buffer_size.yfilter != YFilter.not_set or
                    self.host_name.yfilter != YFilter.not_set or
                    self.in_active_node_count.yfilter != YFilter.not_set or
                    self.interface_count.yfilter != YFilter.not_set or
                    self.last_archival_error.yfilter != YFilter.not_set or
                    self.last_archival_error_time.yfilter != YFilter.not_set or
                    self.last_archival_status.yfilter != YFilter.not_set or
                    self.last_process_duration.yfilter != YFilter.not_set or
                    self.last_process_start_time.yfilter != YFilter.not_set or
                    self.last_process_state.yfilter != YFilter.not_set or
                    self.max_events.yfilter != YFilter.not_set or
                    self.max_interface_count.yfilter != YFilter.not_set or
                    self.monitoring_interval.yfilter != YFilter.not_set or
                    self.next_interval.yfilter != YFilter.not_set or
                    self.node_lc_count.yfilter != YFilter.not_set or
                    self.node_rp_count.yfilter != YFilter.not_set or
                    self.process_count.yfilter != YFilter.not_set or
                    self.reports_archive_node.yfilter != YFilter.not_set or
                    self.reports_archive_path.yfilter != YFilter.not_set or
                    self.spf_process_count.yfilter != YFilter.not_set or
                    self.status.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "detail" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/server/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.archive_count.is_set or self.archive_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.archive_count.get_name_leafdata())
                if (self.diag_node_count.is_set or self.diag_node_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.diag_node_count.get_name_leafdata())
                if (self.diagnostics_archive_node.is_set or self.diagnostics_archive_node.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.diagnostics_archive_node.get_name_leafdata())
                if (self.diagnostics_archive_path.is_set or self.diagnostics_archive_path.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.diagnostics_archive_path.get_name_leafdata())
                if (self.disabled_node_count.is_set or self.disabled_node_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.disabled_node_count.get_name_leafdata())
                if (self.event_buffer_size.is_set or self.event_buffer_size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.event_buffer_size.get_name_leafdata())
                if (self.host_name.is_set or self.host_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.host_name.get_name_leafdata())
                if (self.in_active_node_count.is_set or self.in_active_node_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.in_active_node_count.get_name_leafdata())
                if (self.interface_count.is_set or self.interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_count.get_name_leafdata())
                if (self.last_archival_error.is_set or self.last_archival_error.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_archival_error.get_name_leafdata())
                if (self.last_archival_error_time.is_set or self.last_archival_error_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_archival_error_time.get_name_leafdata())
                if (self.last_archival_status.is_set or self.last_archival_status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_archival_status.get_name_leafdata())
                if (self.last_process_duration.is_set or self.last_process_duration.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_process_duration.get_name_leafdata())
                if (self.last_process_start_time.is_set or self.last_process_start_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_process_start_time.get_name_leafdata())
                if (self.last_process_state.is_set or self.last_process_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_process_state.get_name_leafdata())
                if (self.max_events.is_set or self.max_events.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_events.get_name_leafdata())
                if (self.max_interface_count.is_set or self.max_interface_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.max_interface_count.get_name_leafdata())
                if (self.monitoring_interval.is_set or self.monitoring_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.monitoring_interval.get_name_leafdata())
                if (self.next_interval.is_set or self.next_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.next_interval.get_name_leafdata())
                if (self.node_lc_count.is_set or self.node_lc_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_lc_count.get_name_leafdata())
                if (self.node_rp_count.is_set or self.node_rp_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_rp_count.get_name_leafdata())
                if (self.process_count.is_set or self.process_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.process_count.get_name_leafdata())
                if (self.reports_archive_node.is_set or self.reports_archive_node.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.reports_archive_node.get_name_leafdata())
                if (self.reports_archive_path.is_set or self.reports_archive_path.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.reports_archive_path.get_name_leafdata())
                if (self.spf_process_count.is_set or self.spf_process_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.spf_process_count.get_name_leafdata())
                if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.status.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "protocol-config"):
                    for c in self.protocol_config:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Server.Detail.ProtocolConfig()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.protocol_config.append(c)
                    return c

                if (child_yang_name == "server-detail"):
                    for c in self.server_detail:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Server.Detail.ServerDetail()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.server_detail.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "protocol-config" or name == "server-detail" or name == "archive-count" or name == "diag-node-count" or name == "diagnostics-archive-node" or name == "diagnostics-archive-path" or name == "disabled-node-count" or name == "event-buffer-size" or name == "host-name" or name == "in-active-node-count" or name == "interface-count" or name == "last-archival-error" or name == "last-archival-error-time" or name == "last-archival-status" or name == "last-process-duration" or name == "last-process-start-time" or name == "last-process-state" or name == "max-events" or name == "max-interface-count" or name == "monitoring-interval" or name == "next-interval" or name == "node-lc-count" or name == "node-rp-count" or name == "process-count" or name == "reports-archive-node" or name == "reports-archive-path" or name == "spf-process-count" or name == "status"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "archive-count"):
                    self.archive_count = value
                    self.archive_count.value_namespace = name_space
                    self.archive_count.value_namespace_prefix = name_space_prefix
                if(value_path == "diag-node-count"):
                    self.diag_node_count = value
                    self.diag_node_count.value_namespace = name_space
                    self.diag_node_count.value_namespace_prefix = name_space_prefix
                if(value_path == "diagnostics-archive-node"):
                    self.diagnostics_archive_node = value
                    self.diagnostics_archive_node.value_namespace = name_space
                    self.diagnostics_archive_node.value_namespace_prefix = name_space_prefix
                if(value_path == "diagnostics-archive-path"):
                    self.diagnostics_archive_path = value
                    self.diagnostics_archive_path.value_namespace = name_space
                    self.diagnostics_archive_path.value_namespace_prefix = name_space_prefix
                if(value_path == "disabled-node-count"):
                    self.disabled_node_count = value
                    self.disabled_node_count.value_namespace = name_space
                    self.disabled_node_count.value_namespace_prefix = name_space_prefix
                if(value_path == "event-buffer-size"):
                    self.event_buffer_size = value
                    self.event_buffer_size.value_namespace = name_space
                    self.event_buffer_size.value_namespace_prefix = name_space_prefix
                if(value_path == "host-name"):
                    self.host_name = value
                    self.host_name.value_namespace = name_space
                    self.host_name.value_namespace_prefix = name_space_prefix
                if(value_path == "in-active-node-count"):
                    self.in_active_node_count = value
                    self.in_active_node_count.value_namespace = name_space
                    self.in_active_node_count.value_namespace_prefix = name_space_prefix
                if(value_path == "interface-count"):
                    self.interface_count = value
                    self.interface_count.value_namespace = name_space
                    self.interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "last-archival-error"):
                    self.last_archival_error = value
                    self.last_archival_error.value_namespace = name_space
                    self.last_archival_error.value_namespace_prefix = name_space_prefix
                if(value_path == "last-archival-error-time"):
                    self.last_archival_error_time = value
                    self.last_archival_error_time.value_namespace = name_space
                    self.last_archival_error_time.value_namespace_prefix = name_space_prefix
                if(value_path == "last-archival-status"):
                    self.last_archival_status = value
                    self.last_archival_status.value_namespace = name_space
                    self.last_archival_status.value_namespace_prefix = name_space_prefix
                if(value_path == "last-process-duration"):
                    self.last_process_duration = value
                    self.last_process_duration.value_namespace = name_space
                    self.last_process_duration.value_namespace_prefix = name_space_prefix
                if(value_path == "last-process-start-time"):
                    self.last_process_start_time = value
                    self.last_process_start_time.value_namespace = name_space
                    self.last_process_start_time.value_namespace_prefix = name_space_prefix
                if(value_path == "last-process-state"):
                    self.last_process_state = value
                    self.last_process_state.value_namespace = name_space
                    self.last_process_state.value_namespace_prefix = name_space_prefix
                if(value_path == "max-events"):
                    self.max_events = value
                    self.max_events.value_namespace = name_space
                    self.max_events.value_namespace_prefix = name_space_prefix
                if(value_path == "max-interface-count"):
                    self.max_interface_count = value
                    self.max_interface_count.value_namespace = name_space
                    self.max_interface_count.value_namespace_prefix = name_space_prefix
                if(value_path == "monitoring-interval"):
                    self.monitoring_interval = value
                    self.monitoring_interval.value_namespace = name_space
                    self.monitoring_interval.value_namespace_prefix = name_space_prefix
                if(value_path == "next-interval"):
                    self.next_interval = value
                    self.next_interval.value_namespace = name_space
                    self.next_interval.value_namespace_prefix = name_space_prefix
                if(value_path == "node-lc-count"):
                    self.node_lc_count = value
                    self.node_lc_count.value_namespace = name_space
                    self.node_lc_count.value_namespace_prefix = name_space_prefix
                if(value_path == "node-rp-count"):
                    self.node_rp_count = value
                    self.node_rp_count.value_namespace = name_space
                    self.node_rp_count.value_namespace_prefix = name_space_prefix
                if(value_path == "process-count"):
                    self.process_count = value
                    self.process_count.value_namespace = name_space
                    self.process_count.value_namespace_prefix = name_space_prefix
                if(value_path == "reports-archive-node"):
                    self.reports_archive_node = value
                    self.reports_archive_node.value_namespace = name_space
                    self.reports_archive_node.value_namespace_prefix = name_space_prefix
                if(value_path == "reports-archive-path"):
                    self.reports_archive_path = value
                    self.reports_archive_path.value_namespace = name_space
                    self.reports_archive_path.value_namespace_prefix = name_space_prefix
                if(value_path == "spf-process-count"):
                    self.spf_process_count = value
                    self.spf_process_count.value_namespace = name_space
                    self.spf_process_count.value_namespace_prefix = name_space_prefix
                if(value_path == "status"):
                    self.status = value
                    self.status.value_namespace = name_space
                    self.status.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                (self.detail is not None and self.detail.has_data()) or
                (self.normal is not None and self.normal.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.detail is not None and self.detail.has_operation()) or
                (self.normal is not None and self.normal.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "server" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "detail"):
                if (self.detail is None):
                    self.detail = Rcmd.Server.Detail()
                    self.detail.parent = self
                    self._children_name_map["detail"] = "detail"
                return self.detail

            if (child_yang_name == "normal"):
                if (self.normal is None):
                    self.normal = Rcmd.Server.Normal()
                    self.normal.parent = self
                    self._children_name_map["normal"] = "normal"
                return self.normal

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "detail" or name == "normal"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Node(Entity):
        """
        Node Info
        
        .. attribute:: node_information
        
        	Node Info
        	**type**\: list of    :py:class:`NodeInformation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Node.NodeInformation>`
        
        

        """

        _prefix = 'infra-rcmd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Rcmd.Node, self).__init__()

            self.yang_name = "node"
            self.yang_parent_name = "rcmd"

            self.node_information = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Rcmd.Node, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Rcmd.Node, self).__setattr__(name, value)


        class NodeInformation(Entity):
            """
            Node Info
            
            .. attribute:: card_state
            
            	Card State
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: diag_mode
            
            	Diag Mode
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: fwd_referenced
            
            	Forward Referenced
            	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
            
            .. attribute:: last_update_time
            
            	Last Updated Time
            	**type**\:  str
            
            .. attribute:: node_id
            
            	Node Id
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: node_name
            
            	Node Name
            	**type**\:  str
            
            .. attribute:: node_state
            
            	Node State
            	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
            
            .. attribute:: node_type
            
            	Node Type
            	**type**\:   :py:class:`RcmdShowNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowNode>`
            
            .. attribute:: rack_id
            
            	Rack Id
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: redundancy_state
            
            	Redundancy State
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: software_state
            
            	Software State
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: status
            
            	Status
            	**type**\:   :py:class:`RcmdBagEnblDsbl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBagEnblDsbl>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Node.NodeInformation, self).__init__()

                self.yang_name = "node-information"
                self.yang_parent_name = "node"

                self.card_state = YLeaf(YType.uint32, "card-state")

                self.diag_mode = YLeaf(YType.uint32, "diag-mode")

                self.fwd_referenced = YLeaf(YType.enumeration, "fwd-referenced")

                self.last_update_time = YLeaf(YType.str, "last-update-time")

                self.node_id = YLeaf(YType.uint32, "node-id")

                self.node_name = YLeaf(YType.str, "node-name")

                self.node_state = YLeaf(YType.enumeration, "node-state")

                self.node_type = YLeaf(YType.enumeration, "node-type")

                self.rack_id = YLeaf(YType.uint32, "rack-id")

                self.redundancy_state = YLeaf(YType.uint32, "redundancy-state")

                self.software_state = YLeaf(YType.uint32, "software-state")

                self.status = YLeaf(YType.enumeration, "status")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("card_state",
                                "diag_mode",
                                "fwd_referenced",
                                "last_update_time",
                                "node_id",
                                "node_name",
                                "node_state",
                                "node_type",
                                "rack_id",
                                "redundancy_state",
                                "software_state",
                                "status") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Node.NodeInformation, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Node.NodeInformation, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.card_state.is_set or
                    self.diag_mode.is_set or
                    self.fwd_referenced.is_set or
                    self.last_update_time.is_set or
                    self.node_id.is_set or
                    self.node_name.is_set or
                    self.node_state.is_set or
                    self.node_type.is_set or
                    self.rack_id.is_set or
                    self.redundancy_state.is_set or
                    self.software_state.is_set or
                    self.status.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.card_state.yfilter != YFilter.not_set or
                    self.diag_mode.yfilter != YFilter.not_set or
                    self.fwd_referenced.yfilter != YFilter.not_set or
                    self.last_update_time.yfilter != YFilter.not_set or
                    self.node_id.yfilter != YFilter.not_set or
                    self.node_name.yfilter != YFilter.not_set or
                    self.node_state.yfilter != YFilter.not_set or
                    self.node_type.yfilter != YFilter.not_set or
                    self.rack_id.yfilter != YFilter.not_set or
                    self.redundancy_state.yfilter != YFilter.not_set or
                    self.software_state.yfilter != YFilter.not_set or
                    self.status.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "node-information" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/node/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.card_state.is_set or self.card_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.card_state.get_name_leafdata())
                if (self.diag_mode.is_set or self.diag_mode.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.diag_mode.get_name_leafdata())
                if (self.fwd_referenced.is_set or self.fwd_referenced.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.fwd_referenced.get_name_leafdata())
                if (self.last_update_time.is_set or self.last_update_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.last_update_time.get_name_leafdata())
                if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_id.get_name_leafdata())
                if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_name.get_name_leafdata())
                if (self.node_state.is_set or self.node_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_state.get_name_leafdata())
                if (self.node_type.is_set or self.node_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.node_type.get_name_leafdata())
                if (self.rack_id.is_set or self.rack_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.rack_id.get_name_leafdata())
                if (self.redundancy_state.is_set or self.redundancy_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.redundancy_state.get_name_leafdata())
                if (self.software_state.is_set or self.software_state.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.software_state.get_name_leafdata())
                if (self.status.is_set or self.status.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.status.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "card-state" or name == "diag-mode" or name == "fwd-referenced" or name == "last-update-time" or name == "node-id" or name == "node-name" or name == "node-state" or name == "node-type" or name == "rack-id" or name == "redundancy-state" or name == "software-state" or name == "status"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "card-state"):
                    self.card_state = value
                    self.card_state.value_namespace = name_space
                    self.card_state.value_namespace_prefix = name_space_prefix
                if(value_path == "diag-mode"):
                    self.diag_mode = value
                    self.diag_mode.value_namespace = name_space
                    self.diag_mode.value_namespace_prefix = name_space_prefix
                if(value_path == "fwd-referenced"):
                    self.fwd_referenced = value
                    self.fwd_referenced.value_namespace = name_space
                    self.fwd_referenced.value_namespace_prefix = name_space_prefix
                if(value_path == "last-update-time"):
                    self.last_update_time = value
                    self.last_update_time.value_namespace = name_space
                    self.last_update_time.value_namespace_prefix = name_space_prefix
                if(value_path == "node-id"):
                    self.node_id = value
                    self.node_id.value_namespace = name_space
                    self.node_id.value_namespace_prefix = name_space_prefix
                if(value_path == "node-name"):
                    self.node_name = value
                    self.node_name.value_namespace = name_space
                    self.node_name.value_namespace_prefix = name_space_prefix
                if(value_path == "node-state"):
                    self.node_state = value
                    self.node_state.value_namespace = name_space
                    self.node_state.value_namespace_prefix = name_space_prefix
                if(value_path == "node-type"):
                    self.node_type = value
                    self.node_type.value_namespace = name_space
                    self.node_type.value_namespace_prefix = name_space_prefix
                if(value_path == "rack-id"):
                    self.rack_id = value
                    self.rack_id.value_namespace = name_space
                    self.rack_id.value_namespace_prefix = name_space_prefix
                if(value_path == "redundancy-state"):
                    self.redundancy_state = value
                    self.redundancy_state.value_namespace = name_space
                    self.redundancy_state.value_namespace_prefix = name_space_prefix
                if(value_path == "software-state"):
                    self.software_state = value
                    self.software_state.value_namespace = name_space
                    self.software_state.value_namespace_prefix = name_space_prefix
                if(value_path == "status"):
                    self.status = value
                    self.status.value_namespace = name_space
                    self.status.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.node_information:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.node_information:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "node" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "node-information"):
                for c in self.node_information:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Rcmd.Node.NodeInformation()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.node_information.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "node-information"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Isis(Entity):
        """
        Operational data for ISIS
        
        .. attribute:: instances
        
        	Operational data
        	**type**\:   :py:class:`Instances <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances>`
        
        

        """

        _prefix = 'infra-rcmd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Rcmd.Isis, self).__init__()

            self.yang_name = "isis"
            self.yang_parent_name = "rcmd"

            self.instances = Rcmd.Isis.Instances()
            self.instances.parent = self
            self._children_name_map["instances"] = "instances"
            self._children_yang_names.add("instances")


        class Instances(Entity):
            """
            Operational data
            
            .. attribute:: instance
            
            	Operational data for a particular instance
            	**type**\: list of    :py:class:`Instance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Isis.Instances, self).__init__()

                self.yang_name = "instances"
                self.yang_parent_name = "isis"

                self.instance = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Isis.Instances, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Isis.Instances, self).__setattr__(name, value)


            class Instance(Entity):
                """
                Operational data for a particular instance
                
                .. attribute:: instance_name  <key>
                
                	Operational data for a particular instance
                	**type**\:  str
                
                	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                
                .. attribute:: ipfrr_event_offlines
                
                	ISIS IP\-FRR Event offline data
                	**type**\:   :py:class:`IpfrrEventOfflines <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventOfflines>`
                
                .. attribute:: ipfrr_event_summaries
                
                	ISIS IP\-FRR events summary data
                	**type**\:   :py:class:`IpfrrEventSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventSummaries>`
                
                .. attribute:: lsp_regenerateds
                
                	Regenerated LSP data
                	**type**\:   :py:class:`LspRegenerateds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.LspRegenerateds>`
                
                .. attribute:: prefix_event_offlines
                
                	ISIS Prefix events offline data
                	**type**\:   :py:class:`PrefixEventOfflines <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines>`
                
                .. attribute:: prefix_event_statistics
                
                	ISIS Prefix events statistics data
                	**type**\:   :py:class:`PrefixEventStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventStatistics>`
                
                .. attribute:: prefix_event_summaries
                
                	ISIS Prefix events summary data
                	**type**\:   :py:class:`PrefixEventSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries>`
                
                .. attribute:: spf_run_offlines
                
                	ISIS SPF run offline data
                	**type**\:   :py:class:`SpfRunOfflines <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines>`
                
                .. attribute:: spf_run_summaries
                
                	ISIS SPF run summary data
                	**type**\:   :py:class:`SpfRunSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Isis.Instances.Instance, self).__init__()

                    self.yang_name = "instance"
                    self.yang_parent_name = "instances"

                    self.instance_name = YLeaf(YType.str, "instance-name")

                    self.ipfrr_event_offlines = Rcmd.Isis.Instances.Instance.IpfrrEventOfflines()
                    self.ipfrr_event_offlines.parent = self
                    self._children_name_map["ipfrr_event_offlines"] = "ipfrr-event-offlines"
                    self._children_yang_names.add("ipfrr-event-offlines")

                    self.ipfrr_event_summaries = Rcmd.Isis.Instances.Instance.IpfrrEventSummaries()
                    self.ipfrr_event_summaries.parent = self
                    self._children_name_map["ipfrr_event_summaries"] = "ipfrr-event-summaries"
                    self._children_yang_names.add("ipfrr-event-summaries")

                    self.lsp_regenerateds = Rcmd.Isis.Instances.Instance.LspRegenerateds()
                    self.lsp_regenerateds.parent = self
                    self._children_name_map["lsp_regenerateds"] = "lsp-regenerateds"
                    self._children_yang_names.add("lsp-regenerateds")

                    self.prefix_event_offlines = Rcmd.Isis.Instances.Instance.PrefixEventOfflines()
                    self.prefix_event_offlines.parent = self
                    self._children_name_map["prefix_event_offlines"] = "prefix-event-offlines"
                    self._children_yang_names.add("prefix-event-offlines")

                    self.prefix_event_statistics = Rcmd.Isis.Instances.Instance.PrefixEventStatistics()
                    self.prefix_event_statistics.parent = self
                    self._children_name_map["prefix_event_statistics"] = "prefix-event-statistics"
                    self._children_yang_names.add("prefix-event-statistics")

                    self.prefix_event_summaries = Rcmd.Isis.Instances.Instance.PrefixEventSummaries()
                    self.prefix_event_summaries.parent = self
                    self._children_name_map["prefix_event_summaries"] = "prefix-event-summaries"
                    self._children_yang_names.add("prefix-event-summaries")

                    self.spf_run_offlines = Rcmd.Isis.Instances.Instance.SpfRunOfflines()
                    self.spf_run_offlines.parent = self
                    self._children_name_map["spf_run_offlines"] = "spf-run-offlines"
                    self._children_yang_names.add("spf-run-offlines")

                    self.spf_run_summaries = Rcmd.Isis.Instances.Instance.SpfRunSummaries()
                    self.spf_run_summaries.parent = self
                    self._children_name_map["spf_run_summaries"] = "spf-run-summaries"
                    self._children_yang_names.add("spf-run-summaries")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("instance_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Isis.Instances.Instance, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Isis.Instances.Instance, self).__setattr__(name, value)


                class IpfrrEventSummaries(Entity):
                    """
                    ISIS IP\-FRR events summary data
                    
                    .. attribute:: ipfrr_event_summary
                    
                    	IP\-FRR Event data
                    	**type**\: list of    :py:class:`IpfrrEventSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries, self).__init__()

                        self.yang_name = "ipfrr-event-summaries"
                        self.yang_parent_name = "instance"

                        self.ipfrr_event_summary = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries, self).__setattr__(name, value)


                    class IpfrrEventSummary(Entity):
                        """
                        IP\-FRR Event data
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific IP\-FRR Event
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: completed_spf_run
                        
                        	IP\-Frr Completed reference SPF Run Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: coverage
                        
                        	Coverage in percentage for all priorities
                        	**type**\:  str
                        
                        	**units**\: percentage
                        
                        .. attribute:: duration
                        
                        	Duration for the calculation (in milliseconds)
                        	**type**\:  str
                        
                        	**units**\: millisecond
                        
                        .. attribute:: event_id_xr
                        
                        	IP\-Frr Event ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: fully_protected_routes
                        
                        	Cumulative Number of Fully Protected Routes
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ipfrr_statistic
                        
                        	IP\-Frr Statistics categorized by priority
                        	**type**\: list of    :py:class:`IpfrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic>`
                        
                        .. attribute:: partially_protected_routes
                        
                        	Cumulative Number of Partially Protected Routes
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_node
                        
                        	Remote Node Information
                        	**type**\: list of    :py:class:`RemoteNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode>`
                        
                        .. attribute:: start_time_offset
                        
                        	Start Time offset from trigger time (in milliseconds)
                        	**type**\:  str
                        
                        	**units**\: millisecond
                        
                        .. attribute:: total_routes
                        
                        	Cumulative Number of Routes for all priorities
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: trigger_spf_run
                        
                        	IP\-Frr Triggered reference SPF Run Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: trigger_time
                        
                        	Trigger time  (eg\: Apr 24 13\:16\:04.961)
                        	**type**\:  str
                        
                        .. attribute:: wait_time
                        
                        	Waiting Time (in milliseconds)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary, self).__init__()

                            self.yang_name = "ipfrr-event-summary"
                            self.yang_parent_name = "ipfrr-event-summaries"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.completed_spf_run = YLeaf(YType.uint32, "completed-spf-run")

                            self.coverage = YLeaf(YType.str, "coverage")

                            self.duration = YLeaf(YType.str, "duration")

                            self.event_id_xr = YLeaf(YType.uint32, "event-id-xr")

                            self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                            self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                            self.start_time_offset = YLeaf(YType.str, "start-time-offset")

                            self.total_routes = YLeaf(YType.uint32, "total-routes")

                            self.trigger_spf_run = YLeaf(YType.uint32, "trigger-spf-run")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.wait_time = YLeaf(YType.uint32, "wait-time")

                            self.ipfrr_statistic = YList(self)
                            self.remote_node = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "completed_spf_run",
                                            "coverage",
                                            "duration",
                                            "event_id_xr",
                                            "fully_protected_routes",
                                            "partially_protected_routes",
                                            "start_time_offset",
                                            "total_routes",
                                            "trigger_spf_run",
                                            "trigger_time",
                                            "wait_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary, self).__setattr__(name, value)


                        class IpfrrStatistic(Entity):
                            """
                            IP\-Frr Statistics categorized by priority
                            
                            .. attribute:: below_threshold
                            
                            	Covearge is below Configured Threshold
                            	**type**\:  bool
                            
                            .. attribute:: coverage
                            
                            	Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: fully_protected_routes
                            
                            	Fully Protected Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_lfa_coverage
                            
                            	Local LFA Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: partially_protected_routes
                            
                            	Partially Protected Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: priority
                            
                            	Priority
                            	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                            
                            .. attribute:: remote_lfa_coverage
                            
                            	Remote LFA Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: total_routes
                            
                            	Total Number of Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic, self).__init__()

                                self.yang_name = "ipfrr-statistic"
                                self.yang_parent_name = "ipfrr-event-summary"

                                self.below_threshold = YLeaf(YType.boolean, "below-threshold")

                                self.coverage = YLeaf(YType.str, "coverage")

                                self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                self.local_lfa_coverage = YLeaf(YType.str, "local-lfa-coverage")

                                self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                self.priority = YLeaf(YType.enumeration, "priority")

                                self.remote_lfa_coverage = YLeaf(YType.str, "remote-lfa-coverage")

                                self.total_routes = YLeaf(YType.uint32, "total-routes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("below_threshold",
                                                "coverage",
                                                "fully_protected_routes",
                                                "local_lfa_coverage",
                                                "partially_protected_routes",
                                                "priority",
                                                "remote_lfa_coverage",
                                                "total_routes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.below_threshold.is_set or
                                    self.coverage.is_set or
                                    self.fully_protected_routes.is_set or
                                    self.local_lfa_coverage.is_set or
                                    self.partially_protected_routes.is_set or
                                    self.priority.is_set or
                                    self.remote_lfa_coverage.is_set or
                                    self.total_routes.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.below_threshold.yfilter != YFilter.not_set or
                                    self.coverage.yfilter != YFilter.not_set or
                                    self.fully_protected_routes.yfilter != YFilter.not_set or
                                    self.local_lfa_coverage.yfilter != YFilter.not_set or
                                    self.partially_protected_routes.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set or
                                    self.remote_lfa_coverage.yfilter != YFilter.not_set or
                                    self.total_routes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ipfrr-statistic" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.below_threshold.is_set or self.below_threshold.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.below_threshold.get_name_leafdata())
                                if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.coverage.get_name_leafdata())
                                if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                if (self.local_lfa_coverage.is_set or self.local_lfa_coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_lfa_coverage.get_name_leafdata())
                                if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())
                                if (self.remote_lfa_coverage.is_set or self.remote_lfa_coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_lfa_coverage.get_name_leafdata())
                                if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_routes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "below-threshold" or name == "coverage" or name == "fully-protected-routes" or name == "local-lfa-coverage" or name == "partially-protected-routes" or name == "priority" or name == "remote-lfa-coverage" or name == "total-routes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "below-threshold"):
                                    self.below_threshold = value
                                    self.below_threshold.value_namespace = name_space
                                    self.below_threshold.value_namespace_prefix = name_space_prefix
                                if(value_path == "coverage"):
                                    self.coverage = value
                                    self.coverage.value_namespace = name_space
                                    self.coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "fully-protected-routes"):
                                    self.fully_protected_routes = value
                                    self.fully_protected_routes.value_namespace = name_space
                                    self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-lfa-coverage"):
                                    self.local_lfa_coverage = value
                                    self.local_lfa_coverage.value_namespace = name_space
                                    self.local_lfa_coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "partially-protected-routes"):
                                    self.partially_protected_routes = value
                                    self.partially_protected_routes.value_namespace = name_space
                                    self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-lfa-coverage"):
                                    self.remote_lfa_coverage = value
                                    self.remote_lfa_coverage.value_namespace = name_space
                                    self.remote_lfa_coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-routes"):
                                    self.total_routes = value
                                    self.total_routes.value_namespace = name_space
                                    self.total_routes.value_namespace_prefix = name_space_prefix


                        class RemoteNode(Entity):
                            """
                            Remote Node Information
                            
                            .. attribute:: in_use_time
                            
                            	Inuse time of the Remote Node (eg\: Apr 24 13\:16 \:04.961)
                            	**type**\:  str
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_count
                            
                            	Number of paths protected by this Remote Node
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: primary_path
                            
                            	Protected Primary Paths
                            	**type**\: list of    :py:class:`PrimaryPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath>`
                            
                            .. attribute:: remote_node_id
                            
                            	Remote\-LFA Node ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode, self).__init__()

                                self.yang_name = "remote-node"
                                self.yang_parent_name = "ipfrr-event-summary"

                                self.in_use_time = YLeaf(YType.str, "in-use-time")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_count = YLeaf(YType.uint32, "path-count")

                                self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                self.primary_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("in_use_time",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_count",
                                                "remote_node_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode, self).__setattr__(name, value)


                            class PrimaryPath(Entity):
                                """
                                Protected Primary Paths
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath, self).__init__()

                                    self.yang_name = "primary-path"
                                    self.yang_parent_name = "remote-node"

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface_name",
                                                    "neighbour_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.interface_name.is_set or
                                        self.neighbour_address.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "primary-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface-name" or name == "neighbour-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.primary_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.in_use_time.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_count.is_set or
                                    self.remote_node_id.is_set)

                            def has_operation(self):
                                for c in self.primary_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.in_use_time.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_count.yfilter != YFilter.not_set or
                                    self.remote_node_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "remote-node" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.in_use_time.is_set or self.in_use_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_use_time.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_count.is_set or self.path_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_count.get_name_leafdata())
                                if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "primary-path"):
                                    for c in self.primary_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode.PrimaryPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.primary_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "primary-path" or name == "in-use-time" or name == "interface-name" or name == "neighbour-address" or name == "path-count" or name == "remote-node-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "in-use-time"):
                                    self.in_use_time = value
                                    self.in_use_time.value_namespace = name_space
                                    self.in_use_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-count"):
                                    self.path_count = value
                                    self.path_count.value_namespace = name_space
                                    self.path_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-node-id"):
                                    self.remote_node_id = value
                                    self.remote_node_id.value_namespace = name_space
                                    self.remote_node_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.ipfrr_statistic:
                                if (c.has_data()):
                                    return True
                            for c in self.remote_node:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.completed_spf_run.is_set or
                                self.coverage.is_set or
                                self.duration.is_set or
                                self.event_id_xr.is_set or
                                self.fully_protected_routes.is_set or
                                self.partially_protected_routes.is_set or
                                self.start_time_offset.is_set or
                                self.total_routes.is_set or
                                self.trigger_spf_run.is_set or
                                self.trigger_time.is_set or
                                self.wait_time.is_set)

                        def has_operation(self):
                            for c in self.ipfrr_statistic:
                                if (c.has_operation()):
                                    return True
                            for c in self.remote_node:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.completed_spf_run.yfilter != YFilter.not_set or
                                self.coverage.yfilter != YFilter.not_set or
                                self.duration.yfilter != YFilter.not_set or
                                self.event_id_xr.yfilter != YFilter.not_set or
                                self.fully_protected_routes.yfilter != YFilter.not_set or
                                self.partially_protected_routes.yfilter != YFilter.not_set or
                                self.start_time_offset.yfilter != YFilter.not_set or
                                self.total_routes.yfilter != YFilter.not_set or
                                self.trigger_spf_run.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                self.wait_time.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipfrr-event-summary" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.completed_spf_run.is_set or self.completed_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.completed_spf_run.get_name_leafdata())
                            if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.coverage.get_name_leafdata())
                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.duration.get_name_leafdata())
                            if (self.event_id_xr.is_set or self.event_id_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id_xr.get_name_leafdata())
                            if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                            if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                            if (self.start_time_offset.is_set or self.start_time_offset.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_time_offset.get_name_leafdata())
                            if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_routes.get_name_leafdata())
                            if (self.trigger_spf_run.is_set or self.trigger_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_spf_run.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())
                            if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wait_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ipfrr-statistic"):
                                for c in self.ipfrr_statistic:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.IpfrrStatistic()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.ipfrr_statistic.append(c)
                                return c

                            if (child_yang_name == "remote-node"):
                                for c in self.remote_node:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary.RemoteNode()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.remote_node.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ipfrr-statistic" or name == "remote-node" or name == "event-id" or name == "completed-spf-run" or name == "coverage" or name == "duration" or name == "event-id-xr" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "start-time-offset" or name == "total-routes" or name == "trigger-spf-run" or name == "trigger-time" or name == "wait-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "completed-spf-run"):
                                self.completed_spf_run = value
                                self.completed_spf_run.value_namespace = name_space
                                self.completed_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "coverage"):
                                self.coverage = value
                                self.coverage.value_namespace = name_space
                                self.coverage.value_namespace_prefix = name_space_prefix
                            if(value_path == "duration"):
                                self.duration = value
                                self.duration.value_namespace = name_space
                                self.duration.value_namespace_prefix = name_space_prefix
                            if(value_path == "event-id-xr"):
                                self.event_id_xr = value
                                self.event_id_xr.value_namespace = name_space
                                self.event_id_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "fully-protected-routes"):
                                self.fully_protected_routes = value
                                self.fully_protected_routes.value_namespace = name_space
                                self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "partially-protected-routes"):
                                self.partially_protected_routes = value
                                self.partially_protected_routes.value_namespace = name_space
                                self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-time-offset"):
                                self.start_time_offset = value
                                self.start_time_offset.value_namespace = name_space
                                self.start_time_offset.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-routes"):
                                self.total_routes = value
                                self.total_routes.value_namespace = name_space
                                self.total_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-spf-run"):
                                self.trigger_spf_run = value
                                self.trigger_spf_run.value_namespace = name_space
                                self.trigger_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "wait-time"):
                                self.wait_time = value
                                self.wait_time.value_namespace = name_space
                                self.wait_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.ipfrr_event_summary:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.ipfrr_event_summary:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipfrr-event-summaries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ipfrr-event-summary"):
                            for c in self.ipfrr_event_summary:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Isis.Instances.Instance.IpfrrEventSummaries.IpfrrEventSummary()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.ipfrr_event_summary.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ipfrr-event-summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class PrefixEventStatistics(Entity):
                    """
                    ISIS Prefix events statistics data
                    
                    .. attribute:: prefix_event_statistic
                    
                    	Monitoring Statistics
                    	**type**\: list of    :py:class:`PrefixEventStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Isis.Instances.Instance.PrefixEventStatistics, self).__init__()

                        self.yang_name = "prefix-event-statistics"
                        self.yang_parent_name = "instance"

                        self.prefix_event_statistic = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventStatistics, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Isis.Instances.Instance.PrefixEventStatistics, self).__setattr__(name, value)


                    class PrefixEventStatistic(Entity):
                        """
                        Monitoring Statistics
                        
                        .. attribute:: prefix_info  <key>
                        
                        	Events with Prefix
                        	**type**\: one of the below types:
                        
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])/(([0\-9])\|([1\-2][0\-9])\|(3[0\-2]))
                        
                        
                        ----
                        	**type**\:  str
                        
                        	**pattern:** ((\:\|[0\-9a\-fA\-F]{0,4})\:)([0\-9a\-fA\-F]{0,4}\:){0,5}((([0\-9a\-fA\-F]{0,4}\:)?(\:\|[0\-9a\-fA\-F]{0,4}))\|(((25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])\\.){3}(25[0\-5]\|2[0\-4][0\-9]\|[01]?[0\-9]?[0\-9])))(/(([0\-9])\|([0\-9]{2})\|(1[0\-1][0\-9])\|(12[0\-8])))
                        
                        
                        ----
                        .. attribute:: add_count
                        
                        	No. of times route gets Added
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: critical_priority
                        
                        	No. of times processed under Critical Priority
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: delete_count
                        
                        	No. of times route gets Deleted
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: high_priority
                        
                        	No. of times processed under High Priority
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: last_change_type
                        
                        	Last event Add/Delete
                        	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                        
                        .. attribute:: last_cost
                        
                        	Last Known Cost
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: last_event_time
                        
                        	Last event trigger time
                        	**type**\:  str
                        
                        .. attribute:: last_priority
                        
                        	Last event processed priority
                        	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                        
                        .. attribute:: last_route_type
                        
                        	Last event Route Type
                        	**type**\:   :py:class:`RcmdShowRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoute>`
                        
                        .. attribute:: low_priority
                        
                        	No. of times processed under Low Priority
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: medium_priority
                        
                        	No. of times processed under Medium Priority
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: modify_count
                        
                        	No. of times route gets Deleted
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: prefix
                        
                        	Prefix
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_lenth
                        
                        	Prefix length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: threshold_exceed_count
                        
                        	No. of times threshold got exceeded
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Isis.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic, self).__init__()

                            self.yang_name = "prefix-event-statistic"
                            self.yang_parent_name = "prefix-event-statistics"

                            self.prefix_info = YLeaf(YType.str, "prefix-info")

                            self.add_count = YLeaf(YType.uint32, "add-count")

                            self.critical_priority = YLeaf(YType.uint32, "critical-priority")

                            self.delete_count = YLeaf(YType.uint32, "delete-count")

                            self.high_priority = YLeaf(YType.uint32, "high-priority")

                            self.last_change_type = YLeaf(YType.enumeration, "last-change-type")

                            self.last_cost = YLeaf(YType.uint32, "last-cost")

                            self.last_event_time = YLeaf(YType.str, "last-event-time")

                            self.last_priority = YLeaf(YType.enumeration, "last-priority")

                            self.last_route_type = YLeaf(YType.enumeration, "last-route-type")

                            self.low_priority = YLeaf(YType.uint32, "low-priority")

                            self.medium_priority = YLeaf(YType.uint32, "medium-priority")

                            self.modify_count = YLeaf(YType.uint32, "modify-count")

                            self.prefix = YLeaf(YType.str, "prefix")

                            self.prefix_lenth = YLeaf(YType.uint32, "prefix-lenth")

                            self.threshold_exceed_count = YLeaf(YType.uint32, "threshold-exceed-count")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("prefix_info",
                                            "add_count",
                                            "critical_priority",
                                            "delete_count",
                                            "high_priority",
                                            "last_change_type",
                                            "last_cost",
                                            "last_event_time",
                                            "last_priority",
                                            "last_route_type",
                                            "low_priority",
                                            "medium_priority",
                                            "modify_count",
                                            "prefix",
                                            "prefix_lenth",
                                            "threshold_exceed_count") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.prefix_info.is_set or
                                self.add_count.is_set or
                                self.critical_priority.is_set or
                                self.delete_count.is_set or
                                self.high_priority.is_set or
                                self.last_change_type.is_set or
                                self.last_cost.is_set or
                                self.last_event_time.is_set or
                                self.last_priority.is_set or
                                self.last_route_type.is_set or
                                self.low_priority.is_set or
                                self.medium_priority.is_set or
                                self.modify_count.is_set or
                                self.prefix.is_set or
                                self.prefix_lenth.is_set or
                                self.threshold_exceed_count.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.prefix_info.yfilter != YFilter.not_set or
                                self.add_count.yfilter != YFilter.not_set or
                                self.critical_priority.yfilter != YFilter.not_set or
                                self.delete_count.yfilter != YFilter.not_set or
                                self.high_priority.yfilter != YFilter.not_set or
                                self.last_change_type.yfilter != YFilter.not_set or
                                self.last_cost.yfilter != YFilter.not_set or
                                self.last_event_time.yfilter != YFilter.not_set or
                                self.last_priority.yfilter != YFilter.not_set or
                                self.last_route_type.yfilter != YFilter.not_set or
                                self.low_priority.yfilter != YFilter.not_set or
                                self.medium_priority.yfilter != YFilter.not_set or
                                self.modify_count.yfilter != YFilter.not_set or
                                self.prefix.yfilter != YFilter.not_set or
                                self.prefix_lenth.yfilter != YFilter.not_set or
                                self.threshold_exceed_count.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-event-statistic" + "[prefix-info='" + self.prefix_info.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.prefix_info.is_set or self.prefix_info.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_info.get_name_leafdata())
                            if (self.add_count.is_set or self.add_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.add_count.get_name_leafdata())
                            if (self.critical_priority.is_set or self.critical_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.critical_priority.get_name_leafdata())
                            if (self.delete_count.is_set or self.delete_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.delete_count.get_name_leafdata())
                            if (self.high_priority.is_set or self.high_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.high_priority.get_name_leafdata())
                            if (self.last_change_type.is_set or self.last_change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_change_type.get_name_leafdata())
                            if (self.last_cost.is_set or self.last_cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_cost.get_name_leafdata())
                            if (self.last_event_time.is_set or self.last_event_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_event_time.get_name_leafdata())
                            if (self.last_priority.is_set or self.last_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_priority.get_name_leafdata())
                            if (self.last_route_type.is_set or self.last_route_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_route_type.get_name_leafdata())
                            if (self.low_priority.is_set or self.low_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.low_priority.get_name_leafdata())
                            if (self.medium_priority.is_set or self.medium_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.medium_priority.get_name_leafdata())
                            if (self.modify_count.is_set or self.modify_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.modify_count.get_name_leafdata())
                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix.get_name_leafdata())
                            if (self.prefix_lenth.is_set or self.prefix_lenth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_lenth.get_name_leafdata())
                            if (self.threshold_exceed_count.is_set or self.threshold_exceed_count.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_exceed_count.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "prefix-info" or name == "add-count" or name == "critical-priority" or name == "delete-count" or name == "high-priority" or name == "last-change-type" or name == "last-cost" or name == "last-event-time" or name == "last-priority" or name == "last-route-type" or name == "low-priority" or name == "medium-priority" or name == "modify-count" or name == "prefix" or name == "prefix-lenth" or name == "threshold-exceed-count"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "prefix-info"):
                                self.prefix_info = value
                                self.prefix_info.value_namespace = name_space
                                self.prefix_info.value_namespace_prefix = name_space_prefix
                            if(value_path == "add-count"):
                                self.add_count = value
                                self.add_count.value_namespace = name_space
                                self.add_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "critical-priority"):
                                self.critical_priority = value
                                self.critical_priority.value_namespace = name_space
                                self.critical_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "delete-count"):
                                self.delete_count = value
                                self.delete_count.value_namespace = name_space
                                self.delete_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "high-priority"):
                                self.high_priority = value
                                self.high_priority.value_namespace = name_space
                                self.high_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-change-type"):
                                self.last_change_type = value
                                self.last_change_type.value_namespace = name_space
                                self.last_change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-cost"):
                                self.last_cost = value
                                self.last_cost.value_namespace = name_space
                                self.last_cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-event-time"):
                                self.last_event_time = value
                                self.last_event_time.value_namespace = name_space
                                self.last_event_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-priority"):
                                self.last_priority = value
                                self.last_priority.value_namespace = name_space
                                self.last_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-route-type"):
                                self.last_route_type = value
                                self.last_route_type.value_namespace = name_space
                                self.last_route_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "low-priority"):
                                self.low_priority = value
                                self.low_priority.value_namespace = name_space
                                self.low_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "medium-priority"):
                                self.medium_priority = value
                                self.medium_priority.value_namespace = name_space
                                self.medium_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "modify-count"):
                                self.modify_count = value
                                self.modify_count.value_namespace = name_space
                                self.modify_count.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix"):
                                self.prefix = value
                                self.prefix.value_namespace = name_space
                                self.prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-lenth"):
                                self.prefix_lenth = value
                                self.prefix_lenth.value_namespace = name_space
                                self.prefix_lenth.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-exceed-count"):
                                self.threshold_exceed_count = value
                                self.threshold_exceed_count.value_namespace = name_space
                                self.threshold_exceed_count.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.prefix_event_statistic:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.prefix_event_statistic:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "prefix-event-statistics" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-event-statistic"):
                            for c in self.prefix_event_statistic:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Isis.Instances.Instance.PrefixEventStatistics.PrefixEventStatistic()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.prefix_event_statistic.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-event-statistic"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SpfRunSummaries(Entity):
                    """
                    ISIS SPF run summary data
                    
                    .. attribute:: spf_run_summary
                    
                    	SPF Event data
                    	**type**\: list of    :py:class:`SpfRunSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries, self).__init__()

                        self.yang_name = "spf-run-summaries"
                        self.yang_parent_name = "instance"

                        self.spf_run_summary = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries, self).__setattr__(name, value)


                    class SpfRunSummary(Entity):
                        """
                        SPF Event data
                        
                        .. attribute:: spf_run_number  <key>
                        
                        	Specific SPF run
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: lsp_processed
                        
                        	List of LSP changes processed
                        	**type**\: list of    :py:class:`LspProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspProcessed>`
                        
                        .. attribute:: lsp_regenerated
                        
                        	List of LSP regenerated
                        	**type**\: list of    :py:class:`LspRegenerated <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspRegenerated>`
                        
                        .. attribute:: node_statistics
                        
                        	SPF Node statistics
                        	**type**\:   :py:class:`NodeStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.NodeStatistics>`
                        
                        .. attribute:: priority
                        
                        	Convergence information on per\-priority basis
                        	**type**\: list of    :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority>`
                        
                        .. attribute:: reason
                        
                        	Trigger reasons for SPF run. Example\: pr^ \- periodic, cr^ \- clear (Check the documentation for the entire list)
                        	**type**\:  str
                        
                        .. attribute:: spf_summary
                        
                        	SPF summary information
                        	**type**\:   :py:class:`SpfSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary>`
                        
                        .. attribute:: start_time
                        
                        	Start time (offset from event trigger time in ss .msec)
                        	**type**\:  str
                        
                        .. attribute:: trigger_lsp
                        
                        	Trigger LSP
                        	**type**\: list of    :py:class:`TriggerLsp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.TriggerLsp>`
                        
                        .. attribute:: wait_time
                        
                        	Wait time applied at SPF schedule (in msec)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary, self).__init__()

                            self.yang_name = "spf-run-summary"
                            self.yang_parent_name = "spf-run-summaries"

                            self.spf_run_number = YLeaf(YType.int32, "spf-run-number")

                            self.reason = YLeaf(YType.str, "reason")

                            self.start_time = YLeaf(YType.str, "start-time")

                            self.wait_time = YLeaf(YType.uint32, "wait-time")

                            self.node_statistics = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.NodeStatistics()
                            self.node_statistics.parent = self
                            self._children_name_map["node_statistics"] = "node-statistics"
                            self._children_yang_names.add("node-statistics")

                            self.spf_summary = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary()
                            self.spf_summary.parent = self
                            self._children_name_map["spf_summary"] = "spf-summary"
                            self._children_yang_names.add("spf-summary")

                            self.lsp_processed = YList(self)
                            self.lsp_regenerated = YList(self)
                            self.priority = YList(self)
                            self.trigger_lsp = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("spf_run_number",
                                            "reason",
                                            "start_time",
                                            "wait_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary, self).__setattr__(name, value)


                        class SpfSummary(Entity):
                            """
                            SPF summary information
                            
                            .. attribute:: duration
                            
                            	Duration of SPF calculation (in ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: is_data_complete
                            
                            	Whether the event has all information
                            	**type**\:  bool
                            
                            .. attribute:: isis_level
                            
                            	ISIS Level
                            	**type**\:   :py:class:`RcmdIsisLvl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdIsisLvl>`
                            
                            .. attribute:: priority_summary
                            
                            	Convergence information summary on per\-priority basis
                            	**type**\: list of    :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary>`
                            
                            .. attribute:: state
                            
                            	SPF state
                            	**type**\:   :py:class:`RcmdSpfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdSpfState>`
                            
                            .. attribute:: threshold_exceeded
                            
                            	Threshold exceeded
                            	**type**\:  bool
                            
                            .. attribute:: topology
                            
                            	Topology index (multi\-topology)
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: total_lsp_changes
                            
                            	Total number of LSP changes processed
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: trigger_time
                            
                            	Trigger time (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: type
                            
                            	Type of SPF
                            	**type**\:   :py:class:`RcmdIsisSpf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdIsisSpf>`
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary, self).__init__()

                                self.yang_name = "spf-summary"
                                self.yang_parent_name = "spf-run-summary"

                                self.duration = YLeaf(YType.str, "duration")

                                self.is_data_complete = YLeaf(YType.boolean, "is-data-complete")

                                self.isis_level = YLeaf(YType.enumeration, "isis-level")

                                self.state = YLeaf(YType.enumeration, "state")

                                self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                self.topology = YLeaf(YType.uint32, "topology")

                                self.total_lsp_changes = YLeaf(YType.uint16, "total-lsp-changes")

                                self.trigger_time = YLeaf(YType.str, "trigger-time")

                                self.type = YLeaf(YType.enumeration, "type")

                                self.priority_summary = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("duration",
                                                "is_data_complete",
                                                "isis_level",
                                                "state",
                                                "threshold_exceeded",
                                                "topology",
                                                "total_lsp_changes",
                                                "trigger_time",
                                                "type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary, self).__setattr__(name, value)


                            class PrioritySummary(Entity):
                                """
                                Convergence information summary on per\-priority
                                basis
                                
                                .. attribute:: frr_statistic
                                
                                	Fast Re\-Route Statistics
                                	**type**\: list of    :py:class:`FrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic>`
                                
                                .. attribute:: ip_convergence_time
                                
                                	Convergence time for IP route programming
                                	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime>`
                                
                                .. attribute:: level
                                
                                	Critical, High, Medium or Low
                                	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                
                                .. attribute:: mpls_convergence_time
                                
                                	Convergence time for MPLS label programming
                                	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime>`
                                
                                .. attribute:: route_statistics
                                
                                	Route statistics
                                	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics>`
                                
                                .. attribute:: threshold_exceeded
                                
                                	Threshold exceeded
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary, self).__init__()

                                    self.yang_name = "priority-summary"
                                    self.yang_parent_name = "spf-summary"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                    self.ip_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                    self._children_yang_names.add("ip-convergence-time")

                                    self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                    self._children_yang_names.add("mpls-convergence-time")

                                    self.route_statistics = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics()
                                    self.route_statistics.parent = self
                                    self._children_name_map["route_statistics"] = "route-statistics"
                                    self._children_yang_names.add("route-statistics")

                                    self.frr_statistic = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "threshold_exceeded") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary, self).__setattr__(name, value)


                                class RouteStatistics(Entity):
                                    """
                                    Route statistics
                                    
                                    .. attribute:: adds
                                    
                                    	Added
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: deletes
                                    
                                    	Deleted
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: modifies
                                    
                                    	Modified
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: reachables
                                    
                                    	Reachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: touches
                                    
                                    	Touched
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: unreachables
                                    
                                    	Unreachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics, self).__init__()

                                        self.yang_name = "route-statistics"
                                        self.yang_parent_name = "priority-summary"

                                        self.adds = YLeaf(YType.uint32, "adds")

                                        self.deletes = YLeaf(YType.uint32, "deletes")

                                        self.modifies = YLeaf(YType.uint32, "modifies")

                                        self.reachables = YLeaf(YType.uint32, "reachables")

                                        self.touches = YLeaf(YType.uint32, "touches")

                                        self.unreachables = YLeaf(YType.uint32, "unreachables")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("adds",
                                                        "deletes",
                                                        "modifies",
                                                        "reachables",
                                                        "touches",
                                                        "unreachables") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.adds.is_set or
                                            self.deletes.is_set or
                                            self.modifies.is_set or
                                            self.reachables.is_set or
                                            self.touches.is_set or
                                            self.unreachables.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.adds.yfilter != YFilter.not_set or
                                            self.deletes.yfilter != YFilter.not_set or
                                            self.modifies.yfilter != YFilter.not_set or
                                            self.reachables.yfilter != YFilter.not_set or
                                            self.touches.yfilter != YFilter.not_set or
                                            self.unreachables.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "route-statistics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.adds.get_name_leafdata())
                                        if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.deletes.get_name_leafdata())
                                        if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.modifies.get_name_leafdata())
                                        if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.reachables.get_name_leafdata())
                                        if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.touches.get_name_leafdata())
                                        if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.unreachables.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "adds"):
                                            self.adds = value
                                            self.adds.value_namespace = name_space
                                            self.adds.value_namespace_prefix = name_space_prefix
                                        if(value_path == "deletes"):
                                            self.deletes = value
                                            self.deletes.value_namespace = name_space
                                            self.deletes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "modifies"):
                                            self.modifies = value
                                            self.modifies.value_namespace = name_space
                                            self.modifies.value_namespace_prefix = name_space_prefix
                                        if(value_path == "reachables"):
                                            self.reachables = value
                                            self.reachables.value_namespace = name_space
                                            self.reachables.value_namespace_prefix = name_space_prefix
                                        if(value_path == "touches"):
                                            self.touches = value
                                            self.touches.value_namespace = name_space
                                            self.touches.value_namespace_prefix = name_space_prefix
                                        if(value_path == "unreachables"):
                                            self.unreachables = value
                                            self.unreachables.value_namespace = name_space
                                            self.unreachables.value_namespace_prefix = name_space_prefix


                                class IpConvergenceTime(Entity):
                                    """
                                    Convergence time for IP route programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime, self).__init__()

                                        self.yang_name = "ip-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ip-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class MplsConvergenceTime(Entity):
                                    """
                                    Convergence time for MPLS label programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__init__()

                                        self.yang_name = "mpls-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mpls-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class FrrStatistic(Entity):
                                    """
                                    Fast Re\-Route Statistics
                                    
                                    .. attribute:: coverage
                                    
                                    	Coverage in percentage
                                    	**type**\:  str
                                    
                                    	**units**\: percentage
                                    
                                    .. attribute:: fully_protected_routes
                                    
                                    	Fully Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: partially_protected_routes
                                    
                                    	Partially Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_routes
                                    
                                    	Total Number of Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic, self).__init__()

                                        self.yang_name = "frr-statistic"
                                        self.yang_parent_name = "priority-summary"

                                        self.coverage = YLeaf(YType.str, "coverage")

                                        self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                        self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                        self.total_routes = YLeaf(YType.uint32, "total-routes")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("coverage",
                                                        "fully_protected_routes",
                                                        "partially_protected_routes",
                                                        "total_routes") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.coverage.is_set or
                                            self.fully_protected_routes.is_set or
                                            self.partially_protected_routes.is_set or
                                            self.total_routes.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.coverage.yfilter != YFilter.not_set or
                                            self.fully_protected_routes.yfilter != YFilter.not_set or
                                            self.partially_protected_routes.yfilter != YFilter.not_set or
                                            self.total_routes.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-statistic" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.coverage.get_name_leafdata())
                                        if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                        if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                        if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_routes.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "coverage" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "total-routes"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "coverage"):
                                            self.coverage = value
                                            self.coverage.value_namespace = name_space
                                            self.coverage.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fully-protected-routes"):
                                            self.fully_protected_routes = value
                                            self.fully_protected_routes.value_namespace = name_space
                                            self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "partially-protected-routes"):
                                            self.partially_protected_routes = value
                                            self.partially_protected_routes.value_namespace = name_space
                                            self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-routes"):
                                            self.total_routes = value
                                            self.total_routes.value_namespace = name_space
                                            self.total_routes.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_statistic:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.level.is_set or
                                        self.threshold_exceeded.is_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                        (self.route_statistics is not None and self.route_statistics.has_data()))

                                def has_operation(self):
                                    for c in self.frr_statistic:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.threshold_exceeded.yfilter != YFilter.not_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                        (self.route_statistics is not None and self.route_statistics.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority-summary" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-statistic"):
                                        for c in self.frr_statistic:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.FrrStatistic()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_statistic.append(c)
                                        return c

                                    if (child_yang_name == "ip-convergence-time"):
                                        if (self.ip_convergence_time is None):
                                            self.ip_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.IpConvergenceTime()
                                            self.ip_convergence_time.parent = self
                                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        return self.ip_convergence_time

                                    if (child_yang_name == "mpls-convergence-time"):
                                        if (self.mpls_convergence_time is None):
                                            self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.MplsConvergenceTime()
                                            self.mpls_convergence_time.parent = self
                                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        return self.mpls_convergence_time

                                    if (child_yang_name == "route-statistics"):
                                        if (self.route_statistics is None):
                                            self.route_statistics = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary.RouteStatistics()
                                            self.route_statistics.parent = self
                                            self._children_name_map["route_statistics"] = "route-statistics"
                                        return self.route_statistics

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-statistic" or name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "threshold-exceeded"):
                                        self.threshold_exceeded = value
                                        self.threshold_exceeded.value_namespace = name_space
                                        self.threshold_exceeded.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.priority_summary:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.duration.is_set or
                                    self.is_data_complete.is_set or
                                    self.isis_level.is_set or
                                    self.state.is_set or
                                    self.threshold_exceeded.is_set or
                                    self.topology.is_set or
                                    self.total_lsp_changes.is_set or
                                    self.trigger_time.is_set or
                                    self.type.is_set)

                            def has_operation(self):
                                for c in self.priority_summary:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.duration.yfilter != YFilter.not_set or
                                    self.is_data_complete.yfilter != YFilter.not_set or
                                    self.isis_level.yfilter != YFilter.not_set or
                                    self.state.yfilter != YFilter.not_set or
                                    self.threshold_exceeded.yfilter != YFilter.not_set or
                                    self.topology.yfilter != YFilter.not_set or
                                    self.total_lsp_changes.yfilter != YFilter.not_set or
                                    self.trigger_time.yfilter != YFilter.not_set or
                                    self.type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-summary" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                if (self.is_data_complete.is_set or self.is_data_complete.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_data_complete.get_name_leafdata())
                                if (self.isis_level.is_set or self.isis_level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.isis_level.get_name_leafdata())
                                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.state.get_name_leafdata())
                                if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                                if (self.topology.is_set or self.topology.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.topology.get_name_leafdata())
                                if (self.total_lsp_changes.is_set or self.total_lsp_changes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_lsp_changes.get_name_leafdata())
                                if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.trigger_time.get_name_leafdata())
                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "priority-summary"):
                                    for c in self.priority_summary:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary.PrioritySummary()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.priority_summary.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "priority-summary" or name == "duration" or name == "is-data-complete" or name == "isis-level" or name == "state" or name == "threshold-exceeded" or name == "topology" or name == "total-lsp-changes" or name == "trigger-time" or name == "type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "duration"):
                                    self.duration = value
                                    self.duration.value_namespace = name_space
                                    self.duration.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-data-complete"):
                                    self.is_data_complete = value
                                    self.is_data_complete.value_namespace = name_space
                                    self.is_data_complete.value_namespace_prefix = name_space_prefix
                                if(value_path == "isis-level"):
                                    self.isis_level = value
                                    self.isis_level.value_namespace = name_space
                                    self.isis_level.value_namespace_prefix = name_space_prefix
                                if(value_path == "state"):
                                    self.state = value
                                    self.state.value_namespace = name_space
                                    self.state.value_namespace_prefix = name_space_prefix
                                if(value_path == "threshold-exceeded"):
                                    self.threshold_exceeded = value
                                    self.threshold_exceeded.value_namespace = name_space
                                    self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                                if(value_path == "topology"):
                                    self.topology = value
                                    self.topology.value_namespace = name_space
                                    self.topology.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-lsp-changes"):
                                    self.total_lsp_changes = value
                                    self.total_lsp_changes.value_namespace = name_space
                                    self.total_lsp_changes.value_namespace_prefix = name_space_prefix
                                if(value_path == "trigger-time"):
                                    self.trigger_time = value
                                    self.trigger_time.value_namespace = name_space
                                    self.trigger_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "type"):
                                    self.type = value
                                    self.type.value_namespace = name_space
                                    self.type.value_namespace_prefix = name_space_prefix


                        class NodeStatistics(Entity):
                            """
                            SPF Node statistics
                            
                            .. attribute:: adds
                            
                            	Added
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: deletes
                            
                            	Deleted
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: modifies
                            
                            	Modified
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: reachables
                            
                            	Reachable
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: touches
                            
                            	Touched
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unreachables
                            
                            	Unreachable
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.NodeStatistics, self).__init__()

                                self.yang_name = "node-statistics"
                                self.yang_parent_name = "spf-run-summary"

                                self.adds = YLeaf(YType.uint32, "adds")

                                self.deletes = YLeaf(YType.uint32, "deletes")

                                self.modifies = YLeaf(YType.uint32, "modifies")

                                self.reachables = YLeaf(YType.uint32, "reachables")

                                self.touches = YLeaf(YType.uint32, "touches")

                                self.unreachables = YLeaf(YType.uint32, "unreachables")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("adds",
                                                "deletes",
                                                "modifies",
                                                "reachables",
                                                "touches",
                                                "unreachables") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.NodeStatistics, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.NodeStatistics, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.adds.is_set or
                                    self.deletes.is_set or
                                    self.modifies.is_set or
                                    self.reachables.is_set or
                                    self.touches.is_set or
                                    self.unreachables.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.adds.yfilter != YFilter.not_set or
                                    self.deletes.yfilter != YFilter.not_set or
                                    self.modifies.yfilter != YFilter.not_set or
                                    self.reachables.yfilter != YFilter.not_set or
                                    self.touches.yfilter != YFilter.not_set or
                                    self.unreachables.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "node-statistics" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.adds.get_name_leafdata())
                                if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.deletes.get_name_leafdata())
                                if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.modifies.get_name_leafdata())
                                if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reachables.get_name_leafdata())
                                if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.touches.get_name_leafdata())
                                if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unreachables.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "adds"):
                                    self.adds = value
                                    self.adds.value_namespace = name_space
                                    self.adds.value_namespace_prefix = name_space_prefix
                                if(value_path == "deletes"):
                                    self.deletes = value
                                    self.deletes.value_namespace = name_space
                                    self.deletes.value_namespace_prefix = name_space_prefix
                                if(value_path == "modifies"):
                                    self.modifies = value
                                    self.modifies.value_namespace = name_space
                                    self.modifies.value_namespace_prefix = name_space_prefix
                                if(value_path == "reachables"):
                                    self.reachables = value
                                    self.reachables.value_namespace = name_space
                                    self.reachables.value_namespace_prefix = name_space_prefix
                                if(value_path == "touches"):
                                    self.touches = value
                                    self.touches.value_namespace = name_space
                                    self.touches.value_namespace_prefix = name_space_prefix
                                if(value_path == "unreachables"):
                                    self.unreachables = value
                                    self.unreachables.value_namespace = name_space
                                    self.unreachables.value_namespace_prefix = name_space_prefix


                        class TriggerLsp(Entity):
                            """
                            Trigger LSP
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsp_id
                            
                            	LSP ID
                            	**type**\:  str
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.TriggerLsp, self).__init__()

                                self.yang_name = "trigger-lsp"
                                self.yang_parent_name = "spf-run-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsp_id = YLeaf(YType.str, "lsp-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsp_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.TriggerLsp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.TriggerLsp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsp_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsp_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "trigger-lsp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsp_id.is_set or self.lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsp_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsp-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsp-id"):
                                    self.lsp_id = value
                                    self.lsp_id.value_namespace = name_space
                                    self.lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class Priority(Entity):
                            """
                            Convergence information on per\-priority basis
                            
                            .. attribute:: convergence_timeline
                            
                            	Convergence timeline details
                            	**type**\: list of    :py:class:`ConvergenceTimeline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline>`
                            
                            .. attribute:: leaf_networks_added
                            
                            	List of Leaf Networks Added
                            	**type**\: list of    :py:class:`LeafNetworksAdded <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksAdded>`
                            
                            .. attribute:: leaf_networks_deleted
                            
                            	List of Leaf Networks Deleted
                            	**type**\: list of    :py:class:`LeafNetworksDeleted <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksDeleted>`
                            
                            .. attribute:: priority_summary
                            
                            	Summary of the priority
                            	**type**\:   :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary>`
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority, self).__init__()

                                self.yang_name = "priority"
                                self.yang_parent_name = "spf-run-summary"

                                self.priority_summary = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary()
                                self.priority_summary.parent = self
                                self._children_name_map["priority_summary"] = "priority-summary"
                                self._children_yang_names.add("priority-summary")

                                self.convergence_timeline = YList(self)
                                self.leaf_networks_added = YList(self)
                                self.leaf_networks_deleted = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority, self).__setattr__(name, value)


                            class PrioritySummary(Entity):
                                """
                                Summary of the priority
                                
                                .. attribute:: frr_statistic
                                
                                	Fast Re\-Route Statistics
                                	**type**\: list of    :py:class:`FrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.FrrStatistic>`
                                
                                .. attribute:: ip_convergence_time
                                
                                	Convergence time for IP route programming
                                	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.IpConvergenceTime>`
                                
                                .. attribute:: level
                                
                                	Critical, High, Medium or Low
                                	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                
                                .. attribute:: mpls_convergence_time
                                
                                	Convergence time for MPLS label programming
                                	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.MplsConvergenceTime>`
                                
                                .. attribute:: route_statistics
                                
                                	Route statistics
                                	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.RouteStatistics>`
                                
                                .. attribute:: threshold_exceeded
                                
                                	Threshold exceeded
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary, self).__init__()

                                    self.yang_name = "priority-summary"
                                    self.yang_parent_name = "priority"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                    self.ip_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                    self._children_yang_names.add("ip-convergence-time")

                                    self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                    self._children_yang_names.add("mpls-convergence-time")

                                    self.route_statistics = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.RouteStatistics()
                                    self.route_statistics.parent = self
                                    self._children_name_map["route_statistics"] = "route-statistics"
                                    self._children_yang_names.add("route-statistics")

                                    self.frr_statistic = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "threshold_exceeded") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary, self).__setattr__(name, value)


                                class RouteStatistics(Entity):
                                    """
                                    Route statistics
                                    
                                    .. attribute:: adds
                                    
                                    	Added
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: deletes
                                    
                                    	Deleted
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: modifies
                                    
                                    	Modified
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: reachables
                                    
                                    	Reachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: touches
                                    
                                    	Touched
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: unreachables
                                    
                                    	Unreachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.RouteStatistics, self).__init__()

                                        self.yang_name = "route-statistics"
                                        self.yang_parent_name = "priority-summary"

                                        self.adds = YLeaf(YType.uint32, "adds")

                                        self.deletes = YLeaf(YType.uint32, "deletes")

                                        self.modifies = YLeaf(YType.uint32, "modifies")

                                        self.reachables = YLeaf(YType.uint32, "reachables")

                                        self.touches = YLeaf(YType.uint32, "touches")

                                        self.unreachables = YLeaf(YType.uint32, "unreachables")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("adds",
                                                        "deletes",
                                                        "modifies",
                                                        "reachables",
                                                        "touches",
                                                        "unreachables") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.adds.is_set or
                                            self.deletes.is_set or
                                            self.modifies.is_set or
                                            self.reachables.is_set or
                                            self.touches.is_set or
                                            self.unreachables.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.adds.yfilter != YFilter.not_set or
                                            self.deletes.yfilter != YFilter.not_set or
                                            self.modifies.yfilter != YFilter.not_set or
                                            self.reachables.yfilter != YFilter.not_set or
                                            self.touches.yfilter != YFilter.not_set or
                                            self.unreachables.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "route-statistics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.adds.get_name_leafdata())
                                        if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.deletes.get_name_leafdata())
                                        if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.modifies.get_name_leafdata())
                                        if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.reachables.get_name_leafdata())
                                        if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.touches.get_name_leafdata())
                                        if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.unreachables.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "adds"):
                                            self.adds = value
                                            self.adds.value_namespace = name_space
                                            self.adds.value_namespace_prefix = name_space_prefix
                                        if(value_path == "deletes"):
                                            self.deletes = value
                                            self.deletes.value_namespace = name_space
                                            self.deletes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "modifies"):
                                            self.modifies = value
                                            self.modifies.value_namespace = name_space
                                            self.modifies.value_namespace_prefix = name_space_prefix
                                        if(value_path == "reachables"):
                                            self.reachables = value
                                            self.reachables.value_namespace = name_space
                                            self.reachables.value_namespace_prefix = name_space_prefix
                                        if(value_path == "touches"):
                                            self.touches = value
                                            self.touches.value_namespace = name_space
                                            self.touches.value_namespace_prefix = name_space_prefix
                                        if(value_path == "unreachables"):
                                            self.unreachables = value
                                            self.unreachables.value_namespace = name_space
                                            self.unreachables.value_namespace_prefix = name_space_prefix


                                class IpConvergenceTime(Entity):
                                    """
                                    Convergence time for IP route programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.IpConvergenceTime, self).__init__()

                                        self.yang_name = "ip-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ip-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class MplsConvergenceTime(Entity):
                                    """
                                    Convergence time for MPLS label programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.MplsConvergenceTime, self).__init__()

                                        self.yang_name = "mpls-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mpls-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class FrrStatistic(Entity):
                                    """
                                    Fast Re\-Route Statistics
                                    
                                    .. attribute:: coverage
                                    
                                    	Coverage in percentage
                                    	**type**\:  str
                                    
                                    	**units**\: percentage
                                    
                                    .. attribute:: fully_protected_routes
                                    
                                    	Fully Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: partially_protected_routes
                                    
                                    	Partially Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_routes
                                    
                                    	Total Number of Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.FrrStatistic, self).__init__()

                                        self.yang_name = "frr-statistic"
                                        self.yang_parent_name = "priority-summary"

                                        self.coverage = YLeaf(YType.str, "coverage")

                                        self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                        self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                        self.total_routes = YLeaf(YType.uint32, "total-routes")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("coverage",
                                                        "fully_protected_routes",
                                                        "partially_protected_routes",
                                                        "total_routes") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.FrrStatistic, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.FrrStatistic, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.coverage.is_set or
                                            self.fully_protected_routes.is_set or
                                            self.partially_protected_routes.is_set or
                                            self.total_routes.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.coverage.yfilter != YFilter.not_set or
                                            self.fully_protected_routes.yfilter != YFilter.not_set or
                                            self.partially_protected_routes.yfilter != YFilter.not_set or
                                            self.total_routes.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-statistic" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.coverage.get_name_leafdata())
                                        if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                        if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                        if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_routes.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "coverage" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "total-routes"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "coverage"):
                                            self.coverage = value
                                            self.coverage.value_namespace = name_space
                                            self.coverage.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fully-protected-routes"):
                                            self.fully_protected_routes = value
                                            self.fully_protected_routes.value_namespace = name_space
                                            self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "partially-protected-routes"):
                                            self.partially_protected_routes = value
                                            self.partially_protected_routes.value_namespace = name_space
                                            self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-routes"):
                                            self.total_routes = value
                                            self.total_routes.value_namespace = name_space
                                            self.total_routes.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_statistic:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.level.is_set or
                                        self.threshold_exceeded.is_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                        (self.route_statistics is not None and self.route_statistics.has_data()))

                                def has_operation(self):
                                    for c in self.frr_statistic:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.threshold_exceeded.yfilter != YFilter.not_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                        (self.route_statistics is not None and self.route_statistics.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority-summary" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-statistic"):
                                        for c in self.frr_statistic:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.FrrStatistic()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_statistic.append(c)
                                        return c

                                    if (child_yang_name == "ip-convergence-time"):
                                        if (self.ip_convergence_time is None):
                                            self.ip_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.IpConvergenceTime()
                                            self.ip_convergence_time.parent = self
                                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        return self.ip_convergence_time

                                    if (child_yang_name == "mpls-convergence-time"):
                                        if (self.mpls_convergence_time is None):
                                            self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.MplsConvergenceTime()
                                            self.mpls_convergence_time.parent = self
                                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        return self.mpls_convergence_time

                                    if (child_yang_name == "route-statistics"):
                                        if (self.route_statistics is None):
                                            self.route_statistics = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary.RouteStatistics()
                                            self.route_statistics.parent = self
                                            self._children_name_map["route_statistics"] = "route-statistics"
                                        return self.route_statistics

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-statistic" or name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "threshold-exceeded"):
                                        self.threshold_exceeded = value
                                        self.threshold_exceeded.value_namespace = name_space
                                        self.threshold_exceeded.value_namespace_prefix = name_space_prefix


                            class ConvergenceTimeline(Entity):
                                """
                                Convergence timeline details
                                
                                .. attribute:: lc_ip
                                
                                	List of Linecards' completion point for IP routes
                                	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp>`
                                
                                .. attribute:: lc_mpls
                                
                                	List of Linecards' completion point for MPLS labels
                                	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls>`
                                
                                .. attribute:: ldp_enter
                                
                                	Entry point of LDP
                                	**type**\:   :py:class:`LdpEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpEnter>`
                                
                                .. attribute:: ldp_exit
                                
                                	Exit point of LDP to LSD
                                	**type**\:   :py:class:`LdpExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpExit>`
                                
                                .. attribute:: lsd_enter
                                
                                	Entry point of LSD
                                	**type**\:   :py:class:`LsdEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdEnter>`
                                
                                .. attribute:: lsd_exit
                                
                                	Exit point of LSD to FIBs
                                	**type**\:   :py:class:`LsdExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdExit>`
                                
                                .. attribute:: ri_bv4_enter
                                
                                	Entry point of IPv4 RIB
                                	**type**\:   :py:class:`RiBv4Enter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Enter>`
                                
                                .. attribute:: ri_bv4_exit
                                
                                	Exit point from IPv4 RIB to FIBs
                                	**type**\:   :py:class:`RiBv4Exit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Exit>`
                                
                                .. attribute:: ri_bv4_redistribute
                                
                                	Route Redistribute point from IPv4 RIB to LDP
                                	**type**\:   :py:class:`RiBv4Redistribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Redistribute>`
                                
                                .. attribute:: route_origin
                                
                                	Route origin (routing protocol)
                                	**type**\:   :py:class:`RouteOrigin <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RouteOrigin>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline, self).__init__()

                                    self.yang_name = "convergence-timeline"
                                    self.yang_parent_name = "priority"

                                    self.ldp_enter = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpEnter()
                                    self.ldp_enter.parent = self
                                    self._children_name_map["ldp_enter"] = "ldp-enter"
                                    self._children_yang_names.add("ldp-enter")

                                    self.ldp_exit = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpExit()
                                    self.ldp_exit.parent = self
                                    self._children_name_map["ldp_exit"] = "ldp-exit"
                                    self._children_yang_names.add("ldp-exit")

                                    self.lsd_enter = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdEnter()
                                    self.lsd_enter.parent = self
                                    self._children_name_map["lsd_enter"] = "lsd-enter"
                                    self._children_yang_names.add("lsd-enter")

                                    self.lsd_exit = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdExit()
                                    self.lsd_exit.parent = self
                                    self._children_name_map["lsd_exit"] = "lsd-exit"
                                    self._children_yang_names.add("lsd-exit")

                                    self.ri_bv4_enter = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Enter()
                                    self.ri_bv4_enter.parent = self
                                    self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                    self._children_yang_names.add("ri-bv4-enter")

                                    self.ri_bv4_exit = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Exit()
                                    self.ri_bv4_exit.parent = self
                                    self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                    self._children_yang_names.add("ri-bv4-exit")

                                    self.ri_bv4_redistribute = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                    self.ri_bv4_redistribute.parent = self
                                    self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                    self._children_yang_names.add("ri-bv4-redistribute")

                                    self.route_origin = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RouteOrigin()
                                    self.route_origin.parent = self
                                    self._children_name_map["route_origin"] = "route-origin"
                                    self._children_yang_names.add("route-origin")

                                    self.lc_ip = YList(self)
                                    self.lc_mpls = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline, self).__setattr__(name, value)


                                class RouteOrigin(Entity):
                                    """
                                    Route origin (routing protocol)
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RouteOrigin, self).__init__()

                                        self.yang_name = "route-origin"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "route-origin" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class RiBv4Enter(Entity):
                                    """
                                    Entry point of IPv4 RIB
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Enter, self).__init__()

                                        self.yang_name = "ri-bv4-enter"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ri-bv4-enter" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class RiBv4Exit(Entity):
                                    """
                                    Exit point from IPv4 RIB to FIBs
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Exit, self).__init__()

                                        self.yang_name = "ri-bv4-exit"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ri-bv4-exit" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class RiBv4Redistribute(Entity):
                                    """
                                    Route Redistribute point from IPv4 RIB to LDP
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__init__()

                                        self.yang_name = "ri-bv4-redistribute"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ri-bv4-redistribute" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LdpEnter(Entity):
                                    """
                                    Entry point of LDP
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpEnter, self).__init__()

                                        self.yang_name = "ldp-enter"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ldp-enter" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LdpExit(Entity):
                                    """
                                    Exit point of LDP to LSD
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpExit, self).__init__()

                                        self.yang_name = "ldp-exit"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ldp-exit" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LsdEnter(Entity):
                                    """
                                    Entry point of LSD
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdEnter, self).__init__()

                                        self.yang_name = "lsd-enter"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "lsd-enter" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LsdExit(Entity):
                                    """
                                    Exit point of LSD to FIBs
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdExit, self).__init__()

                                        self.yang_name = "lsd-exit"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "lsd-exit" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LcIp(Entity):
                                    """
                                    List of Linecards' completion point for IP
                                    routes
                                    
                                    .. attribute:: fib_complete
                                    
                                    	Completion point of FIB
                                    	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp.FibComplete>`
                                    
                                    .. attribute:: node_name
                                    
                                    	Linecard node name
                                    	**type**\:  str
                                    
                                    .. attribute:: speed
                                    
                                    	Relative convergence speed
                                    	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp, self).__init__()

                                        self.yang_name = "lc-ip"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.node_name = YLeaf(YType.str, "node-name")

                                        self.speed = YLeaf(YType.enumeration, "speed")

                                        self.fib_complete = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                        self.fib_complete.parent = self
                                        self._children_name_map["fib_complete"] = "fib-complete"
                                        self._children_yang_names.add("fib-complete")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("node_name",
                                                        "speed") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)


                                    class FibComplete(Entity):
                                        """
                                        Completion point of FIB
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__init__()

                                            self.yang_name = "fib-complete"
                                            self.yang_parent_name = "lc-ip"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "fib-complete" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.node_name.is_set or
                                            self.speed.is_set or
                                            (self.fib_complete is not None and self.fib_complete.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.node_name.yfilter != YFilter.not_set or
                                            self.speed.yfilter != YFilter.not_set or
                                            (self.fib_complete is not None and self.fib_complete.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "lc-ip" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.node_name.get_name_leafdata())
                                        if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.speed.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "fib-complete"):
                                            if (self.fib_complete is None):
                                                self.fib_complete = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                                self.fib_complete.parent = self
                                                self._children_name_map["fib_complete"] = "fib-complete"
                                            return self.fib_complete

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "node-name"):
                                            self.node_name = value
                                            self.node_name.value_namespace = name_space
                                            self.node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "speed"):
                                            self.speed = value
                                            self.speed.value_namespace = name_space
                                            self.speed.value_namespace_prefix = name_space_prefix


                                class LcMpls(Entity):
                                    """
                                    List of Linecards' completion point for MPLS
                                    labels
                                    
                                    .. attribute:: fib_complete
                                    
                                    	Completion point of FIB
                                    	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls.FibComplete>`
                                    
                                    .. attribute:: node_name
                                    
                                    	Linecard node name
                                    	**type**\:  str
                                    
                                    .. attribute:: speed
                                    
                                    	Relative convergence speed
                                    	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls, self).__init__()

                                        self.yang_name = "lc-mpls"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.node_name = YLeaf(YType.str, "node-name")

                                        self.speed = YLeaf(YType.enumeration, "speed")

                                        self.fib_complete = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                        self.fib_complete.parent = self
                                        self._children_name_map["fib_complete"] = "fib-complete"
                                        self._children_yang_names.add("fib-complete")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("node_name",
                                                        "speed") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)


                                    class FibComplete(Entity):
                                        """
                                        Completion point of FIB
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__init__()

                                            self.yang_name = "fib-complete"
                                            self.yang_parent_name = "lc-mpls"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "fib-complete" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.node_name.is_set or
                                            self.speed.is_set or
                                            (self.fib_complete is not None and self.fib_complete.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.node_name.yfilter != YFilter.not_set or
                                            self.speed.yfilter != YFilter.not_set or
                                            (self.fib_complete is not None and self.fib_complete.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "lc-mpls" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.node_name.get_name_leafdata())
                                        if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.speed.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "fib-complete"):
                                            if (self.fib_complete is None):
                                                self.fib_complete = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                                self.fib_complete.parent = self
                                                self._children_name_map["fib_complete"] = "fib-complete"
                                            return self.fib_complete

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "node-name"):
                                            self.node_name = value
                                            self.node_name.value_namespace = name_space
                                            self.node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "speed"):
                                            self.speed = value
                                            self.speed.value_namespace = name_space
                                            self.speed.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.lc_ip:
                                        if (c.has_data()):
                                            return True
                                    for c in self.lc_mpls:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        (self.ldp_enter is not None and self.ldp_enter.has_data()) or
                                        (self.ldp_exit is not None and self.ldp_exit.has_data()) or
                                        (self.lsd_enter is not None and self.lsd_enter.has_data()) or
                                        (self.lsd_exit is not None and self.lsd_exit.has_data()) or
                                        (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_data()) or
                                        (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_data()) or
                                        (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_data()) or
                                        (self.route_origin is not None and self.route_origin.has_data()))

                                def has_operation(self):
                                    for c in self.lc_ip:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.lc_mpls:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.ldp_enter is not None and self.ldp_enter.has_operation()) or
                                        (self.ldp_exit is not None and self.ldp_exit.has_operation()) or
                                        (self.lsd_enter is not None and self.lsd_enter.has_operation()) or
                                        (self.lsd_exit is not None and self.lsd_exit.has_operation()) or
                                        (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_operation()) or
                                        (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_operation()) or
                                        (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_operation()) or
                                        (self.route_origin is not None and self.route_origin.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "convergence-timeline" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "lc-ip"):
                                        for c in self.lc_ip:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcIp()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.lc_ip.append(c)
                                        return c

                                    if (child_yang_name == "lc-mpls"):
                                        for c in self.lc_mpls:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LcMpls()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.lc_mpls.append(c)
                                        return c

                                    if (child_yang_name == "ldp-enter"):
                                        if (self.ldp_enter is None):
                                            self.ldp_enter = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpEnter()
                                            self.ldp_enter.parent = self
                                            self._children_name_map["ldp_enter"] = "ldp-enter"
                                        return self.ldp_enter

                                    if (child_yang_name == "ldp-exit"):
                                        if (self.ldp_exit is None):
                                            self.ldp_exit = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LdpExit()
                                            self.ldp_exit.parent = self
                                            self._children_name_map["ldp_exit"] = "ldp-exit"
                                        return self.ldp_exit

                                    if (child_yang_name == "lsd-enter"):
                                        if (self.lsd_enter is None):
                                            self.lsd_enter = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdEnter()
                                            self.lsd_enter.parent = self
                                            self._children_name_map["lsd_enter"] = "lsd-enter"
                                        return self.lsd_enter

                                    if (child_yang_name == "lsd-exit"):
                                        if (self.lsd_exit is None):
                                            self.lsd_exit = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.LsdExit()
                                            self.lsd_exit.parent = self
                                            self._children_name_map["lsd_exit"] = "lsd-exit"
                                        return self.lsd_exit

                                    if (child_yang_name == "ri-bv4-enter"):
                                        if (self.ri_bv4_enter is None):
                                            self.ri_bv4_enter = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Enter()
                                            self.ri_bv4_enter.parent = self
                                            self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                        return self.ri_bv4_enter

                                    if (child_yang_name == "ri-bv4-exit"):
                                        if (self.ri_bv4_exit is None):
                                            self.ri_bv4_exit = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Exit()
                                            self.ri_bv4_exit.parent = self
                                            self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                        return self.ri_bv4_exit

                                    if (child_yang_name == "ri-bv4-redistribute"):
                                        if (self.ri_bv4_redistribute is None):
                                            self.ri_bv4_redistribute = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                            self.ri_bv4_redistribute.parent = self
                                            self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                        return self.ri_bv4_redistribute

                                    if (child_yang_name == "route-origin"):
                                        if (self.route_origin is None):
                                            self.route_origin = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline.RouteOrigin()
                                            self.route_origin.parent = self
                                            self._children_name_map["route_origin"] = "route-origin"
                                        return self.route_origin

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class LeafNetworksAdded(Entity):
                                """
                                List of Leaf Networks Added
                                
                                .. attribute:: address
                                
                                	IP address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: net_mask
                                
                                	Mask
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksAdded, self).__init__()

                                    self.yang_name = "leaf-networks-added"
                                    self.yang_parent_name = "priority"

                                    self.address = YLeaf(YType.str, "address")

                                    self.net_mask = YLeaf(YType.uint8, "net-mask")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address",
                                                    "net_mask") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksAdded, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksAdded, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address.is_set or
                                        self.net_mask.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address.yfilter != YFilter.not_set or
                                        self.net_mask.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "leaf-networks-added" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address.get_name_leafdata())
                                    if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.net_mask.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address" or name == "net-mask"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address"):
                                        self.address = value
                                        self.address.value_namespace = name_space
                                        self.address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "net-mask"):
                                        self.net_mask = value
                                        self.net_mask.value_namespace = name_space
                                        self.net_mask.value_namespace_prefix = name_space_prefix


                            class LeafNetworksDeleted(Entity):
                                """
                                List of Leaf Networks Deleted
                                
                                .. attribute:: address
                                
                                	IP address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: net_mask
                                
                                	Mask
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksDeleted, self).__init__()

                                    self.yang_name = "leaf-networks-deleted"
                                    self.yang_parent_name = "priority"

                                    self.address = YLeaf(YType.str, "address")

                                    self.net_mask = YLeaf(YType.uint8, "net-mask")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address",
                                                    "net_mask") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksDeleted, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksDeleted, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address.is_set or
                                        self.net_mask.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address.yfilter != YFilter.not_set or
                                        self.net_mask.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "leaf-networks-deleted" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address.get_name_leafdata())
                                    if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.net_mask.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address" or name == "net-mask"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address"):
                                        self.address = value
                                        self.address.value_namespace = name_space
                                        self.address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "net-mask"):
                                        self.net_mask = value
                                        self.net_mask.value_namespace = name_space
                                        self.net_mask.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.convergence_timeline:
                                    if (c.has_data()):
                                        return True
                                for c in self.leaf_networks_added:
                                    if (c.has_data()):
                                        return True
                                for c in self.leaf_networks_deleted:
                                    if (c.has_data()):
                                        return True
                                return (self.priority_summary is not None and self.priority_summary.has_data())

                            def has_operation(self):
                                for c in self.convergence_timeline:
                                    if (c.has_operation()):
                                        return True
                                for c in self.leaf_networks_added:
                                    if (c.has_operation()):
                                        return True
                                for c in self.leaf_networks_deleted:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.priority_summary is not None and self.priority_summary.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "priority" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "convergence-timeline"):
                                    for c in self.convergence_timeline:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.ConvergenceTimeline()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.convergence_timeline.append(c)
                                    return c

                                if (child_yang_name == "leaf-networks-added"):
                                    for c in self.leaf_networks_added:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksAdded()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.leaf_networks_added.append(c)
                                    return c

                                if (child_yang_name == "leaf-networks-deleted"):
                                    for c in self.leaf_networks_deleted:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.LeafNetworksDeleted()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.leaf_networks_deleted.append(c)
                                    return c

                                if (child_yang_name == "priority-summary"):
                                    if (self.priority_summary is None):
                                        self.priority_summary = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority.PrioritySummary()
                                        self.priority_summary.parent = self
                                        self._children_name_map["priority_summary"] = "priority-summary"
                                    return self.priority_summary

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "convergence-timeline" or name == "leaf-networks-added" or name == "leaf-networks-deleted" or name == "priority-summary"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class LspProcessed(Entity):
                            """
                            List of LSP changes processed
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsp_id
                            
                            	LSP ID
                            	**type**\:  str
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspProcessed, self).__init__()

                                self.yang_name = "lsp-processed"
                                self.yang_parent_name = "spf-run-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsp_id = YLeaf(YType.str, "lsp-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsp_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspProcessed, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspProcessed, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsp_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsp_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsp-processed" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsp_id.is_set or self.lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsp_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsp-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsp-id"):
                                    self.lsp_id = value
                                    self.lsp_id.value_namespace = name_space
                                    self.lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class LspRegenerated(Entity):
                            """
                            List of LSP regenerated
                            
                            .. attribute:: isis_level
                            
                            	ISIS Level
                            	**type**\:   :py:class:`RcmdIsisLvl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdIsisLvl>`
                            
                            .. attribute:: lsp_id
                            
                            	LSP ID
                            	**type**\:  str
                            
                            .. attribute:: reason
                            
                            	Trigger reasons for LSP regeneration. Example\: pr^ \- periodic, cr^ \- clear (Check the documentation for the entire list)
                            	**type**\:  str
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: serial_number_xr
                            
                            	Serial Number of the session event
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: spf_run_number
                            
                            	SPF Run Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspRegenerated, self).__init__()

                                self.yang_name = "lsp-regenerated"
                                self.yang_parent_name = "spf-run-summary"

                                self.isis_level = YLeaf(YType.enumeration, "isis-level")

                                self.lsp_id = YLeaf(YType.str, "lsp-id")

                                self.reason = YLeaf(YType.str, "reason")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                                self.serial_number_xr = YLeaf(YType.uint32, "serial-number-xr")

                                self.spf_run_number = YLeaf(YType.uint32, "spf-run-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("isis_level",
                                                "lsp_id",
                                                "reason",
                                                "reception_time",
                                                "sequence_number",
                                                "serial_number_xr",
                                                "spf_run_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspRegenerated, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspRegenerated, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.isis_level.is_set or
                                    self.lsp_id.is_set or
                                    self.reason.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set or
                                    self.serial_number_xr.is_set or
                                    self.spf_run_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.isis_level.yfilter != YFilter.not_set or
                                    self.lsp_id.yfilter != YFilter.not_set or
                                    self.reason.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set or
                                    self.serial_number_xr.yfilter != YFilter.not_set or
                                    self.spf_run_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsp-regenerated" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.isis_level.is_set or self.isis_level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.isis_level.get_name_leafdata())
                                if (self.lsp_id.is_set or self.lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsp_id.get_name_leafdata())
                                if (self.reason.is_set or self.reason.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reason.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())
                                if (self.serial_number_xr.is_set or self.serial_number_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.serial_number_xr.get_name_leafdata())
                                if (self.spf_run_number.is_set or self.spf_run_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.spf_run_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "isis-level" or name == "lsp-id" or name == "reason" or name == "reception-time" or name == "sequence-number" or name == "serial-number-xr" or name == "spf-run-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "isis-level"):
                                    self.isis_level = value
                                    self.isis_level.value_namespace = name_space
                                    self.isis_level.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsp-id"):
                                    self.lsp_id = value
                                    self.lsp_id.value_namespace = name_space
                                    self.lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reason"):
                                    self.reason = value
                                    self.reason.value_namespace = name_space
                                    self.reason.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix
                                if(value_path == "serial-number-xr"):
                                    self.serial_number_xr = value
                                    self.serial_number_xr.value_namespace = name_space
                                    self.serial_number_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "spf-run-number"):
                                    self.spf_run_number = value
                                    self.spf_run_number.value_namespace = name_space
                                    self.spf_run_number.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsp_processed:
                                if (c.has_data()):
                                    return True
                            for c in self.lsp_regenerated:
                                if (c.has_data()):
                                    return True
                            for c in self.priority:
                                if (c.has_data()):
                                    return True
                            for c in self.trigger_lsp:
                                if (c.has_data()):
                                    return True
                            return (
                                self.spf_run_number.is_set or
                                self.reason.is_set or
                                self.start_time.is_set or
                                self.wait_time.is_set or
                                (self.node_statistics is not None and self.node_statistics.has_data()) or
                                (self.spf_summary is not None and self.spf_summary.has_data()))

                        def has_operation(self):
                            for c in self.lsp_processed:
                                if (c.has_operation()):
                                    return True
                            for c in self.lsp_regenerated:
                                if (c.has_operation()):
                                    return True
                            for c in self.priority:
                                if (c.has_operation()):
                                    return True
                            for c in self.trigger_lsp:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.spf_run_number.yfilter != YFilter.not_set or
                                self.reason.yfilter != YFilter.not_set or
                                self.start_time.yfilter != YFilter.not_set or
                                self.wait_time.yfilter != YFilter.not_set or
                                (self.node_statistics is not None and self.node_statistics.has_operation()) or
                                (self.spf_summary is not None and self.spf_summary.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "spf-run-summary" + "[spf-run-number='" + self.spf_run_number.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.spf_run_number.is_set or self.spf_run_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_number.get_name_leafdata())
                            if (self.reason.is_set or self.reason.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reason.get_name_leafdata())
                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_time.get_name_leafdata())
                            if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wait_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsp-processed"):
                                for c in self.lsp_processed:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspProcessed()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsp_processed.append(c)
                                return c

                            if (child_yang_name == "lsp-regenerated"):
                                for c in self.lsp_regenerated:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.LspRegenerated()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsp_regenerated.append(c)
                                return c

                            if (child_yang_name == "node-statistics"):
                                if (self.node_statistics is None):
                                    self.node_statistics = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.NodeStatistics()
                                    self.node_statistics.parent = self
                                    self._children_name_map["node_statistics"] = "node-statistics"
                                return self.node_statistics

                            if (child_yang_name == "priority"):
                                for c in self.priority:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.Priority()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.priority.append(c)
                                return c

                            if (child_yang_name == "spf-summary"):
                                if (self.spf_summary is None):
                                    self.spf_summary = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.SpfSummary()
                                    self.spf_summary.parent = self
                                    self._children_name_map["spf_summary"] = "spf-summary"
                                return self.spf_summary

                            if (child_yang_name == "trigger-lsp"):
                                for c in self.trigger_lsp:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary.TriggerLsp()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.trigger_lsp.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsp-processed" or name == "lsp-regenerated" or name == "node-statistics" or name == "priority" or name == "spf-summary" or name == "trigger-lsp" or name == "spf-run-number" or name == "reason" or name == "start-time" or name == "wait-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "spf-run-number"):
                                self.spf_run_number = value
                                self.spf_run_number.value_namespace = name_space
                                self.spf_run_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "reason"):
                                self.reason = value
                                self.reason.value_namespace = name_space
                                self.reason.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-time"):
                                self.start_time = value
                                self.start_time.value_namespace = name_space
                                self.start_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "wait-time"):
                                self.wait_time = value
                                self.wait_time.value_namespace = name_space
                                self.wait_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.spf_run_summary:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.spf_run_summary:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "spf-run-summaries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "spf-run-summary"):
                            for c in self.spf_run_summary:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Isis.Instances.Instance.SpfRunSummaries.SpfRunSummary()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.spf_run_summary.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "spf-run-summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class IpfrrEventOfflines(Entity):
                    """
                    ISIS IP\-FRR Event offline data
                    
                    .. attribute:: ipfrr_event_offline
                    
                    	Offline operational data for particular ISIS IP\-FRR Event
                    	**type**\: list of    :py:class:`IpfrrEventOffline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines, self).__init__()

                        self.yang_name = "ipfrr-event-offlines"
                        self.yang_parent_name = "instance"

                        self.ipfrr_event_offline = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines, self).__setattr__(name, value)


                    class IpfrrEventOffline(Entity):
                        """
                        Offline operational data for particular ISIS
                        IP\-FRR Event
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific IP\-FRR Event
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: completed_spf_run
                        
                        	IP\-Frr Completed reference SPF Run Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: coverage
                        
                        	Coverage in percentage for all priorities
                        	**type**\:  str
                        
                        	**units**\: percentage
                        
                        .. attribute:: duration
                        
                        	Duration for the calculation (in milliseconds)
                        	**type**\:  str
                        
                        	**units**\: millisecond
                        
                        .. attribute:: event_id_xr
                        
                        	IP\-Frr Event ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: fully_protected_routes
                        
                        	Cumulative Number of Fully Protected Routes
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ipfrr_statistic
                        
                        	IP\-Frr Statistics categorized by priority
                        	**type**\: list of    :py:class:`IpfrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic>`
                        
                        .. attribute:: partially_protected_routes
                        
                        	Cumulative Number of Partially Protected Routes
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: remote_node
                        
                        	Remote Node Information
                        	**type**\: list of    :py:class:`RemoteNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode>`
                        
                        .. attribute:: start_time_offset
                        
                        	Start Time offset from trigger time (in milliseconds)
                        	**type**\:  str
                        
                        	**units**\: millisecond
                        
                        .. attribute:: total_routes
                        
                        	Cumulative Number of Routes for all priorities
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: trigger_spf_run
                        
                        	IP\-Frr Triggered reference SPF Run Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: trigger_time
                        
                        	Trigger time  (eg\: Apr 24 13\:16\:04.961)
                        	**type**\:  str
                        
                        .. attribute:: wait_time
                        
                        	Waiting Time (in milliseconds)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**units**\: millisecond
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline, self).__init__()

                            self.yang_name = "ipfrr-event-offline"
                            self.yang_parent_name = "ipfrr-event-offlines"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.completed_spf_run = YLeaf(YType.uint32, "completed-spf-run")

                            self.coverage = YLeaf(YType.str, "coverage")

                            self.duration = YLeaf(YType.str, "duration")

                            self.event_id_xr = YLeaf(YType.uint32, "event-id-xr")

                            self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                            self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                            self.start_time_offset = YLeaf(YType.str, "start-time-offset")

                            self.total_routes = YLeaf(YType.uint32, "total-routes")

                            self.trigger_spf_run = YLeaf(YType.uint32, "trigger-spf-run")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.wait_time = YLeaf(YType.uint32, "wait-time")

                            self.ipfrr_statistic = YList(self)
                            self.remote_node = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "completed_spf_run",
                                            "coverage",
                                            "duration",
                                            "event_id_xr",
                                            "fully_protected_routes",
                                            "partially_protected_routes",
                                            "start_time_offset",
                                            "total_routes",
                                            "trigger_spf_run",
                                            "trigger_time",
                                            "wait_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline, self).__setattr__(name, value)


                        class IpfrrStatistic(Entity):
                            """
                            IP\-Frr Statistics categorized by priority
                            
                            .. attribute:: below_threshold
                            
                            	Covearge is below Configured Threshold
                            	**type**\:  bool
                            
                            .. attribute:: coverage
                            
                            	Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: fully_protected_routes
                            
                            	Fully Protected Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: local_lfa_coverage
                            
                            	Local LFA Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: partially_protected_routes
                            
                            	Partially Protected Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: priority
                            
                            	Priority
                            	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                            
                            .. attribute:: remote_lfa_coverage
                            
                            	Remote LFA Coverage in percentage
                            	**type**\:  str
                            
                            	**units**\: percentage
                            
                            .. attribute:: total_routes
                            
                            	Total Number of Routes
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic, self).__init__()

                                self.yang_name = "ipfrr-statistic"
                                self.yang_parent_name = "ipfrr-event-offline"

                                self.below_threshold = YLeaf(YType.boolean, "below-threshold")

                                self.coverage = YLeaf(YType.str, "coverage")

                                self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                self.local_lfa_coverage = YLeaf(YType.str, "local-lfa-coverage")

                                self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                self.priority = YLeaf(YType.enumeration, "priority")

                                self.remote_lfa_coverage = YLeaf(YType.str, "remote-lfa-coverage")

                                self.total_routes = YLeaf(YType.uint32, "total-routes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("below_threshold",
                                                "coverage",
                                                "fully_protected_routes",
                                                "local_lfa_coverage",
                                                "partially_protected_routes",
                                                "priority",
                                                "remote_lfa_coverage",
                                                "total_routes") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.below_threshold.is_set or
                                    self.coverage.is_set or
                                    self.fully_protected_routes.is_set or
                                    self.local_lfa_coverage.is_set or
                                    self.partially_protected_routes.is_set or
                                    self.priority.is_set or
                                    self.remote_lfa_coverage.is_set or
                                    self.total_routes.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.below_threshold.yfilter != YFilter.not_set or
                                    self.coverage.yfilter != YFilter.not_set or
                                    self.fully_protected_routes.yfilter != YFilter.not_set or
                                    self.local_lfa_coverage.yfilter != YFilter.not_set or
                                    self.partially_protected_routes.yfilter != YFilter.not_set or
                                    self.priority.yfilter != YFilter.not_set or
                                    self.remote_lfa_coverage.yfilter != YFilter.not_set or
                                    self.total_routes.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ipfrr-statistic" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.below_threshold.is_set or self.below_threshold.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.below_threshold.get_name_leafdata())
                                if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.coverage.get_name_leafdata())
                                if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                if (self.local_lfa_coverage.is_set or self.local_lfa_coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.local_lfa_coverage.get_name_leafdata())
                                if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.priority.get_name_leafdata())
                                if (self.remote_lfa_coverage.is_set or self.remote_lfa_coverage.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_lfa_coverage.get_name_leafdata())
                                if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_routes.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "below-threshold" or name == "coverage" or name == "fully-protected-routes" or name == "local-lfa-coverage" or name == "partially-protected-routes" or name == "priority" or name == "remote-lfa-coverage" or name == "total-routes"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "below-threshold"):
                                    self.below_threshold = value
                                    self.below_threshold.value_namespace = name_space
                                    self.below_threshold.value_namespace_prefix = name_space_prefix
                                if(value_path == "coverage"):
                                    self.coverage = value
                                    self.coverage.value_namespace = name_space
                                    self.coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "fully-protected-routes"):
                                    self.fully_protected_routes = value
                                    self.fully_protected_routes.value_namespace = name_space
                                    self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "local-lfa-coverage"):
                                    self.local_lfa_coverage = value
                                    self.local_lfa_coverage.value_namespace = name_space
                                    self.local_lfa_coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "partially-protected-routes"):
                                    self.partially_protected_routes = value
                                    self.partially_protected_routes.value_namespace = name_space
                                    self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                if(value_path == "priority"):
                                    self.priority = value
                                    self.priority.value_namespace = name_space
                                    self.priority.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-lfa-coverage"):
                                    self.remote_lfa_coverage = value
                                    self.remote_lfa_coverage.value_namespace = name_space
                                    self.remote_lfa_coverage.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-routes"):
                                    self.total_routes = value
                                    self.total_routes.value_namespace = name_space
                                    self.total_routes.value_namespace_prefix = name_space_prefix


                        class RemoteNode(Entity):
                            """
                            Remote Node Information
                            
                            .. attribute:: in_use_time
                            
                            	Inuse time of the Remote Node (eg\: Apr 24 13\:16 \:04.961)
                            	**type**\:  str
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_count
                            
                            	Number of paths protected by this Remote Node
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: primary_path
                            
                            	Protected Primary Paths
                            	**type**\: list of    :py:class:`PrimaryPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath>`
                            
                            .. attribute:: remote_node_id
                            
                            	Remote\-LFA Node ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode, self).__init__()

                                self.yang_name = "remote-node"
                                self.yang_parent_name = "ipfrr-event-offline"

                                self.in_use_time = YLeaf(YType.str, "in-use-time")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_count = YLeaf(YType.uint32, "path-count")

                                self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                self.primary_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("in_use_time",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_count",
                                                "remote_node_id") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode, self).__setattr__(name, value)


                            class PrimaryPath(Entity):
                                """
                                Protected Primary Paths
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath, self).__init__()

                                    self.yang_name = "primary-path"
                                    self.yang_parent_name = "remote-node"

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("interface_name",
                                                    "neighbour_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.interface_name.is_set or
                                        self.neighbour_address.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "primary-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "interface-name" or name == "neighbour-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.primary_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.in_use_time.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_count.is_set or
                                    self.remote_node_id.is_set)

                            def has_operation(self):
                                for c in self.primary_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.in_use_time.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_count.yfilter != YFilter.not_set or
                                    self.remote_node_id.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "remote-node" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.in_use_time.is_set or self.in_use_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.in_use_time.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_count.is_set or self.path_count.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_count.get_name_leafdata())
                                if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "primary-path"):
                                    for c in self.primary_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode.PrimaryPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.primary_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "primary-path" or name == "in-use-time" or name == "interface-name" or name == "neighbour-address" or name == "path-count" or name == "remote-node-id"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "in-use-time"):
                                    self.in_use_time = value
                                    self.in_use_time.value_namespace = name_space
                                    self.in_use_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-count"):
                                    self.path_count = value
                                    self.path_count.value_namespace = name_space
                                    self.path_count.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-node-id"):
                                    self.remote_node_id = value
                                    self.remote_node_id.value_namespace = name_space
                                    self.remote_node_id.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.ipfrr_statistic:
                                if (c.has_data()):
                                    return True
                            for c in self.remote_node:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.completed_spf_run.is_set or
                                self.coverage.is_set or
                                self.duration.is_set or
                                self.event_id_xr.is_set or
                                self.fully_protected_routes.is_set or
                                self.partially_protected_routes.is_set or
                                self.start_time_offset.is_set or
                                self.total_routes.is_set or
                                self.trigger_spf_run.is_set or
                                self.trigger_time.is_set or
                                self.wait_time.is_set)

                        def has_operation(self):
                            for c in self.ipfrr_statistic:
                                if (c.has_operation()):
                                    return True
                            for c in self.remote_node:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.completed_spf_run.yfilter != YFilter.not_set or
                                self.coverage.yfilter != YFilter.not_set or
                                self.duration.yfilter != YFilter.not_set or
                                self.event_id_xr.yfilter != YFilter.not_set or
                                self.fully_protected_routes.yfilter != YFilter.not_set or
                                self.partially_protected_routes.yfilter != YFilter.not_set or
                                self.start_time_offset.yfilter != YFilter.not_set or
                                self.total_routes.yfilter != YFilter.not_set or
                                self.trigger_spf_run.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                self.wait_time.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipfrr-event-offline" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.completed_spf_run.is_set or self.completed_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.completed_spf_run.get_name_leafdata())
                            if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.coverage.get_name_leafdata())
                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.duration.get_name_leafdata())
                            if (self.event_id_xr.is_set or self.event_id_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id_xr.get_name_leafdata())
                            if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                            if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                            if (self.start_time_offset.is_set or self.start_time_offset.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_time_offset.get_name_leafdata())
                            if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_routes.get_name_leafdata())
                            if (self.trigger_spf_run.is_set or self.trigger_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_spf_run.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())
                            if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wait_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ipfrr-statistic"):
                                for c in self.ipfrr_statistic:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.IpfrrStatistic()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.ipfrr_statistic.append(c)
                                return c

                            if (child_yang_name == "remote-node"):
                                for c in self.remote_node:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline.RemoteNode()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.remote_node.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ipfrr-statistic" or name == "remote-node" or name == "event-id" or name == "completed-spf-run" or name == "coverage" or name == "duration" or name == "event-id-xr" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "start-time-offset" or name == "total-routes" or name == "trigger-spf-run" or name == "trigger-time" or name == "wait-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "completed-spf-run"):
                                self.completed_spf_run = value
                                self.completed_spf_run.value_namespace = name_space
                                self.completed_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "coverage"):
                                self.coverage = value
                                self.coverage.value_namespace = name_space
                                self.coverage.value_namespace_prefix = name_space_prefix
                            if(value_path == "duration"):
                                self.duration = value
                                self.duration.value_namespace = name_space
                                self.duration.value_namespace_prefix = name_space_prefix
                            if(value_path == "event-id-xr"):
                                self.event_id_xr = value
                                self.event_id_xr.value_namespace = name_space
                                self.event_id_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "fully-protected-routes"):
                                self.fully_protected_routes = value
                                self.fully_protected_routes.value_namespace = name_space
                                self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "partially-protected-routes"):
                                self.partially_protected_routes = value
                                self.partially_protected_routes.value_namespace = name_space
                                self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-time-offset"):
                                self.start_time_offset = value
                                self.start_time_offset.value_namespace = name_space
                                self.start_time_offset.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-routes"):
                                self.total_routes = value
                                self.total_routes.value_namespace = name_space
                                self.total_routes.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-spf-run"):
                                self.trigger_spf_run = value
                                self.trigger_spf_run.value_namespace = name_space
                                self.trigger_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "wait-time"):
                                self.wait_time = value
                                self.wait_time.value_namespace = name_space
                                self.wait_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.ipfrr_event_offline:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.ipfrr_event_offline:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ipfrr-event-offlines" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ipfrr-event-offline"):
                            for c in self.ipfrr_event_offline:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Isis.Instances.Instance.IpfrrEventOfflines.IpfrrEventOffline()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.ipfrr_event_offline.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ipfrr-event-offline"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class SpfRunOfflines(Entity):
                    """
                    ISIS SPF run offline data
                    
                    .. attribute:: spf_run_offline
                    
                    	Offline operational data for particular ISIS SPF run
                    	**type**\: list of    :py:class:`SpfRunOffline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines, self).__init__()

                        self.yang_name = "spf-run-offlines"
                        self.yang_parent_name = "instance"

                        self.spf_run_offline = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines, self).__setattr__(name, value)


                    class SpfRunOffline(Entity):
                        """
                        Offline operational data for particular ISIS
                        SPF run
                        
                        .. attribute:: spf_run_number  <key>
                        
                        	Specific SPF run
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: lsp_processed
                        
                        	List of LSP changes processed
                        	**type**\: list of    :py:class:`LspProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspProcessed>`
                        
                        .. attribute:: lsp_regenerated
                        
                        	List of LSP regenerated
                        	**type**\: list of    :py:class:`LspRegenerated <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspRegenerated>`
                        
                        .. attribute:: node_statistics
                        
                        	SPF Node statistics
                        	**type**\:   :py:class:`NodeStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.NodeStatistics>`
                        
                        .. attribute:: priority
                        
                        	Convergence information on per\-priority basis
                        	**type**\: list of    :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority>`
                        
                        .. attribute:: reason
                        
                        	Trigger reasons for SPF run. Example\: pr^ \- periodic, cr^ \- clear (Check the documentation for the entire list)
                        	**type**\:  str
                        
                        .. attribute:: spf_summary
                        
                        	SPF summary information
                        	**type**\:   :py:class:`SpfSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary>`
                        
                        .. attribute:: start_time
                        
                        	Start time (offset from event trigger time in ss .msec)
                        	**type**\:  str
                        
                        .. attribute:: trigger_lsp
                        
                        	Trigger LSP
                        	**type**\: list of    :py:class:`TriggerLsp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.TriggerLsp>`
                        
                        .. attribute:: wait_time
                        
                        	Wait time applied at SPF schedule (in msec)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline, self).__init__()

                            self.yang_name = "spf-run-offline"
                            self.yang_parent_name = "spf-run-offlines"

                            self.spf_run_number = YLeaf(YType.int32, "spf-run-number")

                            self.reason = YLeaf(YType.str, "reason")

                            self.start_time = YLeaf(YType.str, "start-time")

                            self.wait_time = YLeaf(YType.uint32, "wait-time")

                            self.node_statistics = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.NodeStatistics()
                            self.node_statistics.parent = self
                            self._children_name_map["node_statistics"] = "node-statistics"
                            self._children_yang_names.add("node-statistics")

                            self.spf_summary = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary()
                            self.spf_summary.parent = self
                            self._children_name_map["spf_summary"] = "spf-summary"
                            self._children_yang_names.add("spf-summary")

                            self.lsp_processed = YList(self)
                            self.lsp_regenerated = YList(self)
                            self.priority = YList(self)
                            self.trigger_lsp = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("spf_run_number",
                                            "reason",
                                            "start_time",
                                            "wait_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline, self).__setattr__(name, value)


                        class SpfSummary(Entity):
                            """
                            SPF summary information
                            
                            .. attribute:: duration
                            
                            	Duration of SPF calculation (in ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: is_data_complete
                            
                            	Whether the event has all information
                            	**type**\:  bool
                            
                            .. attribute:: isis_level
                            
                            	ISIS Level
                            	**type**\:   :py:class:`RcmdIsisLvl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdIsisLvl>`
                            
                            .. attribute:: priority_summary
                            
                            	Convergence information summary on per\-priority basis
                            	**type**\: list of    :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary>`
                            
                            .. attribute:: state
                            
                            	SPF state
                            	**type**\:   :py:class:`RcmdSpfState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdSpfState>`
                            
                            .. attribute:: threshold_exceeded
                            
                            	Threshold exceeded
                            	**type**\:  bool
                            
                            .. attribute:: topology
                            
                            	Topology index (multi\-topology)
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: total_lsp_changes
                            
                            	Total number of LSP changes processed
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: trigger_time
                            
                            	Trigger time (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: type
                            
                            	Type of SPF
                            	**type**\:   :py:class:`RcmdIsisSpf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdIsisSpf>`
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary, self).__init__()

                                self.yang_name = "spf-summary"
                                self.yang_parent_name = "spf-run-offline"

                                self.duration = YLeaf(YType.str, "duration")

                                self.is_data_complete = YLeaf(YType.boolean, "is-data-complete")

                                self.isis_level = YLeaf(YType.enumeration, "isis-level")

                                self.state = YLeaf(YType.enumeration, "state")

                                self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                self.topology = YLeaf(YType.uint32, "topology")

                                self.total_lsp_changes = YLeaf(YType.uint16, "total-lsp-changes")

                                self.trigger_time = YLeaf(YType.str, "trigger-time")

                                self.type = YLeaf(YType.enumeration, "type")

                                self.priority_summary = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("duration",
                                                "is_data_complete",
                                                "isis_level",
                                                "state",
                                                "threshold_exceeded",
                                                "topology",
                                                "total_lsp_changes",
                                                "trigger_time",
                                                "type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary, self).__setattr__(name, value)


                            class PrioritySummary(Entity):
                                """
                                Convergence information summary on per\-priority
                                basis
                                
                                .. attribute:: frr_statistic
                                
                                	Fast Re\-Route Statistics
                                	**type**\: list of    :py:class:`FrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic>`
                                
                                .. attribute:: ip_convergence_time
                                
                                	Convergence time for IP route programming
                                	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime>`
                                
                                .. attribute:: level
                                
                                	Critical, High, Medium or Low
                                	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                
                                .. attribute:: mpls_convergence_time
                                
                                	Convergence time for MPLS label programming
                                	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime>`
                                
                                .. attribute:: route_statistics
                                
                                	Route statistics
                                	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics>`
                                
                                .. attribute:: threshold_exceeded
                                
                                	Threshold exceeded
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary, self).__init__()

                                    self.yang_name = "priority-summary"
                                    self.yang_parent_name = "spf-summary"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                    self.ip_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                    self._children_yang_names.add("ip-convergence-time")

                                    self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                    self._children_yang_names.add("mpls-convergence-time")

                                    self.route_statistics = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics()
                                    self.route_statistics.parent = self
                                    self._children_name_map["route_statistics"] = "route-statistics"
                                    self._children_yang_names.add("route-statistics")

                                    self.frr_statistic = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "threshold_exceeded") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary, self).__setattr__(name, value)


                                class RouteStatistics(Entity):
                                    """
                                    Route statistics
                                    
                                    .. attribute:: adds
                                    
                                    	Added
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: deletes
                                    
                                    	Deleted
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: modifies
                                    
                                    	Modified
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: reachables
                                    
                                    	Reachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: touches
                                    
                                    	Touched
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: unreachables
                                    
                                    	Unreachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics, self).__init__()

                                        self.yang_name = "route-statistics"
                                        self.yang_parent_name = "priority-summary"

                                        self.adds = YLeaf(YType.uint32, "adds")

                                        self.deletes = YLeaf(YType.uint32, "deletes")

                                        self.modifies = YLeaf(YType.uint32, "modifies")

                                        self.reachables = YLeaf(YType.uint32, "reachables")

                                        self.touches = YLeaf(YType.uint32, "touches")

                                        self.unreachables = YLeaf(YType.uint32, "unreachables")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("adds",
                                                        "deletes",
                                                        "modifies",
                                                        "reachables",
                                                        "touches",
                                                        "unreachables") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.adds.is_set or
                                            self.deletes.is_set or
                                            self.modifies.is_set or
                                            self.reachables.is_set or
                                            self.touches.is_set or
                                            self.unreachables.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.adds.yfilter != YFilter.not_set or
                                            self.deletes.yfilter != YFilter.not_set or
                                            self.modifies.yfilter != YFilter.not_set or
                                            self.reachables.yfilter != YFilter.not_set or
                                            self.touches.yfilter != YFilter.not_set or
                                            self.unreachables.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "route-statistics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.adds.get_name_leafdata())
                                        if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.deletes.get_name_leafdata())
                                        if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.modifies.get_name_leafdata())
                                        if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.reachables.get_name_leafdata())
                                        if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.touches.get_name_leafdata())
                                        if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.unreachables.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "adds"):
                                            self.adds = value
                                            self.adds.value_namespace = name_space
                                            self.adds.value_namespace_prefix = name_space_prefix
                                        if(value_path == "deletes"):
                                            self.deletes = value
                                            self.deletes.value_namespace = name_space
                                            self.deletes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "modifies"):
                                            self.modifies = value
                                            self.modifies.value_namespace = name_space
                                            self.modifies.value_namespace_prefix = name_space_prefix
                                        if(value_path == "reachables"):
                                            self.reachables = value
                                            self.reachables.value_namespace = name_space
                                            self.reachables.value_namespace_prefix = name_space_prefix
                                        if(value_path == "touches"):
                                            self.touches = value
                                            self.touches.value_namespace = name_space
                                            self.touches.value_namespace_prefix = name_space_prefix
                                        if(value_path == "unreachables"):
                                            self.unreachables = value
                                            self.unreachables.value_namespace = name_space
                                            self.unreachables.value_namespace_prefix = name_space_prefix


                                class IpConvergenceTime(Entity):
                                    """
                                    Convergence time for IP route programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime, self).__init__()

                                        self.yang_name = "ip-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ip-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class MplsConvergenceTime(Entity):
                                    """
                                    Convergence time for MPLS label programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__init__()

                                        self.yang_name = "mpls-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mpls-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class FrrStatistic(Entity):
                                    """
                                    Fast Re\-Route Statistics
                                    
                                    .. attribute:: coverage
                                    
                                    	Coverage in percentage
                                    	**type**\:  str
                                    
                                    	**units**\: percentage
                                    
                                    .. attribute:: fully_protected_routes
                                    
                                    	Fully Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: partially_protected_routes
                                    
                                    	Partially Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_routes
                                    
                                    	Total Number of Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic, self).__init__()

                                        self.yang_name = "frr-statistic"
                                        self.yang_parent_name = "priority-summary"

                                        self.coverage = YLeaf(YType.str, "coverage")

                                        self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                        self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                        self.total_routes = YLeaf(YType.uint32, "total-routes")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("coverage",
                                                        "fully_protected_routes",
                                                        "partially_protected_routes",
                                                        "total_routes") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.coverage.is_set or
                                            self.fully_protected_routes.is_set or
                                            self.partially_protected_routes.is_set or
                                            self.total_routes.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.coverage.yfilter != YFilter.not_set or
                                            self.fully_protected_routes.yfilter != YFilter.not_set or
                                            self.partially_protected_routes.yfilter != YFilter.not_set or
                                            self.total_routes.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-statistic" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.coverage.get_name_leafdata())
                                        if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                        if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                        if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_routes.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "coverage" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "total-routes"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "coverage"):
                                            self.coverage = value
                                            self.coverage.value_namespace = name_space
                                            self.coverage.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fully-protected-routes"):
                                            self.fully_protected_routes = value
                                            self.fully_protected_routes.value_namespace = name_space
                                            self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "partially-protected-routes"):
                                            self.partially_protected_routes = value
                                            self.partially_protected_routes.value_namespace = name_space
                                            self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-routes"):
                                            self.total_routes = value
                                            self.total_routes.value_namespace = name_space
                                            self.total_routes.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_statistic:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.level.is_set or
                                        self.threshold_exceeded.is_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                        (self.route_statistics is not None and self.route_statistics.has_data()))

                                def has_operation(self):
                                    for c in self.frr_statistic:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.threshold_exceeded.yfilter != YFilter.not_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                        (self.route_statistics is not None and self.route_statistics.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority-summary" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-statistic"):
                                        for c in self.frr_statistic:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.FrrStatistic()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_statistic.append(c)
                                        return c

                                    if (child_yang_name == "ip-convergence-time"):
                                        if (self.ip_convergence_time is None):
                                            self.ip_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.IpConvergenceTime()
                                            self.ip_convergence_time.parent = self
                                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        return self.ip_convergence_time

                                    if (child_yang_name == "mpls-convergence-time"):
                                        if (self.mpls_convergence_time is None):
                                            self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.MplsConvergenceTime()
                                            self.mpls_convergence_time.parent = self
                                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        return self.mpls_convergence_time

                                    if (child_yang_name == "route-statistics"):
                                        if (self.route_statistics is None):
                                            self.route_statistics = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary.RouteStatistics()
                                            self.route_statistics.parent = self
                                            self._children_name_map["route_statistics"] = "route-statistics"
                                        return self.route_statistics

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-statistic" or name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "threshold-exceeded"):
                                        self.threshold_exceeded = value
                                        self.threshold_exceeded.value_namespace = name_space
                                        self.threshold_exceeded.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.priority_summary:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.duration.is_set or
                                    self.is_data_complete.is_set or
                                    self.isis_level.is_set or
                                    self.state.is_set or
                                    self.threshold_exceeded.is_set or
                                    self.topology.is_set or
                                    self.total_lsp_changes.is_set or
                                    self.trigger_time.is_set or
                                    self.type.is_set)

                            def has_operation(self):
                                for c in self.priority_summary:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.duration.yfilter != YFilter.not_set or
                                    self.is_data_complete.yfilter != YFilter.not_set or
                                    self.isis_level.yfilter != YFilter.not_set or
                                    self.state.yfilter != YFilter.not_set or
                                    self.threshold_exceeded.yfilter != YFilter.not_set or
                                    self.topology.yfilter != YFilter.not_set or
                                    self.total_lsp_changes.yfilter != YFilter.not_set or
                                    self.trigger_time.yfilter != YFilter.not_set or
                                    self.type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "spf-summary" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.duration.get_name_leafdata())
                                if (self.is_data_complete.is_set or self.is_data_complete.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.is_data_complete.get_name_leafdata())
                                if (self.isis_level.is_set or self.isis_level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.isis_level.get_name_leafdata())
                                if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.state.get_name_leafdata())
                                if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                                if (self.topology.is_set or self.topology.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.topology.get_name_leafdata())
                                if (self.total_lsp_changes.is_set or self.total_lsp_changes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.total_lsp_changes.get_name_leafdata())
                                if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.trigger_time.get_name_leafdata())
                                if (self.type.is_set or self.type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "priority-summary"):
                                    for c in self.priority_summary:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary.PrioritySummary()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.priority_summary.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "priority-summary" or name == "duration" or name == "is-data-complete" or name == "isis-level" or name == "state" or name == "threshold-exceeded" or name == "topology" or name == "total-lsp-changes" or name == "trigger-time" or name == "type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "duration"):
                                    self.duration = value
                                    self.duration.value_namespace = name_space
                                    self.duration.value_namespace_prefix = name_space_prefix
                                if(value_path == "is-data-complete"):
                                    self.is_data_complete = value
                                    self.is_data_complete.value_namespace = name_space
                                    self.is_data_complete.value_namespace_prefix = name_space_prefix
                                if(value_path == "isis-level"):
                                    self.isis_level = value
                                    self.isis_level.value_namespace = name_space
                                    self.isis_level.value_namespace_prefix = name_space_prefix
                                if(value_path == "state"):
                                    self.state = value
                                    self.state.value_namespace = name_space
                                    self.state.value_namespace_prefix = name_space_prefix
                                if(value_path == "threshold-exceeded"):
                                    self.threshold_exceeded = value
                                    self.threshold_exceeded.value_namespace = name_space
                                    self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                                if(value_path == "topology"):
                                    self.topology = value
                                    self.topology.value_namespace = name_space
                                    self.topology.value_namespace_prefix = name_space_prefix
                                if(value_path == "total-lsp-changes"):
                                    self.total_lsp_changes = value
                                    self.total_lsp_changes.value_namespace = name_space
                                    self.total_lsp_changes.value_namespace_prefix = name_space_prefix
                                if(value_path == "trigger-time"):
                                    self.trigger_time = value
                                    self.trigger_time.value_namespace = name_space
                                    self.trigger_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "type"):
                                    self.type = value
                                    self.type.value_namespace = name_space
                                    self.type.value_namespace_prefix = name_space_prefix


                        class NodeStatistics(Entity):
                            """
                            SPF Node statistics
                            
                            .. attribute:: adds
                            
                            	Added
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: deletes
                            
                            	Deleted
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: modifies
                            
                            	Modified
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: reachables
                            
                            	Reachable
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: touches
                            
                            	Touched
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: unreachables
                            
                            	Unreachable
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.NodeStatistics, self).__init__()

                                self.yang_name = "node-statistics"
                                self.yang_parent_name = "spf-run-offline"

                                self.adds = YLeaf(YType.uint32, "adds")

                                self.deletes = YLeaf(YType.uint32, "deletes")

                                self.modifies = YLeaf(YType.uint32, "modifies")

                                self.reachables = YLeaf(YType.uint32, "reachables")

                                self.touches = YLeaf(YType.uint32, "touches")

                                self.unreachables = YLeaf(YType.uint32, "unreachables")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("adds",
                                                "deletes",
                                                "modifies",
                                                "reachables",
                                                "touches",
                                                "unreachables") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.NodeStatistics, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.NodeStatistics, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.adds.is_set or
                                    self.deletes.is_set or
                                    self.modifies.is_set or
                                    self.reachables.is_set or
                                    self.touches.is_set or
                                    self.unreachables.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.adds.yfilter != YFilter.not_set or
                                    self.deletes.yfilter != YFilter.not_set or
                                    self.modifies.yfilter != YFilter.not_set or
                                    self.reachables.yfilter != YFilter.not_set or
                                    self.touches.yfilter != YFilter.not_set or
                                    self.unreachables.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "node-statistics" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.adds.get_name_leafdata())
                                if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.deletes.get_name_leafdata())
                                if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.modifies.get_name_leafdata())
                                if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reachables.get_name_leafdata())
                                if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.touches.get_name_leafdata())
                                if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.unreachables.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "adds"):
                                    self.adds = value
                                    self.adds.value_namespace = name_space
                                    self.adds.value_namespace_prefix = name_space_prefix
                                if(value_path == "deletes"):
                                    self.deletes = value
                                    self.deletes.value_namespace = name_space
                                    self.deletes.value_namespace_prefix = name_space_prefix
                                if(value_path == "modifies"):
                                    self.modifies = value
                                    self.modifies.value_namespace = name_space
                                    self.modifies.value_namespace_prefix = name_space_prefix
                                if(value_path == "reachables"):
                                    self.reachables = value
                                    self.reachables.value_namespace = name_space
                                    self.reachables.value_namespace_prefix = name_space_prefix
                                if(value_path == "touches"):
                                    self.touches = value
                                    self.touches.value_namespace = name_space
                                    self.touches.value_namespace_prefix = name_space_prefix
                                if(value_path == "unreachables"):
                                    self.unreachables = value
                                    self.unreachables.value_namespace = name_space
                                    self.unreachables.value_namespace_prefix = name_space_prefix


                        class TriggerLsp(Entity):
                            """
                            Trigger LSP
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsp_id
                            
                            	LSP ID
                            	**type**\:  str
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.TriggerLsp, self).__init__()

                                self.yang_name = "trigger-lsp"
                                self.yang_parent_name = "spf-run-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsp_id = YLeaf(YType.str, "lsp-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsp_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.TriggerLsp, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.TriggerLsp, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsp_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsp_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "trigger-lsp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsp_id.is_set or self.lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsp_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsp-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsp-id"):
                                    self.lsp_id = value
                                    self.lsp_id.value_namespace = name_space
                                    self.lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class Priority(Entity):
                            """
                            Convergence information on per\-priority basis
                            
                            .. attribute:: convergence_timeline
                            
                            	Convergence timeline details
                            	**type**\: list of    :py:class:`ConvergenceTimeline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline>`
                            
                            .. attribute:: leaf_networks_added
                            
                            	List of Leaf Networks Added
                            	**type**\: list of    :py:class:`LeafNetworksAdded <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksAdded>`
                            
                            .. attribute:: leaf_networks_deleted
                            
                            	List of Leaf Networks Deleted
                            	**type**\: list of    :py:class:`LeafNetworksDeleted <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksDeleted>`
                            
                            .. attribute:: priority_summary
                            
                            	Summary of the priority
                            	**type**\:   :py:class:`PrioritySummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary>`
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority, self).__init__()

                                self.yang_name = "priority"
                                self.yang_parent_name = "spf-run-offline"

                                self.priority_summary = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary()
                                self.priority_summary.parent = self
                                self._children_name_map["priority_summary"] = "priority-summary"
                                self._children_yang_names.add("priority-summary")

                                self.convergence_timeline = YList(self)
                                self.leaf_networks_added = YList(self)
                                self.leaf_networks_deleted = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority, self).__setattr__(name, value)


                            class PrioritySummary(Entity):
                                """
                                Summary of the priority
                                
                                .. attribute:: frr_statistic
                                
                                	Fast Re\-Route Statistics
                                	**type**\: list of    :py:class:`FrrStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.FrrStatistic>`
                                
                                .. attribute:: ip_convergence_time
                                
                                	Convergence time for IP route programming
                                	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.IpConvergenceTime>`
                                
                                .. attribute:: level
                                
                                	Critical, High, Medium or Low
                                	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                                
                                .. attribute:: mpls_convergence_time
                                
                                	Convergence time for MPLS label programming
                                	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.MplsConvergenceTime>`
                                
                                .. attribute:: route_statistics
                                
                                	Route statistics
                                	**type**\:   :py:class:`RouteStatistics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.RouteStatistics>`
                                
                                .. attribute:: threshold_exceeded
                                
                                	Threshold exceeded
                                	**type**\:  bool
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary, self).__init__()

                                    self.yang_name = "priority-summary"
                                    self.yang_parent_name = "priority"

                                    self.level = YLeaf(YType.enumeration, "level")

                                    self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                                    self.ip_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                    self._children_yang_names.add("ip-convergence-time")

                                    self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                    self._children_yang_names.add("mpls-convergence-time")

                                    self.route_statistics = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.RouteStatistics()
                                    self.route_statistics.parent = self
                                    self._children_name_map["route_statistics"] = "route-statistics"
                                    self._children_yang_names.add("route-statistics")

                                    self.frr_statistic = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("level",
                                                    "threshold_exceeded") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary, self).__setattr__(name, value)


                                class RouteStatistics(Entity):
                                    """
                                    Route statistics
                                    
                                    .. attribute:: adds
                                    
                                    	Added
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: deletes
                                    
                                    	Deleted
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: modifies
                                    
                                    	Modified
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: reachables
                                    
                                    	Reachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: touches
                                    
                                    	Touched
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: unreachables
                                    
                                    	Unreachable
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.RouteStatistics, self).__init__()

                                        self.yang_name = "route-statistics"
                                        self.yang_parent_name = "priority-summary"

                                        self.adds = YLeaf(YType.uint32, "adds")

                                        self.deletes = YLeaf(YType.uint32, "deletes")

                                        self.modifies = YLeaf(YType.uint32, "modifies")

                                        self.reachables = YLeaf(YType.uint32, "reachables")

                                        self.touches = YLeaf(YType.uint32, "touches")

                                        self.unreachables = YLeaf(YType.uint32, "unreachables")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("adds",
                                                        "deletes",
                                                        "modifies",
                                                        "reachables",
                                                        "touches",
                                                        "unreachables") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.RouteStatistics, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.adds.is_set or
                                            self.deletes.is_set or
                                            self.modifies.is_set or
                                            self.reachables.is_set or
                                            self.touches.is_set or
                                            self.unreachables.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.adds.yfilter != YFilter.not_set or
                                            self.deletes.yfilter != YFilter.not_set or
                                            self.modifies.yfilter != YFilter.not_set or
                                            self.reachables.yfilter != YFilter.not_set or
                                            self.touches.yfilter != YFilter.not_set or
                                            self.unreachables.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "route-statistics" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.adds.is_set or self.adds.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.adds.get_name_leafdata())
                                        if (self.deletes.is_set or self.deletes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.deletes.get_name_leafdata())
                                        if (self.modifies.is_set or self.modifies.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.modifies.get_name_leafdata())
                                        if (self.reachables.is_set or self.reachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.reachables.get_name_leafdata())
                                        if (self.touches.is_set or self.touches.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.touches.get_name_leafdata())
                                        if (self.unreachables.is_set or self.unreachables.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.unreachables.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "adds" or name == "deletes" or name == "modifies" or name == "reachables" or name == "touches" or name == "unreachables"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "adds"):
                                            self.adds = value
                                            self.adds.value_namespace = name_space
                                            self.adds.value_namespace_prefix = name_space_prefix
                                        if(value_path == "deletes"):
                                            self.deletes = value
                                            self.deletes.value_namespace = name_space
                                            self.deletes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "modifies"):
                                            self.modifies = value
                                            self.modifies.value_namespace = name_space
                                            self.modifies.value_namespace_prefix = name_space_prefix
                                        if(value_path == "reachables"):
                                            self.reachables = value
                                            self.reachables.value_namespace = name_space
                                            self.reachables.value_namespace_prefix = name_space_prefix
                                        if(value_path == "touches"):
                                            self.touches = value
                                            self.touches.value_namespace = name_space
                                            self.touches.value_namespace_prefix = name_space_prefix
                                        if(value_path == "unreachables"):
                                            self.unreachables = value
                                            self.unreachables.value_namespace = name_space
                                            self.unreachables.value_namespace_prefix = name_space_prefix


                                class IpConvergenceTime(Entity):
                                    """
                                    Convergence time for IP route programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.IpConvergenceTime, self).__init__()

                                        self.yang_name = "ip-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.IpConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ip-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class MplsConvergenceTime(Entity):
                                    """
                                    Convergence time for MPLS label programming
                                    
                                    .. attribute:: fastest_node_name
                                    
                                    	Linecard node name which took the minimum time
                                    	**type**\:  str
                                    
                                    .. attribute:: maximum_time
                                    
                                    	Maximum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: minimum_time
                                    
                                    	Minimum time(in seconds.milliseconds)
                                    	**type**\:  str
                                    
                                    	**units**\: millisecond
                                    
                                    .. attribute:: slowest_node_name
                                    
                                    	Linecard node name which took the maximum time
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.MplsConvergenceTime, self).__init__()

                                        self.yang_name = "mpls-convergence-time"
                                        self.yang_parent_name = "priority-summary"

                                        self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                        self.maximum_time = YLeaf(YType.str, "maximum-time")

                                        self.minimum_time = YLeaf(YType.str, "minimum-time")

                                        self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("fastest_node_name",
                                                        "maximum_time",
                                                        "minimum_time",
                                                        "slowest_node_name") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.MplsConvergenceTime, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.fastest_node_name.is_set or
                                            self.maximum_time.is_set or
                                            self.minimum_time.is_set or
                                            self.slowest_node_name.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.fastest_node_name.yfilter != YFilter.not_set or
                                            self.maximum_time.yfilter != YFilter.not_set or
                                            self.minimum_time.yfilter != YFilter.not_set or
                                            self.slowest_node_name.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "mpls-convergence-time" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                        if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                        if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                        if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "fastest-node-name"):
                                            self.fastest_node_name = value
                                            self.fastest_node_name.value_namespace = name_space
                                            self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "maximum-time"):
                                            self.maximum_time = value
                                            self.maximum_time.value_namespace = name_space
                                            self.maximum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "minimum-time"):
                                            self.minimum_time = value
                                            self.minimum_time.value_namespace = name_space
                                            self.minimum_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "slowest-node-name"):
                                            self.slowest_node_name = value
                                            self.slowest_node_name.value_namespace = name_space
                                            self.slowest_node_name.value_namespace_prefix = name_space_prefix


                                class FrrStatistic(Entity):
                                    """
                                    Fast Re\-Route Statistics
                                    
                                    .. attribute:: coverage
                                    
                                    	Coverage in percentage
                                    	**type**\:  str
                                    
                                    	**units**\: percentage
                                    
                                    .. attribute:: fully_protected_routes
                                    
                                    	Fully Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: partially_protected_routes
                                    
                                    	Partially Protected Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    .. attribute:: total_routes
                                    
                                    	Total Number of Routes
                                    	**type**\:  int
                                    
                                    	**range:** 0..4294967295
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.FrrStatistic, self).__init__()

                                        self.yang_name = "frr-statistic"
                                        self.yang_parent_name = "priority-summary"

                                        self.coverage = YLeaf(YType.str, "coverage")

                                        self.fully_protected_routes = YLeaf(YType.uint32, "fully-protected-routes")

                                        self.partially_protected_routes = YLeaf(YType.uint32, "partially-protected-routes")

                                        self.total_routes = YLeaf(YType.uint32, "total-routes")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("coverage",
                                                        "fully_protected_routes",
                                                        "partially_protected_routes",
                                                        "total_routes") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.FrrStatistic, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.FrrStatistic, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.coverage.is_set or
                                            self.fully_protected_routes.is_set or
                                            self.partially_protected_routes.is_set or
                                            self.total_routes.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.coverage.yfilter != YFilter.not_set or
                                            self.fully_protected_routes.yfilter != YFilter.not_set or
                                            self.partially_protected_routes.yfilter != YFilter.not_set or
                                            self.total_routes.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "frr-statistic" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.coverage.is_set or self.coverage.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.coverage.get_name_leafdata())
                                        if (self.fully_protected_routes.is_set or self.fully_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.fully_protected_routes.get_name_leafdata())
                                        if (self.partially_protected_routes.is_set or self.partially_protected_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.partially_protected_routes.get_name_leafdata())
                                        if (self.total_routes.is_set or self.total_routes.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.total_routes.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "coverage" or name == "fully-protected-routes" or name == "partially-protected-routes" or name == "total-routes"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "coverage"):
                                            self.coverage = value
                                            self.coverage.value_namespace = name_space
                                            self.coverage.value_namespace_prefix = name_space_prefix
                                        if(value_path == "fully-protected-routes"):
                                            self.fully_protected_routes = value
                                            self.fully_protected_routes.value_namespace = name_space
                                            self.fully_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "partially-protected-routes"):
                                            self.partially_protected_routes = value
                                            self.partially_protected_routes.value_namespace = name_space
                                            self.partially_protected_routes.value_namespace_prefix = name_space_prefix
                                        if(value_path == "total-routes"):
                                            self.total_routes = value
                                            self.total_routes.value_namespace = name_space
                                            self.total_routes.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.frr_statistic:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        self.level.is_set or
                                        self.threshold_exceeded.is_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()) or
                                        (self.route_statistics is not None and self.route_statistics.has_data()))

                                def has_operation(self):
                                    for c in self.frr_statistic:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.level.yfilter != YFilter.not_set or
                                        self.threshold_exceeded.yfilter != YFilter.not_set or
                                        (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                        (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()) or
                                        (self.route_statistics is not None and self.route_statistics.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "priority-summary" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.level.is_set or self.level.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.level.get_name_leafdata())
                                    if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "frr-statistic"):
                                        for c in self.frr_statistic:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.FrrStatistic()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.frr_statistic.append(c)
                                        return c

                                    if (child_yang_name == "ip-convergence-time"):
                                        if (self.ip_convergence_time is None):
                                            self.ip_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.IpConvergenceTime()
                                            self.ip_convergence_time.parent = self
                                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                        return self.ip_convergence_time

                                    if (child_yang_name == "mpls-convergence-time"):
                                        if (self.mpls_convergence_time is None):
                                            self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.MplsConvergenceTime()
                                            self.mpls_convergence_time.parent = self
                                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                        return self.mpls_convergence_time

                                    if (child_yang_name == "route-statistics"):
                                        if (self.route_statistics is None):
                                            self.route_statistics = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary.RouteStatistics()
                                            self.route_statistics.parent = self
                                            self._children_name_map["route_statistics"] = "route-statistics"
                                        return self.route_statistics

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "frr-statistic" or name == "ip-convergence-time" or name == "mpls-convergence-time" or name == "route-statistics" or name == "level" or name == "threshold-exceeded"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "level"):
                                        self.level = value
                                        self.level.value_namespace = name_space
                                        self.level.value_namespace_prefix = name_space_prefix
                                    if(value_path == "threshold-exceeded"):
                                        self.threshold_exceeded = value
                                        self.threshold_exceeded.value_namespace = name_space
                                        self.threshold_exceeded.value_namespace_prefix = name_space_prefix


                            class ConvergenceTimeline(Entity):
                                """
                                Convergence timeline details
                                
                                .. attribute:: lc_ip
                                
                                	List of Linecards' completion point for IP routes
                                	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp>`
                                
                                .. attribute:: lc_mpls
                                
                                	List of Linecards' completion point for MPLS labels
                                	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls>`
                                
                                .. attribute:: ldp_enter
                                
                                	Entry point of LDP
                                	**type**\:   :py:class:`LdpEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpEnter>`
                                
                                .. attribute:: ldp_exit
                                
                                	Exit point of LDP to LSD
                                	**type**\:   :py:class:`LdpExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpExit>`
                                
                                .. attribute:: lsd_enter
                                
                                	Entry point of LSD
                                	**type**\:   :py:class:`LsdEnter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdEnter>`
                                
                                .. attribute:: lsd_exit
                                
                                	Exit point of LSD to FIBs
                                	**type**\:   :py:class:`LsdExit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdExit>`
                                
                                .. attribute:: ri_bv4_enter
                                
                                	Entry point of IPv4 RIB
                                	**type**\:   :py:class:`RiBv4Enter <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Enter>`
                                
                                .. attribute:: ri_bv4_exit
                                
                                	Exit point from IPv4 RIB to FIBs
                                	**type**\:   :py:class:`RiBv4Exit <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Exit>`
                                
                                .. attribute:: ri_bv4_redistribute
                                
                                	Route Redistribute point from IPv4 RIB to LDP
                                	**type**\:   :py:class:`RiBv4Redistribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Redistribute>`
                                
                                .. attribute:: route_origin
                                
                                	Route origin (routing protocol)
                                	**type**\:   :py:class:`RouteOrigin <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RouteOrigin>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline, self).__init__()

                                    self.yang_name = "convergence-timeline"
                                    self.yang_parent_name = "priority"

                                    self.ldp_enter = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpEnter()
                                    self.ldp_enter.parent = self
                                    self._children_name_map["ldp_enter"] = "ldp-enter"
                                    self._children_yang_names.add("ldp-enter")

                                    self.ldp_exit = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpExit()
                                    self.ldp_exit.parent = self
                                    self._children_name_map["ldp_exit"] = "ldp-exit"
                                    self._children_yang_names.add("ldp-exit")

                                    self.lsd_enter = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdEnter()
                                    self.lsd_enter.parent = self
                                    self._children_name_map["lsd_enter"] = "lsd-enter"
                                    self._children_yang_names.add("lsd-enter")

                                    self.lsd_exit = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdExit()
                                    self.lsd_exit.parent = self
                                    self._children_name_map["lsd_exit"] = "lsd-exit"
                                    self._children_yang_names.add("lsd-exit")

                                    self.ri_bv4_enter = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Enter()
                                    self.ri_bv4_enter.parent = self
                                    self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                    self._children_yang_names.add("ri-bv4-enter")

                                    self.ri_bv4_exit = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Exit()
                                    self.ri_bv4_exit.parent = self
                                    self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                    self._children_yang_names.add("ri-bv4-exit")

                                    self.ri_bv4_redistribute = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                    self.ri_bv4_redistribute.parent = self
                                    self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                    self._children_yang_names.add("ri-bv4-redistribute")

                                    self.route_origin = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RouteOrigin()
                                    self.route_origin.parent = self
                                    self._children_name_map["route_origin"] = "route-origin"
                                    self._children_yang_names.add("route-origin")

                                    self.lc_ip = YList(self)
                                    self.lc_mpls = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline, self).__setattr__(name, value)


                                class RouteOrigin(Entity):
                                    """
                                    Route origin (routing protocol)
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RouteOrigin, self).__init__()

                                        self.yang_name = "route-origin"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RouteOrigin, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "route-origin" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class RiBv4Enter(Entity):
                                    """
                                    Entry point of IPv4 RIB
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Enter, self).__init__()

                                        self.yang_name = "ri-bv4-enter"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Enter, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ri-bv4-enter" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class RiBv4Exit(Entity):
                                    """
                                    Exit point from IPv4 RIB to FIBs
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Exit, self).__init__()

                                        self.yang_name = "ri-bv4-exit"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Exit, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ri-bv4-exit" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class RiBv4Redistribute(Entity):
                                    """
                                    Route Redistribute point from IPv4 RIB to LDP
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__init__()

                                        self.yang_name = "ri-bv4-redistribute"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Redistribute, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ri-bv4-redistribute" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LdpEnter(Entity):
                                    """
                                    Entry point of LDP
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpEnter, self).__init__()

                                        self.yang_name = "ldp-enter"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpEnter, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ldp-enter" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LdpExit(Entity):
                                    """
                                    Exit point of LDP to LSD
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpExit, self).__init__()

                                        self.yang_name = "ldp-exit"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpExit, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "ldp-exit" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LsdEnter(Entity):
                                    """
                                    Entry point of LSD
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdEnter, self).__init__()

                                        self.yang_name = "lsd-enter"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdEnter, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "lsd-enter" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LsdExit(Entity):
                                    """
                                    Exit point of LSD to FIBs
                                    
                                    .. attribute:: duration
                                    
                                    	Duration of processing (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: end_time
                                    
                                    	Last route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    .. attribute:: start_time
                                    
                                    	First route process time relative to event trigger time (in ss.msec)
                                    	**type**\:  str
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdExit, self).__init__()

                                        self.yang_name = "lsd-exit"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.duration = YLeaf(YType.str, "duration")

                                        self.end_time = YLeaf(YType.str, "end-time")

                                        self.start_time = YLeaf(YType.str, "start-time")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("duration",
                                                        "end_time",
                                                        "start_time") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdExit, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.duration.is_set or
                                            self.end_time.is_set or
                                            self.start_time.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.duration.yfilter != YFilter.not_set or
                                            self.end_time.yfilter != YFilter.not_set or
                                            self.start_time.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "lsd-exit" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.duration.get_name_leafdata())
                                        if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.end_time.get_name_leafdata())
                                        if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.start_time.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "duration" or name == "end-time" or name == "start-time"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "duration"):
                                            self.duration = value
                                            self.duration.value_namespace = name_space
                                            self.duration.value_namespace_prefix = name_space_prefix
                                        if(value_path == "end-time"):
                                            self.end_time = value
                                            self.end_time.value_namespace = name_space
                                            self.end_time.value_namespace_prefix = name_space_prefix
                                        if(value_path == "start-time"):
                                            self.start_time = value
                                            self.start_time.value_namespace = name_space
                                            self.start_time.value_namespace_prefix = name_space_prefix


                                class LcIp(Entity):
                                    """
                                    List of Linecards' completion point for IP
                                    routes
                                    
                                    .. attribute:: fib_complete
                                    
                                    	Completion point of FIB
                                    	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp.FibComplete>`
                                    
                                    .. attribute:: node_name
                                    
                                    	Linecard node name
                                    	**type**\:  str
                                    
                                    .. attribute:: speed
                                    
                                    	Relative convergence speed
                                    	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp, self).__init__()

                                        self.yang_name = "lc-ip"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.node_name = YLeaf(YType.str, "node-name")

                                        self.speed = YLeaf(YType.enumeration, "speed")

                                        self.fib_complete = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                        self.fib_complete.parent = self
                                        self._children_name_map["fib_complete"] = "fib-complete"
                                        self._children_yang_names.add("fib-complete")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("node_name",
                                                        "speed") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp, self).__setattr__(name, value)


                                    class FibComplete(Entity):
                                        """
                                        Completion point of FIB
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__init__()

                                            self.yang_name = "fib-complete"
                                            self.yang_parent_name = "lc-ip"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp.FibComplete, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "fib-complete" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.node_name.is_set or
                                            self.speed.is_set or
                                            (self.fib_complete is not None and self.fib_complete.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.node_name.yfilter != YFilter.not_set or
                                            self.speed.yfilter != YFilter.not_set or
                                            (self.fib_complete is not None and self.fib_complete.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "lc-ip" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.node_name.get_name_leafdata())
                                        if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.speed.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "fib-complete"):
                                            if (self.fib_complete is None):
                                                self.fib_complete = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp.FibComplete()
                                                self.fib_complete.parent = self
                                                self._children_name_map["fib_complete"] = "fib-complete"
                                            return self.fib_complete

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "node-name"):
                                            self.node_name = value
                                            self.node_name.value_namespace = name_space
                                            self.node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "speed"):
                                            self.speed = value
                                            self.speed.value_namespace = name_space
                                            self.speed.value_namespace_prefix = name_space_prefix


                                class LcMpls(Entity):
                                    """
                                    List of Linecards' completion point for MPLS
                                    labels
                                    
                                    .. attribute:: fib_complete
                                    
                                    	Completion point of FIB
                                    	**type**\:   :py:class:`FibComplete <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls.FibComplete>`
                                    
                                    .. attribute:: node_name
                                    
                                    	Linecard node name
                                    	**type**\:  str
                                    
                                    .. attribute:: speed
                                    
                                    	Relative convergence speed
                                    	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                    
                                    

                                    """

                                    _prefix = 'infra-rcmd-oper'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls, self).__init__()

                                        self.yang_name = "lc-mpls"
                                        self.yang_parent_name = "convergence-timeline"

                                        self.node_name = YLeaf(YType.str, "node-name")

                                        self.speed = YLeaf(YType.enumeration, "speed")

                                        self.fib_complete = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                        self.fib_complete.parent = self
                                        self._children_name_map["fib_complete"] = "fib-complete"
                                        self._children_yang_names.add("fib-complete")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("node_name",
                                                        "speed") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls, self).__setattr__(name, value)


                                    class FibComplete(Entity):
                                        """
                                        Completion point of FIB
                                        
                                        .. attribute:: duration
                                        
                                        	Duration of processing (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: end_time
                                        
                                        	Last route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        .. attribute:: start_time
                                        
                                        	First route process time relative to event trigger time (in ss.msec)
                                        	**type**\:  str
                                        
                                        

                                        """

                                        _prefix = 'infra-rcmd-oper'
                                        _revision = '2015-11-09'

                                        def __init__(self):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__init__()

                                            self.yang_name = "fib-complete"
                                            self.yang_parent_name = "lc-mpls"

                                            self.duration = YLeaf(YType.str, "duration")

                                            self.end_time = YLeaf(YType.str, "end-time")

                                            self.start_time = YLeaf(YType.str, "start-time")

                                        def __setattr__(self, name, value):
                                            self._check_monkey_patching_error(name, value)
                                            with _handle_type_error():
                                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                        "Please use list append or extend method."
                                                                        .format(value))
                                                if isinstance(value, Enum.YLeaf):
                                                    value = value.name
                                                if name in ("duration",
                                                            "end_time",
                                                            "start_time") and name in self.__dict__:
                                                    if isinstance(value, YLeaf):
                                                        self.__dict__[name].set(value.get())
                                                    elif isinstance(value, YLeafList):
                                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)
                                                    else:
                                                        self.__dict__[name].set(value)
                                                else:
                                                    if hasattr(value, "parent") and name != "parent":
                                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                            value.parent = self
                                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                                            value.parent = self
                                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls.FibComplete, self).__setattr__(name, value)

                                        def has_data(self):
                                            return (
                                                self.duration.is_set or
                                                self.end_time.is_set or
                                                self.start_time.is_set)

                                        def has_operation(self):
                                            return (
                                                self.yfilter != YFilter.not_set or
                                                self.duration.yfilter != YFilter.not_set or
                                                self.end_time.yfilter != YFilter.not_set or
                                                self.start_time.yfilter != YFilter.not_set)

                                        def get_segment_path(self):
                                            path_buffer = ""
                                            path_buffer = "fib-complete" + path_buffer

                                            return path_buffer

                                        def get_entity_path(self, ancestor):
                                            path_buffer = ""
                                            if (ancestor is None):
                                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                            else:
                                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                            leaf_name_data = LeafDataList()
                                            if (self.duration.is_set or self.duration.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.duration.get_name_leafdata())
                                            if (self.end_time.is_set or self.end_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.end_time.get_name_leafdata())
                                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                                leaf_name_data.append(self.start_time.get_name_leafdata())

                                            entity_path = EntityPath(path_buffer, leaf_name_data)
                                            return entity_path

                                        def get_child_by_name(self, child_yang_name, segment_path):
                                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                            if child is not None:
                                                return child

                                            return None

                                        def has_leaf_or_child_of_name(self, name):
                                            if(name == "duration" or name == "end-time" or name == "start-time"):
                                                return True
                                            return False

                                        def set_value(self, value_path, value, name_space, name_space_prefix):
                                            if(value_path == "duration"):
                                                self.duration = value
                                                self.duration.value_namespace = name_space
                                                self.duration.value_namespace_prefix = name_space_prefix
                                            if(value_path == "end-time"):
                                                self.end_time = value
                                                self.end_time.value_namespace = name_space
                                                self.end_time.value_namespace_prefix = name_space_prefix
                                            if(value_path == "start-time"):
                                                self.start_time = value
                                                self.start_time.value_namespace = name_space
                                                self.start_time.value_namespace_prefix = name_space_prefix

                                    def has_data(self):
                                        return (
                                            self.node_name.is_set or
                                            self.speed.is_set or
                                            (self.fib_complete is not None and self.fib_complete.has_data()))

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.node_name.yfilter != YFilter.not_set or
                                            self.speed.yfilter != YFilter.not_set or
                                            (self.fib_complete is not None and self.fib_complete.has_operation()))

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "lc-mpls" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.node_name.get_name_leafdata())
                                        if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.speed.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        if (child_yang_name == "fib-complete"):
                                            if (self.fib_complete is None):
                                                self.fib_complete = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls.FibComplete()
                                                self.fib_complete.parent = self
                                                self._children_name_map["fib_complete"] = "fib-complete"
                                            return self.fib_complete

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "node-name"):
                                            self.node_name = value
                                            self.node_name.value_namespace = name_space
                                            self.node_name.value_namespace_prefix = name_space_prefix
                                        if(value_path == "speed"):
                                            self.speed = value
                                            self.speed.value_namespace = name_space
                                            self.speed.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.lc_ip:
                                        if (c.has_data()):
                                            return True
                                    for c in self.lc_mpls:
                                        if (c.has_data()):
                                            return True
                                    return (
                                        (self.ldp_enter is not None and self.ldp_enter.has_data()) or
                                        (self.ldp_exit is not None and self.ldp_exit.has_data()) or
                                        (self.lsd_enter is not None and self.lsd_enter.has_data()) or
                                        (self.lsd_exit is not None and self.lsd_exit.has_data()) or
                                        (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_data()) or
                                        (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_data()) or
                                        (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_data()) or
                                        (self.route_origin is not None and self.route_origin.has_data()))

                                def has_operation(self):
                                    for c in self.lc_ip:
                                        if (c.has_operation()):
                                            return True
                                    for c in self.lc_mpls:
                                        if (c.has_operation()):
                                            return True
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        (self.ldp_enter is not None and self.ldp_enter.has_operation()) or
                                        (self.ldp_exit is not None and self.ldp_exit.has_operation()) or
                                        (self.lsd_enter is not None and self.lsd_enter.has_operation()) or
                                        (self.lsd_exit is not None and self.lsd_exit.has_operation()) or
                                        (self.ri_bv4_enter is not None and self.ri_bv4_enter.has_operation()) or
                                        (self.ri_bv4_exit is not None and self.ri_bv4_exit.has_operation()) or
                                        (self.ri_bv4_redistribute is not None and self.ri_bv4_redistribute.has_operation()) or
                                        (self.route_origin is not None and self.route_origin.has_operation()))

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "convergence-timeline" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "lc-ip"):
                                        for c in self.lc_ip:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcIp()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.lc_ip.append(c)
                                        return c

                                    if (child_yang_name == "lc-mpls"):
                                        for c in self.lc_mpls:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LcMpls()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.lc_mpls.append(c)
                                        return c

                                    if (child_yang_name == "ldp-enter"):
                                        if (self.ldp_enter is None):
                                            self.ldp_enter = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpEnter()
                                            self.ldp_enter.parent = self
                                            self._children_name_map["ldp_enter"] = "ldp-enter"
                                        return self.ldp_enter

                                    if (child_yang_name == "ldp-exit"):
                                        if (self.ldp_exit is None):
                                            self.ldp_exit = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LdpExit()
                                            self.ldp_exit.parent = self
                                            self._children_name_map["ldp_exit"] = "ldp-exit"
                                        return self.ldp_exit

                                    if (child_yang_name == "lsd-enter"):
                                        if (self.lsd_enter is None):
                                            self.lsd_enter = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdEnter()
                                            self.lsd_enter.parent = self
                                            self._children_name_map["lsd_enter"] = "lsd-enter"
                                        return self.lsd_enter

                                    if (child_yang_name == "lsd-exit"):
                                        if (self.lsd_exit is None):
                                            self.lsd_exit = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.LsdExit()
                                            self.lsd_exit.parent = self
                                            self._children_name_map["lsd_exit"] = "lsd-exit"
                                        return self.lsd_exit

                                    if (child_yang_name == "ri-bv4-enter"):
                                        if (self.ri_bv4_enter is None):
                                            self.ri_bv4_enter = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Enter()
                                            self.ri_bv4_enter.parent = self
                                            self._children_name_map["ri_bv4_enter"] = "ri-bv4-enter"
                                        return self.ri_bv4_enter

                                    if (child_yang_name == "ri-bv4-exit"):
                                        if (self.ri_bv4_exit is None):
                                            self.ri_bv4_exit = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Exit()
                                            self.ri_bv4_exit.parent = self
                                            self._children_name_map["ri_bv4_exit"] = "ri-bv4-exit"
                                        return self.ri_bv4_exit

                                    if (child_yang_name == "ri-bv4-redistribute"):
                                        if (self.ri_bv4_redistribute is None):
                                            self.ri_bv4_redistribute = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RiBv4Redistribute()
                                            self.ri_bv4_redistribute.parent = self
                                            self._children_name_map["ri_bv4_redistribute"] = "ri-bv4-redistribute"
                                        return self.ri_bv4_redistribute

                                    if (child_yang_name == "route-origin"):
                                        if (self.route_origin is None):
                                            self.route_origin = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline.RouteOrigin()
                                            self.route_origin.parent = self
                                            self._children_name_map["route_origin"] = "route-origin"
                                        return self.route_origin

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass


                            class LeafNetworksAdded(Entity):
                                """
                                List of Leaf Networks Added
                                
                                .. attribute:: address
                                
                                	IP address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: net_mask
                                
                                	Mask
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksAdded, self).__init__()

                                    self.yang_name = "leaf-networks-added"
                                    self.yang_parent_name = "priority"

                                    self.address = YLeaf(YType.str, "address")

                                    self.net_mask = YLeaf(YType.uint8, "net-mask")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address",
                                                    "net_mask") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksAdded, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksAdded, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address.is_set or
                                        self.net_mask.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address.yfilter != YFilter.not_set or
                                        self.net_mask.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "leaf-networks-added" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address.get_name_leafdata())
                                    if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.net_mask.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address" or name == "net-mask"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address"):
                                        self.address = value
                                        self.address.value_namespace = name_space
                                        self.address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "net-mask"):
                                        self.net_mask = value
                                        self.net_mask.value_namespace = name_space
                                        self.net_mask.value_namespace_prefix = name_space_prefix


                            class LeafNetworksDeleted(Entity):
                                """
                                List of Leaf Networks Deleted
                                
                                .. attribute:: address
                                
                                	IP address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: net_mask
                                
                                	Mask
                                	**type**\:  int
                                
                                	**range:** 0..255
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksDeleted, self).__init__()

                                    self.yang_name = "leaf-networks-deleted"
                                    self.yang_parent_name = "priority"

                                    self.address = YLeaf(YType.str, "address")

                                    self.net_mask = YLeaf(YType.uint8, "net-mask")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("address",
                                                    "net_mask") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksDeleted, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksDeleted, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.address.is_set or
                                        self.net_mask.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.address.yfilter != YFilter.not_set or
                                        self.net_mask.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "leaf-networks-deleted" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.address.get_name_leafdata())
                                    if (self.net_mask.is_set or self.net_mask.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.net_mask.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "address" or name == "net-mask"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "address"):
                                        self.address = value
                                        self.address.value_namespace = name_space
                                        self.address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "net-mask"):
                                        self.net_mask = value
                                        self.net_mask.value_namespace = name_space
                                        self.net_mask.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.convergence_timeline:
                                    if (c.has_data()):
                                        return True
                                for c in self.leaf_networks_added:
                                    if (c.has_data()):
                                        return True
                                for c in self.leaf_networks_deleted:
                                    if (c.has_data()):
                                        return True
                                return (self.priority_summary is not None and self.priority_summary.has_data())

                            def has_operation(self):
                                for c in self.convergence_timeline:
                                    if (c.has_operation()):
                                        return True
                                for c in self.leaf_networks_added:
                                    if (c.has_operation()):
                                        return True
                                for c in self.leaf_networks_deleted:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.priority_summary is not None and self.priority_summary.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "priority" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "convergence-timeline"):
                                    for c in self.convergence_timeline:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.ConvergenceTimeline()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.convergence_timeline.append(c)
                                    return c

                                if (child_yang_name == "leaf-networks-added"):
                                    for c in self.leaf_networks_added:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksAdded()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.leaf_networks_added.append(c)
                                    return c

                                if (child_yang_name == "leaf-networks-deleted"):
                                    for c in self.leaf_networks_deleted:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.LeafNetworksDeleted()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.leaf_networks_deleted.append(c)
                                    return c

                                if (child_yang_name == "priority-summary"):
                                    if (self.priority_summary is None):
                                        self.priority_summary = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority.PrioritySummary()
                                        self.priority_summary.parent = self
                                        self._children_name_map["priority_summary"] = "priority-summary"
                                    return self.priority_summary

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "convergence-timeline" or name == "leaf-networks-added" or name == "leaf-networks-deleted" or name == "priority-summary"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class LspProcessed(Entity):
                            """
                            List of LSP changes processed
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsp_id
                            
                            	LSP ID
                            	**type**\:  str
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspProcessed, self).__init__()

                                self.yang_name = "lsp-processed"
                                self.yang_parent_name = "spf-run-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsp_id = YLeaf(YType.str, "lsp-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsp_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspProcessed, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspProcessed, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsp_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsp_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsp-processed" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsp_id.is_set or self.lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsp_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsp-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsp-id"):
                                    self.lsp_id = value
                                    self.lsp_id.value_namespace = name_space
                                    self.lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class LspRegenerated(Entity):
                            """
                            List of LSP regenerated
                            
                            .. attribute:: isis_level
                            
                            	ISIS Level
                            	**type**\:   :py:class:`RcmdIsisLvl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdIsisLvl>`
                            
                            .. attribute:: lsp_id
                            
                            	LSP ID
                            	**type**\:  str
                            
                            .. attribute:: reason
                            
                            	Trigger reasons for LSP regeneration. Example\: pr^ \- periodic, cr^ \- clear (Check the documentation for the entire list)
                            	**type**\:  str
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: serial_number_xr
                            
                            	Serial Number of the session event
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            .. attribute:: spf_run_number
                            
                            	SPF Run Number
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspRegenerated, self).__init__()

                                self.yang_name = "lsp-regenerated"
                                self.yang_parent_name = "spf-run-offline"

                                self.isis_level = YLeaf(YType.enumeration, "isis-level")

                                self.lsp_id = YLeaf(YType.str, "lsp-id")

                                self.reason = YLeaf(YType.str, "reason")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                                self.serial_number_xr = YLeaf(YType.uint32, "serial-number-xr")

                                self.spf_run_number = YLeaf(YType.uint32, "spf-run-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("isis_level",
                                                "lsp_id",
                                                "reason",
                                                "reception_time",
                                                "sequence_number",
                                                "serial_number_xr",
                                                "spf_run_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspRegenerated, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspRegenerated, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.isis_level.is_set or
                                    self.lsp_id.is_set or
                                    self.reason.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set or
                                    self.serial_number_xr.is_set or
                                    self.spf_run_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.isis_level.yfilter != YFilter.not_set or
                                    self.lsp_id.yfilter != YFilter.not_set or
                                    self.reason.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set or
                                    self.serial_number_xr.yfilter != YFilter.not_set or
                                    self.spf_run_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsp-regenerated" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.isis_level.is_set or self.isis_level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.isis_level.get_name_leafdata())
                                if (self.lsp_id.is_set or self.lsp_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsp_id.get_name_leafdata())
                                if (self.reason.is_set or self.reason.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reason.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())
                                if (self.serial_number_xr.is_set or self.serial_number_xr.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.serial_number_xr.get_name_leafdata())
                                if (self.spf_run_number.is_set or self.spf_run_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.spf_run_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "isis-level" or name == "lsp-id" or name == "reason" or name == "reception-time" or name == "sequence-number" or name == "serial-number-xr" or name == "spf-run-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "isis-level"):
                                    self.isis_level = value
                                    self.isis_level.value_namespace = name_space
                                    self.isis_level.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsp-id"):
                                    self.lsp_id = value
                                    self.lsp_id.value_namespace = name_space
                                    self.lsp_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reason"):
                                    self.reason = value
                                    self.reason.value_namespace = name_space
                                    self.reason.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix
                                if(value_path == "serial-number-xr"):
                                    self.serial_number_xr = value
                                    self.serial_number_xr.value_namespace = name_space
                                    self.serial_number_xr.value_namespace_prefix = name_space_prefix
                                if(value_path == "spf-run-number"):
                                    self.spf_run_number = value
                                    self.spf_run_number.value_namespace = name_space
                                    self.spf_run_number.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsp_processed:
                                if (c.has_data()):
                                    return True
                            for c in self.lsp_regenerated:
                                if (c.has_data()):
                                    return True
                            for c in self.priority:
                                if (c.has_data()):
                                    return True
                            for c in self.trigger_lsp:
                                if (c.has_data()):
                                    return True
                            return (
                                self.spf_run_number.is_set or
                                self.reason.is_set or
                                self.start_time.is_set or
                                self.wait_time.is_set or
                                (self.node_statistics is not None and self.node_statistics.has_data()) or
                                (self.spf_summary is not None and self.spf_summary.has_data()))

                        def has_operation(self):
                            for c in self.lsp_processed:
                                if (c.has_operation()):
                                    return True
                            for c in self.lsp_regenerated:
                                if (c.has_operation()):
                                    return True
                            for c in self.priority:
                                if (c.has_operation()):
                                    return True
                            for c in self.trigger_lsp:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.spf_run_number.yfilter != YFilter.not_set or
                                self.reason.yfilter != YFilter.not_set or
                                self.start_time.yfilter != YFilter.not_set or
                                self.wait_time.yfilter != YFilter.not_set or
                                (self.node_statistics is not None and self.node_statistics.has_operation()) or
                                (self.spf_summary is not None and self.spf_summary.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "spf-run-offline" + "[spf-run-number='" + self.spf_run_number.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.spf_run_number.is_set or self.spf_run_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_number.get_name_leafdata())
                            if (self.reason.is_set or self.reason.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reason.get_name_leafdata())
                            if (self.start_time.is_set or self.start_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.start_time.get_name_leafdata())
                            if (self.wait_time.is_set or self.wait_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.wait_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsp-processed"):
                                for c in self.lsp_processed:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspProcessed()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsp_processed.append(c)
                                return c

                            if (child_yang_name == "lsp-regenerated"):
                                for c in self.lsp_regenerated:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.LspRegenerated()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsp_regenerated.append(c)
                                return c

                            if (child_yang_name == "node-statistics"):
                                if (self.node_statistics is None):
                                    self.node_statistics = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.NodeStatistics()
                                    self.node_statistics.parent = self
                                    self._children_name_map["node_statistics"] = "node-statistics"
                                return self.node_statistics

                            if (child_yang_name == "priority"):
                                for c in self.priority:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.Priority()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.priority.append(c)
                                return c

                            if (child_yang_name == "spf-summary"):
                                if (self.spf_summary is None):
                                    self.spf_summary = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.SpfSummary()
                                    self.spf_summary.parent = self
                                    self._children_name_map["spf_summary"] = "spf-summary"
                                return self.spf_summary

                            if (child_yang_name == "trigger-lsp"):
                                for c in self.trigger_lsp:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline.TriggerLsp()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.trigger_lsp.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsp-processed" or name == "lsp-regenerated" or name == "node-statistics" or name == "priority" or name == "spf-summary" or name == "trigger-lsp" or name == "spf-run-number" or name == "reason" or name == "start-time" or name == "wait-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "spf-run-number"):
                                self.spf_run_number = value
                                self.spf_run_number.value_namespace = name_space
                                self.spf_run_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "reason"):
                                self.reason = value
                                self.reason.value_namespace = name_space
                                self.reason.value_namespace_prefix = name_space_prefix
                            if(value_path == "start-time"):
                                self.start_time = value
                                self.start_time.value_namespace = name_space
                                self.start_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "wait-time"):
                                self.wait_time = value
                                self.wait_time.value_namespace = name_space
                                self.wait_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.spf_run_offline:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.spf_run_offline:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "spf-run-offlines" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "spf-run-offline"):
                            for c in self.spf_run_offline:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Isis.Instances.Instance.SpfRunOfflines.SpfRunOffline()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.spf_run_offline.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "spf-run-offline"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class PrefixEventSummaries(Entity):
                    """
                    ISIS Prefix events summary data
                    
                    .. attribute:: prefix_event_summary
                    
                    	Prefix Event data
                    	**type**\: list of    :py:class:`PrefixEventSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries, self).__init__()

                        self.yang_name = "prefix-event-summaries"
                        self.yang_parent_name = "instance"

                        self.prefix_event_summary = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries, self).__setattr__(name, value)


                    class PrefixEventSummary(Entity):
                        """
                        Prefix Event data
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific Event ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: change_type
                        
                        	Event Add/Delete
                        	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                        
                        .. attribute:: cost
                        
                        	Protocol route cost
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ip_convergence_time
                        
                        	Convergence time for IP route programming
                        	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime>`
                        
                        .. attribute:: ipfrr_event_id
                        
                        	Referenced IP\-FRR Event ID (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lsa_processed
                        
                        	List of LSAs processed
                        	**type**\: list of    :py:class:`LsaProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed>`
                        
                        .. attribute:: mpls_convergence_time
                        
                        	Convergence time for MPLS label programming
                        	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime>`
                        
                        .. attribute:: path
                        
                        	Path information
                        	**type**\: list of    :py:class:`Path <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path>`
                        
                        .. attribute:: prefix
                        
                        	Prefix
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_lenth
                        
                        	Prefix length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: priority
                        
                        	Event processed priority
                        	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                        
                        .. attribute:: route_path_change_type
                        
                        	Route Path Change Type
                        	**type**\:   :py:class:`RcmdShowRoutePathChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoutePathChange>`
                        
                        .. attribute:: route_type
                        
                        	Route Type intra/inter/l1/l2
                        	**type**\:   :py:class:`RcmdShowRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoute>`
                        
                        .. attribute:: spf_run_no
                        
                        	Referenced SPF Run No (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: threshold_exceeded
                        
                        	Threshold exceeded
                        	**type**\:  bool
                        
                        .. attribute:: time_line
                        
                        	Timeline information
                        	**type**\: list of    :py:class:`TimeLine <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine>`
                        
                        .. attribute:: trigger_lsa
                        
                        	LSA that triggered this event
                        	**type**\: list of    :py:class:`TriggerLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa>`
                        
                        .. attribute:: trigger_time
                        
                        	Event trigger time
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary, self).__init__()

                            self.yang_name = "prefix-event-summary"
                            self.yang_parent_name = "prefix-event-summaries"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.change_type = YLeaf(YType.enumeration, "change-type")

                            self.cost = YLeaf(YType.uint32, "cost")

                            self.ipfrr_event_id = YLeaf(YType.uint32, "ipfrr-event-id")

                            self.prefix = YLeaf(YType.str, "prefix")

                            self.prefix_lenth = YLeaf(YType.uint32, "prefix-lenth")

                            self.priority = YLeaf(YType.enumeration, "priority")

                            self.route_path_change_type = YLeaf(YType.enumeration, "route-path-change-type")

                            self.route_type = YLeaf(YType.enumeration, "route-type")

                            self.spf_run_no = YLeaf(YType.uint32, "spf-run-no")

                            self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.ip_convergence_time = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime()
                            self.ip_convergence_time.parent = self
                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                            self._children_yang_names.add("ip-convergence-time")

                            self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime()
                            self.mpls_convergence_time.parent = self
                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                            self._children_yang_names.add("mpls-convergence-time")

                            self.lsa_processed = YList(self)
                            self.path = YList(self)
                            self.time_line = YList(self)
                            self.trigger_lsa = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "change_type",
                                            "cost",
                                            "ipfrr_event_id",
                                            "prefix",
                                            "prefix_lenth",
                                            "priority",
                                            "route_path_change_type",
                                            "route_type",
                                            "spf_run_no",
                                            "threshold_exceeded",
                                            "trigger_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary, self).__setattr__(name, value)


                        class IpConvergenceTime(Entity):
                            """
                            Convergence time for IP route programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime, self).__init__()

                                self.yang_name = "ip-convergence-time"
                                self.yang_parent_name = "prefix-event-summary"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ip-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class MplsConvergenceTime(Entity):
                            """
                            Convergence time for MPLS label programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime, self).__init__()

                                self.yang_name = "mpls-convergence-time"
                                self.yang_parent_name = "prefix-event-summary"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class Path(Entity):
                            """
                            Path information
                            
                            .. attribute:: change_type
                            
                            	Event Add/Delete
                            	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: lfa_path
                            
                            	Backup Path Informatoin
                            	**type**\: list of    :py:class:`LfaPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath>`
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_metric
                            
                            	Path Metric
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path, self).__init__()

                                self.yang_name = "path"
                                self.yang_parent_name = "prefix-event-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_metric = YLeaf(YType.uint32, "path-metric")

                                self.lfa_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_metric") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path, self).__setattr__(name, value)


                            class LfaPath(Entity):
                                """
                                Backup Path Informatoin
                                
                                .. attribute:: change_type
                                
                                	Event Add/Delete
                                	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: lfa_type
                                
                                	Type of LFA
                                	**type**\:   :py:class:`RcmdShowIpfrrLfa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowIpfrrLfa>`
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: path_metric
                                
                                	Path Metric
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: remote_node_id
                                
                                	Remote Node ID, in case of Remote LFA
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath, self).__init__()

                                    self.yang_name = "lfa-path"
                                    self.yang_parent_name = "path"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.lfa_type = YLeaf(YType.enumeration, "lfa-type")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                    self.path_metric = YLeaf(YType.uint32, "path-metric")

                                    self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "interface_name",
                                                    "lfa_type",
                                                    "neighbour_address",
                                                    "path_metric",
                                                    "remote_node_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.interface_name.is_set or
                                        self.lfa_type.is_set or
                                        self.neighbour_address.is_set or
                                        self.path_metric.is_set or
                                        self.remote_node_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.lfa_type.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set or
                                        self.path_metric.yfilter != YFilter.not_set or
                                        self.remote_node_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lfa-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.lfa_type.is_set or self.lfa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lfa_type.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                    if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.path_metric.get_name_leafdata())
                                    if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "interface-name" or name == "lfa-type" or name == "neighbour-address" or name == "path-metric" or name == "remote-node-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lfa-type"):
                                        self.lfa_type = value
                                        self.lfa_type.value_namespace = name_space
                                        self.lfa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "path-metric"):
                                        self.path_metric = value
                                        self.path_metric.value_namespace = name_space
                                        self.path_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "remote-node-id"):
                                        self.remote_node_id = value
                                        self.remote_node_id.value_namespace = name_space
                                        self.remote_node_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lfa_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.change_type.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_metric.is_set)

                            def has_operation(self):
                                for c in self.lfa_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_metric.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_metric.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lfa-path"):
                                    for c in self.lfa_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path.LfaPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lfa_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lfa-path" or name == "change-type" or name == "interface-name" or name == "neighbour-address" or name == "path-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-metric"):
                                    self.path_metric = value
                                    self.path_metric.value_namespace = name_space
                                    self.path_metric.value_namespace_prefix = name_space_prefix


                        class TriggerLsa(Entity):
                            """
                            LSA that triggered this event
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa, self).__init__()

                                self.yang_name = "trigger-lsa"
                                self.yang_parent_name = "prefix-event-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "trigger-lsa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class TimeLine(Entity):
                            """
                            Timeline information
                            
                            .. attribute:: lc_ip
                            
                            	List of Linecards' completion point for IP routes
                            	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp>`
                            
                            .. attribute:: lc_mpls
                            
                            	List of Linecards' completion point for MPLS labels
                            	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls>`
                            
                            .. attribute:: ldp_enter
                            
                            	Entry point of LDP
                            	**type**\:  str
                            
                            .. attribute:: ldp_exit
                            
                            	Exit point of LDP to LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_enter
                            
                            	Entry point of LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_exit
                            
                            	Exit point of LSD to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_enter
                            
                            	Entry point of IPv4 RIB
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_exit
                            
                            	Exit point from IPv4 RIB to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_redistribute
                            
                            	Route Redistribute point from IPv4 RIB to LDP
                            	**type**\:  str
                            
                            .. attribute:: route_origin
                            
                            	Route origin (routing protocol)
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine, self).__init__()

                                self.yang_name = "time-line"
                                self.yang_parent_name = "prefix-event-summary"

                                self.ldp_enter = YLeaf(YType.str, "ldp-enter")

                                self.ldp_exit = YLeaf(YType.str, "ldp-exit")

                                self.lsd_enter = YLeaf(YType.str, "lsd-enter")

                                self.lsd_exit = YLeaf(YType.str, "lsd-exit")

                                self.ri_bv4_enter = YLeaf(YType.str, "ri-bv4-enter")

                                self.ri_bv4_exit = YLeaf(YType.str, "ri-bv4-exit")

                                self.ri_bv4_redistribute = YLeaf(YType.str, "ri-bv4-redistribute")

                                self.route_origin = YLeaf(YType.str, "route-origin")

                                self.lc_ip = YList(self)
                                self.lc_mpls = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ldp_enter",
                                                "ldp_exit",
                                                "lsd_enter",
                                                "lsd_exit",
                                                "ri_bv4_enter",
                                                "ri_bv4_exit",
                                                "ri_bv4_redistribute",
                                                "route_origin") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine, self).__setattr__(name, value)


                            class LcIp(Entity):
                                """
                                List of Linecards' completion point for IP
                                routes
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp, self).__init__()

                                    self.yang_name = "lc-ip"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-ip" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix


                            class LcMpls(Entity):
                                """
                                List of Linecards' completion point for MPLS
                                labels
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls, self).__init__()

                                    self.yang_name = "lc-mpls"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-mpls" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lc_ip:
                                    if (c.has_data()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.ldp_enter.is_set or
                                    self.ldp_exit.is_set or
                                    self.lsd_enter.is_set or
                                    self.lsd_exit.is_set or
                                    self.ri_bv4_enter.is_set or
                                    self.ri_bv4_exit.is_set or
                                    self.ri_bv4_redistribute.is_set or
                                    self.route_origin.is_set)

                            def has_operation(self):
                                for c in self.lc_ip:
                                    if (c.has_operation()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ldp_enter.yfilter != YFilter.not_set or
                                    self.ldp_exit.yfilter != YFilter.not_set or
                                    self.lsd_enter.yfilter != YFilter.not_set or
                                    self.lsd_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_enter.yfilter != YFilter.not_set or
                                    self.ri_bv4_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_redistribute.yfilter != YFilter.not_set or
                                    self.route_origin.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "time-line" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ldp_enter.is_set or self.ldp_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_enter.get_name_leafdata())
                                if (self.ldp_exit.is_set or self.ldp_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_exit.get_name_leafdata())
                                if (self.lsd_enter.is_set or self.lsd_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_enter.get_name_leafdata())
                                if (self.lsd_exit.is_set or self.lsd_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_exit.get_name_leafdata())
                                if (self.ri_bv4_enter.is_set or self.ri_bv4_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_enter.get_name_leafdata())
                                if (self.ri_bv4_exit.is_set or self.ri_bv4_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_exit.get_name_leafdata())
                                if (self.ri_bv4_redistribute.is_set or self.ri_bv4_redistribute.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_redistribute.get_name_leafdata())
                                if (self.route_origin.is_set or self.route_origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_origin.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lc-ip"):
                                    for c in self.lc_ip:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcIp()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_ip.append(c)
                                    return c

                                if (child_yang_name == "lc-mpls"):
                                    for c in self.lc_mpls:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine.LcMpls()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_mpls.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ldp-enter"):
                                    self.ldp_enter = value
                                    self.ldp_enter.value_namespace = name_space
                                    self.ldp_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldp-exit"):
                                    self.ldp_exit = value
                                    self.ldp_exit.value_namespace = name_space
                                    self.ldp_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-enter"):
                                    self.lsd_enter = value
                                    self.lsd_enter.value_namespace = name_space
                                    self.lsd_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-exit"):
                                    self.lsd_exit = value
                                    self.lsd_exit.value_namespace = name_space
                                    self.lsd_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-enter"):
                                    self.ri_bv4_enter = value
                                    self.ri_bv4_enter.value_namespace = name_space
                                    self.ri_bv4_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-exit"):
                                    self.ri_bv4_exit = value
                                    self.ri_bv4_exit.value_namespace = name_space
                                    self.ri_bv4_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-redistribute"):
                                    self.ri_bv4_redistribute = value
                                    self.ri_bv4_redistribute.value_namespace = name_space
                                    self.ri_bv4_redistribute.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-origin"):
                                    self.route_origin = value
                                    self.route_origin.value_namespace = name_space
                                    self.route_origin.value_namespace_prefix = name_space_prefix


                        class LsaProcessed(Entity):
                            """
                            List of LSAs processed
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed, self).__init__()

                                self.yang_name = "lsa-processed"
                                self.yang_parent_name = "prefix-event-summary"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsa-processed" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsa_processed:
                                if (c.has_data()):
                                    return True
                            for c in self.path:
                                if (c.has_data()):
                                    return True
                            for c in self.time_line:
                                if (c.has_data()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.change_type.is_set or
                                self.cost.is_set or
                                self.ipfrr_event_id.is_set or
                                self.prefix.is_set or
                                self.prefix_lenth.is_set or
                                self.priority.is_set or
                                self.route_path_change_type.is_set or
                                self.route_type.is_set or
                                self.spf_run_no.is_set or
                                self.threshold_exceeded.is_set or
                                self.trigger_time.is_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()))

                        def has_operation(self):
                            for c in self.lsa_processed:
                                if (c.has_operation()):
                                    return True
                            for c in self.path:
                                if (c.has_operation()):
                                    return True
                            for c in self.time_line:
                                if (c.has_operation()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.change_type.yfilter != YFilter.not_set or
                                self.cost.yfilter != YFilter.not_set or
                                self.ipfrr_event_id.yfilter != YFilter.not_set or
                                self.prefix.yfilter != YFilter.not_set or
                                self.prefix_lenth.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set or
                                self.route_path_change_type.yfilter != YFilter.not_set or
                                self.route_type.yfilter != YFilter.not_set or
                                self.spf_run_no.yfilter != YFilter.not_set or
                                self.threshold_exceeded.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-event-summary" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.change_type.get_name_leafdata())
                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cost.get_name_leafdata())
                            if (self.ipfrr_event_id.is_set or self.ipfrr_event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipfrr_event_id.get_name_leafdata())
                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix.get_name_leafdata())
                            if (self.prefix_lenth.is_set or self.prefix_lenth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_lenth.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())
                            if (self.route_path_change_type.is_set or self.route_path_change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_path_change_type.get_name_leafdata())
                            if (self.route_type.is_set or self.route_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_type.get_name_leafdata())
                            if (self.spf_run_no.is_set or self.spf_run_no.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_no.get_name_leafdata())
                            if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ip-convergence-time"):
                                if (self.ip_convergence_time is None):
                                    self.ip_convergence_time = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                return self.ip_convergence_time

                            if (child_yang_name == "lsa-processed"):
                                for c in self.lsa_processed:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.LsaProcessed()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsa_processed.append(c)
                                return c

                            if (child_yang_name == "mpls-convergence-time"):
                                if (self.mpls_convergence_time is None):
                                    self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                return self.mpls_convergence_time

                            if (child_yang_name == "path"):
                                for c in self.path:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.Path()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path.append(c)
                                return c

                            if (child_yang_name == "time-line"):
                                for c in self.time_line:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TimeLine()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.time_line.append(c)
                                return c

                            if (child_yang_name == "trigger-lsa"):
                                for c in self.trigger_lsa:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary.TriggerLsa()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.trigger_lsa.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ip-convergence-time" or name == "lsa-processed" or name == "mpls-convergence-time" or name == "path" or name == "time-line" or name == "trigger-lsa" or name == "event-id" or name == "change-type" or name == "cost" or name == "ipfrr-event-id" or name == "prefix" or name == "prefix-lenth" or name == "priority" or name == "route-path-change-type" or name == "route-type" or name == "spf-run-no" or name == "threshold-exceeded" or name == "trigger-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "change-type"):
                                self.change_type = value
                                self.change_type.value_namespace = name_space
                                self.change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "cost"):
                                self.cost = value
                                self.cost.value_namespace = name_space
                                self.cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipfrr-event-id"):
                                self.ipfrr_event_id = value
                                self.ipfrr_event_id.value_namespace = name_space
                                self.ipfrr_event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix"):
                                self.prefix = value
                                self.prefix.value_namespace = name_space
                                self.prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-lenth"):
                                self.prefix_lenth = value
                                self.prefix_lenth.value_namespace = name_space
                                self.prefix_lenth.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-path-change-type"):
                                self.route_path_change_type = value
                                self.route_path_change_type.value_namespace = name_space
                                self.route_path_change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-type"):
                                self.route_type = value
                                self.route_type.value_namespace = name_space
                                self.route_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-run-no"):
                                self.spf_run_no = value
                                self.spf_run_no.value_namespace = name_space
                                self.spf_run_no.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-exceeded"):
                                self.threshold_exceeded = value
                                self.threshold_exceeded.value_namespace = name_space
                                self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.prefix_event_summary:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.prefix_event_summary:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "prefix-event-summaries" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-event-summary"):
                            for c in self.prefix_event_summary:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Isis.Instances.Instance.PrefixEventSummaries.PrefixEventSummary()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.prefix_event_summary.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-event-summary"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class PrefixEventOfflines(Entity):
                    """
                    ISIS Prefix events offline data
                    
                    .. attribute:: prefix_event_offline
                    
                    	Offline operational data for particular ISIS Prefix Event
                    	**type**\: list of    :py:class:`PrefixEventOffline <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines, self).__init__()

                        self.yang_name = "prefix-event-offlines"
                        self.yang_parent_name = "instance"

                        self.prefix_event_offline = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines, self).__setattr__(name, value)


                    class PrefixEventOffline(Entity):
                        """
                        Offline operational data for particular ISIS
                        Prefix Event
                        
                        .. attribute:: event_id  <key>
                        
                        	Specific Event ID
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: change_type
                        
                        	Event Add/Delete
                        	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                        
                        .. attribute:: cost
                        
                        	Protocol route cost
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: ip_convergence_time
                        
                        	Convergence time for IP route programming
                        	**type**\:   :py:class:`IpConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime>`
                        
                        .. attribute:: ipfrr_event_id
                        
                        	Referenced IP\-FRR Event ID (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: lsa_processed
                        
                        	List of LSAs processed
                        	**type**\: list of    :py:class:`LsaProcessed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed>`
                        
                        .. attribute:: mpls_convergence_time
                        
                        	Convergence time for MPLS label programming
                        	**type**\:   :py:class:`MplsConvergenceTime <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime>`
                        
                        .. attribute:: path
                        
                        	Path information
                        	**type**\: list of    :py:class:`Path <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path>`
                        
                        .. attribute:: prefix
                        
                        	Prefix
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: prefix_lenth
                        
                        	Prefix length
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: priority
                        
                        	Event processed priority
                        	**type**\:   :py:class:`RcmdPriorityLevel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdPriorityLevel>`
                        
                        .. attribute:: route_path_change_type
                        
                        	Route Path Change Type
                        	**type**\:   :py:class:`RcmdShowRoutePathChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoutePathChange>`
                        
                        .. attribute:: route_type
                        
                        	Route Type intra/inter/l1/l2
                        	**type**\:   :py:class:`RcmdShowRoute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowRoute>`
                        
                        .. attribute:: spf_run_no
                        
                        	Referenced SPF Run No (0 \- Not Applicable)
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: threshold_exceeded
                        
                        	Threshold exceeded
                        	**type**\:  bool
                        
                        .. attribute:: time_line
                        
                        	Timeline information
                        	**type**\: list of    :py:class:`TimeLine <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine>`
                        
                        .. attribute:: trigger_lsa
                        
                        	LSA that triggered this event
                        	**type**\: list of    :py:class:`TriggerLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa>`
                        
                        .. attribute:: trigger_time
                        
                        	Event trigger time
                        	**type**\:  str
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline, self).__init__()

                            self.yang_name = "prefix-event-offline"
                            self.yang_parent_name = "prefix-event-offlines"

                            self.event_id = YLeaf(YType.int32, "event-id")

                            self.change_type = YLeaf(YType.enumeration, "change-type")

                            self.cost = YLeaf(YType.uint32, "cost")

                            self.ipfrr_event_id = YLeaf(YType.uint32, "ipfrr-event-id")

                            self.prefix = YLeaf(YType.str, "prefix")

                            self.prefix_lenth = YLeaf(YType.uint32, "prefix-lenth")

                            self.priority = YLeaf(YType.enumeration, "priority")

                            self.route_path_change_type = YLeaf(YType.enumeration, "route-path-change-type")

                            self.route_type = YLeaf(YType.enumeration, "route-type")

                            self.spf_run_no = YLeaf(YType.uint32, "spf-run-no")

                            self.threshold_exceeded = YLeaf(YType.boolean, "threshold-exceeded")

                            self.trigger_time = YLeaf(YType.str, "trigger-time")

                            self.ip_convergence_time = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime()
                            self.ip_convergence_time.parent = self
                            self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                            self._children_yang_names.add("ip-convergence-time")

                            self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime()
                            self.mpls_convergence_time.parent = self
                            self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                            self._children_yang_names.add("mpls-convergence-time")

                            self.lsa_processed = YList(self)
                            self.path = YList(self)
                            self.time_line = YList(self)
                            self.trigger_lsa = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("event_id",
                                            "change_type",
                                            "cost",
                                            "ipfrr_event_id",
                                            "prefix",
                                            "prefix_lenth",
                                            "priority",
                                            "route_path_change_type",
                                            "route_type",
                                            "spf_run_no",
                                            "threshold_exceeded",
                                            "trigger_time") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline, self).__setattr__(name, value)


                        class IpConvergenceTime(Entity):
                            """
                            Convergence time for IP route programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime, self).__init__()

                                self.yang_name = "ip-convergence-time"
                                self.yang_parent_name = "prefix-event-offline"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ip-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class MplsConvergenceTime(Entity):
                            """
                            Convergence time for MPLS label programming
                            
                            .. attribute:: fastest_node_name
                            
                            	Linecard node name which took the minimum time
                            	**type**\:  str
                            
                            .. attribute:: maximum_time
                            
                            	Maximum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: minimum_time
                            
                            	Minimum time(in seconds.milliseconds)
                            	**type**\:  str
                            
                            	**units**\: millisecond
                            
                            .. attribute:: slowest_node_name
                            
                            	Linecard node name which took the maximum time
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime, self).__init__()

                                self.yang_name = "mpls-convergence-time"
                                self.yang_parent_name = "prefix-event-offline"

                                self.fastest_node_name = YLeaf(YType.str, "fastest-node-name")

                                self.maximum_time = YLeaf(YType.str, "maximum-time")

                                self.minimum_time = YLeaf(YType.str, "minimum-time")

                                self.slowest_node_name = YLeaf(YType.str, "slowest-node-name")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("fastest_node_name",
                                                "maximum_time",
                                                "minimum_time",
                                                "slowest_node_name") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.fastest_node_name.is_set or
                                    self.maximum_time.is_set or
                                    self.minimum_time.is_set or
                                    self.slowest_node_name.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.fastest_node_name.yfilter != YFilter.not_set or
                                    self.maximum_time.yfilter != YFilter.not_set or
                                    self.minimum_time.yfilter != YFilter.not_set or
                                    self.slowest_node_name.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "mpls-convergence-time" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.fastest_node_name.is_set or self.fastest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.fastest_node_name.get_name_leafdata())
                                if (self.maximum_time.is_set or self.maximum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.maximum_time.get_name_leafdata())
                                if (self.minimum_time.is_set or self.minimum_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.minimum_time.get_name_leafdata())
                                if (self.slowest_node_name.is_set or self.slowest_node_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.slowest_node_name.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fastest-node-name" or name == "maximum-time" or name == "minimum-time" or name == "slowest-node-name"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "fastest-node-name"):
                                    self.fastest_node_name = value
                                    self.fastest_node_name.value_namespace = name_space
                                    self.fastest_node_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "maximum-time"):
                                    self.maximum_time = value
                                    self.maximum_time.value_namespace = name_space
                                    self.maximum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "minimum-time"):
                                    self.minimum_time = value
                                    self.minimum_time.value_namespace = name_space
                                    self.minimum_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "slowest-node-name"):
                                    self.slowest_node_name = value
                                    self.slowest_node_name.value_namespace = name_space
                                    self.slowest_node_name.value_namespace_prefix = name_space_prefix


                        class Path(Entity):
                            """
                            Path information
                            
                            .. attribute:: change_type
                            
                            	Event Add/Delete
                            	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                            
                            .. attribute:: interface_name
                            
                            	Interface Name
                            	**type**\:  str
                            
                            .. attribute:: lfa_path
                            
                            	Backup Path Informatoin
                            	**type**\: list of    :py:class:`LfaPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath>`
                            
                            .. attribute:: neighbour_address
                            
                            	Nexthop Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: path_metric
                            
                            	Path Metric
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path, self).__init__()

                                self.yang_name = "path"
                                self.yang_parent_name = "prefix-event-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.interface_name = YLeaf(YType.str, "interface-name")

                                self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                self.path_metric = YLeaf(YType.uint32, "path-metric")

                                self.lfa_path = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "interface_name",
                                                "neighbour_address",
                                                "path_metric") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path, self).__setattr__(name, value)


                            class LfaPath(Entity):
                                """
                                Backup Path Informatoin
                                
                                .. attribute:: change_type
                                
                                	Event Add/Delete
                                	**type**\:   :py:class:`RcmdChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdChange>`
                                
                                .. attribute:: interface_name
                                
                                	Interface Name
                                	**type**\:  str
                                
                                .. attribute:: lfa_type
                                
                                	Type of LFA
                                	**type**\:   :py:class:`RcmdShowIpfrrLfa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowIpfrrLfa>`
                                
                                .. attribute:: neighbour_address
                                
                                	Nexthop Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                .. attribute:: path_metric
                                
                                	Path Metric
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: remote_node_id
                                
                                	Remote Node ID, in case of Remote LFA
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath, self).__init__()

                                    self.yang_name = "lfa-path"
                                    self.yang_parent_name = "path"

                                    self.change_type = YLeaf(YType.enumeration, "change-type")

                                    self.interface_name = YLeaf(YType.str, "interface-name")

                                    self.lfa_type = YLeaf(YType.enumeration, "lfa-type")

                                    self.neighbour_address = YLeaf(YType.str, "neighbour-address")

                                    self.path_metric = YLeaf(YType.uint32, "path-metric")

                                    self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("change_type",
                                                    "interface_name",
                                                    "lfa_type",
                                                    "neighbour_address",
                                                    "path_metric",
                                                    "remote_node_id") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.change_type.is_set or
                                        self.interface_name.is_set or
                                        self.lfa_type.is_set or
                                        self.neighbour_address.is_set or
                                        self.path_metric.is_set or
                                        self.remote_node_id.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.change_type.yfilter != YFilter.not_set or
                                        self.interface_name.yfilter != YFilter.not_set or
                                        self.lfa_type.yfilter != YFilter.not_set or
                                        self.neighbour_address.yfilter != YFilter.not_set or
                                        self.path_metric.yfilter != YFilter.not_set or
                                        self.remote_node_id.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lfa-path" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.change_type.get_name_leafdata())
                                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                                    if (self.lfa_type.is_set or self.lfa_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.lfa_type.get_name_leafdata())
                                    if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                    if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.path_metric.get_name_leafdata())
                                    if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.remote_node_id.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "change-type" or name == "interface-name" or name == "lfa-type" or name == "neighbour-address" or name == "path-metric" or name == "remote-node-id"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "change-type"):
                                        self.change_type = value
                                        self.change_type.value_namespace = name_space
                                        self.change_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "interface-name"):
                                        self.interface_name = value
                                        self.interface_name.value_namespace = name_space
                                        self.interface_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "lfa-type"):
                                        self.lfa_type = value
                                        self.lfa_type.value_namespace = name_space
                                        self.lfa_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "neighbour-address"):
                                        self.neighbour_address = value
                                        self.neighbour_address.value_namespace = name_space
                                        self.neighbour_address.value_namespace_prefix = name_space_prefix
                                    if(value_path == "path-metric"):
                                        self.path_metric = value
                                        self.path_metric.value_namespace = name_space
                                        self.path_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "remote-node-id"):
                                        self.remote_node_id = value
                                        self.remote_node_id.value_namespace = name_space
                                        self.remote_node_id.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lfa_path:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.change_type.is_set or
                                    self.interface_name.is_set or
                                    self.neighbour_address.is_set or
                                    self.path_metric.is_set)

                            def has_operation(self):
                                for c in self.lfa_path:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.interface_name.yfilter != YFilter.not_set or
                                    self.neighbour_address.yfilter != YFilter.not_set or
                                    self.path_metric.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.interface_name.get_name_leafdata())
                                if (self.neighbour_address.is_set or self.neighbour_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.neighbour_address.get_name_leafdata())
                                if (self.path_metric.is_set or self.path_metric.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_metric.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lfa-path"):
                                    for c in self.lfa_path:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path.LfaPath()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lfa_path.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lfa-path" or name == "change-type" or name == "interface-name" or name == "neighbour-address" or name == "path-metric"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "interface-name"):
                                    self.interface_name = value
                                    self.interface_name.value_namespace = name_space
                                    self.interface_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "neighbour-address"):
                                    self.neighbour_address = value
                                    self.neighbour_address.value_namespace = name_space
                                    self.neighbour_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-metric"):
                                    self.path_metric = value
                                    self.path_metric.value_namespace = name_space
                                    self.path_metric.value_namespace_prefix = name_space_prefix


                        class TriggerLsa(Entity):
                            """
                            LSA that triggered this event
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa, self).__init__()

                                self.yang_name = "trigger-lsa"
                                self.yang_parent_name = "prefix-event-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "trigger-lsa" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix


                        class TimeLine(Entity):
                            """
                            Timeline information
                            
                            .. attribute:: lc_ip
                            
                            	List of Linecards' completion point for IP routes
                            	**type**\: list of    :py:class:`LcIp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp>`
                            
                            .. attribute:: lc_mpls
                            
                            	List of Linecards' completion point for MPLS labels
                            	**type**\: list of    :py:class:`LcMpls <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls>`
                            
                            .. attribute:: ldp_enter
                            
                            	Entry point of LDP
                            	**type**\:  str
                            
                            .. attribute:: ldp_exit
                            
                            	Exit point of LDP to LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_enter
                            
                            	Entry point of LSD
                            	**type**\:  str
                            
                            .. attribute:: lsd_exit
                            
                            	Exit point of LSD to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_enter
                            
                            	Entry point of IPv4 RIB
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_exit
                            
                            	Exit point from IPv4 RIB to FIBs
                            	**type**\:  str
                            
                            .. attribute:: ri_bv4_redistribute
                            
                            	Route Redistribute point from IPv4 RIB to LDP
                            	**type**\:  str
                            
                            .. attribute:: route_origin
                            
                            	Route origin (routing protocol)
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine, self).__init__()

                                self.yang_name = "time-line"
                                self.yang_parent_name = "prefix-event-offline"

                                self.ldp_enter = YLeaf(YType.str, "ldp-enter")

                                self.ldp_exit = YLeaf(YType.str, "ldp-exit")

                                self.lsd_enter = YLeaf(YType.str, "lsd-enter")

                                self.lsd_exit = YLeaf(YType.str, "lsd-exit")

                                self.ri_bv4_enter = YLeaf(YType.str, "ri-bv4-enter")

                                self.ri_bv4_exit = YLeaf(YType.str, "ri-bv4-exit")

                                self.ri_bv4_redistribute = YLeaf(YType.str, "ri-bv4-redistribute")

                                self.route_origin = YLeaf(YType.str, "route-origin")

                                self.lc_ip = YList(self)
                                self.lc_mpls = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("ldp_enter",
                                                "ldp_exit",
                                                "lsd_enter",
                                                "lsd_exit",
                                                "ri_bv4_enter",
                                                "ri_bv4_exit",
                                                "ri_bv4_redistribute",
                                                "route_origin") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine, self).__setattr__(name, value)


                            class LcIp(Entity):
                                """
                                List of Linecards' completion point for IP
                                routes
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp, self).__init__()

                                    self.yang_name = "lc-ip"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-ip" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix


                            class LcMpls(Entity):
                                """
                                List of Linecards' completion point for MPLS
                                labels
                                
                                .. attribute:: fib_complete
                                
                                	Completion point of FIB
                                	**type**\:  str
                                
                                .. attribute:: node_name
                                
                                	Linecard node name
                                	**type**\:  str
                                
                                .. attribute:: speed
                                
                                	Relative convergence speed
                                	**type**\:   :py:class:`RcmdLinecardSpeed <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLinecardSpeed>`
                                
                                

                                """

                                _prefix = 'infra-rcmd-oper'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls, self).__init__()

                                    self.yang_name = "lc-mpls"
                                    self.yang_parent_name = "time-line"

                                    self.fib_complete = YLeaf(YType.str, "fib-complete")

                                    self.node_name = YLeaf(YType.str, "node-name")

                                    self.speed = YLeaf(YType.enumeration, "speed")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("fib_complete",
                                                    "node_name",
                                                    "speed") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.fib_complete.is_set or
                                        self.node_name.is_set or
                                        self.speed.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.fib_complete.yfilter != YFilter.not_set or
                                        self.node_name.yfilter != YFilter.not_set or
                                        self.speed.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "lc-mpls" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.fib_complete.is_set or self.fib_complete.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.fib_complete.get_name_leafdata())
                                    if (self.node_name.is_set or self.node_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.node_name.get_name_leafdata())
                                    if (self.speed.is_set or self.speed.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.speed.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fib-complete" or name == "node-name" or name == "speed"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "fib-complete"):
                                        self.fib_complete = value
                                        self.fib_complete.value_namespace = name_space
                                        self.fib_complete.value_namespace_prefix = name_space_prefix
                                    if(value_path == "node-name"):
                                        self.node_name = value
                                        self.node_name.value_namespace = name_space
                                        self.node_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "speed"):
                                        self.speed = value
                                        self.speed.value_namespace = name_space
                                        self.speed.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.lc_ip:
                                    if (c.has_data()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_data()):
                                        return True
                                return (
                                    self.ldp_enter.is_set or
                                    self.ldp_exit.is_set or
                                    self.lsd_enter.is_set or
                                    self.lsd_exit.is_set or
                                    self.ri_bv4_enter.is_set or
                                    self.ri_bv4_exit.is_set or
                                    self.ri_bv4_redistribute.is_set or
                                    self.route_origin.is_set)

                            def has_operation(self):
                                for c in self.lc_ip:
                                    if (c.has_operation()):
                                        return True
                                for c in self.lc_mpls:
                                    if (c.has_operation()):
                                        return True
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.ldp_enter.yfilter != YFilter.not_set or
                                    self.ldp_exit.yfilter != YFilter.not_set or
                                    self.lsd_enter.yfilter != YFilter.not_set or
                                    self.lsd_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_enter.yfilter != YFilter.not_set or
                                    self.ri_bv4_exit.yfilter != YFilter.not_set or
                                    self.ri_bv4_redistribute.yfilter != YFilter.not_set or
                                    self.route_origin.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "time-line" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.ldp_enter.is_set or self.ldp_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_enter.get_name_leafdata())
                                if (self.ldp_exit.is_set or self.ldp_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ldp_exit.get_name_leafdata())
                                if (self.lsd_enter.is_set or self.lsd_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_enter.get_name_leafdata())
                                if (self.lsd_exit.is_set or self.lsd_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsd_exit.get_name_leafdata())
                                if (self.ri_bv4_enter.is_set or self.ri_bv4_enter.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_enter.get_name_leafdata())
                                if (self.ri_bv4_exit.is_set or self.ri_bv4_exit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_exit.get_name_leafdata())
                                if (self.ri_bv4_redistribute.is_set or self.ri_bv4_redistribute.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.ri_bv4_redistribute.get_name_leafdata())
                                if (self.route_origin.is_set or self.route_origin.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.route_origin.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "lc-ip"):
                                    for c in self.lc_ip:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcIp()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_ip.append(c)
                                    return c

                                if (child_yang_name == "lc-mpls"):
                                    for c in self.lc_mpls:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine.LcMpls()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.lc_mpls.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "lc-ip" or name == "lc-mpls" or name == "ldp-enter" or name == "ldp-exit" or name == "lsd-enter" or name == "lsd-exit" or name == "ri-bv4-enter" or name == "ri-bv4-exit" or name == "ri-bv4-redistribute" or name == "route-origin"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "ldp-enter"):
                                    self.ldp_enter = value
                                    self.ldp_enter.value_namespace = name_space
                                    self.ldp_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ldp-exit"):
                                    self.ldp_exit = value
                                    self.ldp_exit.value_namespace = name_space
                                    self.ldp_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-enter"):
                                    self.lsd_enter = value
                                    self.lsd_enter.value_namespace = name_space
                                    self.lsd_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsd-exit"):
                                    self.lsd_exit = value
                                    self.lsd_exit.value_namespace = name_space
                                    self.lsd_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-enter"):
                                    self.ri_bv4_enter = value
                                    self.ri_bv4_enter.value_namespace = name_space
                                    self.ri_bv4_enter.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-exit"):
                                    self.ri_bv4_exit = value
                                    self.ri_bv4_exit.value_namespace = name_space
                                    self.ri_bv4_exit.value_namespace_prefix = name_space_prefix
                                if(value_path == "ri-bv4-redistribute"):
                                    self.ri_bv4_redistribute = value
                                    self.ri_bv4_redistribute.value_namespace = name_space
                                    self.ri_bv4_redistribute.value_namespace_prefix = name_space_prefix
                                if(value_path == "route-origin"):
                                    self.route_origin = value
                                    self.route_origin.value_namespace = name_space
                                    self.route_origin.value_namespace_prefix = name_space_prefix


                        class LsaProcessed(Entity):
                            """
                            List of LSAs processed
                            
                            .. attribute:: change_type
                            
                            	Add, Delete, Modify
                            	**type**\:   :py:class:`RcmdLsChange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsChange>`
                            
                            .. attribute:: lsa_id
                            
                            	LSA ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: lsa_type
                            
                            	LSA type
                            	**type**\:   :py:class:`RcmdLsa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLsa>`
                            
                            .. attribute:: origin_router_id
                            
                            	Originating Router ID
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: reception_time
                            
                            	Reception Time on router (in hh\:mm\:ss.msec)
                            	**type**\:  str
                            
                            .. attribute:: sequence_number
                            
                            	Sequence Number
                            	**type**\:  str
                            
                            

                            """

                            _prefix = 'infra-rcmd-oper'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed, self).__init__()

                                self.yang_name = "lsa-processed"
                                self.yang_parent_name = "prefix-event-offline"

                                self.change_type = YLeaf(YType.enumeration, "change-type")

                                self.lsa_id = YLeaf(YType.str, "lsa-id")

                                self.lsa_type = YLeaf(YType.enumeration, "lsa-type")

                                self.origin_router_id = YLeaf(YType.str, "origin-router-id")

                                self.reception_time = YLeaf(YType.str, "reception-time")

                                self.sequence_number = YLeaf(YType.str, "sequence-number")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("change_type",
                                                "lsa_id",
                                                "lsa_type",
                                                "origin_router_id",
                                                "reception_time",
                                                "sequence_number") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.change_type.is_set or
                                    self.lsa_id.is_set or
                                    self.lsa_type.is_set or
                                    self.origin_router_id.is_set or
                                    self.reception_time.is_set or
                                    self.sequence_number.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.change_type.yfilter != YFilter.not_set or
                                    self.lsa_id.yfilter != YFilter.not_set or
                                    self.lsa_type.yfilter != YFilter.not_set or
                                    self.origin_router_id.yfilter != YFilter.not_set or
                                    self.reception_time.yfilter != YFilter.not_set or
                                    self.sequence_number.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsa-processed" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.change_type.get_name_leafdata())
                                if (self.lsa_id.is_set or self.lsa_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_id.get_name_leafdata())
                                if (self.lsa_type.is_set or self.lsa_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lsa_type.get_name_leafdata())
                                if (self.origin_router_id.is_set or self.origin_router_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.origin_router_id.get_name_leafdata())
                                if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.reception_time.get_name_leafdata())
                                if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sequence_number.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "change-type" or name == "lsa-id" or name == "lsa-type" or name == "origin-router-id" or name == "reception-time" or name == "sequence-number"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "change-type"):
                                    self.change_type = value
                                    self.change_type.value_namespace = name_space
                                    self.change_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-id"):
                                    self.lsa_id = value
                                    self.lsa_id.value_namespace = name_space
                                    self.lsa_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "lsa-type"):
                                    self.lsa_type = value
                                    self.lsa_type.value_namespace = name_space
                                    self.lsa_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "origin-router-id"):
                                    self.origin_router_id = value
                                    self.origin_router_id.value_namespace = name_space
                                    self.origin_router_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "reception-time"):
                                    self.reception_time = value
                                    self.reception_time.value_namespace = name_space
                                    self.reception_time.value_namespace_prefix = name_space_prefix
                                if(value_path == "sequence-number"):
                                    self.sequence_number = value
                                    self.sequence_number.value_namespace = name_space
                                    self.sequence_number.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.lsa_processed:
                                if (c.has_data()):
                                    return True
                            for c in self.path:
                                if (c.has_data()):
                                    return True
                            for c in self.time_line:
                                if (c.has_data()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_data()):
                                    return True
                            return (
                                self.event_id.is_set or
                                self.change_type.is_set or
                                self.cost.is_set or
                                self.ipfrr_event_id.is_set or
                                self.prefix.is_set or
                                self.prefix_lenth.is_set or
                                self.priority.is_set or
                                self.route_path_change_type.is_set or
                                self.route_type.is_set or
                                self.spf_run_no.is_set or
                                self.threshold_exceeded.is_set or
                                self.trigger_time.is_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_data()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_data()))

                        def has_operation(self):
                            for c in self.lsa_processed:
                                if (c.has_operation()):
                                    return True
                            for c in self.path:
                                if (c.has_operation()):
                                    return True
                            for c in self.time_line:
                                if (c.has_operation()):
                                    return True
                            for c in self.trigger_lsa:
                                if (c.has_operation()):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.event_id.yfilter != YFilter.not_set or
                                self.change_type.yfilter != YFilter.not_set or
                                self.cost.yfilter != YFilter.not_set or
                                self.ipfrr_event_id.yfilter != YFilter.not_set or
                                self.prefix.yfilter != YFilter.not_set or
                                self.prefix_lenth.yfilter != YFilter.not_set or
                                self.priority.yfilter != YFilter.not_set or
                                self.route_path_change_type.yfilter != YFilter.not_set or
                                self.route_type.yfilter != YFilter.not_set or
                                self.spf_run_no.yfilter != YFilter.not_set or
                                self.threshold_exceeded.yfilter != YFilter.not_set or
                                self.trigger_time.yfilter != YFilter.not_set or
                                (self.ip_convergence_time is not None and self.ip_convergence_time.has_operation()) or
                                (self.mpls_convergence_time is not None and self.mpls_convergence_time.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "prefix-event-offline" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.event_id.get_name_leafdata())
                            if (self.change_type.is_set or self.change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.change_type.get_name_leafdata())
                            if (self.cost.is_set or self.cost.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.cost.get_name_leafdata())
                            if (self.ipfrr_event_id.is_set or self.ipfrr_event_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.ipfrr_event_id.get_name_leafdata())
                            if (self.prefix.is_set or self.prefix.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix.get_name_leafdata())
                            if (self.prefix_lenth.is_set or self.prefix_lenth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.prefix_lenth.get_name_leafdata())
                            if (self.priority.is_set or self.priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.priority.get_name_leafdata())
                            if (self.route_path_change_type.is_set or self.route_path_change_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_path_change_type.get_name_leafdata())
                            if (self.route_type.is_set or self.route_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_type.get_name_leafdata())
                            if (self.spf_run_no.is_set or self.spf_run_no.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_no.get_name_leafdata())
                            if (self.threshold_exceeded.is_set or self.threshold_exceeded.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.threshold_exceeded.get_name_leafdata())
                            if (self.trigger_time.is_set or self.trigger_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.trigger_time.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ip-convergence-time"):
                                if (self.ip_convergence_time is None):
                                    self.ip_convergence_time = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.IpConvergenceTime()
                                    self.ip_convergence_time.parent = self
                                    self._children_name_map["ip_convergence_time"] = "ip-convergence-time"
                                return self.ip_convergence_time

                            if (child_yang_name == "lsa-processed"):
                                for c in self.lsa_processed:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.LsaProcessed()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.lsa_processed.append(c)
                                return c

                            if (child_yang_name == "mpls-convergence-time"):
                                if (self.mpls_convergence_time is None):
                                    self.mpls_convergence_time = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.MplsConvergenceTime()
                                    self.mpls_convergence_time.parent = self
                                    self._children_name_map["mpls_convergence_time"] = "mpls-convergence-time"
                                return self.mpls_convergence_time

                            if (child_yang_name == "path"):
                                for c in self.path:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.Path()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path.append(c)
                                return c

                            if (child_yang_name == "time-line"):
                                for c in self.time_line:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TimeLine()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.time_line.append(c)
                                return c

                            if (child_yang_name == "trigger-lsa"):
                                for c in self.trigger_lsa:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline.TriggerLsa()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.trigger_lsa.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ip-convergence-time" or name == "lsa-processed" or name == "mpls-convergence-time" or name == "path" or name == "time-line" or name == "trigger-lsa" or name == "event-id" or name == "change-type" or name == "cost" or name == "ipfrr-event-id" or name == "prefix" or name == "prefix-lenth" or name == "priority" or name == "route-path-change-type" or name == "route-type" or name == "spf-run-no" or name == "threshold-exceeded" or name == "trigger-time"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "event-id"):
                                self.event_id = value
                                self.event_id.value_namespace = name_space
                                self.event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "change-type"):
                                self.change_type = value
                                self.change_type.value_namespace = name_space
                                self.change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "cost"):
                                self.cost = value
                                self.cost.value_namespace = name_space
                                self.cost.value_namespace_prefix = name_space_prefix
                            if(value_path == "ipfrr-event-id"):
                                self.ipfrr_event_id = value
                                self.ipfrr_event_id.value_namespace = name_space
                                self.ipfrr_event_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix"):
                                self.prefix = value
                                self.prefix.value_namespace = name_space
                                self.prefix.value_namespace_prefix = name_space_prefix
                            if(value_path == "prefix-lenth"):
                                self.prefix_lenth = value
                                self.prefix_lenth.value_namespace = name_space
                                self.prefix_lenth.value_namespace_prefix = name_space_prefix
                            if(value_path == "priority"):
                                self.priority = value
                                self.priority.value_namespace = name_space
                                self.priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-path-change-type"):
                                self.route_path_change_type = value
                                self.route_path_change_type.value_namespace = name_space
                                self.route_path_change_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-type"):
                                self.route_type = value
                                self.route_type.value_namespace = name_space
                                self.route_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-run-no"):
                                self.spf_run_no = value
                                self.spf_run_no.value_namespace = name_space
                                self.spf_run_no.value_namespace_prefix = name_space_prefix
                            if(value_path == "threshold-exceeded"):
                                self.threshold_exceeded = value
                                self.threshold_exceeded.value_namespace = name_space
                                self.threshold_exceeded.value_namespace_prefix = name_space_prefix
                            if(value_path == "trigger-time"):
                                self.trigger_time = value
                                self.trigger_time.value_namespace = name_space
                                self.trigger_time.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.prefix_event_offline:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.prefix_event_offline:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "prefix-event-offlines" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "prefix-event-offline"):
                            for c in self.prefix_event_offline:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Isis.Instances.Instance.PrefixEventOfflines.PrefixEventOffline()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.prefix_event_offline.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "prefix-event-offline"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class LspRegenerateds(Entity):
                    """
                    Regenerated LSP data
                    
                    .. attribute:: lsp_regenerated
                    
                    	Regenerated LSP data
                    	**type**\: list of    :py:class:`LspRegenerated <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Isis.Instances.Instance.LspRegenerateds.LspRegenerated>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Isis.Instances.Instance.LspRegenerateds, self).__init__()

                        self.yang_name = "lsp-regenerateds"
                        self.yang_parent_name = "instance"

                        self.lsp_regenerated = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Isis.Instances.Instance.LspRegenerateds, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Isis.Instances.Instance.LspRegenerateds, self).__setattr__(name, value)


                    class LspRegenerated(Entity):
                        """
                        Regenerated LSP data
                        
                        .. attribute:: serial_number  <key>
                        
                        	Data for a particular regenerated LSP
                        	**type**\:  int
                        
                        	**range:** \-2147483648..2147483647
                        
                        .. attribute:: isis_level
                        
                        	ISIS Level
                        	**type**\:   :py:class:`RcmdIsisLvl <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdIsisLvl>`
                        
                        .. attribute:: lsp_id
                        
                        	LSP ID
                        	**type**\:  str
                        
                        .. attribute:: reason
                        
                        	Trigger reasons for LSP regeneration. Example\: pr^ \- periodic, cr^ \- clear (Check the documentation for the entire list)
                        	**type**\:  str
                        
                        .. attribute:: reception_time
                        
                        	Reception Time on router (in hh\:mm\:ss.msec)
                        	**type**\:  str
                        
                        .. attribute:: sequence_number
                        
                        	Sequence Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: serial_number_xr
                        
                        	Serial Number of the session event
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: spf_run_number
                        
                        	SPF Run Number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Isis.Instances.Instance.LspRegenerateds.LspRegenerated, self).__init__()

                            self.yang_name = "lsp-regenerated"
                            self.yang_parent_name = "lsp-regenerateds"

                            self.serial_number = YLeaf(YType.int32, "serial-number")

                            self.isis_level = YLeaf(YType.enumeration, "isis-level")

                            self.lsp_id = YLeaf(YType.str, "lsp-id")

                            self.reason = YLeaf(YType.str, "reason")

                            self.reception_time = YLeaf(YType.str, "reception-time")

                            self.sequence_number = YLeaf(YType.uint32, "sequence-number")

                            self.serial_number_xr = YLeaf(YType.uint32, "serial-number-xr")

                            self.spf_run_number = YLeaf(YType.uint32, "spf-run-number")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("serial_number",
                                            "isis_level",
                                            "lsp_id",
                                            "reason",
                                            "reception_time",
                                            "sequence_number",
                                            "serial_number_xr",
                                            "spf_run_number") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Isis.Instances.Instance.LspRegenerateds.LspRegenerated, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Isis.Instances.Instance.LspRegenerateds.LspRegenerated, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.serial_number.is_set or
                                self.isis_level.is_set or
                                self.lsp_id.is_set or
                                self.reason.is_set or
                                self.reception_time.is_set or
                                self.sequence_number.is_set or
                                self.serial_number_xr.is_set or
                                self.spf_run_number.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.serial_number.yfilter != YFilter.not_set or
                                self.isis_level.yfilter != YFilter.not_set or
                                self.lsp_id.yfilter != YFilter.not_set or
                                self.reason.yfilter != YFilter.not_set or
                                self.reception_time.yfilter != YFilter.not_set or
                                self.sequence_number.yfilter != YFilter.not_set or
                                self.serial_number_xr.yfilter != YFilter.not_set or
                                self.spf_run_number.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "lsp-regenerated" + "[serial-number='" + self.serial_number.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.serial_number.is_set or self.serial_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.serial_number.get_name_leafdata())
                            if (self.isis_level.is_set or self.isis_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.isis_level.get_name_leafdata())
                            if (self.lsp_id.is_set or self.lsp_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lsp_id.get_name_leafdata())
                            if (self.reason.is_set or self.reason.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reason.get_name_leafdata())
                            if (self.reception_time.is_set or self.reception_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reception_time.get_name_leafdata())
                            if (self.sequence_number.is_set or self.sequence_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sequence_number.get_name_leafdata())
                            if (self.serial_number_xr.is_set or self.serial_number_xr.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.serial_number_xr.get_name_leafdata())
                            if (self.spf_run_number.is_set or self.spf_run_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_run_number.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "serial-number" or name == "isis-level" or name == "lsp-id" or name == "reason" or name == "reception-time" or name == "sequence-number" or name == "serial-number-xr" or name == "spf-run-number"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "serial-number"):
                                self.serial_number = value
                                self.serial_number.value_namespace = name_space
                                self.serial_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "isis-level"):
                                self.isis_level = value
                                self.isis_level.value_namespace = name_space
                                self.isis_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "lsp-id"):
                                self.lsp_id = value
                                self.lsp_id.value_namespace = name_space
                                self.lsp_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "reason"):
                                self.reason = value
                                self.reason.value_namespace = name_space
                                self.reason.value_namespace_prefix = name_space_prefix
                            if(value_path == "reception-time"):
                                self.reception_time = value
                                self.reception_time.value_namespace = name_space
                                self.reception_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "sequence-number"):
                                self.sequence_number = value
                                self.sequence_number.value_namespace = name_space
                                self.sequence_number.value_namespace_prefix = name_space_prefix
                            if(value_path == "serial-number-xr"):
                                self.serial_number_xr = value
                                self.serial_number_xr.value_namespace = name_space
                                self.serial_number_xr.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-run-number"):
                                self.spf_run_number = value
                                self.spf_run_number.value_namespace = name_space
                                self.spf_run_number.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.lsp_regenerated:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.lsp_regenerated:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lsp-regenerateds" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "lsp-regenerated"):
                            for c in self.lsp_regenerated:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Isis.Instances.Instance.LspRegenerateds.LspRegenerated()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.lsp_regenerated.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "lsp-regenerated"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        self.instance_name.is_set or
                        (self.ipfrr_event_offlines is not None and self.ipfrr_event_offlines.has_data()) or
                        (self.ipfrr_event_summaries is not None and self.ipfrr_event_summaries.has_data()) or
                        (self.lsp_regenerateds is not None and self.lsp_regenerateds.has_data()) or
                        (self.prefix_event_offlines is not None and self.prefix_event_offlines.has_data()) or
                        (self.prefix_event_statistics is not None and self.prefix_event_statistics.has_data()) or
                        (self.prefix_event_summaries is not None and self.prefix_event_summaries.has_data()) or
                        (self.spf_run_offlines is not None and self.spf_run_offlines.has_data()) or
                        (self.spf_run_summaries is not None and self.spf_run_summaries.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.instance_name.yfilter != YFilter.not_set or
                        (self.ipfrr_event_offlines is not None and self.ipfrr_event_offlines.has_operation()) or
                        (self.ipfrr_event_summaries is not None and self.ipfrr_event_summaries.has_operation()) or
                        (self.lsp_regenerateds is not None and self.lsp_regenerateds.has_operation()) or
                        (self.prefix_event_offlines is not None and self.prefix_event_offlines.has_operation()) or
                        (self.prefix_event_statistics is not None and self.prefix_event_statistics.has_operation()) or
                        (self.prefix_event_summaries is not None and self.prefix_event_summaries.has_operation()) or
                        (self.spf_run_offlines is not None and self.spf_run_offlines.has_operation()) or
                        (self.spf_run_summaries is not None and self.spf_run_summaries.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "instance" + "[instance-name='" + self.instance_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/isis/instances/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.instance_name.is_set or self.instance_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.instance_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ipfrr-event-offlines"):
                        if (self.ipfrr_event_offlines is None):
                            self.ipfrr_event_offlines = Rcmd.Isis.Instances.Instance.IpfrrEventOfflines()
                            self.ipfrr_event_offlines.parent = self
                            self._children_name_map["ipfrr_event_offlines"] = "ipfrr-event-offlines"
                        return self.ipfrr_event_offlines

                    if (child_yang_name == "ipfrr-event-summaries"):
                        if (self.ipfrr_event_summaries is None):
                            self.ipfrr_event_summaries = Rcmd.Isis.Instances.Instance.IpfrrEventSummaries()
                            self.ipfrr_event_summaries.parent = self
                            self._children_name_map["ipfrr_event_summaries"] = "ipfrr-event-summaries"
                        return self.ipfrr_event_summaries

                    if (child_yang_name == "lsp-regenerateds"):
                        if (self.lsp_regenerateds is None):
                            self.lsp_regenerateds = Rcmd.Isis.Instances.Instance.LspRegenerateds()
                            self.lsp_regenerateds.parent = self
                            self._children_name_map["lsp_regenerateds"] = "lsp-regenerateds"
                        return self.lsp_regenerateds

                    if (child_yang_name == "prefix-event-offlines"):
                        if (self.prefix_event_offlines is None):
                            self.prefix_event_offlines = Rcmd.Isis.Instances.Instance.PrefixEventOfflines()
                            self.prefix_event_offlines.parent = self
                            self._children_name_map["prefix_event_offlines"] = "prefix-event-offlines"
                        return self.prefix_event_offlines

                    if (child_yang_name == "prefix-event-statistics"):
                        if (self.prefix_event_statistics is None):
                            self.prefix_event_statistics = Rcmd.Isis.Instances.Instance.PrefixEventStatistics()
                            self.prefix_event_statistics.parent = self
                            self._children_name_map["prefix_event_statistics"] = "prefix-event-statistics"
                        return self.prefix_event_statistics

                    if (child_yang_name == "prefix-event-summaries"):
                        if (self.prefix_event_summaries is None):
                            self.prefix_event_summaries = Rcmd.Isis.Instances.Instance.PrefixEventSummaries()
                            self.prefix_event_summaries.parent = self
                            self._children_name_map["prefix_event_summaries"] = "prefix-event-summaries"
                        return self.prefix_event_summaries

                    if (child_yang_name == "spf-run-offlines"):
                        if (self.spf_run_offlines is None):
                            self.spf_run_offlines = Rcmd.Isis.Instances.Instance.SpfRunOfflines()
                            self.spf_run_offlines.parent = self
                            self._children_name_map["spf_run_offlines"] = "spf-run-offlines"
                        return self.spf_run_offlines

                    if (child_yang_name == "spf-run-summaries"):
                        if (self.spf_run_summaries is None):
                            self.spf_run_summaries = Rcmd.Isis.Instances.Instance.SpfRunSummaries()
                            self.spf_run_summaries.parent = self
                            self._children_name_map["spf_run_summaries"] = "spf-run-summaries"
                        return self.spf_run_summaries

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ipfrr-event-offlines" or name == "ipfrr-event-summaries" or name == "lsp-regenerateds" or name == "prefix-event-offlines" or name == "prefix-event-statistics" or name == "prefix-event-summaries" or name == "spf-run-offlines" or name == "spf-run-summaries" or name == "instance-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "instance-name"):
                        self.instance_name = value
                        self.instance_name.value_namespace = name_space
                        self.instance_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.instance:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.instance:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "instances" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/isis/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "instance"):
                    for c in self.instance:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Isis.Instances.Instance()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.instance.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "instance"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.instances is not None and self.instances.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.instances is not None and self.instances.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "isis" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "instances"):
                if (self.instances is None):
                    self.instances = Rcmd.Isis.Instances()
                    self.instances.parent = self
                    self._children_name_map["instances"] = "instances"
                return self.instances

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "instances"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Memory(Entity):
        """
        Memory Info
        
        .. attribute:: edm_memory_info
        
        	Memory Info
        	**type**\: list of    :py:class:`EdmMemoryInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Memory.EdmMemoryInfo>`
        
        .. attribute:: memory_info
        
        	Memory Info
        	**type**\: list of    :py:class:`MemoryInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Memory.MemoryInfo>`
        
        .. attribute:: string_memory_info
        
        	Memory Info
        	**type**\: list of    :py:class:`StringMemoryInfo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Memory.StringMemoryInfo>`
        
        

        """

        _prefix = 'infra-rcmd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Rcmd.Memory, self).__init__()

            self.yang_name = "memory"
            self.yang_parent_name = "rcmd"

            self.edm_memory_info = YList(self)
            self.memory_info = YList(self)
            self.string_memory_info = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(Rcmd.Memory, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(Rcmd.Memory, self).__setattr__(name, value)


        class MemoryInfo(Entity):
            """
            Memory Info
            
            .. attribute:: alloc_count
            
            	Allocated count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: alloc_fails
            
            	Allocation Fails
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: current_count
            
            	Current Count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: freed_count
            
            	Freed Count
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: memory_type
            
            	Memory Type
            	**type**\:   :py:class:`RcmdShowMem <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowMem>`
            
            .. attribute:: size
            
            	Size of the datastructure
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: structure_name
            
            	Structure Name
            	**type**\:  str
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Memory.MemoryInfo, self).__init__()

                self.yang_name = "memory-info"
                self.yang_parent_name = "memory"

                self.alloc_count = YLeaf(YType.uint32, "alloc-count")

                self.alloc_fails = YLeaf(YType.uint32, "alloc-fails")

                self.current_count = YLeaf(YType.uint32, "current-count")

                self.freed_count = YLeaf(YType.uint32, "freed-count")

                self.memory_type = YLeaf(YType.enumeration, "memory-type")

                self.size = YLeaf(YType.uint32, "size")

                self.structure_name = YLeaf(YType.str, "structure-name")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("alloc_count",
                                "alloc_fails",
                                "current_count",
                                "freed_count",
                                "memory_type",
                                "size",
                                "structure_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Memory.MemoryInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Memory.MemoryInfo, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.alloc_count.is_set or
                    self.alloc_fails.is_set or
                    self.current_count.is_set or
                    self.freed_count.is_set or
                    self.memory_type.is_set or
                    self.size.is_set or
                    self.structure_name.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.alloc_count.yfilter != YFilter.not_set or
                    self.alloc_fails.yfilter != YFilter.not_set or
                    self.current_count.yfilter != YFilter.not_set or
                    self.freed_count.yfilter != YFilter.not_set or
                    self.memory_type.yfilter != YFilter.not_set or
                    self.size.yfilter != YFilter.not_set or
                    self.structure_name.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "memory-info" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/memory/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.alloc_count.is_set or self.alloc_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.alloc_count.get_name_leafdata())
                if (self.alloc_fails.is_set or self.alloc_fails.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.alloc_fails.get_name_leafdata())
                if (self.current_count.is_set or self.current_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.current_count.get_name_leafdata())
                if (self.freed_count.is_set or self.freed_count.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.freed_count.get_name_leafdata())
                if (self.memory_type.is_set or self.memory_type.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.memory_type.get_name_leafdata())
                if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.size.get_name_leafdata())
                if (self.structure_name.is_set or self.structure_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.structure_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "alloc-count" or name == "alloc-fails" or name == "current-count" or name == "freed-count" or name == "memory-type" or name == "size" or name == "structure-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "alloc-count"):
                    self.alloc_count = value
                    self.alloc_count.value_namespace = name_space
                    self.alloc_count.value_namespace_prefix = name_space_prefix
                if(value_path == "alloc-fails"):
                    self.alloc_fails = value
                    self.alloc_fails.value_namespace = name_space
                    self.alloc_fails.value_namespace_prefix = name_space_prefix
                if(value_path == "current-count"):
                    self.current_count = value
                    self.current_count.value_namespace = name_space
                    self.current_count.value_namespace_prefix = name_space_prefix
                if(value_path == "freed-count"):
                    self.freed_count = value
                    self.freed_count.value_namespace = name_space
                    self.freed_count.value_namespace_prefix = name_space_prefix
                if(value_path == "memory-type"):
                    self.memory_type = value
                    self.memory_type.value_namespace = name_space
                    self.memory_type.value_namespace_prefix = name_space_prefix
                if(value_path == "size"):
                    self.size = value
                    self.size.value_namespace = name_space
                    self.size.value_namespace_prefix = name_space_prefix
                if(value_path == "structure-name"):
                    self.structure_name = value
                    self.structure_name.value_namespace = name_space
                    self.structure_name.value_namespace_prefix = name_space_prefix


        class EdmMemoryInfo(Entity):
            """
            Memory Info
            
            .. attribute:: failure
            
            	Cache\-hit failure
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: size
            
            	Size of the block
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: success
            
            	Cache\-hit success
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total
            
            	Total request
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Memory.EdmMemoryInfo, self).__init__()

                self.yang_name = "edm-memory-info"
                self.yang_parent_name = "memory"

                self.failure = YLeaf(YType.uint32, "failure")

                self.size = YLeaf(YType.uint32, "size")

                self.success = YLeaf(YType.uint32, "success")

                self.total = YLeaf(YType.uint32, "total")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("failure",
                                "size",
                                "success",
                                "total") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Memory.EdmMemoryInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Memory.EdmMemoryInfo, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.failure.is_set or
                    self.size.is_set or
                    self.success.is_set or
                    self.total.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.failure.yfilter != YFilter.not_set or
                    self.size.yfilter != YFilter.not_set or
                    self.success.yfilter != YFilter.not_set or
                    self.total.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "edm-memory-info" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/memory/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.failure.is_set or self.failure.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.failure.get_name_leafdata())
                if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.size.get_name_leafdata())
                if (self.success.is_set or self.success.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.success.get_name_leafdata())
                if (self.total.is_set or self.total.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "failure" or name == "size" or name == "success" or name == "total"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "failure"):
                    self.failure = value
                    self.failure.value_namespace = name_space
                    self.failure.value_namespace_prefix = name_space_prefix
                if(value_path == "size"):
                    self.size = value
                    self.size.value_namespace = name_space
                    self.size.value_namespace_prefix = name_space_prefix
                if(value_path == "success"):
                    self.success = value
                    self.success.value_namespace = name_space
                    self.success.value_namespace_prefix = name_space_prefix
                if(value_path == "total"):
                    self.total = value
                    self.total.value_namespace = name_space
                    self.total.value_namespace_prefix = name_space_prefix


        class StringMemoryInfo(Entity):
            """
            Memory Info
            
            .. attribute:: failure
            
            	Cache\-hit failure
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: size
            
            	Size of the block
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: success
            
            	Cache\-hit success
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: total
            
            	Total request
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Memory.StringMemoryInfo, self).__init__()

                self.yang_name = "string-memory-info"
                self.yang_parent_name = "memory"

                self.failure = YLeaf(YType.uint32, "failure")

                self.size = YLeaf(YType.uint32, "size")

                self.success = YLeaf(YType.uint32, "success")

                self.total = YLeaf(YType.uint32, "total")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("failure",
                                "size",
                                "success",
                                "total") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Memory.StringMemoryInfo, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Memory.StringMemoryInfo, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.failure.is_set or
                    self.size.is_set or
                    self.success.is_set or
                    self.total.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.failure.yfilter != YFilter.not_set or
                    self.size.yfilter != YFilter.not_set or
                    self.success.yfilter != YFilter.not_set or
                    self.total.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "string-memory-info" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/memory/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.failure.is_set or self.failure.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.failure.get_name_leafdata())
                if (self.size.is_set or self.size.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.size.get_name_leafdata())
                if (self.success.is_set or self.success.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.success.get_name_leafdata())
                if (self.total.is_set or self.total.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.total.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "failure" or name == "size" or name == "success" or name == "total"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "failure"):
                    self.failure = value
                    self.failure.value_namespace = name_space
                    self.failure.value_namespace_prefix = name_space_prefix
                if(value_path == "size"):
                    self.size = value
                    self.size.value_namespace = name_space
                    self.size.value_namespace_prefix = name_space_prefix
                if(value_path == "success"):
                    self.success = value
                    self.success.value_namespace = name_space
                    self.success.value_namespace_prefix = name_space_prefix
                if(value_path == "total"):
                    self.total = value
                    self.total.value_namespace = name_space
                    self.total.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.edm_memory_info:
                if (c.has_data()):
                    return True
            for c in self.memory_info:
                if (c.has_data()):
                    return True
            for c in self.string_memory_info:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.edm_memory_info:
                if (c.has_operation()):
                    return True
            for c in self.memory_info:
                if (c.has_operation()):
                    return True
            for c in self.string_memory_info:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "memory" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "edm-memory-info"):
                for c in self.edm_memory_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Rcmd.Memory.EdmMemoryInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.edm_memory_info.append(c)
                return c

            if (child_yang_name == "memory-info"):
                for c in self.memory_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Rcmd.Memory.MemoryInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.memory_info.append(c)
                return c

            if (child_yang_name == "string-memory-info"):
                for c in self.string_memory_info:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = Rcmd.Memory.StringMemoryInfo()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.string_memory_info.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "edm-memory-info" or name == "memory-info" or name == "string-memory-info"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ldp(Entity):
        """
        LDP data
        
        .. attribute:: remote_lfa_s
        
        	Remote LFA Coverage Events
        	**type**\:   :py:class:`RemoteLfaS <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaS>`
        
        .. attribute:: remote_lfa_summaries
        
        	Remote LFA Coverage Events
        	**type**\:   :py:class:`RemoteLfaSummaries <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaSummaries>`
        
        .. attribute:: sessions
        
        	Session Events
        	**type**\:   :py:class:`Sessions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.Sessions>`
        
        

        """

        _prefix = 'infra-rcmd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Rcmd.Ldp, self).__init__()

            self.yang_name = "ldp"
            self.yang_parent_name = "rcmd"

            self.remote_lfa_s = Rcmd.Ldp.RemoteLfaS()
            self.remote_lfa_s.parent = self
            self._children_name_map["remote_lfa_s"] = "remote-lfa-s"
            self._children_yang_names.add("remote-lfa-s")

            self.remote_lfa_summaries = Rcmd.Ldp.RemoteLfaSummaries()
            self.remote_lfa_summaries.parent = self
            self._children_name_map["remote_lfa_summaries"] = "remote-lfa-summaries"
            self._children_yang_names.add("remote-lfa-summaries")

            self.sessions = Rcmd.Ldp.Sessions()
            self.sessions.parent = self
            self._children_name_map["sessions"] = "sessions"
            self._children_yang_names.add("sessions")


        class Sessions(Entity):
            """
            Session Events
            
            .. attribute:: session
            
            	Session
            	**type**\: list of    :py:class:`Session <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.Sessions.Session>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Ldp.Sessions, self).__init__()

                self.yang_name = "sessions"
                self.yang_parent_name = "ldp"

                self.session = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Ldp.Sessions, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Ldp.Sessions, self).__setattr__(name, value)


            class Session(Entity):
                """
                Session
                
                .. attribute:: event_id  <key>
                
                	Specific Event ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: address
                
                	transport address or adjacency address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: event_id_xr
                
                	Event ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: event_time
                
                	Event Time
                	**type**\:  str
                
                .. attribute:: event_type
                
                	Type of event
                	**type**\:   :py:class:`RcmdLdpEvent <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdLdpEvent>`
                
                .. attribute:: interface_name
                
                	Interface Name
                	**type**\:  str
                
                .. attribute:: lsr_id
                
                	Label Space Router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: state
                
                	Adjacency Session Status
                	**type**\:   :py:class:`RcmdShowLdpNeighbourStatus <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowLdpNeighbourStatus>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Ldp.Sessions.Session, self).__init__()

                    self.yang_name = "session"
                    self.yang_parent_name = "sessions"

                    self.event_id = YLeaf(YType.int32, "event-id")

                    self.address = YLeaf(YType.str, "address")

                    self.event_id_xr = YLeaf(YType.uint32, "event-id-xr")

                    self.event_time = YLeaf(YType.str, "event-time")

                    self.event_type = YLeaf(YType.enumeration, "event-type")

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.lsr_id = YLeaf(YType.str, "lsr-id")

                    self.state = YLeaf(YType.enumeration, "state")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("event_id",
                                    "address",
                                    "event_id_xr",
                                    "event_time",
                                    "event_type",
                                    "interface_name",
                                    "lsr_id",
                                    "state") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Ldp.Sessions.Session, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Ldp.Sessions.Session, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.event_id.is_set or
                        self.address.is_set or
                        self.event_id_xr.is_set or
                        self.event_time.is_set or
                        self.event_type.is_set or
                        self.interface_name.is_set or
                        self.lsr_id.is_set or
                        self.state.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.event_id.yfilter != YFilter.not_set or
                        self.address.yfilter != YFilter.not_set or
                        self.event_id_xr.yfilter != YFilter.not_set or
                        self.event_time.yfilter != YFilter.not_set or
                        self.event_type.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.lsr_id.yfilter != YFilter.not_set or
                        self.state.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "session" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/ldp/sessions/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_id.get_name_leafdata())
                    if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.address.get_name_leafdata())
                    if (self.event_id_xr.is_set or self.event_id_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_id_xr.get_name_leafdata())
                    if (self.event_time.is_set or self.event_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_time.get_name_leafdata())
                    if (self.event_type.is_set or self.event_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_type.get_name_leafdata())
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.lsr_id.is_set or self.lsr_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsr_id.get_name_leafdata())
                    if (self.state.is_set or self.state.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.state.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "event-id" or name == "address" or name == "event-id-xr" or name == "event-time" or name == "event-type" or name == "interface-name" or name == "lsr-id" or name == "state"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "event-id"):
                        self.event_id = value
                        self.event_id.value_namespace = name_space
                        self.event_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "address"):
                        self.address = value
                        self.address.value_namespace = name_space
                        self.address.value_namespace_prefix = name_space_prefix
                    if(value_path == "event-id-xr"):
                        self.event_id_xr = value
                        self.event_id_xr.value_namespace = name_space
                        self.event_id_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "event-time"):
                        self.event_time = value
                        self.event_time.value_namespace = name_space
                        self.event_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "event-type"):
                        self.event_type = value
                        self.event_type.value_namespace = name_space
                        self.event_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsr-id"):
                        self.lsr_id = value
                        self.lsr_id.value_namespace = name_space
                        self.lsr_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "state"):
                        self.state = value
                        self.state.value_namespace = name_space
                        self.state.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.session:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.session:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "sessions" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/ldp/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "session"):
                    for c in self.session:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Ldp.Sessions.Session()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.session.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "session"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class RemoteLfaS(Entity):
            """
            Remote LFA Coverage Events
            
            .. attribute:: remote_lfa
            
            	RemoteLFA
            	**type**\: list of    :py:class:`RemoteLfa <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaS.RemoteLfa>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Ldp.RemoteLfaS, self).__init__()

                self.yang_name = "remote-lfa-s"
                self.yang_parent_name = "ldp"

                self.remote_lfa = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Ldp.RemoteLfaS, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Ldp.RemoteLfaS, self).__setattr__(name, value)


            class RemoteLfa(Entity):
                """
                RemoteLFA
                
                .. attribute:: event_id  <key>
                
                	Specific Event ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: below_threshold
                
                	Coverage Below Threshold
                	**type**\:  bool
                
                .. attribute:: end_of_calculation_time
                
                	End of IGP LFA Calculation Time (eg\: Apr 24 13 \:16\:04.961)
                	**type**\:  str
                
                .. attribute:: event_id_xr
                
                	LDP\-rLFA Event ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: igp_protocol
                
                	IGP Protocol
                	**type**\:   :py:class:`RcmdProtocolId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdProtocolId>`
                
                .. attribute:: ipfrr_event_id
                
                	IGP IP\-FRR Event ID (ref\: rcmd\_show\_ipfrr\_event\_info(EventID))
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: logs
                
                	Logs Information
                	**type**\: list of    :py:class:`Logs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaS.RemoteLfa.Logs>`
                
                .. attribute:: process_name
                
                	Process Name
                	**type**\:  str
                
                .. attribute:: remote_node
                
                	Remote Node Information
                	**type**\: list of    :py:class:`RemoteNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaS.RemoteLfa.RemoteNode>`
                
                .. attribute:: session_statistic
                
                	RLFA Statistics categorized by session state
                	**type**\: list of    :py:class:`SessionStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaS.RemoteLfa.SessionStatistic>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Ldp.RemoteLfaS.RemoteLfa, self).__init__()

                    self.yang_name = "remote-lfa"
                    self.yang_parent_name = "remote-lfa-s"

                    self.event_id = YLeaf(YType.int32, "event-id")

                    self.below_threshold = YLeaf(YType.boolean, "below-threshold")

                    self.end_of_calculation_time = YLeaf(YType.str, "end-of-calculation-time")

                    self.event_id_xr = YLeaf(YType.uint32, "event-id-xr")

                    self.igp_protocol = YLeaf(YType.enumeration, "igp-protocol")

                    self.ipfrr_event_id = YLeaf(YType.uint32, "ipfrr-event-id")

                    self.process_name = YLeaf(YType.str, "process-name")

                    self.logs = YList(self)
                    self.remote_node = YList(self)
                    self.session_statistic = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("event_id",
                                    "below_threshold",
                                    "end_of_calculation_time",
                                    "event_id_xr",
                                    "igp_protocol",
                                    "ipfrr_event_id",
                                    "process_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Ldp.RemoteLfaS.RemoteLfa, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Ldp.RemoteLfaS.RemoteLfa, self).__setattr__(name, value)


                class SessionStatistic(Entity):
                    """
                    RLFA Statistics categorized by session state
                    
                    .. attribute:: path_count
                    
                    	Total Path Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: protected_path_count
                    
                    	Protected Path Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: protected_route_count
                    
                    	Protected Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: remote_label_count
                    
                    	Remote Label Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: route_count
                    
                    	Total Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_count
                    
                    	LDP Session Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_state
                    
                    	Session State
                    	**type**\:   :py:class:`RcmdShowLdpSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowLdpSessionState>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ldp.RemoteLfaS.RemoteLfa.SessionStatistic, self).__init__()

                        self.yang_name = "session-statistic"
                        self.yang_parent_name = "remote-lfa"

                        self.path_count = YLeaf(YType.uint32, "path-count")

                        self.protected_path_count = YLeaf(YType.uint32, "protected-path-count")

                        self.protected_route_count = YLeaf(YType.uint32, "protected-route-count")

                        self.remote_label_count = YLeaf(YType.uint32, "remote-label-count")

                        self.route_count = YLeaf(YType.uint32, "route-count")

                        self.session_count = YLeaf(YType.uint32, "session-count")

                        self.session_state = YLeaf(YType.enumeration, "session-state")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("path_count",
                                        "protected_path_count",
                                        "protected_route_count",
                                        "remote_label_count",
                                        "route_count",
                                        "session_count",
                                        "session_state") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ldp.RemoteLfaS.RemoteLfa.SessionStatistic, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ldp.RemoteLfaS.RemoteLfa.SessionStatistic, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.path_count.is_set or
                            self.protected_path_count.is_set or
                            self.protected_route_count.is_set or
                            self.remote_label_count.is_set or
                            self.route_count.is_set or
                            self.session_count.is_set or
                            self.session_state.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.path_count.yfilter != YFilter.not_set or
                            self.protected_path_count.yfilter != YFilter.not_set or
                            self.protected_route_count.yfilter != YFilter.not_set or
                            self.remote_label_count.yfilter != YFilter.not_set or
                            self.route_count.yfilter != YFilter.not_set or
                            self.session_count.yfilter != YFilter.not_set or
                            self.session_state.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-statistic" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.path_count.is_set or self.path_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.path_count.get_name_leafdata())
                        if (self.protected_path_count.is_set or self.protected_path_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protected_path_count.get_name_leafdata())
                        if (self.protected_route_count.is_set or self.protected_route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protected_route_count.get_name_leafdata())
                        if (self.remote_label_count.is_set or self.remote_label_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_label_count.get_name_leafdata())
                        if (self.route_count.is_set or self.route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_count.get_name_leafdata())
                        if (self.session_count.is_set or self.session_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_count.get_name_leafdata())
                        if (self.session_state.is_set or self.session_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_state.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "path-count" or name == "protected-path-count" or name == "protected-route-count" or name == "remote-label-count" or name == "route-count" or name == "session-count" or name == "session-state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "path-count"):
                            self.path_count = value
                            self.path_count.value_namespace = name_space
                            self.path_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "protected-path-count"):
                            self.protected_path_count = value
                            self.protected_path_count.value_namespace = name_space
                            self.protected_path_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "protected-route-count"):
                            self.protected_route_count = value
                            self.protected_route_count.value_namespace = name_space
                            self.protected_route_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-label-count"):
                            self.remote_label_count = value
                            self.remote_label_count.value_namespace = name_space
                            self.remote_label_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-count"):
                            self.route_count = value
                            self.route_count.value_namespace = name_space
                            self.route_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-count"):
                            self.session_count = value
                            self.session_count.value_namespace = name_space
                            self.session_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-state"):
                            self.session_state = value
                            self.session_state.value_namespace = name_space
                            self.session_state.value_namespace_prefix = name_space_prefix


                class RemoteNode(Entity):
                    """
                    Remote Node Information
                    
                    .. attribute:: in_use_time
                    
                    	Inuse time of the Session
                    	**type**\:  str
                    
                    .. attribute:: lsr_id
                    
                    	Label Space Router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: path_count
                    
                    	Total Path Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: protected_path_count
                    
                    	Protected Path Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: protected_route_count
                    
                    	Protected Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: remote_label_count
                    
                    	Remote Label Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: remote_node_id
                    
                    	Remote Node ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: route_count
                    
                    	Total Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_state
                    
                    	Session State
                    	**type**\:   :py:class:`RcmdShowLdpSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowLdpSessionState>`
                    
                    .. attribute:: transport_address
                    
                    	Transport Address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ldp.RemoteLfaS.RemoteLfa.RemoteNode, self).__init__()

                        self.yang_name = "remote-node"
                        self.yang_parent_name = "remote-lfa"

                        self.in_use_time = YLeaf(YType.str, "in-use-time")

                        self.lsr_id = YLeaf(YType.str, "lsr-id")

                        self.path_count = YLeaf(YType.uint32, "path-count")

                        self.protected_path_count = YLeaf(YType.uint32, "protected-path-count")

                        self.protected_route_count = YLeaf(YType.uint32, "protected-route-count")

                        self.remote_label_count = YLeaf(YType.uint32, "remote-label-count")

                        self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                        self.route_count = YLeaf(YType.uint32, "route-count")

                        self.session_state = YLeaf(YType.enumeration, "session-state")

                        self.transport_address = YLeaf(YType.str, "transport-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("in_use_time",
                                        "lsr_id",
                                        "path_count",
                                        "protected_path_count",
                                        "protected_route_count",
                                        "remote_label_count",
                                        "remote_node_id",
                                        "route_count",
                                        "session_state",
                                        "transport_address") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ldp.RemoteLfaS.RemoteLfa.RemoteNode, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ldp.RemoteLfaS.RemoteLfa.RemoteNode, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.in_use_time.is_set or
                            self.lsr_id.is_set or
                            self.path_count.is_set or
                            self.protected_path_count.is_set or
                            self.protected_route_count.is_set or
                            self.remote_label_count.is_set or
                            self.remote_node_id.is_set or
                            self.route_count.is_set or
                            self.session_state.is_set or
                            self.transport_address.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.in_use_time.yfilter != YFilter.not_set or
                            self.lsr_id.yfilter != YFilter.not_set or
                            self.path_count.yfilter != YFilter.not_set or
                            self.protected_path_count.yfilter != YFilter.not_set or
                            self.protected_route_count.yfilter != YFilter.not_set or
                            self.remote_label_count.yfilter != YFilter.not_set or
                            self.remote_node_id.yfilter != YFilter.not_set or
                            self.route_count.yfilter != YFilter.not_set or
                            self.session_state.yfilter != YFilter.not_set or
                            self.transport_address.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote-node" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.in_use_time.is_set or self.in_use_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_use_time.get_name_leafdata())
                        if (self.lsr_id.is_set or self.lsr_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsr_id.get_name_leafdata())
                        if (self.path_count.is_set or self.path_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.path_count.get_name_leafdata())
                        if (self.protected_path_count.is_set or self.protected_path_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protected_path_count.get_name_leafdata())
                        if (self.protected_route_count.is_set or self.protected_route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protected_route_count.get_name_leafdata())
                        if (self.remote_label_count.is_set or self.remote_label_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_label_count.get_name_leafdata())
                        if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_node_id.get_name_leafdata())
                        if (self.route_count.is_set or self.route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_count.get_name_leafdata())
                        if (self.session_state.is_set or self.session_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_state.get_name_leafdata())
                        if (self.transport_address.is_set or self.transport_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.transport_address.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "in-use-time" or name == "lsr-id" or name == "path-count" or name == "protected-path-count" or name == "protected-route-count" or name == "remote-label-count" or name == "remote-node-id" or name == "route-count" or name == "session-state" or name == "transport-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "in-use-time"):
                            self.in_use_time = value
                            self.in_use_time.value_namespace = name_space
                            self.in_use_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsr-id"):
                            self.lsr_id = value
                            self.lsr_id.value_namespace = name_space
                            self.lsr_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "path-count"):
                            self.path_count = value
                            self.path_count.value_namespace = name_space
                            self.path_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "protected-path-count"):
                            self.protected_path_count = value
                            self.protected_path_count.value_namespace = name_space
                            self.protected_path_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "protected-route-count"):
                            self.protected_route_count = value
                            self.protected_route_count.value_namespace = name_space
                            self.protected_route_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-label-count"):
                            self.remote_label_count = value
                            self.remote_label_count.value_namespace = name_space
                            self.remote_label_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-node-id"):
                            self.remote_node_id = value
                            self.remote_node_id.value_namespace = name_space
                            self.remote_node_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-count"):
                            self.route_count = value
                            self.route_count.value_namespace = name_space
                            self.route_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-state"):
                            self.session_state = value
                            self.session_state.value_namespace = name_space
                            self.session_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "transport-address"):
                            self.transport_address = value
                            self.transport_address.value_namespace = name_space
                            self.transport_address.value_namespace_prefix = name_space_prefix


                class Logs(Entity):
                    """
                    Logs Information
                    
                    .. attribute:: label_coverage_state
                    
                    	Label Coverage State
                    	**type**\:   :py:class:`RcmdShowLdpConvState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowLdpConvState>`
                    
                    .. attribute:: log_time
                    
                    	Event Time (eg\: Apr 24 13\:16\:04.961)
                    	**type**\:  str
                    
                    .. attribute:: remote_label_count
                    
                    	Remote Label Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: route_count
                    
                    	Total Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ldp.RemoteLfaS.RemoteLfa.Logs, self).__init__()

                        self.yang_name = "logs"
                        self.yang_parent_name = "remote-lfa"

                        self.label_coverage_state = YLeaf(YType.enumeration, "label-coverage-state")

                        self.log_time = YLeaf(YType.str, "log-time")

                        self.remote_label_count = YLeaf(YType.uint32, "remote-label-count")

                        self.route_count = YLeaf(YType.uint32, "route-count")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("label_coverage_state",
                                        "log_time",
                                        "remote_label_count",
                                        "route_count") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ldp.RemoteLfaS.RemoteLfa.Logs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ldp.RemoteLfaS.RemoteLfa.Logs, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.label_coverage_state.is_set or
                            self.log_time.is_set or
                            self.remote_label_count.is_set or
                            self.route_count.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.label_coverage_state.yfilter != YFilter.not_set or
                            self.log_time.yfilter != YFilter.not_set or
                            self.remote_label_count.yfilter != YFilter.not_set or
                            self.route_count.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "logs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.label_coverage_state.is_set or self.label_coverage_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_coverage_state.get_name_leafdata())
                        if (self.log_time.is_set or self.log_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.log_time.get_name_leafdata())
                        if (self.remote_label_count.is_set or self.remote_label_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_label_count.get_name_leafdata())
                        if (self.route_count.is_set or self.route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_count.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "label-coverage-state" or name == "log-time" or name == "remote-label-count" or name == "route-count"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "label-coverage-state"):
                            self.label_coverage_state = value
                            self.label_coverage_state.value_namespace = name_space
                            self.label_coverage_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "log-time"):
                            self.log_time = value
                            self.log_time.value_namespace = name_space
                            self.log_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-label-count"):
                            self.remote_label_count = value
                            self.remote_label_count.value_namespace = name_space
                            self.remote_label_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-count"):
                            self.route_count = value
                            self.route_count.value_namespace = name_space
                            self.route_count.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.logs:
                        if (c.has_data()):
                            return True
                    for c in self.remote_node:
                        if (c.has_data()):
                            return True
                    for c in self.session_statistic:
                        if (c.has_data()):
                            return True
                    return (
                        self.event_id.is_set or
                        self.below_threshold.is_set or
                        self.end_of_calculation_time.is_set or
                        self.event_id_xr.is_set or
                        self.igp_protocol.is_set or
                        self.ipfrr_event_id.is_set or
                        self.process_name.is_set)

                def has_operation(self):
                    for c in self.logs:
                        if (c.has_operation()):
                            return True
                    for c in self.remote_node:
                        if (c.has_operation()):
                            return True
                    for c in self.session_statistic:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.event_id.yfilter != YFilter.not_set or
                        self.below_threshold.yfilter != YFilter.not_set or
                        self.end_of_calculation_time.yfilter != YFilter.not_set or
                        self.event_id_xr.yfilter != YFilter.not_set or
                        self.igp_protocol.yfilter != YFilter.not_set or
                        self.ipfrr_event_id.yfilter != YFilter.not_set or
                        self.process_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "remote-lfa" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/ldp/remote-lfa-s/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_id.get_name_leafdata())
                    if (self.below_threshold.is_set or self.below_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.below_threshold.get_name_leafdata())
                    if (self.end_of_calculation_time.is_set or self.end_of_calculation_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.end_of_calculation_time.get_name_leafdata())
                    if (self.event_id_xr.is_set or self.event_id_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_id_xr.get_name_leafdata())
                    if (self.igp_protocol.is_set or self.igp_protocol.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.igp_protocol.get_name_leafdata())
                    if (self.ipfrr_event_id.is_set or self.ipfrr_event_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipfrr_event_id.get_name_leafdata())
                    if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.process_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "logs"):
                        for c in self.logs:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Ldp.RemoteLfaS.RemoteLfa.Logs()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.logs.append(c)
                        return c

                    if (child_yang_name == "remote-node"):
                        for c in self.remote_node:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Ldp.RemoteLfaS.RemoteLfa.RemoteNode()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.remote_node.append(c)
                        return c

                    if (child_yang_name == "session-statistic"):
                        for c in self.session_statistic:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Ldp.RemoteLfaS.RemoteLfa.SessionStatistic()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.session_statistic.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "logs" or name == "remote-node" or name == "session-statistic" or name == "event-id" or name == "below-threshold" or name == "end-of-calculation-time" or name == "event-id-xr" or name == "igp-protocol" or name == "ipfrr-event-id" or name == "process-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "event-id"):
                        self.event_id = value
                        self.event_id.value_namespace = name_space
                        self.event_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "below-threshold"):
                        self.below_threshold = value
                        self.below_threshold.value_namespace = name_space
                        self.below_threshold.value_namespace_prefix = name_space_prefix
                    if(value_path == "end-of-calculation-time"):
                        self.end_of_calculation_time = value
                        self.end_of_calculation_time.value_namespace = name_space
                        self.end_of_calculation_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "event-id-xr"):
                        self.event_id_xr = value
                        self.event_id_xr.value_namespace = name_space
                        self.event_id_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "igp-protocol"):
                        self.igp_protocol = value
                        self.igp_protocol.value_namespace = name_space
                        self.igp_protocol.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipfrr-event-id"):
                        self.ipfrr_event_id = value
                        self.ipfrr_event_id.value_namespace = name_space
                        self.ipfrr_event_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "process-name"):
                        self.process_name = value
                        self.process_name.value_namespace = name_space
                        self.process_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.remote_lfa:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.remote_lfa:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "remote-lfa-s" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/ldp/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "remote-lfa"):
                    for c in self.remote_lfa:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Ldp.RemoteLfaS.RemoteLfa()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.remote_lfa.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "remote-lfa"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class RemoteLfaSummaries(Entity):
            """
            Remote LFA Coverage Events
            
            .. attribute:: remote_lfa_summary
            
            	Summary operational data for Remote LFA
            	**type**\: list of    :py:class:`RemoteLfaSummary <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Ldp.RemoteLfaSummaries, self).__init__()

                self.yang_name = "remote-lfa-summaries"
                self.yang_parent_name = "ldp"

                self.remote_lfa_summary = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Ldp.RemoteLfaSummaries, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Ldp.RemoteLfaSummaries, self).__setattr__(name, value)


            class RemoteLfaSummary(Entity):
                """
                Summary operational data for Remote LFA
                
                .. attribute:: event_id  <key>
                
                	Specific Event ID
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: below_threshold
                
                	Coverage Below Threshold
                	**type**\:  bool
                
                .. attribute:: end_of_calculation_time
                
                	End of IGP LFA Calculation Time (eg\: Apr 24 13 \:16\:04.961)
                	**type**\:  str
                
                .. attribute:: event_id_xr
                
                	LDP\-rLFA Event ID
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: igp_protocol
                
                	IGP Protocol
                	**type**\:   :py:class:`RcmdProtocolId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdProtocolId>`
                
                .. attribute:: ipfrr_event_id
                
                	IGP IP\-FRR Event ID (ref\: rcmd\_show\_ipfrr\_event\_info(EventID))
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                .. attribute:: logs
                
                	Logs Information
                	**type**\: list of    :py:class:`Logs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.Logs>`
                
                .. attribute:: process_name
                
                	Process Name
                	**type**\:  str
                
                .. attribute:: remote_node
                
                	Remote Node Information
                	**type**\: list of    :py:class:`RemoteNode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.RemoteNode>`
                
                .. attribute:: session_statistic
                
                	RLFA Statistics categorized by session state
                	**type**\: list of    :py:class:`SessionStatistic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.SessionStatistic>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary, self).__init__()

                    self.yang_name = "remote-lfa-summary"
                    self.yang_parent_name = "remote-lfa-summaries"

                    self.event_id = YLeaf(YType.int32, "event-id")

                    self.below_threshold = YLeaf(YType.boolean, "below-threshold")

                    self.end_of_calculation_time = YLeaf(YType.str, "end-of-calculation-time")

                    self.event_id_xr = YLeaf(YType.uint32, "event-id-xr")

                    self.igp_protocol = YLeaf(YType.enumeration, "igp-protocol")

                    self.ipfrr_event_id = YLeaf(YType.uint32, "ipfrr-event-id")

                    self.process_name = YLeaf(YType.str, "process-name")

                    self.logs = YList(self)
                    self.remote_node = YList(self)
                    self.session_statistic = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("event_id",
                                    "below_threshold",
                                    "end_of_calculation_time",
                                    "event_id_xr",
                                    "igp_protocol",
                                    "ipfrr_event_id",
                                    "process_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary, self).__setattr__(name, value)


                class SessionStatistic(Entity):
                    """
                    RLFA Statistics categorized by session state
                    
                    .. attribute:: path_count
                    
                    	Total Path Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: protected_path_count
                    
                    	Protected Path Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: protected_route_count
                    
                    	Protected Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: remote_label_count
                    
                    	Remote Label Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: route_count
                    
                    	Total Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_count
                    
                    	LDP Session Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_state
                    
                    	Session State
                    	**type**\:   :py:class:`RcmdShowLdpSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowLdpSessionState>`
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.SessionStatistic, self).__init__()

                        self.yang_name = "session-statistic"
                        self.yang_parent_name = "remote-lfa-summary"

                        self.path_count = YLeaf(YType.uint32, "path-count")

                        self.protected_path_count = YLeaf(YType.uint32, "protected-path-count")

                        self.protected_route_count = YLeaf(YType.uint32, "protected-route-count")

                        self.remote_label_count = YLeaf(YType.uint32, "remote-label-count")

                        self.route_count = YLeaf(YType.uint32, "route-count")

                        self.session_count = YLeaf(YType.uint32, "session-count")

                        self.session_state = YLeaf(YType.enumeration, "session-state")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("path_count",
                                        "protected_path_count",
                                        "protected_route_count",
                                        "remote_label_count",
                                        "route_count",
                                        "session_count",
                                        "session_state") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.SessionStatistic, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.SessionStatistic, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.path_count.is_set or
                            self.protected_path_count.is_set or
                            self.protected_route_count.is_set or
                            self.remote_label_count.is_set or
                            self.route_count.is_set or
                            self.session_count.is_set or
                            self.session_state.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.path_count.yfilter != YFilter.not_set or
                            self.protected_path_count.yfilter != YFilter.not_set or
                            self.protected_route_count.yfilter != YFilter.not_set or
                            self.remote_label_count.yfilter != YFilter.not_set or
                            self.route_count.yfilter != YFilter.not_set or
                            self.session_count.yfilter != YFilter.not_set or
                            self.session_state.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "session-statistic" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.path_count.is_set or self.path_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.path_count.get_name_leafdata())
                        if (self.protected_path_count.is_set or self.protected_path_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protected_path_count.get_name_leafdata())
                        if (self.protected_route_count.is_set or self.protected_route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protected_route_count.get_name_leafdata())
                        if (self.remote_label_count.is_set or self.remote_label_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_label_count.get_name_leafdata())
                        if (self.route_count.is_set or self.route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_count.get_name_leafdata())
                        if (self.session_count.is_set or self.session_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_count.get_name_leafdata())
                        if (self.session_state.is_set or self.session_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_state.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "path-count" or name == "protected-path-count" or name == "protected-route-count" or name == "remote-label-count" or name == "route-count" or name == "session-count" or name == "session-state"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "path-count"):
                            self.path_count = value
                            self.path_count.value_namespace = name_space
                            self.path_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "protected-path-count"):
                            self.protected_path_count = value
                            self.protected_path_count.value_namespace = name_space
                            self.protected_path_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "protected-route-count"):
                            self.protected_route_count = value
                            self.protected_route_count.value_namespace = name_space
                            self.protected_route_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-label-count"):
                            self.remote_label_count = value
                            self.remote_label_count.value_namespace = name_space
                            self.remote_label_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-count"):
                            self.route_count = value
                            self.route_count.value_namespace = name_space
                            self.route_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-count"):
                            self.session_count = value
                            self.session_count.value_namespace = name_space
                            self.session_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-state"):
                            self.session_state = value
                            self.session_state.value_namespace = name_space
                            self.session_state.value_namespace_prefix = name_space_prefix


                class RemoteNode(Entity):
                    """
                    Remote Node Information
                    
                    .. attribute:: in_use_time
                    
                    	Inuse time of the Session
                    	**type**\:  str
                    
                    .. attribute:: lsr_id
                    
                    	Label Space Router ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: path_count
                    
                    	Total Path Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: protected_path_count
                    
                    	Protected Path Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: protected_route_count
                    
                    	Protected Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: remote_label_count
                    
                    	Remote Label Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: remote_node_id
                    
                    	Remote Node ID
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: route_count
                    
                    	Total Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: session_state
                    
                    	Session State
                    	**type**\:   :py:class:`RcmdShowLdpSessionState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowLdpSessionState>`
                    
                    .. attribute:: transport_address
                    
                    	Transport Address
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.RemoteNode, self).__init__()

                        self.yang_name = "remote-node"
                        self.yang_parent_name = "remote-lfa-summary"

                        self.in_use_time = YLeaf(YType.str, "in-use-time")

                        self.lsr_id = YLeaf(YType.str, "lsr-id")

                        self.path_count = YLeaf(YType.uint32, "path-count")

                        self.protected_path_count = YLeaf(YType.uint32, "protected-path-count")

                        self.protected_route_count = YLeaf(YType.uint32, "protected-route-count")

                        self.remote_label_count = YLeaf(YType.uint32, "remote-label-count")

                        self.remote_node_id = YLeaf(YType.str, "remote-node-id")

                        self.route_count = YLeaf(YType.uint32, "route-count")

                        self.session_state = YLeaf(YType.enumeration, "session-state")

                        self.transport_address = YLeaf(YType.str, "transport-address")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("in_use_time",
                                        "lsr_id",
                                        "path_count",
                                        "protected_path_count",
                                        "protected_route_count",
                                        "remote_label_count",
                                        "remote_node_id",
                                        "route_count",
                                        "session_state",
                                        "transport_address") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.RemoteNode, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.RemoteNode, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.in_use_time.is_set or
                            self.lsr_id.is_set or
                            self.path_count.is_set or
                            self.protected_path_count.is_set or
                            self.protected_route_count.is_set or
                            self.remote_label_count.is_set or
                            self.remote_node_id.is_set or
                            self.route_count.is_set or
                            self.session_state.is_set or
                            self.transport_address.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.in_use_time.yfilter != YFilter.not_set or
                            self.lsr_id.yfilter != YFilter.not_set or
                            self.path_count.yfilter != YFilter.not_set or
                            self.protected_path_count.yfilter != YFilter.not_set or
                            self.protected_route_count.yfilter != YFilter.not_set or
                            self.remote_label_count.yfilter != YFilter.not_set or
                            self.remote_node_id.yfilter != YFilter.not_set or
                            self.route_count.yfilter != YFilter.not_set or
                            self.session_state.yfilter != YFilter.not_set or
                            self.transport_address.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "remote-node" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.in_use_time.is_set or self.in_use_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.in_use_time.get_name_leafdata())
                        if (self.lsr_id.is_set or self.lsr_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsr_id.get_name_leafdata())
                        if (self.path_count.is_set or self.path_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.path_count.get_name_leafdata())
                        if (self.protected_path_count.is_set or self.protected_path_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protected_path_count.get_name_leafdata())
                        if (self.protected_route_count.is_set or self.protected_route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.protected_route_count.get_name_leafdata())
                        if (self.remote_label_count.is_set or self.remote_label_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_label_count.get_name_leafdata())
                        if (self.remote_node_id.is_set or self.remote_node_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_node_id.get_name_leafdata())
                        if (self.route_count.is_set or self.route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_count.get_name_leafdata())
                        if (self.session_state.is_set or self.session_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.session_state.get_name_leafdata())
                        if (self.transport_address.is_set or self.transport_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.transport_address.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "in-use-time" or name == "lsr-id" or name == "path-count" or name == "protected-path-count" or name == "protected-route-count" or name == "remote-label-count" or name == "remote-node-id" or name == "route-count" or name == "session-state" or name == "transport-address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "in-use-time"):
                            self.in_use_time = value
                            self.in_use_time.value_namespace = name_space
                            self.in_use_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsr-id"):
                            self.lsr_id = value
                            self.lsr_id.value_namespace = name_space
                            self.lsr_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "path-count"):
                            self.path_count = value
                            self.path_count.value_namespace = name_space
                            self.path_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "protected-path-count"):
                            self.protected_path_count = value
                            self.protected_path_count.value_namespace = name_space
                            self.protected_path_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "protected-route-count"):
                            self.protected_route_count = value
                            self.protected_route_count.value_namespace = name_space
                            self.protected_route_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-label-count"):
                            self.remote_label_count = value
                            self.remote_label_count.value_namespace = name_space
                            self.remote_label_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-node-id"):
                            self.remote_node_id = value
                            self.remote_node_id.value_namespace = name_space
                            self.remote_node_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-count"):
                            self.route_count = value
                            self.route_count.value_namespace = name_space
                            self.route_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "session-state"):
                            self.session_state = value
                            self.session_state.value_namespace = name_space
                            self.session_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "transport-address"):
                            self.transport_address = value
                            self.transport_address.value_namespace = name_space
                            self.transport_address.value_namespace_prefix = name_space_prefix


                class Logs(Entity):
                    """
                    Logs Information
                    
                    .. attribute:: label_coverage_state
                    
                    	Label Coverage State
                    	**type**\:   :py:class:`RcmdShowLdpConvState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowLdpConvState>`
                    
                    .. attribute:: log_time
                    
                    	Event Time (eg\: Apr 24 13\:16\:04.961)
                    	**type**\:  str
                    
                    .. attribute:: remote_label_count
                    
                    	Remote Label Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: route_count
                    
                    	Total Route Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.Logs, self).__init__()

                        self.yang_name = "logs"
                        self.yang_parent_name = "remote-lfa-summary"

                        self.label_coverage_state = YLeaf(YType.enumeration, "label-coverage-state")

                        self.log_time = YLeaf(YType.str, "log-time")

                        self.remote_label_count = YLeaf(YType.uint32, "remote-label-count")

                        self.route_count = YLeaf(YType.uint32, "route-count")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("label_coverage_state",
                                        "log_time",
                                        "remote_label_count",
                                        "route_count") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.Logs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.Logs, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.label_coverage_state.is_set or
                            self.log_time.is_set or
                            self.remote_label_count.is_set or
                            self.route_count.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.label_coverage_state.yfilter != YFilter.not_set or
                            self.log_time.yfilter != YFilter.not_set or
                            self.remote_label_count.yfilter != YFilter.not_set or
                            self.route_count.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "logs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.label_coverage_state.is_set or self.label_coverage_state.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.label_coverage_state.get_name_leafdata())
                        if (self.log_time.is_set or self.log_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.log_time.get_name_leafdata())
                        if (self.remote_label_count.is_set or self.remote_label_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.remote_label_count.get_name_leafdata())
                        if (self.route_count.is_set or self.route_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_count.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "label-coverage-state" or name == "log-time" or name == "remote-label-count" or name == "route-count"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "label-coverage-state"):
                            self.label_coverage_state = value
                            self.label_coverage_state.value_namespace = name_space
                            self.label_coverage_state.value_namespace_prefix = name_space_prefix
                        if(value_path == "log-time"):
                            self.log_time = value
                            self.log_time.value_namespace = name_space
                            self.log_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "remote-label-count"):
                            self.remote_label_count = value
                            self.remote_label_count.value_namespace = name_space
                            self.remote_label_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-count"):
                            self.route_count = value
                            self.route_count.value_namespace = name_space
                            self.route_count.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.logs:
                        if (c.has_data()):
                            return True
                    for c in self.remote_node:
                        if (c.has_data()):
                            return True
                    for c in self.session_statistic:
                        if (c.has_data()):
                            return True
                    return (
                        self.event_id.is_set or
                        self.below_threshold.is_set or
                        self.end_of_calculation_time.is_set or
                        self.event_id_xr.is_set or
                        self.igp_protocol.is_set or
                        self.ipfrr_event_id.is_set or
                        self.process_name.is_set)

                def has_operation(self):
                    for c in self.logs:
                        if (c.has_operation()):
                            return True
                    for c in self.remote_node:
                        if (c.has_operation()):
                            return True
                    for c in self.session_statistic:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.event_id.yfilter != YFilter.not_set or
                        self.below_threshold.yfilter != YFilter.not_set or
                        self.end_of_calculation_time.yfilter != YFilter.not_set or
                        self.event_id_xr.yfilter != YFilter.not_set or
                        self.igp_protocol.yfilter != YFilter.not_set or
                        self.ipfrr_event_id.yfilter != YFilter.not_set or
                        self.process_name.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "remote-lfa-summary" + "[event-id='" + self.event_id.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/ldp/remote-lfa-summaries/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.event_id.is_set or self.event_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_id.get_name_leafdata())
                    if (self.below_threshold.is_set or self.below_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.below_threshold.get_name_leafdata())
                    if (self.end_of_calculation_time.is_set or self.end_of_calculation_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.end_of_calculation_time.get_name_leafdata())
                    if (self.event_id_xr.is_set or self.event_id_xr.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_id_xr.get_name_leafdata())
                    if (self.igp_protocol.is_set or self.igp_protocol.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.igp_protocol.get_name_leafdata())
                    if (self.ipfrr_event_id.is_set or self.ipfrr_event_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ipfrr_event_id.get_name_leafdata())
                    if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.process_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "logs"):
                        for c in self.logs:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.Logs()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.logs.append(c)
                        return c

                    if (child_yang_name == "remote-node"):
                        for c in self.remote_node:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.RemoteNode()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.remote_node.append(c)
                        return c

                    if (child_yang_name == "session-statistic"):
                        for c in self.session_statistic:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary.SessionStatistic()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.session_statistic.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "logs" or name == "remote-node" or name == "session-statistic" or name == "event-id" or name == "below-threshold" or name == "end-of-calculation-time" or name == "event-id-xr" or name == "igp-protocol" or name == "ipfrr-event-id" or name == "process-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "event-id"):
                        self.event_id = value
                        self.event_id.value_namespace = name_space
                        self.event_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "below-threshold"):
                        self.below_threshold = value
                        self.below_threshold.value_namespace = name_space
                        self.below_threshold.value_namespace_prefix = name_space_prefix
                    if(value_path == "end-of-calculation-time"):
                        self.end_of_calculation_time = value
                        self.end_of_calculation_time.value_namespace = name_space
                        self.end_of_calculation_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "event-id-xr"):
                        self.event_id_xr = value
                        self.event_id_xr.value_namespace = name_space
                        self.event_id_xr.value_namespace_prefix = name_space_prefix
                    if(value_path == "igp-protocol"):
                        self.igp_protocol = value
                        self.igp_protocol.value_namespace = name_space
                        self.igp_protocol.value_namespace_prefix = name_space_prefix
                    if(value_path == "ipfrr-event-id"):
                        self.ipfrr_event_id = value
                        self.ipfrr_event_id.value_namespace = name_space
                        self.ipfrr_event_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "process-name"):
                        self.process_name = value
                        self.process_name.value_namespace = name_space
                        self.process_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.remote_lfa_summary:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.remote_lfa_summary:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "remote-lfa-summaries" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/ldp/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "remote-lfa-summary"):
                    for c in self.remote_lfa_summary:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Ldp.RemoteLfaSummaries.RemoteLfaSummary()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.remote_lfa_summary.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "remote-lfa-summary"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.remote_lfa_s is not None and self.remote_lfa_s.has_data()) or
                (self.remote_lfa_summaries is not None and self.remote_lfa_summaries.has_data()) or
                (self.sessions is not None and self.sessions.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.remote_lfa_s is not None and self.remote_lfa_s.has_operation()) or
                (self.remote_lfa_summaries is not None and self.remote_lfa_summaries.has_operation()) or
                (self.sessions is not None and self.sessions.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "ldp" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "remote-lfa-s"):
                if (self.remote_lfa_s is None):
                    self.remote_lfa_s = Rcmd.Ldp.RemoteLfaS()
                    self.remote_lfa_s.parent = self
                    self._children_name_map["remote_lfa_s"] = "remote-lfa-s"
                return self.remote_lfa_s

            if (child_yang_name == "remote-lfa-summaries"):
                if (self.remote_lfa_summaries is None):
                    self.remote_lfa_summaries = Rcmd.Ldp.RemoteLfaSummaries()
                    self.remote_lfa_summaries.parent = self
                    self._children_name_map["remote_lfa_summaries"] = "remote-lfa-summaries"
                return self.remote_lfa_summaries

            if (child_yang_name == "sessions"):
                if (self.sessions is None):
                    self.sessions = Rcmd.Ldp.Sessions()
                    self.sessions.parent = self
                    self._children_name_map["sessions"] = "sessions"
                return self.sessions

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "remote-lfa-s" or name == "remote-lfa-summaries" or name == "sessions"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Intf(Entity):
        """
        Interface data
        
        .. attribute:: events
        
        	Events
        	**type**\:   :py:class:`Events <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Intf.Events>`
        
        

        """

        _prefix = 'infra-rcmd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Rcmd.Intf, self).__init__()

            self.yang_name = "intf"
            self.yang_parent_name = "rcmd"

            self.events = Rcmd.Intf.Events()
            self.events.parent = self
            self._children_name_map["events"] = "events"
            self._children_yang_names.add("events")


        class Events(Entity):
            """
            Events
            
            .. attribute:: event
            
            	Events
            	**type**\: list of    :py:class:`Event <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Intf.Events.Event>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Intf.Events, self).__init__()

                self.yang_name = "events"
                self.yang_parent_name = "intf"

                self.event = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Intf.Events, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Intf.Events, self).__setattr__(name, value)


            class Event(Entity):
                """
                Events
                
                .. attribute:: event_no  <key>
                
                	Specific Event No
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: component
                
                	Component info
                	**type**\:   :py:class:`RcmdShowCompId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowCompId>`
                
                .. attribute:: event_time
                
                	Event Time
                	**type**\:  str
                
                .. attribute:: event_type
                
                	Event Info
                	**type**\:   :py:class:`RcmdShowIntfEvent <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowIntfEvent>`
                
                .. attribute:: interface_name
                
                	Interface Name
                	**type**\:  str
                
                .. attribute:: primary_address
                
                	Primary Address
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                .. attribute:: sequence_no
                
                	Sequence No
                	**type**\:  int
                
                	**range:** 0..4294967295
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Intf.Events.Event, self).__init__()

                    self.yang_name = "event"
                    self.yang_parent_name = "events"

                    self.event_no = YLeaf(YType.int32, "event-no")

                    self.component = YLeaf(YType.enumeration, "component")

                    self.event_time = YLeaf(YType.str, "event-time")

                    self.event_type = YLeaf(YType.enumeration, "event-type")

                    self.interface_name = YLeaf(YType.str, "interface-name")

                    self.primary_address = YLeaf(YType.str, "primary-address")

                    self.sequence_no = YLeaf(YType.uint32, "sequence-no")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("event_no",
                                    "component",
                                    "event_time",
                                    "event_type",
                                    "interface_name",
                                    "primary_address",
                                    "sequence_no") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Intf.Events.Event, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Intf.Events.Event, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.event_no.is_set or
                        self.component.is_set or
                        self.event_time.is_set or
                        self.event_type.is_set or
                        self.interface_name.is_set or
                        self.primary_address.is_set or
                        self.sequence_no.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.event_no.yfilter != YFilter.not_set or
                        self.component.yfilter != YFilter.not_set or
                        self.event_time.yfilter != YFilter.not_set or
                        self.event_type.yfilter != YFilter.not_set or
                        self.interface_name.yfilter != YFilter.not_set or
                        self.primary_address.yfilter != YFilter.not_set or
                        self.sequence_no.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "event" + "[event-no='" + self.event_no.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/intf/events/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.event_no.is_set or self.event_no.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_no.get_name_leafdata())
                    if (self.component.is_set or self.component.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.component.get_name_leafdata())
                    if (self.event_time.is_set or self.event_time.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_time.get_name_leafdata())
                    if (self.event_type.is_set or self.event_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.event_type.get_name_leafdata())
                    if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interface_name.get_name_leafdata())
                    if (self.primary_address.is_set or self.primary_address.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.primary_address.get_name_leafdata())
                    if (self.sequence_no.is_set or self.sequence_no.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.sequence_no.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "event-no" or name == "component" or name == "event-time" or name == "event-type" or name == "interface-name" or name == "primary-address" or name == "sequence-no"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "event-no"):
                        self.event_no = value
                        self.event_no.value_namespace = name_space
                        self.event_no.value_namespace_prefix = name_space_prefix
                    if(value_path == "component"):
                        self.component = value
                        self.component.value_namespace = name_space
                        self.component.value_namespace_prefix = name_space_prefix
                    if(value_path == "event-time"):
                        self.event_time = value
                        self.event_time.value_namespace = name_space
                        self.event_time.value_namespace_prefix = name_space_prefix
                    if(value_path == "event-type"):
                        self.event_type = value
                        self.event_type.value_namespace = name_space
                        self.event_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "interface-name"):
                        self.interface_name = value
                        self.interface_name.value_namespace = name_space
                        self.interface_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "primary-address"):
                        self.primary_address = value
                        self.primary_address.value_namespace = name_space
                        self.primary_address.value_namespace_prefix = name_space_prefix
                    if(value_path == "sequence-no"):
                        self.sequence_no = value
                        self.sequence_no.value_namespace = name_space
                        self.sequence_no.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.event:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.event:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "events" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/intf/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "event"):
                    for c in self.event:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Intf.Events.Event()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.event.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "event"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (self.events is not None and self.events.has_data())

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.events is not None and self.events.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "intf" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "events"):
                if (self.events is None):
                    self.events = Rcmd.Intf.Events()
                    self.events.parent = self
                    self._children_name_map["events"] = "events"
                return self.events

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "events"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Process(Entity):
        """
        Process information
        
        .. attribute:: isis
        
        	ISIS Process Information
        	**type**\:   :py:class:`Isis <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Isis>`
        
        .. attribute:: ldp
        
        	LDP Process Information
        	**type**\:   :py:class:`Ldp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Ldp>`
        
        .. attribute:: ospf
        
        	OSPF Process Information
        	**type**\:   :py:class:`Ospf <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Ospf>`
        
        

        """

        _prefix = 'infra-rcmd-oper'
        _revision = '2015-11-09'

        def __init__(self):
            super(Rcmd.Process, self).__init__()

            self.yang_name = "process"
            self.yang_parent_name = "rcmd"

            self.isis = Rcmd.Process.Isis()
            self.isis.parent = self
            self._children_name_map["isis"] = "isis"
            self._children_yang_names.add("isis")

            self.ldp = Rcmd.Process.Ldp()
            self.ldp.parent = self
            self._children_name_map["ldp"] = "ldp"
            self._children_yang_names.add("ldp")

            self.ospf = Rcmd.Process.Ospf()
            self.ospf.parent = self
            self._children_name_map["ospf"] = "ospf"
            self._children_yang_names.add("ospf")


        class Isis(Entity):
            """
            ISIS Process Information
            
            .. attribute:: process
            
            	Process Information
            	**type**\: list of    :py:class:`Process <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Isis.Process>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Process.Isis, self).__init__()

                self.yang_name = "isis"
                self.yang_parent_name = "process"

                self.process = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Process.Isis, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Process.Isis, self).__setattr__(name, value)


            class Process(Entity):
                """
                Process Information
                
                .. attribute:: instance_name
                
                	Instance/VRF Name
                	**type**\: list of    :py:class:`InstanceName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Isis.Process.InstanceName>`
                
                .. attribute:: process_name
                
                	Process Name
                	**type**\:  str
                
                .. attribute:: protocol_id
                
                	Protocol id
                	**type**\:   :py:class:`RcmdProtocolId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdProtocolId>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Process.Isis.Process, self).__init__()

                    self.yang_name = "process"
                    self.yang_parent_name = "isis"

                    self.process_name = YLeaf(YType.str, "process-name")

                    self.protocol_id = YLeaf(YType.enumeration, "protocol-id")

                    self.instance_name = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("process_name",
                                    "protocol_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Process.Isis.Process, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Process.Isis.Process, self).__setattr__(name, value)


                class InstanceName(Entity):
                    """
                    Instance/VRF Name
                    
                    .. attribute:: arch_lsp_regeneration
                    
                    	Archive Lsp regen
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: arch_spf_event
                    
                    	Archive SPF event
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: instance
                    
                    	Instance Information
                    	**type**\: list of    :py:class:`Instance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Isis.Process.InstanceName.Instance>`
                    
                    .. attribute:: last_update_time
                    
                    	Last Updated Time
                    	**type**\:  str
                    
                    .. attribute:: lsp_regeneration_count
                    
                    	LSP Regen Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: lsp_regeneration_serial
                    
                    	Last Serial
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: name
                    
                    	Instance Name
                    	**type**\:  str
                    
                    .. attribute:: no_route_change_spf_nos
                    
                    	No Route change spf nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: not_interested_spf_nos
                    
                    	Not Interested SPF nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: route_change_spf_nos
                    
                    	Route change spf nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_spf_nos
                    
                    	Total spf nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Process.Isis.Process.InstanceName, self).__init__()

                        self.yang_name = "instance-name"
                        self.yang_parent_name = "process"

                        self.arch_lsp_regeneration = YLeaf(YType.uint32, "arch-lsp-regeneration")

                        self.arch_spf_event = YLeaf(YType.uint32, "arch-spf-event")

                        self.last_update_time = YLeaf(YType.str, "last-update-time")

                        self.lsp_regeneration_count = YLeaf(YType.uint32, "lsp-regeneration-count")

                        self.lsp_regeneration_serial = YLeaf(YType.uint32, "lsp-regeneration-serial")

                        self.name = YLeaf(YType.str, "name")

                        self.no_route_change_spf_nos = YLeaf(YType.uint32, "no-route-change-spf-nos")

                        self.not_interested_spf_nos = YLeaf(YType.uint32, "not-interested-spf-nos")

                        self.route_change_spf_nos = YLeaf(YType.uint32, "route-change-spf-nos")

                        self.total_spf_nos = YLeaf(YType.uint32, "total-spf-nos")

                        self.instance = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("arch_lsp_regeneration",
                                        "arch_spf_event",
                                        "last_update_time",
                                        "lsp_regeneration_count",
                                        "lsp_regeneration_serial",
                                        "name",
                                        "no_route_change_spf_nos",
                                        "not_interested_spf_nos",
                                        "route_change_spf_nos",
                                        "total_spf_nos") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Process.Isis.Process.InstanceName, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Process.Isis.Process.InstanceName, self).__setattr__(name, value)


                    class Instance(Entity):
                        """
                        Instance Information
                        
                        .. attribute:: arch_spf_run
                        
                        	spf run can be archived
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: fwd_referenced
                        
                        	Forward Referenced
                        	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
                        
                        .. attribute:: instance_deleted
                        
                        	Instance Deleted
                        	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
                        
                        .. attribute:: instance_id
                        
                        	Instance Id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: instance_state
                        
                        	Instance State
                        	**type**\:   :py:class:`RcmdShowInstState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowInstState>`
                        
                        .. attribute:: last_update_time
                        
                        	Last Updated Time
                        	**type**\:  str
                        
                        .. attribute:: no_route_change_spf_nos
                        
                        	No Route change spf nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: node_id
                        
                        	Node Id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: not_interested_spf_nos
                        
                        	Not Interested SPF nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: route_change_spf_nos
                        
                        	Route change spf nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: spf_offset
                        
                        	SPF Offset
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_spf_nos
                        
                        	Total spf nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_spt_nos
                        
                        	Total spt nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Process.Isis.Process.InstanceName.Instance, self).__init__()

                            self.yang_name = "instance"
                            self.yang_parent_name = "instance-name"

                            self.arch_spf_run = YLeaf(YType.uint32, "arch-spf-run")

                            self.fwd_referenced = YLeaf(YType.enumeration, "fwd-referenced")

                            self.instance_deleted = YLeaf(YType.enumeration, "instance-deleted")

                            self.instance_id = YLeaf(YType.uint32, "instance-id")

                            self.instance_state = YLeaf(YType.enumeration, "instance-state")

                            self.last_update_time = YLeaf(YType.str, "last-update-time")

                            self.no_route_change_spf_nos = YLeaf(YType.uint32, "no-route-change-spf-nos")

                            self.node_id = YLeaf(YType.uint32, "node-id")

                            self.not_interested_spf_nos = YLeaf(YType.uint32, "not-interested-spf-nos")

                            self.route_change_spf_nos = YLeaf(YType.uint32, "route-change-spf-nos")

                            self.spf_offset = YLeaf(YType.uint32, "spf-offset")

                            self.total_spf_nos = YLeaf(YType.uint32, "total-spf-nos")

                            self.total_spt_nos = YLeaf(YType.uint32, "total-spt-nos")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("arch_spf_run",
                                            "fwd_referenced",
                                            "instance_deleted",
                                            "instance_id",
                                            "instance_state",
                                            "last_update_time",
                                            "no_route_change_spf_nos",
                                            "node_id",
                                            "not_interested_spf_nos",
                                            "route_change_spf_nos",
                                            "spf_offset",
                                            "total_spf_nos",
                                            "total_spt_nos") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Process.Isis.Process.InstanceName.Instance, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Process.Isis.Process.InstanceName.Instance, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.arch_spf_run.is_set or
                                self.fwd_referenced.is_set or
                                self.instance_deleted.is_set or
                                self.instance_id.is_set or
                                self.instance_state.is_set or
                                self.last_update_time.is_set or
                                self.no_route_change_spf_nos.is_set or
                                self.node_id.is_set or
                                self.not_interested_spf_nos.is_set or
                                self.route_change_spf_nos.is_set or
                                self.spf_offset.is_set or
                                self.total_spf_nos.is_set or
                                self.total_spt_nos.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.arch_spf_run.yfilter != YFilter.not_set or
                                self.fwd_referenced.yfilter != YFilter.not_set or
                                self.instance_deleted.yfilter != YFilter.not_set or
                                self.instance_id.yfilter != YFilter.not_set or
                                self.instance_state.yfilter != YFilter.not_set or
                                self.last_update_time.yfilter != YFilter.not_set or
                                self.no_route_change_spf_nos.yfilter != YFilter.not_set or
                                self.node_id.yfilter != YFilter.not_set or
                                self.not_interested_spf_nos.yfilter != YFilter.not_set or
                                self.route_change_spf_nos.yfilter != YFilter.not_set or
                                self.spf_offset.yfilter != YFilter.not_set or
                                self.total_spf_nos.yfilter != YFilter.not_set or
                                self.total_spt_nos.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "instance" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/isis/process/instance-name/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.arch_spf_run.is_set or self.arch_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.arch_spf_run.get_name_leafdata())
                            if (self.fwd_referenced.is_set or self.fwd_referenced.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fwd_referenced.get_name_leafdata())
                            if (self.instance_deleted.is_set or self.instance_deleted.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance_deleted.get_name_leafdata())
                            if (self.instance_id.is_set or self.instance_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance_id.get_name_leafdata())
                            if (self.instance_state.is_set or self.instance_state.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance_state.get_name_leafdata())
                            if (self.last_update_time.is_set or self.last_update_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_update_time.get_name_leafdata())
                            if (self.no_route_change_spf_nos.is_set or self.no_route_change_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.no_route_change_spf_nos.get_name_leafdata())
                            if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.node_id.get_name_leafdata())
                            if (self.not_interested_spf_nos.is_set or self.not_interested_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.not_interested_spf_nos.get_name_leafdata())
                            if (self.route_change_spf_nos.is_set or self.route_change_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_change_spf_nos.get_name_leafdata())
                            if (self.spf_offset.is_set or self.spf_offset.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_offset.get_name_leafdata())
                            if (self.total_spf_nos.is_set or self.total_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_spf_nos.get_name_leafdata())
                            if (self.total_spt_nos.is_set or self.total_spt_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_spt_nos.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "arch-spf-run" or name == "fwd-referenced" or name == "instance-deleted" or name == "instance-id" or name == "instance-state" or name == "last-update-time" or name == "no-route-change-spf-nos" or name == "node-id" or name == "not-interested-spf-nos" or name == "route-change-spf-nos" or name == "spf-offset" or name == "total-spf-nos" or name == "total-spt-nos"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "arch-spf-run"):
                                self.arch_spf_run = value
                                self.arch_spf_run.value_namespace = name_space
                                self.arch_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "fwd-referenced"):
                                self.fwd_referenced = value
                                self.fwd_referenced.value_namespace = name_space
                                self.fwd_referenced.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance-deleted"):
                                self.instance_deleted = value
                                self.instance_deleted.value_namespace = name_space
                                self.instance_deleted.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance-id"):
                                self.instance_id = value
                                self.instance_id.value_namespace = name_space
                                self.instance_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance-state"):
                                self.instance_state = value
                                self.instance_state.value_namespace = name_space
                                self.instance_state.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-update-time"):
                                self.last_update_time = value
                                self.last_update_time.value_namespace = name_space
                                self.last_update_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "no-route-change-spf-nos"):
                                self.no_route_change_spf_nos = value
                                self.no_route_change_spf_nos.value_namespace = name_space
                                self.no_route_change_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "node-id"):
                                self.node_id = value
                                self.node_id.value_namespace = name_space
                                self.node_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "not-interested-spf-nos"):
                                self.not_interested_spf_nos = value
                                self.not_interested_spf_nos.value_namespace = name_space
                                self.not_interested_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-change-spf-nos"):
                                self.route_change_spf_nos = value
                                self.route_change_spf_nos.value_namespace = name_space
                                self.route_change_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-offset"):
                                self.spf_offset = value
                                self.spf_offset.value_namespace = name_space
                                self.spf_offset.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-spf-nos"):
                                self.total_spf_nos = value
                                self.total_spf_nos.value_namespace = name_space
                                self.total_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-spt-nos"):
                                self.total_spt_nos = value
                                self.total_spt_nos.value_namespace = name_space
                                self.total_spt_nos.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.instance:
                            if (c.has_data()):
                                return True
                        return (
                            self.arch_lsp_regeneration.is_set or
                            self.arch_spf_event.is_set or
                            self.last_update_time.is_set or
                            self.lsp_regeneration_count.is_set or
                            self.lsp_regeneration_serial.is_set or
                            self.name.is_set or
                            self.no_route_change_spf_nos.is_set or
                            self.not_interested_spf_nos.is_set or
                            self.route_change_spf_nos.is_set or
                            self.total_spf_nos.is_set)

                    def has_operation(self):
                        for c in self.instance:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.arch_lsp_regeneration.yfilter != YFilter.not_set or
                            self.arch_spf_event.yfilter != YFilter.not_set or
                            self.last_update_time.yfilter != YFilter.not_set or
                            self.lsp_regeneration_count.yfilter != YFilter.not_set or
                            self.lsp_regeneration_serial.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.no_route_change_spf_nos.yfilter != YFilter.not_set or
                            self.not_interested_spf_nos.yfilter != YFilter.not_set or
                            self.route_change_spf_nos.yfilter != YFilter.not_set or
                            self.total_spf_nos.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "instance-name" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/isis/process/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.arch_lsp_regeneration.is_set or self.arch_lsp_regeneration.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.arch_lsp_regeneration.get_name_leafdata())
                        if (self.arch_spf_event.is_set or self.arch_spf_event.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.arch_spf_event.get_name_leafdata())
                        if (self.last_update_time.is_set or self.last_update_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_update_time.get_name_leafdata())
                        if (self.lsp_regeneration_count.is_set or self.lsp_regeneration_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsp_regeneration_count.get_name_leafdata())
                        if (self.lsp_regeneration_serial.is_set or self.lsp_regeneration_serial.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsp_regeneration_serial.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.no_route_change_spf_nos.is_set or self.no_route_change_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.no_route_change_spf_nos.get_name_leafdata())
                        if (self.not_interested_spf_nos.is_set or self.not_interested_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.not_interested_spf_nos.get_name_leafdata())
                        if (self.route_change_spf_nos.is_set or self.route_change_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_change_spf_nos.get_name_leafdata())
                        if (self.total_spf_nos.is_set or self.total_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_spf_nos.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "instance"):
                            for c in self.instance:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Process.Isis.Process.InstanceName.Instance()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.instance.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "instance" or name == "arch-lsp-regeneration" or name == "arch-spf-event" or name == "last-update-time" or name == "lsp-regeneration-count" or name == "lsp-regeneration-serial" or name == "name" or name == "no-route-change-spf-nos" or name == "not-interested-spf-nos" or name == "route-change-spf-nos" or name == "total-spf-nos"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "arch-lsp-regeneration"):
                            self.arch_lsp_regeneration = value
                            self.arch_lsp_regeneration.value_namespace = name_space
                            self.arch_lsp_regeneration.value_namespace_prefix = name_space_prefix
                        if(value_path == "arch-spf-event"):
                            self.arch_spf_event = value
                            self.arch_spf_event.value_namespace = name_space
                            self.arch_spf_event.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-update-time"):
                            self.last_update_time = value
                            self.last_update_time.value_namespace = name_space
                            self.last_update_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsp-regeneration-count"):
                            self.lsp_regeneration_count = value
                            self.lsp_regeneration_count.value_namespace = name_space
                            self.lsp_regeneration_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsp-regeneration-serial"):
                            self.lsp_regeneration_serial = value
                            self.lsp_regeneration_serial.value_namespace = name_space
                            self.lsp_regeneration_serial.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "no-route-change-spf-nos"):
                            self.no_route_change_spf_nos = value
                            self.no_route_change_spf_nos.value_namespace = name_space
                            self.no_route_change_spf_nos.value_namespace_prefix = name_space_prefix
                        if(value_path == "not-interested-spf-nos"):
                            self.not_interested_spf_nos = value
                            self.not_interested_spf_nos.value_namespace = name_space
                            self.not_interested_spf_nos.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-change-spf-nos"):
                            self.route_change_spf_nos = value
                            self.route_change_spf_nos.value_namespace = name_space
                            self.route_change_spf_nos.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-spf-nos"):
                            self.total_spf_nos = value
                            self.total_spf_nos.value_namespace = name_space
                            self.total_spf_nos.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.instance_name:
                        if (c.has_data()):
                            return True
                    return (
                        self.process_name.is_set or
                        self.protocol_id.is_set)

                def has_operation(self):
                    for c in self.instance_name:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.process_name.yfilter != YFilter.not_set or
                        self.protocol_id.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "process" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/isis/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.process_name.get_name_leafdata())
                    if (self.protocol_id.is_set or self.protocol_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.protocol_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "instance-name"):
                        for c in self.instance_name:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Process.Isis.Process.InstanceName()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.instance_name.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "instance-name" or name == "process-name" or name == "protocol-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "process-name"):
                        self.process_name = value
                        self.process_name.value_namespace = name_space
                        self.process_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "protocol-id"):
                        self.protocol_id = value
                        self.protocol_id.value_namespace = name_space
                        self.protocol_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.process:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.process:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "isis" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "process"):
                    for c in self.process:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Process.Isis.Process()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.process.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "process"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Ospf(Entity):
            """
            OSPF Process Information
            
            .. attribute:: process
            
            	Process Information
            	**type**\: list of    :py:class:`Process <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Ospf.Process>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Process.Ospf, self).__init__()

                self.yang_name = "ospf"
                self.yang_parent_name = "process"

                self.process = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Process.Ospf, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Process.Ospf, self).__setattr__(name, value)


            class Process(Entity):
                """
                Process Information
                
                .. attribute:: instance_name
                
                	Instance/VRF Name
                	**type**\: list of    :py:class:`InstanceName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Ospf.Process.InstanceName>`
                
                .. attribute:: process_name
                
                	Process Name
                	**type**\:  str
                
                .. attribute:: protocol_id
                
                	Protocol id
                	**type**\:   :py:class:`RcmdProtocolId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdProtocolId>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Process.Ospf.Process, self).__init__()

                    self.yang_name = "process"
                    self.yang_parent_name = "ospf"

                    self.process_name = YLeaf(YType.str, "process-name")

                    self.protocol_id = YLeaf(YType.enumeration, "protocol-id")

                    self.instance_name = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("process_name",
                                    "protocol_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Process.Ospf.Process, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Process.Ospf.Process, self).__setattr__(name, value)


                class InstanceName(Entity):
                    """
                    Instance/VRF Name
                    
                    .. attribute:: arch_lsp_regeneration
                    
                    	Archive Lsp regen
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: arch_spf_event
                    
                    	Archive SPF event
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: instance
                    
                    	Instance Information
                    	**type**\: list of    :py:class:`Instance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Ospf.Process.InstanceName.Instance>`
                    
                    .. attribute:: last_update_time
                    
                    	Last Updated Time
                    	**type**\:  str
                    
                    .. attribute:: lsp_regeneration_count
                    
                    	LSP Regen Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: lsp_regeneration_serial
                    
                    	Last Serial
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: name
                    
                    	Instance Name
                    	**type**\:  str
                    
                    .. attribute:: no_route_change_spf_nos
                    
                    	No Route change spf nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: not_interested_spf_nos
                    
                    	Not Interested SPF nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: route_change_spf_nos
                    
                    	Route change spf nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_spf_nos
                    
                    	Total spf nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Process.Ospf.Process.InstanceName, self).__init__()

                        self.yang_name = "instance-name"
                        self.yang_parent_name = "process"

                        self.arch_lsp_regeneration = YLeaf(YType.uint32, "arch-lsp-regeneration")

                        self.arch_spf_event = YLeaf(YType.uint32, "arch-spf-event")

                        self.last_update_time = YLeaf(YType.str, "last-update-time")

                        self.lsp_regeneration_count = YLeaf(YType.uint32, "lsp-regeneration-count")

                        self.lsp_regeneration_serial = YLeaf(YType.uint32, "lsp-regeneration-serial")

                        self.name = YLeaf(YType.str, "name")

                        self.no_route_change_spf_nos = YLeaf(YType.uint32, "no-route-change-spf-nos")

                        self.not_interested_spf_nos = YLeaf(YType.uint32, "not-interested-spf-nos")

                        self.route_change_spf_nos = YLeaf(YType.uint32, "route-change-spf-nos")

                        self.total_spf_nos = YLeaf(YType.uint32, "total-spf-nos")

                        self.instance = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("arch_lsp_regeneration",
                                        "arch_spf_event",
                                        "last_update_time",
                                        "lsp_regeneration_count",
                                        "lsp_regeneration_serial",
                                        "name",
                                        "no_route_change_spf_nos",
                                        "not_interested_spf_nos",
                                        "route_change_spf_nos",
                                        "total_spf_nos") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Process.Ospf.Process.InstanceName, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Process.Ospf.Process.InstanceName, self).__setattr__(name, value)


                    class Instance(Entity):
                        """
                        Instance Information
                        
                        .. attribute:: arch_spf_run
                        
                        	spf run can be archived
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: fwd_referenced
                        
                        	Forward Referenced
                        	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
                        
                        .. attribute:: instance_deleted
                        
                        	Instance Deleted
                        	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
                        
                        .. attribute:: instance_id
                        
                        	Instance Id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: instance_state
                        
                        	Instance State
                        	**type**\:   :py:class:`RcmdShowInstState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowInstState>`
                        
                        .. attribute:: last_update_time
                        
                        	Last Updated Time
                        	**type**\:  str
                        
                        .. attribute:: no_route_change_spf_nos
                        
                        	No Route change spf nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: node_id
                        
                        	Node Id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: not_interested_spf_nos
                        
                        	Not Interested SPF nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: route_change_spf_nos
                        
                        	Route change spf nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: spf_offset
                        
                        	SPF Offset
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_spf_nos
                        
                        	Total spf nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_spt_nos
                        
                        	Total spt nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Process.Ospf.Process.InstanceName.Instance, self).__init__()

                            self.yang_name = "instance"
                            self.yang_parent_name = "instance-name"

                            self.arch_spf_run = YLeaf(YType.uint32, "arch-spf-run")

                            self.fwd_referenced = YLeaf(YType.enumeration, "fwd-referenced")

                            self.instance_deleted = YLeaf(YType.enumeration, "instance-deleted")

                            self.instance_id = YLeaf(YType.uint32, "instance-id")

                            self.instance_state = YLeaf(YType.enumeration, "instance-state")

                            self.last_update_time = YLeaf(YType.str, "last-update-time")

                            self.no_route_change_spf_nos = YLeaf(YType.uint32, "no-route-change-spf-nos")

                            self.node_id = YLeaf(YType.uint32, "node-id")

                            self.not_interested_spf_nos = YLeaf(YType.uint32, "not-interested-spf-nos")

                            self.route_change_spf_nos = YLeaf(YType.uint32, "route-change-spf-nos")

                            self.spf_offset = YLeaf(YType.uint32, "spf-offset")

                            self.total_spf_nos = YLeaf(YType.uint32, "total-spf-nos")

                            self.total_spt_nos = YLeaf(YType.uint32, "total-spt-nos")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("arch_spf_run",
                                            "fwd_referenced",
                                            "instance_deleted",
                                            "instance_id",
                                            "instance_state",
                                            "last_update_time",
                                            "no_route_change_spf_nos",
                                            "node_id",
                                            "not_interested_spf_nos",
                                            "route_change_spf_nos",
                                            "spf_offset",
                                            "total_spf_nos",
                                            "total_spt_nos") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Process.Ospf.Process.InstanceName.Instance, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Process.Ospf.Process.InstanceName.Instance, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.arch_spf_run.is_set or
                                self.fwd_referenced.is_set or
                                self.instance_deleted.is_set or
                                self.instance_id.is_set or
                                self.instance_state.is_set or
                                self.last_update_time.is_set or
                                self.no_route_change_spf_nos.is_set or
                                self.node_id.is_set or
                                self.not_interested_spf_nos.is_set or
                                self.route_change_spf_nos.is_set or
                                self.spf_offset.is_set or
                                self.total_spf_nos.is_set or
                                self.total_spt_nos.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.arch_spf_run.yfilter != YFilter.not_set or
                                self.fwd_referenced.yfilter != YFilter.not_set or
                                self.instance_deleted.yfilter != YFilter.not_set or
                                self.instance_id.yfilter != YFilter.not_set or
                                self.instance_state.yfilter != YFilter.not_set or
                                self.last_update_time.yfilter != YFilter.not_set or
                                self.no_route_change_spf_nos.yfilter != YFilter.not_set or
                                self.node_id.yfilter != YFilter.not_set or
                                self.not_interested_spf_nos.yfilter != YFilter.not_set or
                                self.route_change_spf_nos.yfilter != YFilter.not_set or
                                self.spf_offset.yfilter != YFilter.not_set or
                                self.total_spf_nos.yfilter != YFilter.not_set or
                                self.total_spt_nos.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "instance" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/ospf/process/instance-name/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.arch_spf_run.is_set or self.arch_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.arch_spf_run.get_name_leafdata())
                            if (self.fwd_referenced.is_set or self.fwd_referenced.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fwd_referenced.get_name_leafdata())
                            if (self.instance_deleted.is_set or self.instance_deleted.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance_deleted.get_name_leafdata())
                            if (self.instance_id.is_set or self.instance_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance_id.get_name_leafdata())
                            if (self.instance_state.is_set or self.instance_state.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance_state.get_name_leafdata())
                            if (self.last_update_time.is_set or self.last_update_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_update_time.get_name_leafdata())
                            if (self.no_route_change_spf_nos.is_set or self.no_route_change_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.no_route_change_spf_nos.get_name_leafdata())
                            if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.node_id.get_name_leafdata())
                            if (self.not_interested_spf_nos.is_set or self.not_interested_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.not_interested_spf_nos.get_name_leafdata())
                            if (self.route_change_spf_nos.is_set or self.route_change_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_change_spf_nos.get_name_leafdata())
                            if (self.spf_offset.is_set or self.spf_offset.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_offset.get_name_leafdata())
                            if (self.total_spf_nos.is_set or self.total_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_spf_nos.get_name_leafdata())
                            if (self.total_spt_nos.is_set or self.total_spt_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_spt_nos.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "arch-spf-run" or name == "fwd-referenced" or name == "instance-deleted" or name == "instance-id" or name == "instance-state" or name == "last-update-time" or name == "no-route-change-spf-nos" or name == "node-id" or name == "not-interested-spf-nos" or name == "route-change-spf-nos" or name == "spf-offset" or name == "total-spf-nos" or name == "total-spt-nos"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "arch-spf-run"):
                                self.arch_spf_run = value
                                self.arch_spf_run.value_namespace = name_space
                                self.arch_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "fwd-referenced"):
                                self.fwd_referenced = value
                                self.fwd_referenced.value_namespace = name_space
                                self.fwd_referenced.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance-deleted"):
                                self.instance_deleted = value
                                self.instance_deleted.value_namespace = name_space
                                self.instance_deleted.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance-id"):
                                self.instance_id = value
                                self.instance_id.value_namespace = name_space
                                self.instance_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance-state"):
                                self.instance_state = value
                                self.instance_state.value_namespace = name_space
                                self.instance_state.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-update-time"):
                                self.last_update_time = value
                                self.last_update_time.value_namespace = name_space
                                self.last_update_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "no-route-change-spf-nos"):
                                self.no_route_change_spf_nos = value
                                self.no_route_change_spf_nos.value_namespace = name_space
                                self.no_route_change_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "node-id"):
                                self.node_id = value
                                self.node_id.value_namespace = name_space
                                self.node_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "not-interested-spf-nos"):
                                self.not_interested_spf_nos = value
                                self.not_interested_spf_nos.value_namespace = name_space
                                self.not_interested_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-change-spf-nos"):
                                self.route_change_spf_nos = value
                                self.route_change_spf_nos.value_namespace = name_space
                                self.route_change_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-offset"):
                                self.spf_offset = value
                                self.spf_offset.value_namespace = name_space
                                self.spf_offset.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-spf-nos"):
                                self.total_spf_nos = value
                                self.total_spf_nos.value_namespace = name_space
                                self.total_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-spt-nos"):
                                self.total_spt_nos = value
                                self.total_spt_nos.value_namespace = name_space
                                self.total_spt_nos.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.instance:
                            if (c.has_data()):
                                return True
                        return (
                            self.arch_lsp_regeneration.is_set or
                            self.arch_spf_event.is_set or
                            self.last_update_time.is_set or
                            self.lsp_regeneration_count.is_set or
                            self.lsp_regeneration_serial.is_set or
                            self.name.is_set or
                            self.no_route_change_spf_nos.is_set or
                            self.not_interested_spf_nos.is_set or
                            self.route_change_spf_nos.is_set or
                            self.total_spf_nos.is_set)

                    def has_operation(self):
                        for c in self.instance:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.arch_lsp_regeneration.yfilter != YFilter.not_set or
                            self.arch_spf_event.yfilter != YFilter.not_set or
                            self.last_update_time.yfilter != YFilter.not_set or
                            self.lsp_regeneration_count.yfilter != YFilter.not_set or
                            self.lsp_regeneration_serial.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.no_route_change_spf_nos.yfilter != YFilter.not_set or
                            self.not_interested_spf_nos.yfilter != YFilter.not_set or
                            self.route_change_spf_nos.yfilter != YFilter.not_set or
                            self.total_spf_nos.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "instance-name" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/ospf/process/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.arch_lsp_regeneration.is_set or self.arch_lsp_regeneration.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.arch_lsp_regeneration.get_name_leafdata())
                        if (self.arch_spf_event.is_set or self.arch_spf_event.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.arch_spf_event.get_name_leafdata())
                        if (self.last_update_time.is_set or self.last_update_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_update_time.get_name_leafdata())
                        if (self.lsp_regeneration_count.is_set or self.lsp_regeneration_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsp_regeneration_count.get_name_leafdata())
                        if (self.lsp_regeneration_serial.is_set or self.lsp_regeneration_serial.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsp_regeneration_serial.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.no_route_change_spf_nos.is_set or self.no_route_change_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.no_route_change_spf_nos.get_name_leafdata())
                        if (self.not_interested_spf_nos.is_set or self.not_interested_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.not_interested_spf_nos.get_name_leafdata())
                        if (self.route_change_spf_nos.is_set or self.route_change_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_change_spf_nos.get_name_leafdata())
                        if (self.total_spf_nos.is_set or self.total_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_spf_nos.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "instance"):
                            for c in self.instance:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Process.Ospf.Process.InstanceName.Instance()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.instance.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "instance" or name == "arch-lsp-regeneration" or name == "arch-spf-event" or name == "last-update-time" or name == "lsp-regeneration-count" or name == "lsp-regeneration-serial" or name == "name" or name == "no-route-change-spf-nos" or name == "not-interested-spf-nos" or name == "route-change-spf-nos" or name == "total-spf-nos"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "arch-lsp-regeneration"):
                            self.arch_lsp_regeneration = value
                            self.arch_lsp_regeneration.value_namespace = name_space
                            self.arch_lsp_regeneration.value_namespace_prefix = name_space_prefix
                        if(value_path == "arch-spf-event"):
                            self.arch_spf_event = value
                            self.arch_spf_event.value_namespace = name_space
                            self.arch_spf_event.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-update-time"):
                            self.last_update_time = value
                            self.last_update_time.value_namespace = name_space
                            self.last_update_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsp-regeneration-count"):
                            self.lsp_regeneration_count = value
                            self.lsp_regeneration_count.value_namespace = name_space
                            self.lsp_regeneration_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsp-regeneration-serial"):
                            self.lsp_regeneration_serial = value
                            self.lsp_regeneration_serial.value_namespace = name_space
                            self.lsp_regeneration_serial.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "no-route-change-spf-nos"):
                            self.no_route_change_spf_nos = value
                            self.no_route_change_spf_nos.value_namespace = name_space
                            self.no_route_change_spf_nos.value_namespace_prefix = name_space_prefix
                        if(value_path == "not-interested-spf-nos"):
                            self.not_interested_spf_nos = value
                            self.not_interested_spf_nos.value_namespace = name_space
                            self.not_interested_spf_nos.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-change-spf-nos"):
                            self.route_change_spf_nos = value
                            self.route_change_spf_nos.value_namespace = name_space
                            self.route_change_spf_nos.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-spf-nos"):
                            self.total_spf_nos = value
                            self.total_spf_nos.value_namespace = name_space
                            self.total_spf_nos.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.instance_name:
                        if (c.has_data()):
                            return True
                    return (
                        self.process_name.is_set or
                        self.protocol_id.is_set)

                def has_operation(self):
                    for c in self.instance_name:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.process_name.yfilter != YFilter.not_set or
                        self.protocol_id.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "process" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/ospf/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.process_name.get_name_leafdata())
                    if (self.protocol_id.is_set or self.protocol_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.protocol_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "instance-name"):
                        for c in self.instance_name:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Process.Ospf.Process.InstanceName()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.instance_name.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "instance-name" or name == "process-name" or name == "protocol-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "process-name"):
                        self.process_name = value
                        self.process_name.value_namespace = name_space
                        self.process_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "protocol-id"):
                        self.protocol_id = value
                        self.protocol_id.value_namespace = name_space
                        self.protocol_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.process:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.process:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ospf" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "process"):
                    for c in self.process:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Process.Ospf.Process()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.process.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "process"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Ldp(Entity):
            """
            LDP Process Information
            
            .. attribute:: process
            
            	Process Information
            	**type**\: list of    :py:class:`Process <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Ldp.Process>`
            
            

            """

            _prefix = 'infra-rcmd-oper'
            _revision = '2015-11-09'

            def __init__(self):
                super(Rcmd.Process.Ldp, self).__init__()

                self.yang_name = "ldp"
                self.yang_parent_name = "process"

                self.process = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(Rcmd.Process.Ldp, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(Rcmd.Process.Ldp, self).__setattr__(name, value)


            class Process(Entity):
                """
                Process Information
                
                .. attribute:: instance_name
                
                	Instance/VRF Name
                	**type**\: list of    :py:class:`InstanceName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Ldp.Process.InstanceName>`
                
                .. attribute:: process_name
                
                	Process Name
                	**type**\:  str
                
                .. attribute:: protocol_id
                
                	Protocol id
                	**type**\:   :py:class:`RcmdProtocolId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdProtocolId>`
                
                

                """

                _prefix = 'infra-rcmd-oper'
                _revision = '2015-11-09'

                def __init__(self):
                    super(Rcmd.Process.Ldp.Process, self).__init__()

                    self.yang_name = "process"
                    self.yang_parent_name = "ldp"

                    self.process_name = YLeaf(YType.str, "process-name")

                    self.protocol_id = YLeaf(YType.enumeration, "protocol-id")

                    self.instance_name = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("process_name",
                                    "protocol_id") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(Rcmd.Process.Ldp.Process, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(Rcmd.Process.Ldp.Process, self).__setattr__(name, value)


                class InstanceName(Entity):
                    """
                    Instance/VRF Name
                    
                    .. attribute:: arch_lsp_regeneration
                    
                    	Archive Lsp regen
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: arch_spf_event
                    
                    	Archive SPF event
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: instance
                    
                    	Instance Information
                    	**type**\: list of    :py:class:`Instance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.Rcmd.Process.Ldp.Process.InstanceName.Instance>`
                    
                    .. attribute:: last_update_time
                    
                    	Last Updated Time
                    	**type**\:  str
                    
                    .. attribute:: lsp_regeneration_count
                    
                    	LSP Regen Count
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: lsp_regeneration_serial
                    
                    	Last Serial
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: name
                    
                    	Instance Name
                    	**type**\:  str
                    
                    .. attribute:: no_route_change_spf_nos
                    
                    	No Route change spf nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: not_interested_spf_nos
                    
                    	Not Interested SPF nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: route_change_spf_nos
                    
                    	Route change spf nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: total_spf_nos
                    
                    	Total spf nos
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    

                    """

                    _prefix = 'infra-rcmd-oper'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(Rcmd.Process.Ldp.Process.InstanceName, self).__init__()

                        self.yang_name = "instance-name"
                        self.yang_parent_name = "process"

                        self.arch_lsp_regeneration = YLeaf(YType.uint32, "arch-lsp-regeneration")

                        self.arch_spf_event = YLeaf(YType.uint32, "arch-spf-event")

                        self.last_update_time = YLeaf(YType.str, "last-update-time")

                        self.lsp_regeneration_count = YLeaf(YType.uint32, "lsp-regeneration-count")

                        self.lsp_regeneration_serial = YLeaf(YType.uint32, "lsp-regeneration-serial")

                        self.name = YLeaf(YType.str, "name")

                        self.no_route_change_spf_nos = YLeaf(YType.uint32, "no-route-change-spf-nos")

                        self.not_interested_spf_nos = YLeaf(YType.uint32, "not-interested-spf-nos")

                        self.route_change_spf_nos = YLeaf(YType.uint32, "route-change-spf-nos")

                        self.total_spf_nos = YLeaf(YType.uint32, "total-spf-nos")

                        self.instance = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("arch_lsp_regeneration",
                                        "arch_spf_event",
                                        "last_update_time",
                                        "lsp_regeneration_count",
                                        "lsp_regeneration_serial",
                                        "name",
                                        "no_route_change_spf_nos",
                                        "not_interested_spf_nos",
                                        "route_change_spf_nos",
                                        "total_spf_nos") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(Rcmd.Process.Ldp.Process.InstanceName, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(Rcmd.Process.Ldp.Process.InstanceName, self).__setattr__(name, value)


                    class Instance(Entity):
                        """
                        Instance Information
                        
                        .. attribute:: arch_spf_run
                        
                        	spf run can be archived
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: fwd_referenced
                        
                        	Forward Referenced
                        	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
                        
                        .. attribute:: instance_deleted
                        
                        	Instance Deleted
                        	**type**\:   :py:class:`RcmdBoolYesNo <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdBoolYesNo>`
                        
                        .. attribute:: instance_id
                        
                        	Instance Id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: instance_state
                        
                        	Instance State
                        	**type**\:   :py:class:`RcmdShowInstState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_infra_rcmd_oper.RcmdShowInstState>`
                        
                        .. attribute:: last_update_time
                        
                        	Last Updated Time
                        	**type**\:  str
                        
                        .. attribute:: no_route_change_spf_nos
                        
                        	No Route change spf nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: node_id
                        
                        	Node Id
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: not_interested_spf_nos
                        
                        	Not Interested SPF nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: route_change_spf_nos
                        
                        	Route change spf nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: spf_offset
                        
                        	SPF Offset
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_spf_nos
                        
                        	Total spf nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: total_spt_nos
                        
                        	Total spt nos
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'infra-rcmd-oper'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(Rcmd.Process.Ldp.Process.InstanceName.Instance, self).__init__()

                            self.yang_name = "instance"
                            self.yang_parent_name = "instance-name"

                            self.arch_spf_run = YLeaf(YType.uint32, "arch-spf-run")

                            self.fwd_referenced = YLeaf(YType.enumeration, "fwd-referenced")

                            self.instance_deleted = YLeaf(YType.enumeration, "instance-deleted")

                            self.instance_id = YLeaf(YType.uint32, "instance-id")

                            self.instance_state = YLeaf(YType.enumeration, "instance-state")

                            self.last_update_time = YLeaf(YType.str, "last-update-time")

                            self.no_route_change_spf_nos = YLeaf(YType.uint32, "no-route-change-spf-nos")

                            self.node_id = YLeaf(YType.uint32, "node-id")

                            self.not_interested_spf_nos = YLeaf(YType.uint32, "not-interested-spf-nos")

                            self.route_change_spf_nos = YLeaf(YType.uint32, "route-change-spf-nos")

                            self.spf_offset = YLeaf(YType.uint32, "spf-offset")

                            self.total_spf_nos = YLeaf(YType.uint32, "total-spf-nos")

                            self.total_spt_nos = YLeaf(YType.uint32, "total-spt-nos")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("arch_spf_run",
                                            "fwd_referenced",
                                            "instance_deleted",
                                            "instance_id",
                                            "instance_state",
                                            "last_update_time",
                                            "no_route_change_spf_nos",
                                            "node_id",
                                            "not_interested_spf_nos",
                                            "route_change_spf_nos",
                                            "spf_offset",
                                            "total_spf_nos",
                                            "total_spt_nos") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(Rcmd.Process.Ldp.Process.InstanceName.Instance, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(Rcmd.Process.Ldp.Process.InstanceName.Instance, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.arch_spf_run.is_set or
                                self.fwd_referenced.is_set or
                                self.instance_deleted.is_set or
                                self.instance_id.is_set or
                                self.instance_state.is_set or
                                self.last_update_time.is_set or
                                self.no_route_change_spf_nos.is_set or
                                self.node_id.is_set or
                                self.not_interested_spf_nos.is_set or
                                self.route_change_spf_nos.is_set or
                                self.spf_offset.is_set or
                                self.total_spf_nos.is_set or
                                self.total_spt_nos.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.arch_spf_run.yfilter != YFilter.not_set or
                                self.fwd_referenced.yfilter != YFilter.not_set or
                                self.instance_deleted.yfilter != YFilter.not_set or
                                self.instance_id.yfilter != YFilter.not_set or
                                self.instance_state.yfilter != YFilter.not_set or
                                self.last_update_time.yfilter != YFilter.not_set or
                                self.no_route_change_spf_nos.yfilter != YFilter.not_set or
                                self.node_id.yfilter != YFilter.not_set or
                                self.not_interested_spf_nos.yfilter != YFilter.not_set or
                                self.route_change_spf_nos.yfilter != YFilter.not_set or
                                self.spf_offset.yfilter != YFilter.not_set or
                                self.total_spf_nos.yfilter != YFilter.not_set or
                                self.total_spt_nos.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "instance" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/ldp/process/instance-name/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.arch_spf_run.is_set or self.arch_spf_run.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.arch_spf_run.get_name_leafdata())
                            if (self.fwd_referenced.is_set or self.fwd_referenced.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.fwd_referenced.get_name_leafdata())
                            if (self.instance_deleted.is_set or self.instance_deleted.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance_deleted.get_name_leafdata())
                            if (self.instance_id.is_set or self.instance_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance_id.get_name_leafdata())
                            if (self.instance_state.is_set or self.instance_state.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.instance_state.get_name_leafdata())
                            if (self.last_update_time.is_set or self.last_update_time.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.last_update_time.get_name_leafdata())
                            if (self.no_route_change_spf_nos.is_set or self.no_route_change_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.no_route_change_spf_nos.get_name_leafdata())
                            if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.node_id.get_name_leafdata())
                            if (self.not_interested_spf_nos.is_set or self.not_interested_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.not_interested_spf_nos.get_name_leafdata())
                            if (self.route_change_spf_nos.is_set or self.route_change_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.route_change_spf_nos.get_name_leafdata())
                            if (self.spf_offset.is_set or self.spf_offset.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.spf_offset.get_name_leafdata())
                            if (self.total_spf_nos.is_set or self.total_spf_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_spf_nos.get_name_leafdata())
                            if (self.total_spt_nos.is_set or self.total_spt_nos.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.total_spt_nos.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "arch-spf-run" or name == "fwd-referenced" or name == "instance-deleted" or name == "instance-id" or name == "instance-state" or name == "last-update-time" or name == "no-route-change-spf-nos" or name == "node-id" or name == "not-interested-spf-nos" or name == "route-change-spf-nos" or name == "spf-offset" or name == "total-spf-nos" or name == "total-spt-nos"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "arch-spf-run"):
                                self.arch_spf_run = value
                                self.arch_spf_run.value_namespace = name_space
                                self.arch_spf_run.value_namespace_prefix = name_space_prefix
                            if(value_path == "fwd-referenced"):
                                self.fwd_referenced = value
                                self.fwd_referenced.value_namespace = name_space
                                self.fwd_referenced.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance-deleted"):
                                self.instance_deleted = value
                                self.instance_deleted.value_namespace = name_space
                                self.instance_deleted.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance-id"):
                                self.instance_id = value
                                self.instance_id.value_namespace = name_space
                                self.instance_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "instance-state"):
                                self.instance_state = value
                                self.instance_state.value_namespace = name_space
                                self.instance_state.value_namespace_prefix = name_space_prefix
                            if(value_path == "last-update-time"):
                                self.last_update_time = value
                                self.last_update_time.value_namespace = name_space
                                self.last_update_time.value_namespace_prefix = name_space_prefix
                            if(value_path == "no-route-change-spf-nos"):
                                self.no_route_change_spf_nos = value
                                self.no_route_change_spf_nos.value_namespace = name_space
                                self.no_route_change_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "node-id"):
                                self.node_id = value
                                self.node_id.value_namespace = name_space
                                self.node_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "not-interested-spf-nos"):
                                self.not_interested_spf_nos = value
                                self.not_interested_spf_nos.value_namespace = name_space
                                self.not_interested_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "route-change-spf-nos"):
                                self.route_change_spf_nos = value
                                self.route_change_spf_nos.value_namespace = name_space
                                self.route_change_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "spf-offset"):
                                self.spf_offset = value
                                self.spf_offset.value_namespace = name_space
                                self.spf_offset.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-spf-nos"):
                                self.total_spf_nos = value
                                self.total_spf_nos.value_namespace = name_space
                                self.total_spf_nos.value_namespace_prefix = name_space_prefix
                            if(value_path == "total-spt-nos"):
                                self.total_spt_nos = value
                                self.total_spt_nos.value_namespace = name_space
                                self.total_spt_nos.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.instance:
                            if (c.has_data()):
                                return True
                        return (
                            self.arch_lsp_regeneration.is_set or
                            self.arch_spf_event.is_set or
                            self.last_update_time.is_set or
                            self.lsp_regeneration_count.is_set or
                            self.lsp_regeneration_serial.is_set or
                            self.name.is_set or
                            self.no_route_change_spf_nos.is_set or
                            self.not_interested_spf_nos.is_set or
                            self.route_change_spf_nos.is_set or
                            self.total_spf_nos.is_set)

                    def has_operation(self):
                        for c in self.instance:
                            if (c.has_operation()):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.arch_lsp_regeneration.yfilter != YFilter.not_set or
                            self.arch_spf_event.yfilter != YFilter.not_set or
                            self.last_update_time.yfilter != YFilter.not_set or
                            self.lsp_regeneration_count.yfilter != YFilter.not_set or
                            self.lsp_regeneration_serial.yfilter != YFilter.not_set or
                            self.name.yfilter != YFilter.not_set or
                            self.no_route_change_spf_nos.yfilter != YFilter.not_set or
                            self.not_interested_spf_nos.yfilter != YFilter.not_set or
                            self.route_change_spf_nos.yfilter != YFilter.not_set or
                            self.total_spf_nos.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "instance-name" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/ldp/process/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.arch_lsp_regeneration.is_set or self.arch_lsp_regeneration.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.arch_lsp_regeneration.get_name_leafdata())
                        if (self.arch_spf_event.is_set or self.arch_spf_event.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.arch_spf_event.get_name_leafdata())
                        if (self.last_update_time.is_set or self.last_update_time.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.last_update_time.get_name_leafdata())
                        if (self.lsp_regeneration_count.is_set or self.lsp_regeneration_count.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsp_regeneration_count.get_name_leafdata())
                        if (self.lsp_regeneration_serial.is_set or self.lsp_regeneration_serial.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lsp_regeneration_serial.get_name_leafdata())
                        if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.name.get_name_leafdata())
                        if (self.no_route_change_spf_nos.is_set or self.no_route_change_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.no_route_change_spf_nos.get_name_leafdata())
                        if (self.not_interested_spf_nos.is_set or self.not_interested_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.not_interested_spf_nos.get_name_leafdata())
                        if (self.route_change_spf_nos.is_set or self.route_change_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.route_change_spf_nos.get_name_leafdata())
                        if (self.total_spf_nos.is_set or self.total_spf_nos.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.total_spf_nos.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "instance"):
                            for c in self.instance:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = Rcmd.Process.Ldp.Process.InstanceName.Instance()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.instance.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "instance" or name == "arch-lsp-regeneration" or name == "arch-spf-event" or name == "last-update-time" or name == "lsp-regeneration-count" or name == "lsp-regeneration-serial" or name == "name" or name == "no-route-change-spf-nos" or name == "not-interested-spf-nos" or name == "route-change-spf-nos" or name == "total-spf-nos"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "arch-lsp-regeneration"):
                            self.arch_lsp_regeneration = value
                            self.arch_lsp_regeneration.value_namespace = name_space
                            self.arch_lsp_regeneration.value_namespace_prefix = name_space_prefix
                        if(value_path == "arch-spf-event"):
                            self.arch_spf_event = value
                            self.arch_spf_event.value_namespace = name_space
                            self.arch_spf_event.value_namespace_prefix = name_space_prefix
                        if(value_path == "last-update-time"):
                            self.last_update_time = value
                            self.last_update_time.value_namespace = name_space
                            self.last_update_time.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsp-regeneration-count"):
                            self.lsp_regeneration_count = value
                            self.lsp_regeneration_count.value_namespace = name_space
                            self.lsp_regeneration_count.value_namespace_prefix = name_space_prefix
                        if(value_path == "lsp-regeneration-serial"):
                            self.lsp_regeneration_serial = value
                            self.lsp_regeneration_serial.value_namespace = name_space
                            self.lsp_regeneration_serial.value_namespace_prefix = name_space_prefix
                        if(value_path == "name"):
                            self.name = value
                            self.name.value_namespace = name_space
                            self.name.value_namespace_prefix = name_space_prefix
                        if(value_path == "no-route-change-spf-nos"):
                            self.no_route_change_spf_nos = value
                            self.no_route_change_spf_nos.value_namespace = name_space
                            self.no_route_change_spf_nos.value_namespace_prefix = name_space_prefix
                        if(value_path == "not-interested-spf-nos"):
                            self.not_interested_spf_nos = value
                            self.not_interested_spf_nos.value_namespace = name_space
                            self.not_interested_spf_nos.value_namespace_prefix = name_space_prefix
                        if(value_path == "route-change-spf-nos"):
                            self.route_change_spf_nos = value
                            self.route_change_spf_nos.value_namespace = name_space
                            self.route_change_spf_nos.value_namespace_prefix = name_space_prefix
                        if(value_path == "total-spf-nos"):
                            self.total_spf_nos = value
                            self.total_spf_nos.value_namespace = name_space
                            self.total_spf_nos.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.instance_name:
                        if (c.has_data()):
                            return True
                    return (
                        self.process_name.is_set or
                        self.protocol_id.is_set)

                def has_operation(self):
                    for c in self.instance_name:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.process_name.yfilter != YFilter.not_set or
                        self.protocol_id.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "process" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/ldp/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.process_name.get_name_leafdata())
                    if (self.protocol_id.is_set or self.protocol_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.protocol_id.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "instance-name"):
                        for c in self.instance_name:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = Rcmd.Process.Ldp.Process.InstanceName()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.instance_name.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "instance-name" or name == "process-name" or name == "protocol-id"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "process-name"):
                        self.process_name = value
                        self.process_name.value_namespace = name_space
                        self.process_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "protocol-id"):
                        self.protocol_id = value
                        self.protocol_id.value_namespace = name_space
                        self.protocol_id.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.process:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.process:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "ldp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/process/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "process"):
                    for c in self.process:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = Rcmd.Process.Ldp.Process()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.process.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "process"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.isis is not None and self.isis.has_data()) or
                (self.ldp is not None and self.ldp.has_data()) or
                (self.ospf is not None and self.ospf.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.isis is not None and self.isis.has_operation()) or
                (self.ldp is not None and self.ldp.has_operation()) or
                (self.ospf is not None and self.ospf.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "process" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "isis"):
                if (self.isis is None):
                    self.isis = Rcmd.Process.Isis()
                    self.isis.parent = self
                    self._children_name_map["isis"] = "isis"
                return self.isis

            if (child_yang_name == "ldp"):
                if (self.ldp is None):
                    self.ldp = Rcmd.Process.Ldp()
                    self.ldp.parent = self
                    self._children_name_map["ldp"] = "ldp"
                return self.ldp

            if (child_yang_name == "ospf"):
                if (self.ospf is None):
                    self.ospf = Rcmd.Process.Ospf()
                    self.ospf.parent = self
                    self._children_name_map["ospf"] = "ospf"
                return self.ospf

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "isis" or name == "ldp" or name == "ospf"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.intf is not None and self.intf.has_data()) or
            (self.isis is not None and self.isis.has_data()) or
            (self.ldp is not None and self.ldp.has_data()) or
            (self.memory is not None and self.memory.has_data()) or
            (self.node is not None and self.node.has_data()) or
            (self.ospf is not None and self.ospf.has_data()) or
            (self.process is not None and self.process.has_data()) or
            (self.server is not None and self.server.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.intf is not None and self.intf.has_operation()) or
            (self.isis is not None and self.isis.has_operation()) or
            (self.ldp is not None and self.ldp.has_operation()) or
            (self.memory is not None and self.memory.has_operation()) or
            (self.node is not None and self.node.has_operation()) or
            (self.ospf is not None and self.ospf.has_operation()) or
            (self.process is not None and self.process.has_operation()) or
            (self.server is not None and self.server.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-infra-rcmd-oper:rcmd" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "intf"):
            if (self.intf is None):
                self.intf = Rcmd.Intf()
                self.intf.parent = self
                self._children_name_map["intf"] = "intf"
            return self.intf

        if (child_yang_name == "isis"):
            if (self.isis is None):
                self.isis = Rcmd.Isis()
                self.isis.parent = self
                self._children_name_map["isis"] = "isis"
            return self.isis

        if (child_yang_name == "ldp"):
            if (self.ldp is None):
                self.ldp = Rcmd.Ldp()
                self.ldp.parent = self
                self._children_name_map["ldp"] = "ldp"
            return self.ldp

        if (child_yang_name == "memory"):
            if (self.memory is None):
                self.memory = Rcmd.Memory()
                self.memory.parent = self
                self._children_name_map["memory"] = "memory"
            return self.memory

        if (child_yang_name == "node"):
            if (self.node is None):
                self.node = Rcmd.Node()
                self.node.parent = self
                self._children_name_map["node"] = "node"
            return self.node

        if (child_yang_name == "ospf"):
            if (self.ospf is None):
                self.ospf = Rcmd.Ospf()
                self.ospf.parent = self
                self._children_name_map["ospf"] = "ospf"
            return self.ospf

        if (child_yang_name == "process"):
            if (self.process is None):
                self.process = Rcmd.Process()
                self.process.parent = self
                self._children_name_map["process"] = "process"
            return self.process

        if (child_yang_name == "server"):
            if (self.server is None):
                self.server = Rcmd.Server()
                self.server.parent = self
                self._children_name_map["server"] = "server"
            return self.server

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "intf" or name == "isis" or name == "ldp" or name == "memory" or name == "node" or name == "ospf" or name == "process" or name == "server"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = Rcmd()
        return self._top_entity

