""" CISCO_TAP2_MIB 

This module manages Cisco's intercept feature.
This MIB replaces CISCO\-TAP\-MIB. This MIB defines
a generic stream table that contains fields common to
all intercept types. Specific intercept filters are
defined in extension MIBs. They are CISCO\-IP\-TAP\-MIB
for IP intercepts, CISCO\-802\-TAP\-MIB for IEEE 802
intercepts and CISCO\-USER\-CONNECTION\-TAP\-MIB for
RADIUS\-based user connection intercepts.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error



class CiscoTap2Mib(Entity):
    """
    
    
    .. attribute:: ctap2debuggroup
    
    	
    	**type**\:   :py:class:`Ctap2Debuggroup <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Debuggroup>`
    
    .. attribute:: ctap2debugtable
    
    	A table that contains Lawful Intercept debug messages generated by the implementing device. This table is used  by ciscoTap2MediationDebug and ciscoTap2StreamDebug  notifications.  An entry in this table contains a debug message which is regarding either a Mediation Device or a intercept stream  created by a Mediation Device. The Mediation device is  identified by cTap2DebugMediationId whose value is that of cTap2MediationContentId of cTapMediationEntry. The stream is identified by cTap2DebugMediationId and cTap2DebugStreamId whose values are that of  cTap2MediationContentId and cTap2StreamIndex of  the corresponding cTap2StreamEntry.  Note that cTap2DebugStreamId may be zero for an entry, in which case the debug message is regarding a Medation Device.  Entries are added to this table via cTap2DebugStatus in accordance with the RowStatus convention
    	**type**\:   :py:class:`Ctap2Debugtable <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Debugtable>`
    
    .. attribute:: ctap2debugusertable
    
    	The User Table lists information of all the users configured in the system who are given permission by different Mediation Devices to access Lawful Intercept CLIs.  This table will have dependancy on cTap2MediationTable. When entry in cTap2MediationTable is deleted or moved to 'notInService', entries corresponding cTap2MediationContentId in this table will be deleted
    	**type**\:   :py:class:`Ctap2Debugusertable <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Debugusertable>`
    
    .. attribute:: ctap2mediationgroup
    
    	
    	**type**\:   :py:class:`Ctap2Mediationgroup <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Mediationgroup>`
    
    .. attribute:: ctap2mediationtable
    
    	This table lists the Mediation Devices with which the intercepting device communicates. These may be on the same or different Mediation Devices.   This table is written by the Mediation Device, and is always volatile. This is because intercepts may disappear during a restart of the intercepting equipment.  Entries are added to this table via cTap2MediationStatus in  accordance with the RowStatus convention
    	**type**\:   :py:class:`Ctap2Mediationtable <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Mediationtable>`
    
    .. attribute:: ctap2streamtable
    
    	The Intercept Stream Table lists the traffic streams to be intercepted. The same data stream may be required by multiple  taps, and one might assume that often the intercepted stream  is a small subset of the traffic that could be intercepted.   The Table consists of generic fields that are independent of the type of intercept. It contains type of the specific  filter which is defined in an extension MIB and counters to  account for packets intercepted or dropped by the attached filter specification.  Note that the Mediation Device must make sure there is  only one type of specific filter created with the same  indices as that of a row in this table, otherwise the  later creations will fail. For example, if there is a  row in this table with index 1.2, there can be a  corresponding row with the same index either in  citapStreamTable, c8tapStreamTable or cuctTapStreamTable, but not all.    The first index indicates which Mediation Device the intercepted traffic will be diverted to. The second index permits multiple classifiers to be used together.   Entries are added to this table via cTap2StreamStatus in accordance with the RowStatus convention
    	**type**\:   :py:class:`Ctap2Streamtable <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Streamtable>`
    
    

    """

    _prefix = 'CISCO-TAP2-MIB'
    _revision = '2009-11-06'

    def __init__(self):
        super(CiscoTap2Mib, self).__init__()
        self._top_entity = None

        self.yang_name = "CISCO-TAP2-MIB"
        self.yang_parent_name = "CISCO-TAP2-MIB"

        self.ctap2debuggroup = CiscoTap2Mib.Ctap2Debuggroup()
        self.ctap2debuggroup.parent = self
        self._children_name_map["ctap2debuggroup"] = "cTap2DebugGroup"
        self._children_yang_names.add("cTap2DebugGroup")

        self.ctap2debugtable = CiscoTap2Mib.Ctap2Debugtable()
        self.ctap2debugtable.parent = self
        self._children_name_map["ctap2debugtable"] = "cTap2DebugTable"
        self._children_yang_names.add("cTap2DebugTable")

        self.ctap2debugusertable = CiscoTap2Mib.Ctap2Debugusertable()
        self.ctap2debugusertable.parent = self
        self._children_name_map["ctap2debugusertable"] = "cTap2DebugUserTable"
        self._children_yang_names.add("cTap2DebugUserTable")

        self.ctap2mediationgroup = CiscoTap2Mib.Ctap2Mediationgroup()
        self.ctap2mediationgroup.parent = self
        self._children_name_map["ctap2mediationgroup"] = "cTap2MediationGroup"
        self._children_yang_names.add("cTap2MediationGroup")

        self.ctap2mediationtable = CiscoTap2Mib.Ctap2Mediationtable()
        self.ctap2mediationtable.parent = self
        self._children_name_map["ctap2mediationtable"] = "cTap2MediationTable"
        self._children_yang_names.add("cTap2MediationTable")

        self.ctap2streamtable = CiscoTap2Mib.Ctap2Streamtable()
        self.ctap2streamtable.parent = self
        self._children_name_map["ctap2streamtable"] = "cTap2StreamTable"
        self._children_yang_names.add("cTap2StreamTable")


    class Ctap2Mediationgroup(Entity):
        """
        
        
        .. attribute:: ctap2mediationcapabilities
        
        	This object displays the device capabilities with respect to certain fields in Mediation Device table. This may be dependent on hardware capabilities, software capabilities. The following values may be supported\:     ipV4SrcInterface\:  SNMP ifIndex Value may be used to select                        the interface (denoted by                        cTap2MediationSrcInterface) on the                        intercepting device from which to                        transmit intercepted data to an IPv4                        address Mediation Device.       ipV6SrcInterface\:  SNMP ifIndex Value may be used to select                        the interface (denoted by                        cTap2MediationSrcInterface) on the                        intercepting device from which to                        transmit intercepted data to an IPv6                        address Mediation Device.       udp\:               UDP may be used as transport protocol                        (denoted by cTap2MediationTransport) in                        transferring intercepted data to the                        Mediation Device.       rtcpNack\:          RTP with Nack resilience may be used                        as transport protocol (denoted by                        cTap2MediationTransport) in transferring                        intercepted data to the Mediation                        Device.      tcp\:               TCP may be used as transport protocol                        (denoted by cTap2MediationTransport) in                        transferring intercepted data to the                        Mediation Device.       sctp\:              SCTP may be used as transport protocol                        (denoted by cTap2MediationTransport) in                        transferring intercepted data to the                        Mediation Device.      rtp\:               RTP may be used as transport protocol                        (denoted by cTap2MediationTransport) in                        transferring intercepted data to the                        Mediation Device.       radius\:            Radius may be used as transport protocol                        (denoted by cTap2MediationTransport) in                        transferring intercepted information to                         the Mediation Device
        	**type**\:   :py:class:`Ctap2Mediationcapabilities <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Mediationgroup.Ctap2Mediationcapabilities>`
        
        .. attribute:: ctap2mediationnewindex
        
        	This object contains a value which may be used as an index value for a new cTap2MediationEntry. Whenever read, the agent will change the value to a new non\-conflicting value.  This is to reduce the probability of errors during creation of new cTap2MediationTable entries
        	**type**\:  int
        
        	**range:** 1..2147483647
        
        

        """

        _prefix = 'CISCO-TAP2-MIB'
        _revision = '2009-11-06'

        def __init__(self):
            super(CiscoTap2Mib.Ctap2Mediationgroup, self).__init__()

            self.yang_name = "cTap2MediationGroup"
            self.yang_parent_name = "CISCO-TAP2-MIB"

            self.ctap2mediationcapabilities = YLeaf(YType.bits, "cTap2MediationCapabilities")

            self.ctap2mediationnewindex = YLeaf(YType.int32, "cTap2MediationNewIndex")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("ctap2mediationcapabilities",
                            "ctap2mediationnewindex") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoTap2Mib.Ctap2Mediationgroup, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoTap2Mib.Ctap2Mediationgroup, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.ctap2mediationcapabilities.is_set or
                self.ctap2mediationnewindex.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.ctap2mediationcapabilities.yfilter != YFilter.not_set or
                self.ctap2mediationnewindex.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "cTap2MediationGroup" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.ctap2mediationcapabilities.is_set or self.ctap2mediationcapabilities.yfilter != YFilter.not_set):
                leaf_name_data.append(self.ctap2mediationcapabilities.get_name_leafdata())
            if (self.ctap2mediationnewindex.is_set or self.ctap2mediationnewindex.yfilter != YFilter.not_set):
                leaf_name_data.append(self.ctap2mediationnewindex.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cTap2MediationCapabilities" or name == "cTap2MediationNewIndex"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "cTap2MediationCapabilities"):
                self.ctap2mediationcapabilities[value] = True
            if(value_path == "cTap2MediationNewIndex"):
                self.ctap2mediationnewindex = value
                self.ctap2mediationnewindex.value_namespace = name_space
                self.ctap2mediationnewindex.value_namespace_prefix = name_space_prefix


    class Ctap2Debuggroup(Entity):
        """
        
        
        .. attribute:: ctap2debugage
        
        	This object contains the duration in minutes for which an entry in cTap2DebugTable is maintained by the implementing device after which the entry is deleted. The management station also has the option of deleting the entry itself by setting cTap2DebugStatus
        	**type**\:  int
        
        	**range:** 1..2147483647
        
        .. attribute:: ctap2debugmaxentries
        
        	This object contains the maximum number of debug messages maintained by the implementing device at a time. If this  limit is crossed, most recent message will replace the least recent message
        	**type**\:  int
        
        	**range:** 1..2147483647
        
        

        """

        _prefix = 'CISCO-TAP2-MIB'
        _revision = '2009-11-06'

        def __init__(self):
            super(CiscoTap2Mib.Ctap2Debuggroup, self).__init__()

            self.yang_name = "cTap2DebugGroup"
            self.yang_parent_name = "CISCO-TAP2-MIB"

            self.ctap2debugage = YLeaf(YType.int32, "cTap2DebugAge")

            self.ctap2debugmaxentries = YLeaf(YType.int32, "cTap2DebugMaxEntries")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("ctap2debugage",
                            "ctap2debugmaxentries") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoTap2Mib.Ctap2Debuggroup, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoTap2Mib.Ctap2Debuggroup, self).__setattr__(name, value)

        def has_data(self):
            return (
                self.ctap2debugage.is_set or
                self.ctap2debugmaxentries.is_set)

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.ctap2debugage.yfilter != YFilter.not_set or
                self.ctap2debugmaxentries.yfilter != YFilter.not_set)

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "cTap2DebugGroup" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.ctap2debugage.is_set or self.ctap2debugage.yfilter != YFilter.not_set):
                leaf_name_data.append(self.ctap2debugage.get_name_leafdata())
            if (self.ctap2debugmaxentries.is_set or self.ctap2debugmaxentries.yfilter != YFilter.not_set):
                leaf_name_data.append(self.ctap2debugmaxentries.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cTap2DebugAge" or name == "cTap2DebugMaxEntries"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "cTap2DebugAge"):
                self.ctap2debugage = value
                self.ctap2debugage.value_namespace = name_space
                self.ctap2debugage.value_namespace_prefix = name_space_prefix
            if(value_path == "cTap2DebugMaxEntries"):
                self.ctap2debugmaxentries = value
                self.ctap2debugmaxentries.value_namespace = name_space
                self.ctap2debugmaxentries.value_namespace_prefix = name_space_prefix


    class Ctap2Mediationtable(Entity):
        """
        This table lists the Mediation Devices with which the
        intercepting device communicates. These may be on the same or
        different Mediation Devices.
        
        
        This table is written by the Mediation Device, and is always
        volatile. This is because intercepts may disappear during a
        restart of the intercepting equipment.
        
        Entries are added to this table via cTap2MediationStatus in 
        accordance with the RowStatus convention.
        
        .. attribute:: ctap2mediationentry
        
        	The entry describes a single session maintained with an application on a Mediation Device
        	**type**\: list of    :py:class:`Ctap2Mediationentry <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Mediationtable.Ctap2Mediationentry>`
        
        

        """

        _prefix = 'CISCO-TAP2-MIB'
        _revision = '2009-11-06'

        def __init__(self):
            super(CiscoTap2Mib.Ctap2Mediationtable, self).__init__()

            self.yang_name = "cTap2MediationTable"
            self.yang_parent_name = "CISCO-TAP2-MIB"

            self.ctap2mediationentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoTap2Mib.Ctap2Mediationtable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoTap2Mib.Ctap2Mediationtable, self).__setattr__(name, value)


        class Ctap2Mediationentry(Entity):
            """
            The entry describes a single session maintained with an
            application on a Mediation Device.
            
            .. attribute:: ctap2mediationcontentid  <key>
            
            	cTap2MediationContentId is a session identifier, from the intercept application's perspective, and a content identifier from the Mediation Device's perspective. The Mediation Device is responsible for making sure these are unique, although the SNMP RowStatus row creation process will help by not allowing it to create conflicting entries. Before creating a new entry, a value for this variable may be obtained by reading cTap2MediationNewIndex to reduce the probability of a value collision
            	**type**\:  int
            
            	**range:** 1..2147483647
            
            .. attribute:: ctap2mediationdatatype
            
            	If RTP with Ack/Nack resilience is selected as a transport, the mediation process requires an RTP payload type for data transmissions, and a second RTP payload type for retransmissions.  This is the RTP payload type for transmissions.   This object is only effective when the value of cTap2MediationTransport is 'rtpNack'
            	**type**\:  int
            
            	**range:** 0..127
            
            .. attribute:: ctap2mediationdestaddress
            
            	The IP Address of the Mediation Device's network interface to which to direct intercepted traffic
            	**type**\:  str
            
            	**length:** 0..255
            
            .. attribute:: ctap2mediationdestaddresstype
            
            	The type of cTap2MediationDestAddress
            	**type**\:   :py:class:`Inetaddresstype <ydk.models.cisco_ios_xe.INET_ADDRESS_MIB.Inetaddresstype>`
            
            .. attribute:: ctap2mediationdestport
            
            	The port number on the Mediation Device's network interface to which to direct intercepted traffic
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: ctap2mediationdscp
            
            	The Differentiated Services Code Point the intercepting device applies to the IP packets encapsulating the intercepted traffic
            	**type**\:  int
            
            	**range:** 0..63
            
            .. attribute:: ctap2mediationnotificationenable
            
            	This variable controls the generation of any notifications or informs by the MIB agent for this table entry
            	**type**\:  bool
            
            .. attribute:: ctap2mediationradiuskey
            
            	Radius Authentication Key is the shared secret key between  radius client and server
            	**type**\:  str
            
            	**length:** 0..64
            
            .. attribute:: ctap2mediationretransmittype
            
            	If RTP with Ack/Nack resilience is selected as a transport, the mediation process requires an RTP payload type for data transmissions, and a second RTP payload type for retransmissions.  This is the RTP payload type for retransmissions.   This object is only effective when the value of cTap2MediationTransport is 'rtpNack'
            	**type**\:  int
            
            	**range:** 0..127
            
            .. attribute:: ctap2mediationrtcpport
            
            	The port number on the intercepting device to which the Mediation Devices directs RTCP Receiver Reports and Nacks. This object is only relevant when the value of cTap2MediationTransport is 'rtpNack'.   This port is assigned by the intercepting device, rather than by the Mediation Device or manager application.  The value of this MIB object has no effect before activating the cTap2MediationEntry
            	**type**\:  int
            
            	**range:** 0..65535
            
            .. attribute:: ctap2mediationsrcinterface
            
            	The interface on the intercepting device from which to transmit intercepted data. If zero, any interface may be used according to normal IP practice
            	**type**\:  int
            
            	**range:** 0..2147483647
            
            .. attribute:: ctap2mediationstatus
            
            	The status of this conceptual row. This object is used to manage creation, modification and deletion of rows in this table.   cTap2MediationTimeout may be modified at any time (even while the row is active). But when the row is active, the other writable objects may not be modified without setting its value to 'notInService'.   The entry may not be deleted or deactivated by setting its value to 'destroy' or 'notInService' if there is any associated entry in cTap2StreamTable
            	**type**\:   :py:class:`Rowstatus <ydk.models.cisco_ios_xe.SNMPv2_TC.Rowstatus>`
            
            .. attribute:: ctap2mediationtimeout
            
            	The time at which this row and all related Stream Table rows should be automatically removed, and the intercept function cease. Since the initiating network manager may be the only device able to manage a specific intercept or know of its existence, this acts as a fail\-safe for the failure or removal of the network manager. The object is only effective when the value of cTap2MediationStatus is 'active'
            	**type**\:  str
            
            .. attribute:: ctap2mediationtransport
            
            	The protocol used in transferring intercepted data to the Mediation Device. The following protocols may be supported\:            udp\:     PacketCable udp format            rtpNack\: RTP with Nack resilience            tcp\:     TCP with head of line blocking            sctp\:    SCTP with head of line blocking             rtp\:     Realtime Transport Protocol(RTP)                     packet format            radius\:  Use Radius, PacketCable1.5 Event Message                     to transport the intercepted information
            	**type**\:   :py:class:`Ctap2Mediationtransport <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Mediationtable.Ctap2Mediationentry.Ctap2Mediationtransport>`
            
            

            """

            _prefix = 'CISCO-TAP2-MIB'
            _revision = '2009-11-06'

            def __init__(self):
                super(CiscoTap2Mib.Ctap2Mediationtable.Ctap2Mediationentry, self).__init__()

                self.yang_name = "cTap2MediationEntry"
                self.yang_parent_name = "cTap2MediationTable"

                self.ctap2mediationcontentid = YLeaf(YType.int32, "cTap2MediationContentId")

                self.ctap2mediationdatatype = YLeaf(YType.int32, "cTap2MediationDataType")

                self.ctap2mediationdestaddress = YLeaf(YType.str, "cTap2MediationDestAddress")

                self.ctap2mediationdestaddresstype = YLeaf(YType.enumeration, "cTap2MediationDestAddressType")

                self.ctap2mediationdestport = YLeaf(YType.uint16, "cTap2MediationDestPort")

                self.ctap2mediationdscp = YLeaf(YType.int32, "cTap2MediationDscp")

                self.ctap2mediationnotificationenable = YLeaf(YType.boolean, "cTap2MediationNotificationEnable")

                self.ctap2mediationradiuskey = YLeaf(YType.str, "cTap2MediationRadiusKey")

                self.ctap2mediationretransmittype = YLeaf(YType.int32, "cTap2MediationRetransmitType")

                self.ctap2mediationrtcpport = YLeaf(YType.uint16, "cTap2MediationRtcpPort")

                self.ctap2mediationsrcinterface = YLeaf(YType.int32, "cTap2MediationSrcInterface")

                self.ctap2mediationstatus = YLeaf(YType.enumeration, "cTap2MediationStatus")

                self.ctap2mediationtimeout = YLeaf(YType.str, "cTap2MediationTimeout")

                self.ctap2mediationtransport = YLeaf(YType.enumeration, "cTap2MediationTransport")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("ctap2mediationcontentid",
                                "ctap2mediationdatatype",
                                "ctap2mediationdestaddress",
                                "ctap2mediationdestaddresstype",
                                "ctap2mediationdestport",
                                "ctap2mediationdscp",
                                "ctap2mediationnotificationenable",
                                "ctap2mediationradiuskey",
                                "ctap2mediationretransmittype",
                                "ctap2mediationrtcpport",
                                "ctap2mediationsrcinterface",
                                "ctap2mediationstatus",
                                "ctap2mediationtimeout",
                                "ctap2mediationtransport") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoTap2Mib.Ctap2Mediationtable.Ctap2Mediationentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoTap2Mib.Ctap2Mediationtable.Ctap2Mediationentry, self).__setattr__(name, value)

            class Ctap2Mediationtransport(Enum):
                """
                Ctap2Mediationtransport

                The protocol used in transferring intercepted data to the

                Mediation Device. The following protocols may be supported\:

                           udp\:     PacketCable udp format

                           rtpNack\: RTP with Nack resilience

                           tcp\:     TCP with head of line blocking

                           sctp\:    SCTP with head of line blocking 

                           rtp\:     Realtime Transport Protocol(RTP)

                                    packet format

                           radius\:  Use Radius, PacketCable1.5 Event Message

                                    to transport the intercepted information.

                .. data:: udp = 1

                .. data:: rtpNack = 2

                .. data:: tcp = 3

                .. data:: sctp = 4

                .. data:: rtp = 5

                .. data:: radius = 6

                """

                udp = Enum.YLeaf(1, "udp")

                rtpNack = Enum.YLeaf(2, "rtpNack")

                tcp = Enum.YLeaf(3, "tcp")

                sctp = Enum.YLeaf(4, "sctp")

                rtp = Enum.YLeaf(5, "rtp")

                radius = Enum.YLeaf(6, "radius")


            def has_data(self):
                return (
                    self.ctap2mediationcontentid.is_set or
                    self.ctap2mediationdatatype.is_set or
                    self.ctap2mediationdestaddress.is_set or
                    self.ctap2mediationdestaddresstype.is_set or
                    self.ctap2mediationdestport.is_set or
                    self.ctap2mediationdscp.is_set or
                    self.ctap2mediationnotificationenable.is_set or
                    self.ctap2mediationradiuskey.is_set or
                    self.ctap2mediationretransmittype.is_set or
                    self.ctap2mediationrtcpport.is_set or
                    self.ctap2mediationsrcinterface.is_set or
                    self.ctap2mediationstatus.is_set or
                    self.ctap2mediationtimeout.is_set or
                    self.ctap2mediationtransport.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.ctap2mediationcontentid.yfilter != YFilter.not_set or
                    self.ctap2mediationdatatype.yfilter != YFilter.not_set or
                    self.ctap2mediationdestaddress.yfilter != YFilter.not_set or
                    self.ctap2mediationdestaddresstype.yfilter != YFilter.not_set or
                    self.ctap2mediationdestport.yfilter != YFilter.not_set or
                    self.ctap2mediationdscp.yfilter != YFilter.not_set or
                    self.ctap2mediationnotificationenable.yfilter != YFilter.not_set or
                    self.ctap2mediationradiuskey.yfilter != YFilter.not_set or
                    self.ctap2mediationretransmittype.yfilter != YFilter.not_set or
                    self.ctap2mediationrtcpport.yfilter != YFilter.not_set or
                    self.ctap2mediationsrcinterface.yfilter != YFilter.not_set or
                    self.ctap2mediationstatus.yfilter != YFilter.not_set or
                    self.ctap2mediationtimeout.yfilter != YFilter.not_set or
                    self.ctap2mediationtransport.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "cTap2MediationEntry" + "[cTap2MediationContentId='" + self.ctap2mediationcontentid.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/cTap2MediationTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.ctap2mediationcontentid.is_set or self.ctap2mediationcontentid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationcontentid.get_name_leafdata())
                if (self.ctap2mediationdatatype.is_set or self.ctap2mediationdatatype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationdatatype.get_name_leafdata())
                if (self.ctap2mediationdestaddress.is_set or self.ctap2mediationdestaddress.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationdestaddress.get_name_leafdata())
                if (self.ctap2mediationdestaddresstype.is_set or self.ctap2mediationdestaddresstype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationdestaddresstype.get_name_leafdata())
                if (self.ctap2mediationdestport.is_set or self.ctap2mediationdestport.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationdestport.get_name_leafdata())
                if (self.ctap2mediationdscp.is_set or self.ctap2mediationdscp.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationdscp.get_name_leafdata())
                if (self.ctap2mediationnotificationenable.is_set or self.ctap2mediationnotificationenable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationnotificationenable.get_name_leafdata())
                if (self.ctap2mediationradiuskey.is_set or self.ctap2mediationradiuskey.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationradiuskey.get_name_leafdata())
                if (self.ctap2mediationretransmittype.is_set or self.ctap2mediationretransmittype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationretransmittype.get_name_leafdata())
                if (self.ctap2mediationrtcpport.is_set or self.ctap2mediationrtcpport.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationrtcpport.get_name_leafdata())
                if (self.ctap2mediationsrcinterface.is_set or self.ctap2mediationsrcinterface.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationsrcinterface.get_name_leafdata())
                if (self.ctap2mediationstatus.is_set or self.ctap2mediationstatus.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationstatus.get_name_leafdata())
                if (self.ctap2mediationtimeout.is_set or self.ctap2mediationtimeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationtimeout.get_name_leafdata())
                if (self.ctap2mediationtransport.is_set or self.ctap2mediationtransport.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationtransport.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "cTap2MediationContentId" or name == "cTap2MediationDataType" or name == "cTap2MediationDestAddress" or name == "cTap2MediationDestAddressType" or name == "cTap2MediationDestPort" or name == "cTap2MediationDscp" or name == "cTap2MediationNotificationEnable" or name == "cTap2MediationRadiusKey" or name == "cTap2MediationRetransmitType" or name == "cTap2MediationRtcpPort" or name == "cTap2MediationSrcInterface" or name == "cTap2MediationStatus" or name == "cTap2MediationTimeout" or name == "cTap2MediationTransport"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "cTap2MediationContentId"):
                    self.ctap2mediationcontentid = value
                    self.ctap2mediationcontentid.value_namespace = name_space
                    self.ctap2mediationcontentid.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationDataType"):
                    self.ctap2mediationdatatype = value
                    self.ctap2mediationdatatype.value_namespace = name_space
                    self.ctap2mediationdatatype.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationDestAddress"):
                    self.ctap2mediationdestaddress = value
                    self.ctap2mediationdestaddress.value_namespace = name_space
                    self.ctap2mediationdestaddress.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationDestAddressType"):
                    self.ctap2mediationdestaddresstype = value
                    self.ctap2mediationdestaddresstype.value_namespace = name_space
                    self.ctap2mediationdestaddresstype.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationDestPort"):
                    self.ctap2mediationdestport = value
                    self.ctap2mediationdestport.value_namespace = name_space
                    self.ctap2mediationdestport.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationDscp"):
                    self.ctap2mediationdscp = value
                    self.ctap2mediationdscp.value_namespace = name_space
                    self.ctap2mediationdscp.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationNotificationEnable"):
                    self.ctap2mediationnotificationenable = value
                    self.ctap2mediationnotificationenable.value_namespace = name_space
                    self.ctap2mediationnotificationenable.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationRadiusKey"):
                    self.ctap2mediationradiuskey = value
                    self.ctap2mediationradiuskey.value_namespace = name_space
                    self.ctap2mediationradiuskey.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationRetransmitType"):
                    self.ctap2mediationretransmittype = value
                    self.ctap2mediationretransmittype.value_namespace = name_space
                    self.ctap2mediationretransmittype.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationRtcpPort"):
                    self.ctap2mediationrtcpport = value
                    self.ctap2mediationrtcpport.value_namespace = name_space
                    self.ctap2mediationrtcpport.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationSrcInterface"):
                    self.ctap2mediationsrcinterface = value
                    self.ctap2mediationsrcinterface.value_namespace = name_space
                    self.ctap2mediationsrcinterface.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationStatus"):
                    self.ctap2mediationstatus = value
                    self.ctap2mediationstatus.value_namespace = name_space
                    self.ctap2mediationstatus.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationTimeout"):
                    self.ctap2mediationtimeout = value
                    self.ctap2mediationtimeout.value_namespace = name_space
                    self.ctap2mediationtimeout.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2MediationTransport"):
                    self.ctap2mediationtransport = value
                    self.ctap2mediationtransport.value_namespace = name_space
                    self.ctap2mediationtransport.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ctap2mediationentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ctap2mediationentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "cTap2MediationTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "cTap2MediationEntry"):
                for c in self.ctap2mediationentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoTap2Mib.Ctap2Mediationtable.Ctap2Mediationentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ctap2mediationentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cTap2MediationEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ctap2Streamtable(Entity):
        """
        The Intercept Stream Table lists the traffic streams to be
        intercepted. The same data stream may be required by multiple 
        taps, and one might assume that often the intercepted stream 
        is a small subset of the traffic that could be intercepted.
        
        
        The Table consists of generic fields that are independent
        of the type of intercept. It contains type of the specific 
        filter which is defined in an extension MIB and counters to 
        account for packets intercepted or dropped by the attached
        filter specification.
        
        Note that the Mediation Device must make sure there is 
        only one type of specific filter created with the same 
        indices as that of a row in this table, otherwise the 
        later creations will fail. For example, if there is a 
        row in this table with index 1.2, there can be a 
        corresponding row with the same index either in 
        citapStreamTable, c8tapStreamTable or cuctTapStreamTable,
        but not all. 
        
        
        The first index indicates which Mediation Device the
        intercepted traffic will be diverted to. The second index
        permits multiple classifiers to be used together. 
        
        Entries are added to this table via cTap2StreamStatus in
        accordance with the RowStatus convention.
        
        .. attribute:: ctap2streamentry
        
        	A stream entry indicates a single data stream to be intercepted to a Mediation Device. Many selected data streams may go to the same application interface, and many application interfaces are supported
        	**type**\: list of    :py:class:`Ctap2Streamentry <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Streamtable.Ctap2Streamentry>`
        
        

        """

        _prefix = 'CISCO-TAP2-MIB'
        _revision = '2009-11-06'

        def __init__(self):
            super(CiscoTap2Mib.Ctap2Streamtable, self).__init__()

            self.yang_name = "cTap2StreamTable"
            self.yang_parent_name = "CISCO-TAP2-MIB"

            self.ctap2streamentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoTap2Mib.Ctap2Streamtable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoTap2Mib.Ctap2Streamtable, self).__setattr__(name, value)


        class Ctap2Streamentry(Entity):
            """
            A stream entry indicates a single data stream to be
            intercepted to a Mediation Device. Many selected data
            streams may go to the same application interface, and many
            application interfaces are supported.
            
            .. attribute:: ctap2mediationcontentid  <key>
            
            	
            	**type**\:  int
            
            	**range:** 1..2147483647
            
            	**refers to**\:  :py:class:`ctap2mediationcontentid <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Mediationtable.Ctap2Mediationentry>`
            
            .. attribute:: ctap2streamindex  <key>
            
            	The index of the stream itself
            	**type**\:  int
            
            	**range:** 1..2147483647
            
            .. attribute:: ctap2streaminterceptdrops
            
            	The number of packets matching this data stream specification that, having been intercepted, were dropped in the lawful intercept process
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: ctap2streaminterceptedhcpackets
            
            	The number of packets matching this data stream specification that have been intercepted. This object is a 64\-bit version of cTap2StreamInterceptedPackets
            	**type**\:  int
            
            	**range:** 0..18446744073709551615
            
            .. attribute:: ctap2streaminterceptedpackets
            
            	The number of packets matching this data stream specification that have been intercepted
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: ctap2streaminterceptenable
            
            	If 'true', the tap should intercept matching traffic. The value for this object should be set to 'true' only after an  additional filter specification has been attached to this  stream
            	**type**\:  bool
            
            .. attribute:: ctap2streamintercepthcdrops
            
            	The number of packets matching this data stream specification that, having been intercepted, were dropped in the lawful intercept process. This object is a 64\-bit version of cTap2StreamInterceptDrops
            	**type**\:  int
            
            	**range:** 0..18446744073709551615
            
            .. attribute:: ctap2streamstatus
            
            	The status of this conceptual row. This object manages creation, modification, and deletion of rows in this table. cTap2StreamInterceptEnable may be modified any time even the value of this entry rowStatus object is 'active'.  When other rows must be changed, cTap2StreamStatus must be first set to 'notInService'
            	**type**\:   :py:class:`Rowstatus <ydk.models.cisco_ios_xe.SNMPv2_TC.Rowstatus>`
            
            .. attribute:: ctap2streamtype
            
            	Identifies the type of intercept filter associated to this generic stream. The following types of streams are supported\:        ip\:             The specific filter is an IP filter                         with same indices as that of this                         table. The exact filter is a row in                         citapStreamTable of CISCO\-IP\-TAP\-MIB.        mac\:            The specific filter is a MAC filter                        with same indices as that of this table.                        The exact filter is a row in                         c8tapStreamTable of CISCO\-802\-TAP\-MIB.        userConnecton\:  The specific filter is a user connection                        filter with same indices as that of                         this table. The exact filter is a row                         in cuctTapStreamTable of                         CISCO\-USER\-CONNECTION\-TAP\-MIB.        msPdsn\:         The specific filter is a Mobile Sub                        connection filter with same indices as                        that of this table. The exact filter                        is a row in ccptapStreamTable of                         CISCO\-CDMA\-PDSN\-TAP\-MIB.        mobility\:       The specific filter is a Mobile                         Subscriber connection filter with same                        indices as that of this table. The exact                        filter is a row in cmtapStreamTable of                         CISCO\-MOBILITY\-TAP\-MIB.        voip\:           The specific filter is a VoIP                        Subscriber filter with same                        indices as that of this table. The exact                        filter is a row in cvoiptapStreamTable of                        CISCO\-VOIP\-TAP\-MIB
            	**type**\:   :py:class:`Ctap2Streamtype <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Streamtable.Ctap2Streamentry.Ctap2Streamtype>`
            
            

            """

            _prefix = 'CISCO-TAP2-MIB'
            _revision = '2009-11-06'

            def __init__(self):
                super(CiscoTap2Mib.Ctap2Streamtable.Ctap2Streamentry, self).__init__()

                self.yang_name = "cTap2StreamEntry"
                self.yang_parent_name = "cTap2StreamTable"

                self.ctap2mediationcontentid = YLeaf(YType.str, "cTap2MediationContentId")

                self.ctap2streamindex = YLeaf(YType.int32, "cTap2StreamIndex")

                self.ctap2streaminterceptdrops = YLeaf(YType.uint32, "cTap2StreamInterceptDrops")

                self.ctap2streaminterceptedhcpackets = YLeaf(YType.uint64, "cTap2StreamInterceptedHCPackets")

                self.ctap2streaminterceptedpackets = YLeaf(YType.uint32, "cTap2StreamInterceptedPackets")

                self.ctap2streaminterceptenable = YLeaf(YType.boolean, "cTap2StreamInterceptEnable")

                self.ctap2streamintercepthcdrops = YLeaf(YType.uint64, "cTap2StreamInterceptHCDrops")

                self.ctap2streamstatus = YLeaf(YType.enumeration, "cTap2StreamStatus")

                self.ctap2streamtype = YLeaf(YType.enumeration, "cTap2StreamType")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("ctap2mediationcontentid",
                                "ctap2streamindex",
                                "ctap2streaminterceptdrops",
                                "ctap2streaminterceptedhcpackets",
                                "ctap2streaminterceptedpackets",
                                "ctap2streaminterceptenable",
                                "ctap2streamintercepthcdrops",
                                "ctap2streamstatus",
                                "ctap2streamtype") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoTap2Mib.Ctap2Streamtable.Ctap2Streamentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoTap2Mib.Ctap2Streamtable.Ctap2Streamentry, self).__setattr__(name, value)

            class Ctap2Streamtype(Enum):
                """
                Ctap2Streamtype

                Identifies the type of intercept filter associated to this

                generic stream. The following types of streams are supported\:

                       ip\:             The specific filter is an IP filter 

                                       with same indices as that of this 

                                       table. The exact filter is a row in 

                                       citapStreamTable of CISCO\-IP\-TAP\-MIB.

                       mac\:            The specific filter is a MAC filter

                                       with same indices as that of this table.

                                       The exact filter is a row in 

                                       c8tapStreamTable of CISCO\-802\-TAP\-MIB.

                       userConnecton\:  The specific filter is a user connection

                                       filter with same indices as that of 

                                       this table. The exact filter is a row 

                                       in cuctTapStreamTable of 

                                       CISCO\-USER\-CONNECTION\-TAP\-MIB.

                       msPdsn\:         The specific filter is a Mobile Sub

                                       connection filter with same indices as

                                       that of this table. The exact filter

                                       is a row in ccptapStreamTable of 

                                       CISCO\-CDMA\-PDSN\-TAP\-MIB.

                       mobility\:       The specific filter is a Mobile 

                                       Subscriber connection filter with same

                                       indices as that of this table. The exact

                                       filter is a row in cmtapStreamTable of 

                                       CISCO\-MOBILITY\-TAP\-MIB.

                       voip\:           The specific filter is a VoIP

                                       Subscriber filter with same

                                       indices as that of this table. The exact

                                       filter is a row in cvoiptapStreamTable of

                                       CISCO\-VOIP\-TAP\-MIB.

                .. data:: ip = 1

                .. data:: mac = 2

                .. data:: userConnection = 3

                .. data:: msPdsn = 4

                .. data:: mobility = 5

                .. data:: voip = 6

                """

                ip = Enum.YLeaf(1, "ip")

                mac = Enum.YLeaf(2, "mac")

                userConnection = Enum.YLeaf(3, "userConnection")

                msPdsn = Enum.YLeaf(4, "msPdsn")

                mobility = Enum.YLeaf(5, "mobility")

                voip = Enum.YLeaf(6, "voip")


            def has_data(self):
                return (
                    self.ctap2mediationcontentid.is_set or
                    self.ctap2streamindex.is_set or
                    self.ctap2streaminterceptdrops.is_set or
                    self.ctap2streaminterceptedhcpackets.is_set or
                    self.ctap2streaminterceptedpackets.is_set or
                    self.ctap2streaminterceptenable.is_set or
                    self.ctap2streamintercepthcdrops.is_set or
                    self.ctap2streamstatus.is_set or
                    self.ctap2streamtype.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.ctap2mediationcontentid.yfilter != YFilter.not_set or
                    self.ctap2streamindex.yfilter != YFilter.not_set or
                    self.ctap2streaminterceptdrops.yfilter != YFilter.not_set or
                    self.ctap2streaminterceptedhcpackets.yfilter != YFilter.not_set or
                    self.ctap2streaminterceptedpackets.yfilter != YFilter.not_set or
                    self.ctap2streaminterceptenable.yfilter != YFilter.not_set or
                    self.ctap2streamintercepthcdrops.yfilter != YFilter.not_set or
                    self.ctap2streamstatus.yfilter != YFilter.not_set or
                    self.ctap2streamtype.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "cTap2StreamEntry" + "[cTap2MediationContentId='" + self.ctap2mediationcontentid.get() + "']" + "[cTap2StreamIndex='" + self.ctap2streamindex.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/cTap2StreamTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.ctap2mediationcontentid.is_set or self.ctap2mediationcontentid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationcontentid.get_name_leafdata())
                if (self.ctap2streamindex.is_set or self.ctap2streamindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2streamindex.get_name_leafdata())
                if (self.ctap2streaminterceptdrops.is_set or self.ctap2streaminterceptdrops.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2streaminterceptdrops.get_name_leafdata())
                if (self.ctap2streaminterceptedhcpackets.is_set or self.ctap2streaminterceptedhcpackets.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2streaminterceptedhcpackets.get_name_leafdata())
                if (self.ctap2streaminterceptedpackets.is_set or self.ctap2streaminterceptedpackets.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2streaminterceptedpackets.get_name_leafdata())
                if (self.ctap2streaminterceptenable.is_set or self.ctap2streaminterceptenable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2streaminterceptenable.get_name_leafdata())
                if (self.ctap2streamintercepthcdrops.is_set or self.ctap2streamintercepthcdrops.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2streamintercepthcdrops.get_name_leafdata())
                if (self.ctap2streamstatus.is_set or self.ctap2streamstatus.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2streamstatus.get_name_leafdata())
                if (self.ctap2streamtype.is_set or self.ctap2streamtype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2streamtype.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "cTap2MediationContentId" or name == "cTap2StreamIndex" or name == "cTap2StreamInterceptDrops" or name == "cTap2StreamInterceptedHCPackets" or name == "cTap2StreamInterceptedPackets" or name == "cTap2StreamInterceptEnable" or name == "cTap2StreamInterceptHCDrops" or name == "cTap2StreamStatus" or name == "cTap2StreamType"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "cTap2MediationContentId"):
                    self.ctap2mediationcontentid = value
                    self.ctap2mediationcontentid.value_namespace = name_space
                    self.ctap2mediationcontentid.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2StreamIndex"):
                    self.ctap2streamindex = value
                    self.ctap2streamindex.value_namespace = name_space
                    self.ctap2streamindex.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2StreamInterceptDrops"):
                    self.ctap2streaminterceptdrops = value
                    self.ctap2streaminterceptdrops.value_namespace = name_space
                    self.ctap2streaminterceptdrops.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2StreamInterceptedHCPackets"):
                    self.ctap2streaminterceptedhcpackets = value
                    self.ctap2streaminterceptedhcpackets.value_namespace = name_space
                    self.ctap2streaminterceptedhcpackets.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2StreamInterceptedPackets"):
                    self.ctap2streaminterceptedpackets = value
                    self.ctap2streaminterceptedpackets.value_namespace = name_space
                    self.ctap2streaminterceptedpackets.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2StreamInterceptEnable"):
                    self.ctap2streaminterceptenable = value
                    self.ctap2streaminterceptenable.value_namespace = name_space
                    self.ctap2streaminterceptenable.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2StreamInterceptHCDrops"):
                    self.ctap2streamintercepthcdrops = value
                    self.ctap2streamintercepthcdrops.value_namespace = name_space
                    self.ctap2streamintercepthcdrops.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2StreamStatus"):
                    self.ctap2streamstatus = value
                    self.ctap2streamstatus.value_namespace = name_space
                    self.ctap2streamstatus.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2StreamType"):
                    self.ctap2streamtype = value
                    self.ctap2streamtype.value_namespace = name_space
                    self.ctap2streamtype.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ctap2streamentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ctap2streamentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "cTap2StreamTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "cTap2StreamEntry"):
                for c in self.ctap2streamentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoTap2Mib.Ctap2Streamtable.Ctap2Streamentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ctap2streamentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cTap2StreamEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ctap2Debugtable(Entity):
        """
        A table that contains Lawful Intercept debug messages
        generated by the implementing device. This table is used 
        by ciscoTap2MediationDebug and ciscoTap2StreamDebug 
        notifications.
        
        An entry in this table contains a debug message which is
        regarding either a Mediation Device or a intercept stream 
        created by a Mediation Device. The Mediation device is 
        identified by cTap2DebugMediationId whose value is
        that of cTap2MediationContentId of cTapMediationEntry.
        The stream is identified by cTap2DebugMediationId and
        cTap2DebugStreamId whose values are that of 
        cTap2MediationContentId and cTap2StreamIndex of 
        the corresponding cTap2StreamEntry.
        
        Note that cTap2DebugStreamId may be zero for an entry,
        in which case the debug message is regarding a Medation
        Device.
        
        Entries are added to this table via cTap2DebugStatus in
        accordance with the RowStatus convention.
        
        .. attribute:: ctap2debugentry
        
        	A list of the debug messages
        	**type**\: list of    :py:class:`Ctap2Debugentry <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Debugtable.Ctap2Debugentry>`
        
        

        """

        _prefix = 'CISCO-TAP2-MIB'
        _revision = '2009-11-06'

        def __init__(self):
            super(CiscoTap2Mib.Ctap2Debugtable, self).__init__()

            self.yang_name = "cTap2DebugTable"
            self.yang_parent_name = "CISCO-TAP2-MIB"

            self.ctap2debugentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoTap2Mib.Ctap2Debugtable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoTap2Mib.Ctap2Debugtable, self).__setattr__(name, value)


        class Ctap2Debugentry(Entity):
            """
            A list of the debug messages.
            
            .. attribute:: ctap2debugindex  <key>
            
            	Index to the debug table
            	**type**\:  int
            
            	**range:** 1..2147483647
            
            .. attribute:: ctap2debugmediationid
            
            	The value of this object is that of cTap2MediationContentId identifying an entry in cTap2MediationTable. Note this object may contain a value for which an entry in cTap2MediationTable does not exist. This happens when creation of an entry in cTap2MediationTable fails and this debug message conveys more detailed information regarding the failure
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            .. attribute:: ctap2debugmessage
            
            	A text string contains the debug message
            	**type**\:  str
            
            .. attribute:: ctap2debugstatus
            
            	The status of this conceptual row. A row in this table is created by the implementing device. A management station cannot modify any of the objects in this row, except deleting the row by setting this object to 'destroy'
            	**type**\:   :py:class:`Rowstatus <ydk.models.cisco_ios_xe.SNMPv2_TC.Rowstatus>`
            
            .. attribute:: ctap2debugstreamid
            
            	The value of this object is that of cTap2StreamIndex of an entry in cTap2StreamTable. This object along with cTap2DebugMediationId identifies an entry in cTap2StreamTable. The value of this object may be zero, in which this debug message is regarding a Mediation Device, but not a particular stream.  Note this object may contain a value for which an  entry in cTap2MediationTable does not exist. This happens  when creation of an entry in cTap2StreamTable fails
            	**type**\:  int
            
            	**range:** 0..4294967295
            
            

            """

            _prefix = 'CISCO-TAP2-MIB'
            _revision = '2009-11-06'

            def __init__(self):
                super(CiscoTap2Mib.Ctap2Debugtable.Ctap2Debugentry, self).__init__()

                self.yang_name = "cTap2DebugEntry"
                self.yang_parent_name = "cTap2DebugTable"

                self.ctap2debugindex = YLeaf(YType.int32, "cTap2DebugIndex")

                self.ctap2debugmediationid = YLeaf(YType.uint32, "cTap2DebugMediationId")

                self.ctap2debugmessage = YLeaf(YType.str, "cTap2DebugMessage")

                self.ctap2debugstatus = YLeaf(YType.enumeration, "cTap2DebugStatus")

                self.ctap2debugstreamid = YLeaf(YType.uint32, "cTap2DebugStreamId")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("ctap2debugindex",
                                "ctap2debugmediationid",
                                "ctap2debugmessage",
                                "ctap2debugstatus",
                                "ctap2debugstreamid") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoTap2Mib.Ctap2Debugtable.Ctap2Debugentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoTap2Mib.Ctap2Debugtable.Ctap2Debugentry, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.ctap2debugindex.is_set or
                    self.ctap2debugmediationid.is_set or
                    self.ctap2debugmessage.is_set or
                    self.ctap2debugstatus.is_set or
                    self.ctap2debugstreamid.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.ctap2debugindex.yfilter != YFilter.not_set or
                    self.ctap2debugmediationid.yfilter != YFilter.not_set or
                    self.ctap2debugmessage.yfilter != YFilter.not_set or
                    self.ctap2debugstatus.yfilter != YFilter.not_set or
                    self.ctap2debugstreamid.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "cTap2DebugEntry" + "[cTap2DebugIndex='" + self.ctap2debugindex.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/cTap2DebugTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.ctap2debugindex.is_set or self.ctap2debugindex.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2debugindex.get_name_leafdata())
                if (self.ctap2debugmediationid.is_set or self.ctap2debugmediationid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2debugmediationid.get_name_leafdata())
                if (self.ctap2debugmessage.is_set or self.ctap2debugmessage.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2debugmessage.get_name_leafdata())
                if (self.ctap2debugstatus.is_set or self.ctap2debugstatus.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2debugstatus.get_name_leafdata())
                if (self.ctap2debugstreamid.is_set or self.ctap2debugstreamid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2debugstreamid.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "cTap2DebugIndex" or name == "cTap2DebugMediationId" or name == "cTap2DebugMessage" or name == "cTap2DebugStatus" or name == "cTap2DebugStreamId"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "cTap2DebugIndex"):
                    self.ctap2debugindex = value
                    self.ctap2debugindex.value_namespace = name_space
                    self.ctap2debugindex.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2DebugMediationId"):
                    self.ctap2debugmediationid = value
                    self.ctap2debugmediationid.value_namespace = name_space
                    self.ctap2debugmediationid.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2DebugMessage"):
                    self.ctap2debugmessage = value
                    self.ctap2debugmessage.value_namespace = name_space
                    self.ctap2debugmessage.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2DebugStatus"):
                    self.ctap2debugstatus = value
                    self.ctap2debugstatus.value_namespace = name_space
                    self.ctap2debugstatus.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2DebugStreamId"):
                    self.ctap2debugstreamid = value
                    self.ctap2debugstreamid.value_namespace = name_space
                    self.ctap2debugstreamid.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ctap2debugentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ctap2debugentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "cTap2DebugTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "cTap2DebugEntry"):
                for c in self.ctap2debugentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoTap2Mib.Ctap2Debugtable.Ctap2Debugentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ctap2debugentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cTap2DebugEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class Ctap2Debugusertable(Entity):
        """
        The User Table lists information of all the users configured
        in the system who are given permission by different Mediation
        Devices to access Lawful Intercept CLIs.
        
        This table will have dependancy on cTap2MediationTable. When
        entry in cTap2MediationTable is deleted or moved to
        'notInService', entries corresponding cTap2MediationContentId
        in this table will be deleted.
        
        .. attribute:: ctap2debuguserentry
        
        	A conceptual row in the cTap2DebugUserTable. Each row represents name of user on the router to whom Mediation Device with CCCid represented by cTap2MediationContentId has given access to Lawful Intercept commands and cTap2DebugUserTimeout represents the time when the entry will expire
        	**type**\: list of    :py:class:`Ctap2Debuguserentry <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Debugusertable.Ctap2Debuguserentry>`
        
        

        """

        _prefix = 'CISCO-TAP2-MIB'
        _revision = '2009-11-06'

        def __init__(self):
            super(CiscoTap2Mib.Ctap2Debugusertable, self).__init__()

            self.yang_name = "cTap2DebugUserTable"
            self.yang_parent_name = "CISCO-TAP2-MIB"

            self.ctap2debuguserentry = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(CiscoTap2Mib.Ctap2Debugusertable, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(CiscoTap2Mib.Ctap2Debugusertable, self).__setattr__(name, value)


        class Ctap2Debuguserentry(Entity):
            """
            A conceptual row in the cTap2DebugUserTable. Each row
            represents name of user on the router to whom Mediation Device
            with CCCid represented by cTap2MediationContentId has given
            access to Lawful Intercept commands and cTap2DebugUserTimeout
            represents the time when the entry will expire.
            
            .. attribute:: ctap2mediationcontentid  <key>
            
            	
            	**type**\:  int
            
            	**range:** 1..2147483647
            
            	**refers to**\:  :py:class:`ctap2mediationcontentid <ydk.models.cisco_ios_xe.CISCO_TAP2_MIB.CiscoTap2Mib.Ctap2Mediationtable.Ctap2Mediationentry>`
            
            .. attribute:: ctap2debugusername  <key>
            
            	A human readable string representing the name of debug user who will have access to Lawful Intercept commands
            	**type**\:  str
            
            	**length:** 1..255
            
            .. attribute:: ctap2debuguserstatus
            
            	The status of this conceptual row. This object manages creation, modification, and deletion of rows in this table. cTap2DebugUserTimeout may be modified any time even when the value of this entry rowStatus object is 'active'
            	**type**\:   :py:class:`Rowstatus <ydk.models.cisco_ios_xe.SNMPv2_TC.Rowstatus>`
            
            .. attribute:: ctap2debuguserstoragetype
            
            	This object specifies the storage type of this conceptual row. If it is set to 'nonVolatile', this entry can be saved into non\-volatile memory
            	**type**\:   :py:class:`Storagetype <ydk.models.cisco_ios_xe.SNMPv2_TC.Storagetype>`
            
            .. attribute:: ctap2debugusertimeout
            
            	This object specifies the time at which the row will be removed from the table by the system. The value of this object is only effective when the value of corresponding instance of cTap2DebugUserStatus is 'active'
            	**type**\:  str
            
            

            """

            _prefix = 'CISCO-TAP2-MIB'
            _revision = '2009-11-06'

            def __init__(self):
                super(CiscoTap2Mib.Ctap2Debugusertable.Ctap2Debuguserentry, self).__init__()

                self.yang_name = "cTap2DebugUserEntry"
                self.yang_parent_name = "cTap2DebugUserTable"

                self.ctap2mediationcontentid = YLeaf(YType.str, "cTap2MediationContentId")

                self.ctap2debugusername = YLeaf(YType.str, "cTap2DebugUserName")

                self.ctap2debuguserstatus = YLeaf(YType.enumeration, "cTap2DebugUserStatus")

                self.ctap2debuguserstoragetype = YLeaf(YType.enumeration, "cTap2DebugUserStorageType")

                self.ctap2debugusertimeout = YLeaf(YType.str, "cTap2DebugUserTimeout")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("ctap2mediationcontentid",
                                "ctap2debugusername",
                                "ctap2debuguserstatus",
                                "ctap2debuguserstoragetype",
                                "ctap2debugusertimeout") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(CiscoTap2Mib.Ctap2Debugusertable.Ctap2Debuguserentry, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(CiscoTap2Mib.Ctap2Debugusertable.Ctap2Debuguserentry, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.ctap2mediationcontentid.is_set or
                    self.ctap2debugusername.is_set or
                    self.ctap2debuguserstatus.is_set or
                    self.ctap2debuguserstoragetype.is_set or
                    self.ctap2debugusertimeout.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.ctap2mediationcontentid.yfilter != YFilter.not_set or
                    self.ctap2debugusername.yfilter != YFilter.not_set or
                    self.ctap2debuguserstatus.yfilter != YFilter.not_set or
                    self.ctap2debuguserstoragetype.yfilter != YFilter.not_set or
                    self.ctap2debugusertimeout.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "cTap2DebugUserEntry" + "[cTap2MediationContentId='" + self.ctap2mediationcontentid.get() + "']" + "[cTap2DebugUserName='" + self.ctap2debugusername.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/cTap2DebugUserTable/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.ctap2mediationcontentid.is_set or self.ctap2mediationcontentid.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2mediationcontentid.get_name_leafdata())
                if (self.ctap2debugusername.is_set or self.ctap2debugusername.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2debugusername.get_name_leafdata())
                if (self.ctap2debuguserstatus.is_set or self.ctap2debuguserstatus.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2debuguserstatus.get_name_leafdata())
                if (self.ctap2debuguserstoragetype.is_set or self.ctap2debuguserstoragetype.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2debuguserstoragetype.get_name_leafdata())
                if (self.ctap2debugusertimeout.is_set or self.ctap2debugusertimeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.ctap2debugusertimeout.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "cTap2MediationContentId" or name == "cTap2DebugUserName" or name == "cTap2DebugUserStatus" or name == "cTap2DebugUserStorageType" or name == "cTap2DebugUserTimeout"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "cTap2MediationContentId"):
                    self.ctap2mediationcontentid = value
                    self.ctap2mediationcontentid.value_namespace = name_space
                    self.ctap2mediationcontentid.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2DebugUserName"):
                    self.ctap2debugusername = value
                    self.ctap2debugusername.value_namespace = name_space
                    self.ctap2debugusername.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2DebugUserStatus"):
                    self.ctap2debuguserstatus = value
                    self.ctap2debuguserstatus.value_namespace = name_space
                    self.ctap2debuguserstatus.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2DebugUserStorageType"):
                    self.ctap2debuguserstoragetype = value
                    self.ctap2debuguserstoragetype.value_namespace = name_space
                    self.ctap2debuguserstoragetype.value_namespace_prefix = name_space_prefix
                if(value_path == "cTap2DebugUserTimeout"):
                    self.ctap2debugusertimeout = value
                    self.ctap2debugusertimeout.value_namespace = name_space
                    self.ctap2debugusertimeout.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.ctap2debuguserentry:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.ctap2debuguserentry:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "cTap2DebugUserTable" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "cTap2DebugUserEntry"):
                for c in self.ctap2debuguserentry:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = CiscoTap2Mib.Ctap2Debugusertable.Ctap2Debuguserentry()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.ctap2debuguserentry.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "cTap2DebugUserEntry"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass

    def has_data(self):
        return (
            (self.ctap2debuggroup is not None and self.ctap2debuggroup.has_data()) or
            (self.ctap2debugtable is not None and self.ctap2debugtable.has_data()) or
            (self.ctap2debugusertable is not None and self.ctap2debugusertable.has_data()) or
            (self.ctap2mediationgroup is not None and self.ctap2mediationgroup.has_data()) or
            (self.ctap2mediationtable is not None and self.ctap2mediationtable.has_data()) or
            (self.ctap2streamtable is not None and self.ctap2streamtable.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            (self.ctap2debuggroup is not None and self.ctap2debuggroup.has_operation()) or
            (self.ctap2debugtable is not None and self.ctap2debugtable.has_operation()) or
            (self.ctap2debugusertable is not None and self.ctap2debugusertable.has_operation()) or
            (self.ctap2mediationgroup is not None and self.ctap2mediationgroup.has_operation()) or
            (self.ctap2mediationtable is not None and self.ctap2mediationtable.has_operation()) or
            (self.ctap2streamtable is not None and self.ctap2streamtable.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "CISCO-TAP2-MIB:CISCO-TAP2-MIB" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "cTap2DebugGroup"):
            if (self.ctap2debuggroup is None):
                self.ctap2debuggroup = CiscoTap2Mib.Ctap2Debuggroup()
                self.ctap2debuggroup.parent = self
                self._children_name_map["ctap2debuggroup"] = "cTap2DebugGroup"
            return self.ctap2debuggroup

        if (child_yang_name == "cTap2DebugTable"):
            if (self.ctap2debugtable is None):
                self.ctap2debugtable = CiscoTap2Mib.Ctap2Debugtable()
                self.ctap2debugtable.parent = self
                self._children_name_map["ctap2debugtable"] = "cTap2DebugTable"
            return self.ctap2debugtable

        if (child_yang_name == "cTap2DebugUserTable"):
            if (self.ctap2debugusertable is None):
                self.ctap2debugusertable = CiscoTap2Mib.Ctap2Debugusertable()
                self.ctap2debugusertable.parent = self
                self._children_name_map["ctap2debugusertable"] = "cTap2DebugUserTable"
            return self.ctap2debugusertable

        if (child_yang_name == "cTap2MediationGroup"):
            if (self.ctap2mediationgroup is None):
                self.ctap2mediationgroup = CiscoTap2Mib.Ctap2Mediationgroup()
                self.ctap2mediationgroup.parent = self
                self._children_name_map["ctap2mediationgroup"] = "cTap2MediationGroup"
            return self.ctap2mediationgroup

        if (child_yang_name == "cTap2MediationTable"):
            if (self.ctap2mediationtable is None):
                self.ctap2mediationtable = CiscoTap2Mib.Ctap2Mediationtable()
                self.ctap2mediationtable.parent = self
                self._children_name_map["ctap2mediationtable"] = "cTap2MediationTable"
            return self.ctap2mediationtable

        if (child_yang_name == "cTap2StreamTable"):
            if (self.ctap2streamtable is None):
                self.ctap2streamtable = CiscoTap2Mib.Ctap2Streamtable()
                self.ctap2streamtable.parent = self
                self._children_name_map["ctap2streamtable"] = "cTap2StreamTable"
            return self.ctap2streamtable

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "cTap2DebugGroup" or name == "cTap2DebugTable" or name == "cTap2DebugUserTable" or name == "cTap2MediationGroup" or name == "cTap2MediationTable" or name == "cTap2StreamTable"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        pass

    def clone_ptr(self):
        self._top_entity = CiscoTap2Mib()
        return self._top_entity

