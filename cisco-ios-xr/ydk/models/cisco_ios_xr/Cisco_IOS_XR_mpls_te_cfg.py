""" Cisco_IOS_XR_mpls_te_cfg 

This module contains a collection of YANG definitions
for Cisco IOS\-XR mpls\-te package configuration.

This module contains definitions
for the following management objects\:
  mpls\-te\: The root of MPLS TE configuration

This YANG module augments the
  Cisco\-IOS\-XR\-ifmgr\-cfg,
  Cisco\-IOS\-XR\-snmp\-agent\-cfg
modules with configuration data.

Copyright (c) 2013\-2016 by Cisco Systems, Inc.
All rights reserved.

"""
from ydk.entity_utils import get_relative_entity_path as _get_relative_entity_path
from ydk.types import Entity, EntityPath, Identity, Enum, YType, YLeaf, YLeafList, YList, LeafDataList, Bits, Empty, Decimal64
from ydk.filters import YFilter
from ydk.errors import YPYError, YPYModelError
from ydk.errors.error_handler import handle_type_error as _handle_type_error


class BandwidthConstraint(Enum):
    """
    BandwidthConstraint

    Bandwidth constraint

    .. data:: bandwidth_constraint_maximum_allocation_model = 1

    	Maximum Allocation Bandwidth Constaints Model

    """

    bandwidth_constraint_maximum_allocation_model = Enum.YLeaf(1, "bandwidth-constraint-maximum-allocation-model")


class BfdReversePath(Enum):
    """
    BfdReversePath

    Bfd reverse path

    .. data:: bfd_reverse_path_binding_label = 1

    	BindingLabel

    """

    bfd_reverse_path_binding_label = Enum.YLeaf(1, "bfd-reverse-path-binding-label")


class BindingSegmentId(Enum):
    """
    BindingSegmentId

    Binding segment id

    .. data:: any_label = 1

    	AnyLabel

    .. data:: specified_label = 2

    	SpecifiedLabel

    """

    any_label = Enum.YLeaf(1, "any-label")

    specified_label = Enum.YLeaf(2, "specified-label")


class GmplsttiMode(Enum):
    """
    GmplsttiMode

    Gmplstti mode

    .. data:: sm = 1

    	Section Monitoring

    .. data:: pm = 2

    	Path Monitoring

    .. data:: tcm = 3

    	Tandem Connection

    """

    sm = Enum.YLeaf(1, "sm")

    pm = Enum.YLeaf(2, "pm")

    tcm = Enum.YLeaf(3, "tcm")


class IetfMode(Enum):
    """
    IetfMode

    Ietf mode

    .. data:: standard = 3

    	IETF Standard

    """

    standard = Enum.YLeaf(3, "standard")


class LinkNextHop(Enum):
    """
    LinkNextHop

    Link next hop

    .. data:: none = 1

    	No next hop

    .. data:: ipv4_address = 2

    	IPv4 next-hop address

    """

    none = Enum.YLeaf(1, "none")

    ipv4_address = Enum.YLeaf(2, "ipv4-address")


class MplsLcacFloodingIgp(Enum):
    """
    MplsLcacFloodingIgp

    Mpls lcac flooding igp

    .. data:: ospf = 0

    	OSPF

    """

    ospf = Enum.YLeaf(0, "ospf")


class MplsTeAffinityValue(Enum):
    """
    MplsTeAffinityValue

    Mpls te affinity value

    .. data:: hex_value = 1

    	Affinity value in Hex number

    .. data:: bit_position = 2

    	Affinity value by Bit-Position

    """

    hex_value = Enum.YLeaf(1, "hex-value")

    bit_position = Enum.YLeaf(2, "bit-position")


class MplsTeAutorouteMetric(Enum):
    """
    MplsTeAutorouteMetric

    Mpls te autoroute metric

    .. data:: relative = 1

    	Relative

    .. data:: absolute = 2

    	Absolute

    .. data:: constant = 3

    	Constant

    """

    relative = Enum.YLeaf(1, "relative")

    absolute = Enum.YLeaf(2, "absolute")

    constant = Enum.YLeaf(3, "constant")


class MplsTeBackupBandwidthClass(Enum):
    """
    MplsTeBackupBandwidthClass

    Mpls te backup bandwidth class

    .. data:: class0 = 0

    	Class 0

    .. data:: class1 = 1

    	Class 1

    .. data:: any_class = 9

    	Any Class

    """

    class0 = Enum.YLeaf(0, "class0")

    class1 = Enum.YLeaf(1, "class1")

    any_class = Enum.YLeaf(9, "any-class")


class MplsTeBackupBandwidthPool(Enum):
    """
    MplsTeBackupBandwidthPool

    Mpls te backup bandwidth pool

    .. data:: any_pool = 1

    	Any Pool

    .. data:: global_pool = 2

    	Global Pool

    .. data:: sub_pool = 4

    	Sub Pool

    """

    any_pool = Enum.YLeaf(1, "any-pool")

    global_pool = Enum.YLeaf(2, "global-pool")

    sub_pool = Enum.YLeaf(4, "sub-pool")


class MplsTeBandwidthDste(Enum):
    """
    MplsTeBandwidthDste

    Mpls te bandwidth dste

    .. data:: standard_dste = 0

    	IETF-Standard DSTE

    .. data:: pre_standard_dste = 1

    	Pre-Standard DSTE

    """

    standard_dste = Enum.YLeaf(0, "standard-dste")

    pre_standard_dste = Enum.YLeaf(1, "pre-standard-dste")


class MplsTeBandwidthLimit(Enum):
    """
    MplsTeBandwidthLimit

    Mpls te bandwidth limit

    .. data:: unlimited = 64

    	Unlimited

    .. data:: limited = 128

    	Limited

    """

    unlimited = Enum.YLeaf(64, "unlimited")

    limited = Enum.YLeaf(128, "limited")


class MplsTeBfdSessionDownAction(Enum):
    """
    MplsTeBfdSessionDownAction

    Mpls te bfd session down action

    .. data:: re_setup = 1

    	Tear down and resetup

    """

    re_setup = Enum.YLeaf(1, "re-setup")


class MplsTeConfigTunnel(Enum):
    """
    MplsTeConfigTunnel

    Mpls te config tunnel

    .. data:: p2p = 0

    	P2P

    .. data:: p2mp = 1

    	P2MP

    """

    p2p = Enum.YLeaf(0, "p2p")

    p2mp = Enum.YLeaf(1, "p2mp")


class MplsTeIgpProtocol(Enum):
    """
    MplsTeIgpProtocol

    Mpls te igp protocol

    .. data:: none = 0

    	Not set

    .. data:: isis = 1

    	IS IS

    .. data:: ospf = 2

    	OSPF

    """

    none = Enum.YLeaf(0, "none")

    isis = Enum.YLeaf(1, "isis")

    ospf = Enum.YLeaf(2, "ospf")


class MplsTeLogFrrProtection(Enum):
    """
    MplsTeLogFrrProtection

    Mpls te log frr protection

    .. data:: frr_active_primary = 1

    	Track only FRR active on primary LSP

    .. data:: backup = 256

    	backup tunnel

    .. data:: frr_ready_primary = 512

    	Track only FRR ready on primary LSP

    .. data:: primary = 513

    	primary LSP

    .. data:: all = 769

    	all

    """

    frr_active_primary = Enum.YLeaf(1, "frr-active-primary")

    backup = Enum.YLeaf(256, "backup")

    frr_ready_primary = Enum.YLeaf(512, "frr-ready-primary")

    primary = Enum.YLeaf(513, "primary")

    all = Enum.YLeaf(769, "all")


class MplsTeOtnApsProtection(Enum):
    """
    MplsTeOtnApsProtection

    Mpls te otn aps protection

    .. data:: Y_1plus1_unidir_no_aps = 4

    	1PLUS1 UNIDIR NO APS

    .. data:: Y_1plus1_unidir_aps = 8

    	1PLUS1 UNIDIR APS

    .. data:: Y_1plus1_bdir_aps = 16

    	1PLUS1 BIDIR APS

    """

    Y_1plus1_unidir_no_aps = Enum.YLeaf(4, "1plus1-unidir-no-aps")

    Y_1plus1_unidir_aps = Enum.YLeaf(8, "1plus1-unidir-aps")

    Y_1plus1_bdir_aps = Enum.YLeaf(16, "1plus1-bdir-aps")


class MplsTeOtnApsProtectionMode(Enum):
    """
    MplsTeOtnApsProtectionMode

    Mpls te otn aps protection mode

    .. data:: revertive = 1

    	Revertive

    .. data:: non_revertive = 2

    	Non Revertive

    """

    revertive = Enum.YLeaf(1, "revertive")

    non_revertive = Enum.YLeaf(2, "non-revertive")


class MplsTeOtnApsRestorationStyle(Enum):
    """
    MplsTeOtnApsRestorationStyle

    Mpls te otn aps restoration style

    .. data:: keep_failed_lsp = 1

    	Keep Failed Lsp

    .. data:: delete_failed_lsp = 2

    	Delete Failed Lsp

    """

    keep_failed_lsp = Enum.YLeaf(1, "keep-failed-lsp")

    delete_failed_lsp = Enum.YLeaf(2, "delete-failed-lsp")


class MplsTeOtnSncMode(Enum):
    """
    MplsTeOtnSncMode

    Mpls te otn snc mode

    .. data:: snc_n = 1

    	SNC N

    .. data:: snc_i = 2

    	SNC I

    .. data:: snc_s = 3

    	SNC S

    """

    snc_n = Enum.YLeaf(1, "snc-n")

    snc_i = Enum.YLeaf(2, "snc-i")

    snc_s = Enum.YLeaf(3, "snc-s")


class MplsTePathComputationMethod(Enum):
    """
    MplsTePathComputationMethod

    Mpls te path computation method

    .. data:: not_set = 0

    	NotSet

    .. data:: dynamic = 1

    	Dynamic

    .. data:: pce = 2

    	PCE

    .. data:: explicit = 3

    	Explicit

    """

    not_set = Enum.YLeaf(0, "not-set")

    dynamic = Enum.YLeaf(1, "dynamic")

    pce = Enum.YLeaf(2, "pce")

    explicit = Enum.YLeaf(3, "explicit")


class MplsTePathDiversityConformance(Enum):
    """
    MplsTePathDiversityConformance

    Mpls te path diversity conformance

    .. data:: strict = 0

    	Strict

    .. data:: best_effort = 1

    	Best effort

    """

    strict = Enum.YLeaf(0, "strict")

    best_effort = Enum.YLeaf(1, "best-effort")


class MplsTePathOption(Enum):
    """
    MplsTePathOption

    Mpls te path option

    .. data:: not_set = 0

    	Not Set

    .. data:: dynamic = 1

    	Dynamic

    .. data:: explicit_name = 3

    	Explicit, identified by name

    .. data:: explicit_number = 4

    	Explicit, identified by number

    .. data:: no_ero = 5

    	No ERO

    .. data:: sr = 6

    	Segment routing

    """

    not_set = Enum.YLeaf(0, "not-set")

    dynamic = Enum.YLeaf(1, "dynamic")

    explicit_name = Enum.YLeaf(3, "explicit-name")

    explicit_number = Enum.YLeaf(4, "explicit-number")

    no_ero = Enum.YLeaf(5, "no-ero")

    sr = Enum.YLeaf(6, "sr")


class MplsTePathOptionProperty(Enum):
    """
    MplsTePathOptionProperty

    Mpls te path option property

    .. data:: none = 0

    	No property

    .. data:: lockdown = 1

    	Path is not a canditate forreoptimization

    .. data:: verbatim = 4

    	Explicit path does not require topology

    	database

    .. data:: pce = 8

    	Dynamic path found by PCE server

    .. data:: segment_routing = 16

    	Segment Routing path

    """

    none = Enum.YLeaf(0, "none")

    lockdown = Enum.YLeaf(1, "lockdown")

    verbatim = Enum.YLeaf(4, "verbatim")

    pce = Enum.YLeaf(8, "pce")

    segment_routing = Enum.YLeaf(16, "segment-routing")


class MplsTePathOptionProtection(Enum):
    """
    MplsTePathOptionProtection

    Mpls te path option protection

    .. data:: active = 0

    	Active path

    .. data:: protecting = 1

    	Protecting Path

    """

    active = Enum.YLeaf(0, "active")

    protecting = Enum.YLeaf(1, "protecting")


class MplsTePathSelectionInvalidationTimerExpire(Enum):
    """
    MplsTePathSelectionInvalidationTimerExpire

    Mpls te path selection invalidation timer expire

    .. data:: tunnel_action_tear = 1

    	Tear down tunnel.

    .. data:: tunnel_action_drop = 2

    	Drop tunnel traffic.

    """

    tunnel_action_tear = Enum.YLeaf(1, "tunnel-action-tear")

    tunnel_action_drop = Enum.YLeaf(2, "tunnel-action-drop")


class MplsTePathSelectionMetric(Enum):
    """
    MplsTePathSelectionMetric

    Mpls te path selection metric

    .. data:: igp = 1

    	IGP Metric

    .. data:: te = 2

    	TE Metric

    .. data:: delay = 4

    	DELAY Metric

    """

    igp = Enum.YLeaf(1, "igp")

    te = Enum.YLeaf(2, "te")

    delay = Enum.YLeaf(4, "delay")


class MplsTePathSelectionSegmentRoutingAdjacencyProtection(Enum):
    """
    MplsTePathSelectionSegmentRoutingAdjacencyProtection

    Mpls te path selection segment routing adjacency

    protection

    .. data:: not_set = 0

    	Any segment can be used in a path.

    .. data:: adj_unprotected = 1

    	Only unprotected adjacency segments can be used

    	in a path.

    .. data:: adj_protected = 2

    	Only protected adjacency segments can be used

    	in a path.

    """

    not_set = Enum.YLeaf(0, "not-set")

    adj_unprotected = Enum.YLeaf(1, "adj-unprotected")

    adj_protected = Enum.YLeaf(2, "adj-protected")


class MplsTePathSelectionTiebreaker(Enum):
    """
    MplsTePathSelectionTiebreaker

    Mpls te path selection tiebreaker

    .. data:: min_fill = 1

    	Prefer the path with the least-utilized links

    .. data:: max_fill = 2

    	Prefer the path with the most-utilized links

    .. data:: random = 3

    	Prefer a path with links utilized randomly

    """

    min_fill = Enum.YLeaf(1, "min-fill")

    max_fill = Enum.YLeaf(2, "max-fill")

    random = Enum.YLeaf(3, "random")


class MplsTeSigNameOption(Enum):
    """
    MplsTeSigNameOption

    Mpls te sig name option

    .. data:: none = 0

    	None

    .. data:: address = 1

    	Address

    .. data:: name = 2

    	Name

    """

    none = Enum.YLeaf(0, "none")

    address = Enum.YLeaf(1, "address")

    name = Enum.YLeaf(2, "name")


class MplsTeSignaledLabel(Enum):
    """
    MplsTeSignaledLabel

    Mpls te signaled label

    .. data:: not_set = 0

    	Not Set

    .. data:: dwdm = 1

    	DWDM Label (RFC 6205), 50GHz channel spacing

    """

    not_set = Enum.YLeaf(0, "not-set")

    dwdm = Enum.YLeaf(1, "dwdm")


class MplsTeSwitchingCap(Enum):
    """
    MplsTeSwitchingCap

    Mpls te switching cap

    .. data:: psc1 = 1

    	PSC1

    .. data:: lsc = 150

    	LSC

    .. data:: fsc = 200

    	FSC

    """

    psc1 = Enum.YLeaf(1, "psc1")

    lsc = Enum.YLeaf(150, "lsc")

    fsc = Enum.YLeaf(200, "fsc")


class MplsTeSwitchingEncode(Enum):
    """
    MplsTeSwitchingEncode

    Mpls te switching encode

    .. data:: none = 0

    	None

    .. data:: packet = 1

    	Packet

    .. data:: ethernet = 2

    	Ethernet

    .. data:: sondet_sdh = 5

    	SONET SDH

    """

    none = Enum.YLeaf(0, "none")

    packet = Enum.YLeaf(1, "packet")

    ethernet = Enum.YLeaf(2, "ethernet")

    sondet_sdh = Enum.YLeaf(5, "sondet-sdh")


class MplsTeSwitchingEncoding(Enum):
    """
    MplsTeSwitchingEncoding

    Mpls te switching encoding

    .. data:: packet = 1

    	Packet

    .. data:: ethernet = 2

    	Ethernet

    .. data:: sondet_sdh = 5

    	SONET SDH

    """

    packet = Enum.YLeaf(1, "packet")

    ethernet = Enum.YLeaf(2, "ethernet")

    sondet_sdh = Enum.YLeaf(5, "sondet-sdh")


class MplsTeSwitchingIndex(Enum):
    """
    MplsTeSwitchingIndex

    Mpls te switching index

    .. data:: link = 255

    	Link

    """

    link = Enum.YLeaf(255, "link")


class MplsTeTunnelAffinity(Enum):
    """
    MplsTeTunnelAffinity

    Mpls te tunnel affinity

    .. data:: include = 1

    	Include Affinity

    .. data:: include_strict = 2

    	Strictly Include Affinity

    .. data:: exclude = 3

    	Exclude Affinity

    .. data:: exclude_all = 4

    	Exclude All Affinities

    .. data:: ignore = 5

    	Ignore Affinity

    """

    include = Enum.YLeaf(1, "include")

    include_strict = Enum.YLeaf(2, "include-strict")

    exclude = Enum.YLeaf(3, "exclude")

    exclude_all = Enum.YLeaf(4, "exclude-all")

    ignore = Enum.YLeaf(5, "ignore")


class MplsTeTunnelId(Enum):
    """
    MplsTeTunnelId

    Mpls te tunnel id

    .. data:: auto = 0

    	Auto

    .. data:: explicit = 1

    	Explicit

    """

    auto = Enum.YLeaf(0, "auto")

    explicit = Enum.YLeaf(1, "explicit")


class MplsTebfdSession(Enum):
    """
    MplsTebfdSession

    Mpls tebfd session

    .. data:: regular_bfd = 1

    	Regular BFD

    .. data:: sbfd = 2

    	Seamless BFD

    .. data:: redundant_sbfd = 3

    	Redundant SBFD

    """

    regular_bfd = Enum.YLeaf(1, "regular-bfd")

    sbfd = Enum.YLeaf(2, "sbfd")

    redundant_sbfd = Enum.YLeaf(3, "redundant-sbfd")


class MplsTesrlgExclude(Enum):
    """
    MplsTesrlgExclude

    Mpls tesrlg exclude

    .. data:: mandatory = 1

    	SRLG Mandatory Exclude

    .. data:: preferred = 2

    	SRLG Preferred Exclude

    .. data:: weighted = 3

    	SRLG Weighted Exclude

    """

    mandatory = Enum.YLeaf(1, "mandatory")

    preferred = Enum.YLeaf(2, "preferred")

    weighted = Enum.YLeaf(3, "weighted")


class OspfAreaMode(Enum):
    """
    OspfAreaMode

    Ospf area mode

    .. data:: ospf_int = 0

    	OSPF area in integer format

    .. data:: ospfip_addr = 1

    	OSPF area in IP address format

    """

    ospf_int = Enum.YLeaf(0, "ospf-int")

    ospfip_addr = Enum.YLeaf(1, "ospfip-addr")


class OtnDestination(Enum):
    """
    OtnDestination

    Otn destination

    .. data:: number_ed = 0

    	Destination numbered

    .. data:: un_number_ed = 1

    	Destination unnumbered

    """

    number_ed = Enum.YLeaf(0, "number-ed")

    un_number_ed = Enum.YLeaf(1, "un-number-ed")


class OtnPayload(Enum):
    """
    OtnPayload

    Otn payload

    .. data:: unknown = 0

    	Payload unknown

    .. data:: bmp = 50

    	Bmp Payload

    .. data:: gfp_f = 54

    	Gfp_F Payload

    .. data:: gmp = 55

    	GMP Payload

    .. data:: gfp_f_ext = 70

    	Gfp_F_EXT Payload

    """

    unknown = Enum.YLeaf(0, "unknown")

    bmp = Enum.YLeaf(50, "bmp")

    gfp_f = Enum.YLeaf(54, "gfp-f")

    gmp = Enum.YLeaf(55, "gmp")

    gfp_f_ext = Enum.YLeaf(70, "gfp-f-ext")


class OtnProtectionSwitchLockout(Enum):
    """
    OtnProtectionSwitchLockout

    Otn protection switch lockout

    .. data:: none = 0

    	No Lockout

    .. data:: working = 1

    	Lockout Working

    """

    none = Enum.YLeaf(0, "none")

    working = Enum.YLeaf(1, "working")


class OtnSignaledBandwidth(Enum):
    """
    OtnSignaledBandwidth

    Otn signaled bandwidth

    .. data:: odu1 = 1

    	Signalled BW for ODU1

    .. data:: odu2 = 2

    	Signalled BW for ODU2

    .. data:: odu3 = 3

    	Signalled BW for ODU3

    .. data:: odu4 = 4

    	Signalled BW for ODU4

    .. data:: odu0 = 10

    	Signalled BW for ODU0

    .. data:: odu2e = 11

    	Signalled BW for ODU2e

    .. data:: od_uflex_cbr = 20

    	Signalled BW for ODUflex CBR

    .. data:: od_uflex_gfp_resize = 21

    	Signalled BW for ODUflex GFP Resizable

    .. data:: od_uflex_gfp_not_resize = 22

    	Signalled BW for ODUflex GFP not Resizable

    .. data:: odu1e = 23

    	Signalled BW for ODU1e

    .. data:: odu1f = 24

    	Signalled BW for ODU1f

    .. data:: odu2f = 25

    	Signalled BW for ODU2f

    .. data:: odu3e1 = 26

    	Signalled BW for ODU3e1

    .. data:: odu3e2 = 27

    	Signalled BW for ODU3e2

    """

    odu1 = Enum.YLeaf(1, "odu1")

    odu2 = Enum.YLeaf(2, "odu2")

    odu3 = Enum.YLeaf(3, "odu3")

    odu4 = Enum.YLeaf(4, "odu4")

    odu0 = Enum.YLeaf(10, "odu0")

    odu2e = Enum.YLeaf(11, "odu2e")

    od_uflex_cbr = Enum.YLeaf(20, "od-uflex-cbr")

    od_uflex_gfp_resize = Enum.YLeaf(21, "od-uflex-gfp-resize")

    od_uflex_gfp_not_resize = Enum.YLeaf(22, "od-uflex-gfp-not-resize")

    odu1e = Enum.YLeaf(23, "odu1e")

    odu1f = Enum.YLeaf(24, "odu1f")

    odu2f = Enum.YLeaf(25, "odu2f")

    odu3e1 = Enum.YLeaf(26, "odu3e1")

    odu3e2 = Enum.YLeaf(27, "odu3e2")


class OtnSignaledBandwidthFlexFraming(Enum):
    """
    OtnSignaledBandwidthFlexFraming

    Otn signaled bandwidth flex framing

    .. data:: cbr = 20

    	CBR

    .. data:: framed_gfp_fixed = 21

    	GFP fixed framing type

    .. data:: framed_gfp_resize = 22

    	GFP resizeable framing type

    """

    cbr = Enum.YLeaf(20, "cbr")

    framed_gfp_fixed = Enum.YLeaf(21, "framed-gfp-fixed")

    framed_gfp_resize = Enum.YLeaf(22, "framed-gfp-resize")


class OtnStaticUni(Enum):
    """
    OtnStaticUni

    Otn static uni

    .. data:: unknown = 0

    	Uni-Type None

    .. data:: xc = 1

    	Uni-Type XC

    .. data:: termination = 2

    	Uni-Type Termination

    """

    unknown = Enum.YLeaf(0, "unknown")

    xc = Enum.YLeaf(1, "xc")

    termination = Enum.YLeaf(2, "termination")


class PathInvalidationAction(Enum):
    """
    PathInvalidationAction

    Path invalidation action

    .. data:: tear = 1

    	Tear

    .. data:: drop = 2

    	Drop

    """

    tear = Enum.YLeaf(1, "tear")

    drop = Enum.YLeaf(2, "drop")


class RoutePriorityRole(Enum):
    """
    RoutePriorityRole

    Route priority role

    .. data:: route_priority_role_head_back_up = 0

    	TE Route Priority Role Head Backup

    .. data:: route_priority_role_head_primary = 1

    	TE Route Priority Role Head Primary

    .. data:: route_priority_role_middle = 2

    	TE Route Priority Role Middle

    """

    route_priority_role_head_back_up = Enum.YLeaf(0, "route-priority-role-head-back-up")

    route_priority_role_head_primary = Enum.YLeaf(1, "route-priority-role-head-primary")

    route_priority_role_middle = Enum.YLeaf(2, "route-priority-role-middle")


class SrPrepend(Enum):
    """
    SrPrepend

    Sr prepend

    .. data:: none_type = 0

    	NoneType

    .. data:: next_label = 1

    	Next Label

    .. data:: bgp_n_hop = 2

    	BGP NHOP

    """

    none_type = Enum.YLeaf(0, "none-type")

    next_label = Enum.YLeaf(1, "next-label")

    bgp_n_hop = Enum.YLeaf(2, "bgp-n-hop")



class MplsTe(Entity):
    """
    The root of MPLS TE configuration
    
    .. attribute:: diff_serv_traffic_engineering
    
    	Configure Diff\-Serv Traffic\-Engineering
    	**type**\:   :py:class:`DiffServTrafficEngineering <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.DiffServTrafficEngineering>`
    
    .. attribute:: enable_traffic_engineering
    
    	Enable MPLS Traffic Engineering
    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
    
    .. attribute:: global_attributes
    
    	Configure MPLS TE global attributes
    	**type**\:   :py:class:`GlobalAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes>`
    
    .. attribute:: gmpls_nni
    
    	GMPLS\-NNI configuration
    	**type**\:   :py:class:`GmplsNni <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni>`
    
    .. attribute:: gmpls_uni
    
    	GMPLS\-UNI configuration
    	**type**\:   :py:class:`GmplsUni <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni>`
    
    .. attribute:: interfaces
    
    	Configure MPLS TE interfaces
    	**type**\:   :py:class:`Interfaces <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces>`
    
    .. attribute:: lcac
    
    	LCAC specific MPLS global configuration
    	**type**\:   :py:class:`Lcac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Lcac>`
    
    .. attribute:: named_tunnels
    
    	Configure MPLS TE tunnel
    	**type**\:   :py:class:`NamedTunnels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels>`
    
    .. attribute:: transport_profile
    
    	MPLS transport profile configuration data
    	**type**\:   :py:class:`TransportProfile <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile>`
    
    

    """

    _prefix = 'mpls-te-cfg'
    _revision = '2015-11-09'

    def __init__(self):
        super(MplsTe, self).__init__()
        self._top_entity = None

        self.yang_name = "mpls-te"
        self.yang_parent_name = "Cisco-IOS-XR-mpls-te-cfg"

        self.enable_traffic_engineering = YLeaf(YType.empty, "enable-traffic-engineering")

        self.diff_serv_traffic_engineering = MplsTe.DiffServTrafficEngineering()
        self.diff_serv_traffic_engineering.parent = self
        self._children_name_map["diff_serv_traffic_engineering"] = "diff-serv-traffic-engineering"
        self._children_yang_names.add("diff-serv-traffic-engineering")

        self.global_attributes = MplsTe.GlobalAttributes()
        self.global_attributes.parent = self
        self._children_name_map["global_attributes"] = "global-attributes"
        self._children_yang_names.add("global-attributes")

        self.gmpls_nni = MplsTe.GmplsNni()
        self.gmpls_nni.parent = self
        self._children_name_map["gmpls_nni"] = "gmpls-nni"
        self._children_yang_names.add("gmpls-nni")

        self.gmpls_uni = MplsTe.GmplsUni()
        self.gmpls_uni.parent = self
        self._children_name_map["gmpls_uni"] = "gmpls-uni"
        self._children_yang_names.add("gmpls-uni")

        self.interfaces = MplsTe.Interfaces()
        self.interfaces.parent = self
        self._children_name_map["interfaces"] = "interfaces"
        self._children_yang_names.add("interfaces")

        self.lcac = MplsTe.Lcac()
        self.lcac.parent = self
        self._children_name_map["lcac"] = "lcac"
        self._children_yang_names.add("lcac")

        self.named_tunnels = MplsTe.NamedTunnels()
        self.named_tunnels.parent = self
        self._children_name_map["named_tunnels"] = "named-tunnels"
        self._children_yang_names.add("named-tunnels")

        self.transport_profile = MplsTe.TransportProfile()
        self.transport_profile.parent = self
        self._children_name_map["transport_profile"] = "transport-profile"
        self._children_yang_names.add("transport-profile")

    def __setattr__(self, name, value):
        self._check_monkey_patching_error(name, value)
        with _handle_type_error():
            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                    "Please use list append or extend method."
                                    .format(value))
            if isinstance(value, Enum.YLeaf):
                value = value.name
            if name in ("enable_traffic_engineering") and name in self.__dict__:
                if isinstance(value, YLeaf):
                    self.__dict__[name].set(value.get())
                elif isinstance(value, YLeafList):
                    super(MplsTe, self).__setattr__(name, value)
                else:
                    self.__dict__[name].set(value)
            else:
                if hasattr(value, "parent") and name != "parent":
                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                        value.parent = self
                    elif value.parent is None and value.yang_name in self._children_yang_names:
                        value.parent = self
                super(MplsTe, self).__setattr__(name, value)


    class DiffServTrafficEngineering(Entity):
        """
        Configure Diff\-Serv Traffic\-Engineering
        
        .. attribute:: bandwidth_constraint_model
        
        	Diff\-Serv Traffic\-Engineering Bandwidth Constraint Model
        	**type**\:   :py:class:`BandwidthConstraint <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.BandwidthConstraint>`
        
        .. attribute:: classes
        
        	Configure Diff\-Serv Traffic\-Engineering Classes
        	**type**\:   :py:class:`Classes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.DiffServTrafficEngineering.Classes>`
        
        .. attribute:: mode_ietf
        
        	Diff\-Serv Traffic\-Engineering IETF mode
        	**type**\:   :py:class:`IetfMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.IetfMode>`
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(MplsTe.DiffServTrafficEngineering, self).__init__()

            self.yang_name = "diff-serv-traffic-engineering"
            self.yang_parent_name = "mpls-te"

            self.bandwidth_constraint_model = YLeaf(YType.enumeration, "bandwidth-constraint-model")

            self.mode_ietf = YLeaf(YType.enumeration, "mode-ietf")

            self.classes = MplsTe.DiffServTrafficEngineering.Classes()
            self.classes.parent = self
            self._children_name_map["classes"] = "classes"
            self._children_yang_names.add("classes")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("bandwidth_constraint_model",
                            "mode_ietf") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(MplsTe.DiffServTrafficEngineering, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(MplsTe.DiffServTrafficEngineering, self).__setattr__(name, value)


        class Classes(Entity):
            """
            Configure Diff\-Serv Traffic\-Engineering Classes
            
            .. attribute:: class_
            
            	DSTE class number
            	**type**\: list of    :py:class:`Class_ <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.DiffServTrafficEngineering.Classes.Class_>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.DiffServTrafficEngineering.Classes, self).__init__()

                self.yang_name = "classes"
                self.yang_parent_name = "diff-serv-traffic-engineering"

                self.class_ = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.DiffServTrafficEngineering.Classes, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.DiffServTrafficEngineering.Classes, self).__setattr__(name, value)


            class Class_(Entity):
                """
                DSTE class number
                
                .. attribute:: class_number  <key>
                
                	DS\-TE class number
                	**type**\:  int
                
                	**range:** 0..7
                
                .. attribute:: class_priority
                
                	Class\-type priority
                	**type**\:  int
                
                	**range:** 0..7
                
                .. attribute:: class_type
                
                	Class type number
                	**type**\:  int
                
                	**range:** 0..1
                
                .. attribute:: unused
                
                	TRUE to skip classtype and class priority provisioning FALSE to provision them
                	**type**\:  bool
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.DiffServTrafficEngineering.Classes.Class_, self).__init__()

                    self.yang_name = "class"
                    self.yang_parent_name = "classes"

                    self.class_number = YLeaf(YType.uint32, "class-number")

                    self.class_priority = YLeaf(YType.uint32, "class-priority")

                    self.class_type = YLeaf(YType.uint32, "class-type")

                    self.unused = YLeaf(YType.boolean, "unused")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("class_number",
                                    "class_priority",
                                    "class_type",
                                    "unused") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.DiffServTrafficEngineering.Classes.Class_, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.DiffServTrafficEngineering.Classes.Class_, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.class_number.is_set or
                        self.class_priority.is_set or
                        self.class_type.is_set or
                        self.unused.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.class_number.yfilter != YFilter.not_set or
                        self.class_priority.yfilter != YFilter.not_set or
                        self.class_type.yfilter != YFilter.not_set or
                        self.unused.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "class" + "[class-number='" + self.class_number.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/diff-serv-traffic-engineering/classes/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.class_number.is_set or self.class_number.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.class_number.get_name_leafdata())
                    if (self.class_priority.is_set or self.class_priority.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.class_priority.get_name_leafdata())
                    if (self.class_type.is_set or self.class_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.class_type.get_name_leafdata())
                    if (self.unused.is_set or self.unused.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unused.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "class-number" or name == "class-priority" or name == "class-type" or name == "unused"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "class-number"):
                        self.class_number = value
                        self.class_number.value_namespace = name_space
                        self.class_number.value_namespace_prefix = name_space_prefix
                    if(value_path == "class-priority"):
                        self.class_priority = value
                        self.class_priority.value_namespace = name_space
                        self.class_priority.value_namespace_prefix = name_space_prefix
                    if(value_path == "class-type"):
                        self.class_type = value
                        self.class_type.value_namespace = name_space
                        self.class_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "unused"):
                        self.unused = value
                        self.unused.value_namespace = name_space
                        self.unused.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.class_:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.class_:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "classes" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/diff-serv-traffic-engineering/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "class"):
                    for c in self.class_:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsTe.DiffServTrafficEngineering.Classes.Class_()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.class_.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "class"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.bandwidth_constraint_model.is_set or
                self.mode_ietf.is_set or
                (self.classes is not None and self.classes.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.bandwidth_constraint_model.yfilter != YFilter.not_set or
                self.mode_ietf.yfilter != YFilter.not_set or
                (self.classes is not None and self.classes.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "diff-serv-traffic-engineering" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.bandwidth_constraint_model.is_set or self.bandwidth_constraint_model.yfilter != YFilter.not_set):
                leaf_name_data.append(self.bandwidth_constraint_model.get_name_leafdata())
            if (self.mode_ietf.is_set or self.mode_ietf.yfilter != YFilter.not_set):
                leaf_name_data.append(self.mode_ietf.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "classes"):
                if (self.classes is None):
                    self.classes = MplsTe.DiffServTrafficEngineering.Classes()
                    self.classes.parent = self
                    self._children_name_map["classes"] = "classes"
                return self.classes

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "classes" or name == "bandwidth-constraint-model" or name == "mode-ietf"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "bandwidth-constraint-model"):
                self.bandwidth_constraint_model = value
                self.bandwidth_constraint_model.value_namespace = name_space
                self.bandwidth_constraint_model.value_namespace_prefix = name_space_prefix
            if(value_path == "mode-ietf"):
                self.mode_ietf = value
                self.mode_ietf.value_namespace = name_space
                self.mode_ietf.value_namespace_prefix = name_space_prefix


    class NamedTunnels(Entity):
        """
        Configure MPLS TE tunnel
        
        .. attribute:: enable
        
        	Enable Named Tunnels
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: tunnels
        
        	Configure MPLS TE tunnel
        	**type**\:   :py:class:`Tunnels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels>`
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(MplsTe.NamedTunnels, self).__init__()

            self.yang_name = "named-tunnels"
            self.yang_parent_name = "mpls-te"

            self.enable = YLeaf(YType.empty, "enable")

            self.tunnels = MplsTe.NamedTunnels.Tunnels()
            self.tunnels.parent = self
            self._children_name_map["tunnels"] = "tunnels"
            self._children_yang_names.add("tunnels")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("enable") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(MplsTe.NamedTunnels, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(MplsTe.NamedTunnels, self).__setattr__(name, value)


        class Tunnels(Entity):
            """
            Configure MPLS TE tunnel
            
            .. attribute:: tunnel
            
            	Configure a MPLS TE tunnel
            	**type**\: list of    :py:class:`Tunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.NamedTunnels.Tunnels, self).__init__()

                self.yang_name = "tunnels"
                self.yang_parent_name = "named-tunnels"

                self.tunnel = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.NamedTunnels.Tunnels, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.NamedTunnels.Tunnels, self).__setattr__(name, value)


            class Tunnel(Entity):
                """
                Configure a MPLS TE tunnel
                
                .. attribute:: tunnel_name  <key>
                
                	Tunnel name
                	**type**\:  str
                
                	**length:** 1..59
                
                .. attribute:: tunnel_type  <key>
                
                	Tunnel Type
                	**type**\:   :py:class:`MplsTeConfigTunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeConfigTunnel>`
                
                .. attribute:: enable
                
                	Always set to true
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: tunnel_attributes
                
                	MPLS tunnel attributes
                	**type**\:   :py:class:`TunnelAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes>`
                
                .. attribute:: tunnel_id
                
                	Set the tunnel ID
                	**type**\:   :py:class:`TunnelId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelId>`
                
                	**presence node**\: True
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.NamedTunnels.Tunnels.Tunnel, self).__init__()

                    self.yang_name = "tunnel"
                    self.yang_parent_name = "tunnels"

                    self.tunnel_name = YLeaf(YType.str, "tunnel-name")

                    self.tunnel_type = YLeaf(YType.enumeration, "tunnel-type")

                    self.enable = YLeaf(YType.empty, "enable")

                    self.tunnel_attributes = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes()
                    self.tunnel_attributes.parent = self
                    self._children_name_map["tunnel_attributes"] = "tunnel-attributes"
                    self._children_yang_names.add("tunnel-attributes")

                    self.tunnel_id = None
                    self._children_name_map["tunnel_id"] = "tunnel-id"
                    self._children_yang_names.add("tunnel-id")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("tunnel_name",
                                    "tunnel_type",
                                    "enable") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel, self).__setattr__(name, value)


                class TunnelAttributes(Entity):
                    """
                    MPLS tunnel attributes
                    
                    .. attribute:: auto_bandwidth
                    
                    	Tunnel Interface Auto\-bandwidth configuration data
                    	**type**\:   :py:class:`AutoBandwidth <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth>`
                    
                    .. attribute:: autoroute
                    
                    	Parameters for IGP routing over tunnel
                    	**type**\:   :py:class:`Autoroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute>`
                    
                    .. attribute:: bandwidth
                    
                    	Tunnel bandwidth requirement
                    	**type**\:   :py:class:`Bandwidth <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Bandwidth>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: destination
                    
                    	Set the destination of the tunnel
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: fast_reroute
                    
                    	Specify MPLS tunnel can be fast\-rerouted
                    	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.FastReroute>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: forward_class
                    
                    	Forward class value
                    	**type**\:  int
                    
                    	**range:** 1..7
                    
                    .. attribute:: load_share
                    
                    	Tunnel loadsharing metric
                    	**type**\:  int
                    
                    	**range:** 1..4294967295
                    
                    .. attribute:: logging
                    
                    	Log tunnel LSP messages
                    	**type**\:   :py:class:`Logging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Logging>`
                    
                    .. attribute:: new_style_affinity_affinity_types
                    
                    	Tunnel new style affinity attributes table
                    	**type**\:   :py:class:`NewStyleAffinityAffinityTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes>`
                    
                    .. attribute:: path_selection_metric
                    
                    	Path selection metric to use in path calculation
                    	**type**\:   :py:class:`MplsTePathSelectionMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionMetric>`
                    
                    .. attribute:: path_setups
                    
                    	Tunnel path setup table
                    	**type**\:   :py:class:`PathSetups <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups>`
                    
                    .. attribute:: priority
                    
                    	Tunnel Setup and Hold Priorities
                    	**type**\:   :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Priority>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: record_route
                    
                    	Record the route used by the tunnel
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: shutdown
                    
                    	shutdown the tunnel
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: soft_preemption
                    
                    	Enable the soft\-preemption feature on the tunnel
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: tunnel_path_selection
                    
                    	Configure path selection properties
                    	**type**\:   :py:class:`TunnelPathSelection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes, self).__init__()

                        self.yang_name = "tunnel-attributes"
                        self.yang_parent_name = "tunnel"

                        self.destination = YLeaf(YType.str, "destination")

                        self.forward_class = YLeaf(YType.uint32, "forward-class")

                        self.load_share = YLeaf(YType.uint32, "load-share")

                        self.path_selection_metric = YLeaf(YType.enumeration, "path-selection-metric")

                        self.record_route = YLeaf(YType.empty, "record-route")

                        self.shutdown = YLeaf(YType.empty, "shutdown")

                        self.soft_preemption = YLeaf(YType.empty, "soft-preemption")

                        self.auto_bandwidth = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth()
                        self.auto_bandwidth.parent = self
                        self._children_name_map["auto_bandwidth"] = "auto-bandwidth"
                        self._children_yang_names.add("auto-bandwidth")

                        self.autoroute = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute()
                        self.autoroute.parent = self
                        self._children_name_map["autoroute"] = "autoroute"
                        self._children_yang_names.add("autoroute")

                        self.bandwidth = None
                        self._children_name_map["bandwidth"] = "bandwidth"
                        self._children_yang_names.add("bandwidth")

                        self.fast_reroute = None
                        self._children_name_map["fast_reroute"] = "fast-reroute"
                        self._children_yang_names.add("fast-reroute")

                        self.logging = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Logging()
                        self.logging.parent = self
                        self._children_name_map["logging"] = "logging"
                        self._children_yang_names.add("logging")

                        self.new_style_affinity_affinity_types = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes()
                        self.new_style_affinity_affinity_types.parent = self
                        self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                        self._children_yang_names.add("new-style-affinity-affinity-types")

                        self.path_setups = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups()
                        self.path_setups.parent = self
                        self._children_name_map["path_setups"] = "path-setups"
                        self._children_yang_names.add("path-setups")

                        self.priority = None
                        self._children_name_map["priority"] = "priority"
                        self._children_yang_names.add("priority")

                        self.tunnel_path_selection = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection()
                        self.tunnel_path_selection.parent = self
                        self._children_name_map["tunnel_path_selection"] = "tunnel-path-selection"
                        self._children_yang_names.add("tunnel-path-selection")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("destination",
                                        "forward_class",
                                        "load_share",
                                        "path_selection_metric",
                                        "record_route",
                                        "shutdown",
                                        "soft_preemption") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes, self).__setattr__(name, value)


                    class PathSetups(Entity):
                        """
                        Tunnel path setup table
                        
                        .. attribute:: path_setup
                        
                        	Tunnel path setup
                        	**type**\: list of    :py:class:`PathSetup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups, self).__init__()

                            self.yang_name = "path-setups"
                            self.yang_parent_name = "tunnel-attributes"

                            self.path_setup = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups, self).__setattr__(name, value)


                        class PathSetup(Entity):
                            """
                            Tunnel path setup
                            
                            .. attribute:: path_setup_name  <key>
                            
                            	Path Name
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: enable
                            
                            	Always set to true
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: path_computation
                            
                            	Path computation method
                            	**type**\:   :py:class:`PathComputation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup.PathComputation>`
                            
                            	**presence node**\: True
                            
                            .. attribute:: preference
                            
                            	Path preference level
                            	**type**\:  int
                            
                            	**range:** \-2147483648..2147483647
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup, self).__init__()

                                self.yang_name = "path-setup"
                                self.yang_parent_name = "path-setups"

                                self.path_setup_name = YLeaf(YType.str, "path-setup-name")

                                self.enable = YLeaf(YType.empty, "enable")

                                self.preference = YLeaf(YType.int32, "preference")

                                self.path_computation = None
                                self._children_name_map["path_computation"] = "path-computation"
                                self._children_yang_names.add("path-computation")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("path_setup_name",
                                                "enable",
                                                "preference") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup, self).__setattr__(name, value)


                            class PathComputation(Entity):
                                """
                                Path computation method
                                
                                .. attribute:: explicit_path_name
                                
                                	Explicit Path Name
                                	**type**\:  str
                                
                                .. attribute:: path_computation_method
                                
                                	Path computation method
                                	**type**\:   :py:class:`MplsTePathComputationMethod <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathComputationMethod>`
                                
                                	**mandatory**\: True
                                
                                .. attribute:: path_computation_server
                                
                                	Path Computation Server Address
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                	**default value**\: 0.0.0.0
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup.PathComputation, self).__init__()

                                    self.yang_name = "path-computation"
                                    self.yang_parent_name = "path-setup"
                                    self.is_presence_container = True

                                    self.explicit_path_name = YLeaf(YType.str, "explicit-path-name")

                                    self.path_computation_method = YLeaf(YType.enumeration, "path-computation-method")

                                    self.path_computation_server = YLeaf(YType.str, "path-computation-server")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("explicit_path_name",
                                                    "path_computation_method",
                                                    "path_computation_server") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup.PathComputation, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup.PathComputation, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.explicit_path_name.is_set or
                                        self.path_computation_method.is_set or
                                        self.path_computation_server.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.explicit_path_name.yfilter != YFilter.not_set or
                                        self.path_computation_method.yfilter != YFilter.not_set or
                                        self.path_computation_server.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "path-computation" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.explicit_path_name.is_set or self.explicit_path_name.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.explicit_path_name.get_name_leafdata())
                                    if (self.path_computation_method.is_set or self.path_computation_method.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.path_computation_method.get_name_leafdata())
                                    if (self.path_computation_server.is_set or self.path_computation_server.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.path_computation_server.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "explicit-path-name" or name == "path-computation-method" or name == "path-computation-server"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "explicit-path-name"):
                                        self.explicit_path_name = value
                                        self.explicit_path_name.value_namespace = name_space
                                        self.explicit_path_name.value_namespace_prefix = name_space_prefix
                                    if(value_path == "path-computation-method"):
                                        self.path_computation_method = value
                                        self.path_computation_method.value_namespace = name_space
                                        self.path_computation_method.value_namespace_prefix = name_space_prefix
                                    if(value_path == "path-computation-server"):
                                        self.path_computation_server = value
                                        self.path_computation_server.value_namespace = name_space
                                        self.path_computation_server.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.path_setup_name.is_set or
                                    self.enable.is_set or
                                    self.preference.is_set or
                                    (self.path_computation is not None))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.path_setup_name.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.preference.yfilter != YFilter.not_set or
                                    (self.path_computation is not None and self.path_computation.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path-setup" + "[path-setup-name='" + self.path_setup_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.path_setup_name.is_set or self.path_setup_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_setup_name.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.preference.is_set or self.preference.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preference.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "path-computation"):
                                    if (self.path_computation is None):
                                        self.path_computation = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup.PathComputation()
                                        self.path_computation.parent = self
                                        self._children_name_map["path_computation"] = "path-computation"
                                    return self.path_computation

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "path-computation" or name == "path-setup-name" or name == "enable" or name == "preference"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "path-setup-name"):
                                    self.path_setup_name = value
                                    self.path_setup_name.value_namespace = name_space
                                    self.path_setup_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "preference"):
                                    self.preference = value
                                    self.preference.value_namespace = name_space
                                    self.preference.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.path_setup:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.path_setup:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-setups" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "path-setup"):
                                for c in self.path_setup:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups.PathSetup()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path_setup.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "path-setup"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class TunnelPathSelection(Entity):
                        """
                        Configure path selection properties
                        
                        .. attribute:: invalidation
                        
                        	Path invalidation configuration for this specific tunnel
                        	**type**\:   :py:class:`Invalidation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection.Invalidation>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: path_selection_cost_limit
                        
                        	Path selection cost limit configuration for this specific tunnel
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        .. attribute:: path_selection_hop_limit
                        
                        	Path selection hop limit configuration for this specific tunnel
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        .. attribute:: tiebreaker
                        
                        	CSPF tiebreaker to use in path calculation
                        	**type**\:   :py:class:`MplsTePathSelectionTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionTiebreaker>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection, self).__init__()

                            self.yang_name = "tunnel-path-selection"
                            self.yang_parent_name = "tunnel-attributes"

                            self.path_selection_cost_limit = YLeaf(YType.uint32, "path-selection-cost-limit")

                            self.path_selection_hop_limit = YLeaf(YType.uint32, "path-selection-hop-limit")

                            self.tiebreaker = YLeaf(YType.enumeration, "tiebreaker")

                            self.invalidation = None
                            self._children_name_map["invalidation"] = "invalidation"
                            self._children_yang_names.add("invalidation")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("path_selection_cost_limit",
                                            "path_selection_hop_limit",
                                            "tiebreaker") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection, self).__setattr__(name, value)


                        class Invalidation(Entity):
                            """
                            Path invalidation configuration for this
                            specific tunnel
                            
                            .. attribute:: path_invalidation_action
                            
                            	Path Invalidation Action
                            	**type**\:   :py:class:`PathInvalidationAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.PathInvalidationAction>`
                            
                            .. attribute:: path_invalidation_timeout
                            
                            	Path Invalidation Timeout
                            	**type**\:  int
                            
                            	**range:** 0..60000
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection.Invalidation, self).__init__()

                                self.yang_name = "invalidation"
                                self.yang_parent_name = "tunnel-path-selection"
                                self.is_presence_container = True

                                self.path_invalidation_action = YLeaf(YType.enumeration, "path-invalidation-action")

                                self.path_invalidation_timeout = YLeaf(YType.uint32, "path-invalidation-timeout")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("path_invalidation_action",
                                                "path_invalidation_timeout") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection.Invalidation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection.Invalidation, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.path_invalidation_action.is_set or
                                    self.path_invalidation_timeout.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.path_invalidation_action.yfilter != YFilter.not_set or
                                    self.path_invalidation_timeout.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "invalidation" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.path_invalidation_action.is_set or self.path_invalidation_action.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_invalidation_action.get_name_leafdata())
                                if (self.path_invalidation_timeout.is_set or self.path_invalidation_timeout.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_invalidation_timeout.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "path-invalidation-action" or name == "path-invalidation-timeout"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "path-invalidation-action"):
                                    self.path_invalidation_action = value
                                    self.path_invalidation_action.value_namespace = name_space
                                    self.path_invalidation_action.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-invalidation-timeout"):
                                    self.path_invalidation_timeout = value
                                    self.path_invalidation_timeout.value_namespace = name_space
                                    self.path_invalidation_timeout.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.path_selection_cost_limit.is_set or
                                self.path_selection_hop_limit.is_set or
                                self.tiebreaker.is_set or
                                (self.invalidation is not None))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.path_selection_cost_limit.yfilter != YFilter.not_set or
                                self.path_selection_hop_limit.yfilter != YFilter.not_set or
                                self.tiebreaker.yfilter != YFilter.not_set or
                                (self.invalidation is not None and self.invalidation.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "tunnel-path-selection" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.path_selection_cost_limit.is_set or self.path_selection_cost_limit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_selection_cost_limit.get_name_leafdata())
                            if (self.path_selection_hop_limit.is_set or self.path_selection_hop_limit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_selection_hop_limit.get_name_leafdata())
                            if (self.tiebreaker.is_set or self.tiebreaker.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tiebreaker.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "invalidation"):
                                if (self.invalidation is None):
                                    self.invalidation = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection.Invalidation()
                                    self.invalidation.parent = self
                                    self._children_name_map["invalidation"] = "invalidation"
                                return self.invalidation

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "invalidation" or name == "path-selection-cost-limit" or name == "path-selection-hop-limit" or name == "tiebreaker"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "path-selection-cost-limit"):
                                self.path_selection_cost_limit = value
                                self.path_selection_cost_limit.value_namespace = name_space
                                self.path_selection_cost_limit.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-selection-hop-limit"):
                                self.path_selection_hop_limit = value
                                self.path_selection_hop_limit.value_namespace = name_space
                                self.path_selection_hop_limit.value_namespace_prefix = name_space_prefix
                            if(value_path == "tiebreaker"):
                                self.tiebreaker = value
                                self.tiebreaker.value_namespace = name_space
                                self.tiebreaker.value_namespace_prefix = name_space_prefix


                    class AutoBandwidth(Entity):
                        """
                        Tunnel Interface Auto\-bandwidth configuration
                        data
                        
                        .. attribute:: adjustment_threshold
                        
                        	Set the bandwidth change threshold to trigger adjustment
                        	**type**\:   :py:class:`AdjustmentThreshold <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.AdjustmentThreshold>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: application_frequency
                        
                        	Set the tunnel auto\-bw application frequency in minutes
                        	**type**\:  int
                        
                        	**range:** 5..10080
                        
                        	**units**\: minute
                        
                        .. attribute:: bandwidth_limits
                        
                        	Set min/max bandwidth auto\-bw can apply on a tunnel
                        	**type**\:   :py:class:`BandwidthLimits <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.BandwidthLimits>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: collection_only
                        
                        	Enable bandwidth collection only, no auto\-bw adjustment
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: enabled
                        
                        	This object is only valid for tunnel interfaces and it controls whether that interface has auto\-bw enabled on it or not.The object must be set before any other auto\-bw configuration is supplied for the interface, and must be the last auto\-bw configuration object to be removed 
                        	**type**\:  bool
                        
                        .. attribute:: overflow
                        
                        	Configuring the tunnel overflow detection
                        	**type**\:   :py:class:`Overflow <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Overflow>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: overflow_enable
                        
                        	Enable auto bandwidth overflow detection
                        	**type**\:  bool
                        
                        .. attribute:: underflow
                        
                        	Configuring the tunnel underflow detection
                        	**type**\:   :py:class:`Underflow <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Underflow>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: underflow_enable
                        
                        	Enable auto bandwidth underflow detection
                        	**type**\:  bool
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth, self).__init__()

                            self.yang_name = "auto-bandwidth"
                            self.yang_parent_name = "tunnel-attributes"

                            self.application_frequency = YLeaf(YType.uint32, "application-frequency")

                            self.collection_only = YLeaf(YType.empty, "collection-only")

                            self.enabled = YLeaf(YType.boolean, "enabled")

                            self.overflow_enable = YLeaf(YType.boolean, "overflow-enable")

                            self.underflow_enable = YLeaf(YType.boolean, "underflow-enable")

                            self.adjustment_threshold = None
                            self._children_name_map["adjustment_threshold"] = "adjustment-threshold"
                            self._children_yang_names.add("adjustment-threshold")

                            self.bandwidth_limits = None
                            self._children_name_map["bandwidth_limits"] = "bandwidth-limits"
                            self._children_yang_names.add("bandwidth-limits")

                            self.overflow = None
                            self._children_name_map["overflow"] = "overflow"
                            self._children_yang_names.add("overflow")

                            self.underflow = None
                            self._children_name_map["underflow"] = "underflow"
                            self._children_yang_names.add("underflow")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("application_frequency",
                                            "collection_only",
                                            "enabled",
                                            "overflow_enable",
                                            "underflow_enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth, self).__setattr__(name, value)


                        class Underflow(Entity):
                            """
                            Configuring the tunnel underflow detection
                            
                            .. attribute:: underflow_threshold_limit
                            
                            	Number of consecutive collections exceeding threshold
                            	**type**\:  int
                            
                            	**range:** 1..10
                            
                            	**mandatory**\: True
                            
                            .. attribute:: underflow_threshold_percent
                            
                            	Bandwidth change percent to trigger an underflow
                            	**type**\:  int
                            
                            	**range:** 1..100
                            
                            	**mandatory**\: True
                            
                            	**units**\: percentage
                            
                            .. attribute:: underflow_threshold_value
                            
                            	Bandwidth change value to trigger an underflow (kbps)
                            	**type**\:  int
                            
                            	**range:** 10..4294967295
                            
                            	**mandatory**\: True
                            
                            	**units**\: kbit/s
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Underflow, self).__init__()

                                self.yang_name = "underflow"
                                self.yang_parent_name = "auto-bandwidth"
                                self.is_presence_container = True

                                self.underflow_threshold_limit = YLeaf(YType.uint32, "underflow-threshold-limit")

                                self.underflow_threshold_percent = YLeaf(YType.uint32, "underflow-threshold-percent")

                                self.underflow_threshold_value = YLeaf(YType.uint32, "underflow-threshold-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("underflow_threshold_limit",
                                                "underflow_threshold_percent",
                                                "underflow_threshold_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Underflow, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Underflow, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.underflow_threshold_limit.is_set or
                                    self.underflow_threshold_percent.is_set or
                                    self.underflow_threshold_value.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.underflow_threshold_limit.yfilter != YFilter.not_set or
                                    self.underflow_threshold_percent.yfilter != YFilter.not_set or
                                    self.underflow_threshold_value.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "underflow" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.underflow_threshold_limit.is_set or self.underflow_threshold_limit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.underflow_threshold_limit.get_name_leafdata())
                                if (self.underflow_threshold_percent.is_set or self.underflow_threshold_percent.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.underflow_threshold_percent.get_name_leafdata())
                                if (self.underflow_threshold_value.is_set or self.underflow_threshold_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.underflow_threshold_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "underflow-threshold-limit" or name == "underflow-threshold-percent" or name == "underflow-threshold-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "underflow-threshold-limit"):
                                    self.underflow_threshold_limit = value
                                    self.underflow_threshold_limit.value_namespace = name_space
                                    self.underflow_threshold_limit.value_namespace_prefix = name_space_prefix
                                if(value_path == "underflow-threshold-percent"):
                                    self.underflow_threshold_percent = value
                                    self.underflow_threshold_percent.value_namespace = name_space
                                    self.underflow_threshold_percent.value_namespace_prefix = name_space_prefix
                                if(value_path == "underflow-threshold-value"):
                                    self.underflow_threshold_value = value
                                    self.underflow_threshold_value.value_namespace = name_space
                                    self.underflow_threshold_value.value_namespace_prefix = name_space_prefix


                        class Overflow(Entity):
                            """
                            Configuring the tunnel overflow detection
                            
                            .. attribute:: overflow_threshold_limit
                            
                            	Number of consecutive collections exceeding threshold
                            	**type**\:  int
                            
                            	**range:** 1..10
                            
                            	**mandatory**\: True
                            
                            .. attribute:: overflow_threshold_percent
                            
                            	Bandwidth change percent to trigger an overflow
                            	**type**\:  int
                            
                            	**range:** 1..100
                            
                            	**mandatory**\: True
                            
                            	**units**\: percentage
                            
                            .. attribute:: overflow_threshold_value
                            
                            	Bandwidth change value to trigger an overflow (kbps)
                            	**type**\:  int
                            
                            	**range:** 10..4294967295
                            
                            	**mandatory**\: True
                            
                            	**units**\: kbit/s
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Overflow, self).__init__()

                                self.yang_name = "overflow"
                                self.yang_parent_name = "auto-bandwidth"
                                self.is_presence_container = True

                                self.overflow_threshold_limit = YLeaf(YType.uint32, "overflow-threshold-limit")

                                self.overflow_threshold_percent = YLeaf(YType.uint32, "overflow-threshold-percent")

                                self.overflow_threshold_value = YLeaf(YType.uint32, "overflow-threshold-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("overflow_threshold_limit",
                                                "overflow_threshold_percent",
                                                "overflow_threshold_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Overflow, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Overflow, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.overflow_threshold_limit.is_set or
                                    self.overflow_threshold_percent.is_set or
                                    self.overflow_threshold_value.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.overflow_threshold_limit.yfilter != YFilter.not_set or
                                    self.overflow_threshold_percent.yfilter != YFilter.not_set or
                                    self.overflow_threshold_value.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "overflow" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.overflow_threshold_limit.is_set or self.overflow_threshold_limit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.overflow_threshold_limit.get_name_leafdata())
                                if (self.overflow_threshold_percent.is_set or self.overflow_threshold_percent.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.overflow_threshold_percent.get_name_leafdata())
                                if (self.overflow_threshold_value.is_set or self.overflow_threshold_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.overflow_threshold_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "overflow-threshold-limit" or name == "overflow-threshold-percent" or name == "overflow-threshold-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "overflow-threshold-limit"):
                                    self.overflow_threshold_limit = value
                                    self.overflow_threshold_limit.value_namespace = name_space
                                    self.overflow_threshold_limit.value_namespace_prefix = name_space_prefix
                                if(value_path == "overflow-threshold-percent"):
                                    self.overflow_threshold_percent = value
                                    self.overflow_threshold_percent.value_namespace = name_space
                                    self.overflow_threshold_percent.value_namespace_prefix = name_space_prefix
                                if(value_path == "overflow-threshold-value"):
                                    self.overflow_threshold_value = value
                                    self.overflow_threshold_value.value_namespace = name_space
                                    self.overflow_threshold_value.value_namespace_prefix = name_space_prefix


                        class BandwidthLimits(Entity):
                            """
                            Set min/max bandwidth auto\-bw can apply on a
                            tunnel
                            
                            .. attribute:: bandwidth_max_limit
                            
                            	Set maximum bandwidth auto\-bw can apply on a tunnel
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**mandatory**\: True
                            
                            .. attribute:: bandwidth_min_limit
                            
                            	Set minimum bandwidth auto\-bw can apply on a tunnel
                            	**type**\:  int
                            
                            	**range:** 0..4294967295
                            
                            	**mandatory**\: True
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.BandwidthLimits, self).__init__()

                                self.yang_name = "bandwidth-limits"
                                self.yang_parent_name = "auto-bandwidth"
                                self.is_presence_container = True

                                self.bandwidth_max_limit = YLeaf(YType.uint32, "bandwidth-max-limit")

                                self.bandwidth_min_limit = YLeaf(YType.uint32, "bandwidth-min-limit")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("bandwidth_max_limit",
                                                "bandwidth_min_limit") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.BandwidthLimits, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.BandwidthLimits, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.bandwidth_max_limit.is_set or
                                    self.bandwidth_min_limit.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.bandwidth_max_limit.yfilter != YFilter.not_set or
                                    self.bandwidth_min_limit.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bandwidth-limits" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.bandwidth_max_limit.is_set or self.bandwidth_max_limit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bandwidth_max_limit.get_name_leafdata())
                                if (self.bandwidth_min_limit.is_set or self.bandwidth_min_limit.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bandwidth_min_limit.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bandwidth-max-limit" or name == "bandwidth-min-limit"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "bandwidth-max-limit"):
                                    self.bandwidth_max_limit = value
                                    self.bandwidth_max_limit.value_namespace = name_space
                                    self.bandwidth_max_limit.value_namespace_prefix = name_space_prefix
                                if(value_path == "bandwidth-min-limit"):
                                    self.bandwidth_min_limit = value
                                    self.bandwidth_min_limit.value_namespace = name_space
                                    self.bandwidth_min_limit.value_namespace_prefix = name_space_prefix


                        class AdjustmentThreshold(Entity):
                            """
                            Set the bandwidth change threshold to trigger
                            adjustment
                            
                            .. attribute:: adjustment_threshold_percent
                            
                            	Bandwidth change percent to trigger adjustment
                            	**type**\:  int
                            
                            	**range:** 1..100
                            
                            	**mandatory**\: True
                            
                            	**units**\: percentage
                            
                            .. attribute:: adjustment_threshold_value
                            
                            	Bandwidth change value to trigger adjustment (kbps)
                            	**type**\:  int
                            
                            	**range:** 10..4294967295
                            
                            	**mandatory**\: True
                            
                            	**units**\: kbit/s
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.AdjustmentThreshold, self).__init__()

                                self.yang_name = "adjustment-threshold"
                                self.yang_parent_name = "auto-bandwidth"
                                self.is_presence_container = True

                                self.adjustment_threshold_percent = YLeaf(YType.uint32, "adjustment-threshold-percent")

                                self.adjustment_threshold_value = YLeaf(YType.uint32, "adjustment-threshold-value")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("adjustment_threshold_percent",
                                                "adjustment_threshold_value") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.AdjustmentThreshold, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.AdjustmentThreshold, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.adjustment_threshold_percent.is_set or
                                    self.adjustment_threshold_value.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.adjustment_threshold_percent.yfilter != YFilter.not_set or
                                    self.adjustment_threshold_value.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "adjustment-threshold" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.adjustment_threshold_percent.is_set or self.adjustment_threshold_percent.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.adjustment_threshold_percent.get_name_leafdata())
                                if (self.adjustment_threshold_value.is_set or self.adjustment_threshold_value.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.adjustment_threshold_value.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "adjustment-threshold-percent" or name == "adjustment-threshold-value"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "adjustment-threshold-percent"):
                                    self.adjustment_threshold_percent = value
                                    self.adjustment_threshold_percent.value_namespace = name_space
                                    self.adjustment_threshold_percent.value_namespace_prefix = name_space_prefix
                                if(value_path == "adjustment-threshold-value"):
                                    self.adjustment_threshold_value = value
                                    self.adjustment_threshold_value.value_namespace = name_space
                                    self.adjustment_threshold_value.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.application_frequency.is_set or
                                self.collection_only.is_set or
                                self.enabled.is_set or
                                self.overflow_enable.is_set or
                                self.underflow_enable.is_set or
                                (self.adjustment_threshold is not None) or
                                (self.bandwidth_limits is not None) or
                                (self.overflow is not None) or
                                (self.underflow is not None))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.application_frequency.yfilter != YFilter.not_set or
                                self.collection_only.yfilter != YFilter.not_set or
                                self.enabled.yfilter != YFilter.not_set or
                                self.overflow_enable.yfilter != YFilter.not_set or
                                self.underflow_enable.yfilter != YFilter.not_set or
                                (self.adjustment_threshold is not None and self.adjustment_threshold.has_operation()) or
                                (self.bandwidth_limits is not None and self.bandwidth_limits.has_operation()) or
                                (self.overflow is not None and self.overflow.has_operation()) or
                                (self.underflow is not None and self.underflow.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "auto-bandwidth" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.application_frequency.is_set or self.application_frequency.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.application_frequency.get_name_leafdata())
                            if (self.collection_only.is_set or self.collection_only.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.collection_only.get_name_leafdata())
                            if (self.enabled.is_set or self.enabled.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enabled.get_name_leafdata())
                            if (self.overflow_enable.is_set or self.overflow_enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.overflow_enable.get_name_leafdata())
                            if (self.underflow_enable.is_set or self.underflow_enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.underflow_enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "adjustment-threshold"):
                                if (self.adjustment_threshold is None):
                                    self.adjustment_threshold = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.AdjustmentThreshold()
                                    self.adjustment_threshold.parent = self
                                    self._children_name_map["adjustment_threshold"] = "adjustment-threshold"
                                return self.adjustment_threshold

                            if (child_yang_name == "bandwidth-limits"):
                                if (self.bandwidth_limits is None):
                                    self.bandwidth_limits = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.BandwidthLimits()
                                    self.bandwidth_limits.parent = self
                                    self._children_name_map["bandwidth_limits"] = "bandwidth-limits"
                                return self.bandwidth_limits

                            if (child_yang_name == "overflow"):
                                if (self.overflow is None):
                                    self.overflow = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Overflow()
                                    self.overflow.parent = self
                                    self._children_name_map["overflow"] = "overflow"
                                return self.overflow

                            if (child_yang_name == "underflow"):
                                if (self.underflow is None):
                                    self.underflow = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth.Underflow()
                                    self.underflow.parent = self
                                    self._children_name_map["underflow"] = "underflow"
                                return self.underflow

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "adjustment-threshold" or name == "bandwidth-limits" or name == "overflow" or name == "underflow" or name == "application-frequency" or name == "collection-only" or name == "enabled" or name == "overflow-enable" or name == "underflow-enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "application-frequency"):
                                self.application_frequency = value
                                self.application_frequency.value_namespace = name_space
                                self.application_frequency.value_namespace_prefix = name_space_prefix
                            if(value_path == "collection-only"):
                                self.collection_only = value
                                self.collection_only.value_namespace = name_space
                                self.collection_only.value_namespace_prefix = name_space_prefix
                            if(value_path == "enabled"):
                                self.enabled = value
                                self.enabled.value_namespace = name_space
                                self.enabled.value_namespace_prefix = name_space_prefix
                            if(value_path == "overflow-enable"):
                                self.overflow_enable = value
                                self.overflow_enable.value_namespace = name_space
                                self.overflow_enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "underflow-enable"):
                                self.underflow_enable = value
                                self.underflow_enable.value_namespace = name_space
                                self.underflow_enable.value_namespace_prefix = name_space_prefix


                    class Priority(Entity):
                        """
                        Tunnel Setup and Hold Priorities
                        
                        .. attribute:: hold_priority
                        
                        	Hold Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        .. attribute:: setup_priority
                        
                        	Setup Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Priority, self).__init__()

                            self.yang_name = "priority"
                            self.yang_parent_name = "tunnel-attributes"
                            self.is_presence_container = True

                            self.hold_priority = YLeaf(YType.uint32, "hold-priority")

                            self.setup_priority = YLeaf(YType.uint32, "setup-priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hold_priority",
                                            "setup_priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Priority, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Priority, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.hold_priority.is_set or
                                self.setup_priority.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hold_priority.yfilter != YFilter.not_set or
                                self.setup_priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "priority" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hold_priority.get_name_leafdata())
                            if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.setup_priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hold-priority" or name == "setup-priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hold-priority"):
                                self.hold_priority = value
                                self.hold_priority.value_namespace = name_space
                                self.hold_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "setup-priority"):
                                self.setup_priority = value
                                self.setup_priority.value_namespace = name_space
                                self.setup_priority.value_namespace_prefix = name_space_prefix


                    class Logging(Entity):
                        """
                        Log tunnel LSP messages
                        
                        .. attribute:: all
                        
                        	Log all events for a tunnel
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: bandwidth_change_message
                        
                        	Log tunnel messages for bandwidth change
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: bfd_state_message
                        
                        	Enable BFD session state change alarm
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: insufficient_bw_message
                        
                        	Log tunnel messages for insufficient bandwidth
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: lsp_switch_over_change_message
                        
                        	Log tunnel messages for bandwidth change
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: pcalc_failure_message
                        
                        	Enable logging for path\-calculation failures
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: record_route_messsage
                        
                        	Log tunnel record\-route messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimize_attempts_message
                        
                        	Log tunnel reoptimization attempts messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimized_message
                        
                        	Log tunnel reoptimized messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reroute_messsage
                        
                        	Log tunnel rereoute messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: state_message
                        
                        	Log tunnel state messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Logging, self).__init__()

                            self.yang_name = "logging"
                            self.yang_parent_name = "tunnel-attributes"

                            self.all = YLeaf(YType.empty, "all")

                            self.bandwidth_change_message = YLeaf(YType.empty, "bandwidth-change-message")

                            self.bfd_state_message = YLeaf(YType.empty, "bfd-state-message")

                            self.insufficient_bw_message = YLeaf(YType.empty, "insufficient-bw-message")

                            self.lsp_switch_over_change_message = YLeaf(YType.empty, "lsp-switch-over-change-message")

                            self.pcalc_failure_message = YLeaf(YType.empty, "pcalc-failure-message")

                            self.record_route_messsage = YLeaf(YType.empty, "record-route-messsage")

                            self.reoptimize_attempts_message = YLeaf(YType.empty, "reoptimize-attempts-message")

                            self.reoptimized_message = YLeaf(YType.empty, "reoptimized-message")

                            self.reroute_messsage = YLeaf(YType.empty, "reroute-messsage")

                            self.state_message = YLeaf(YType.empty, "state-message")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("all",
                                            "bandwidth_change_message",
                                            "bfd_state_message",
                                            "insufficient_bw_message",
                                            "lsp_switch_over_change_message",
                                            "pcalc_failure_message",
                                            "record_route_messsage",
                                            "reoptimize_attempts_message",
                                            "reoptimized_message",
                                            "reroute_messsage",
                                            "state_message") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Logging, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Logging, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.all.is_set or
                                self.bandwidth_change_message.is_set or
                                self.bfd_state_message.is_set or
                                self.insufficient_bw_message.is_set or
                                self.lsp_switch_over_change_message.is_set or
                                self.pcalc_failure_message.is_set or
                                self.record_route_messsage.is_set or
                                self.reoptimize_attempts_message.is_set or
                                self.reoptimized_message.is_set or
                                self.reroute_messsage.is_set or
                                self.state_message.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.all.yfilter != YFilter.not_set or
                                self.bandwidth_change_message.yfilter != YFilter.not_set or
                                self.bfd_state_message.yfilter != YFilter.not_set or
                                self.insufficient_bw_message.yfilter != YFilter.not_set or
                                self.lsp_switch_over_change_message.yfilter != YFilter.not_set or
                                self.pcalc_failure_message.yfilter != YFilter.not_set or
                                self.record_route_messsage.yfilter != YFilter.not_set or
                                self.reoptimize_attempts_message.yfilter != YFilter.not_set or
                                self.reoptimized_message.yfilter != YFilter.not_set or
                                self.reroute_messsage.yfilter != YFilter.not_set or
                                self.state_message.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "logging" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.all.is_set or self.all.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.all.get_name_leafdata())
                            if (self.bandwidth_change_message.is_set or self.bandwidth_change_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth_change_message.get_name_leafdata())
                            if (self.bfd_state_message.is_set or self.bfd_state_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfd_state_message.get_name_leafdata())
                            if (self.insufficient_bw_message.is_set or self.insufficient_bw_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.insufficient_bw_message.get_name_leafdata())
                            if (self.lsp_switch_over_change_message.is_set or self.lsp_switch_over_change_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lsp_switch_over_change_message.get_name_leafdata())
                            if (self.pcalc_failure_message.is_set or self.pcalc_failure_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pcalc_failure_message.get_name_leafdata())
                            if (self.record_route_messsage.is_set or self.record_route_messsage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.record_route_messsage.get_name_leafdata())
                            if (self.reoptimize_attempts_message.is_set or self.reoptimize_attempts_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimize_attempts_message.get_name_leafdata())
                            if (self.reoptimized_message.is_set or self.reoptimized_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimized_message.get_name_leafdata())
                            if (self.reroute_messsage.is_set or self.reroute_messsage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reroute_messsage.get_name_leafdata())
                            if (self.state_message.is_set or self.state_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.state_message.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "all" or name == "bandwidth-change-message" or name == "bfd-state-message" or name == "insufficient-bw-message" or name == "lsp-switch-over-change-message" or name == "pcalc-failure-message" or name == "record-route-messsage" or name == "reoptimize-attempts-message" or name == "reoptimized-message" or name == "reroute-messsage" or name == "state-message"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "all"):
                                self.all = value
                                self.all.value_namespace = name_space
                                self.all.value_namespace_prefix = name_space_prefix
                            if(value_path == "bandwidth-change-message"):
                                self.bandwidth_change_message = value
                                self.bandwidth_change_message.value_namespace = name_space
                                self.bandwidth_change_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "bfd-state-message"):
                                self.bfd_state_message = value
                                self.bfd_state_message.value_namespace = name_space
                                self.bfd_state_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "insufficient-bw-message"):
                                self.insufficient_bw_message = value
                                self.insufficient_bw_message.value_namespace = name_space
                                self.insufficient_bw_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "lsp-switch-over-change-message"):
                                self.lsp_switch_over_change_message = value
                                self.lsp_switch_over_change_message.value_namespace = name_space
                                self.lsp_switch_over_change_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "pcalc-failure-message"):
                                self.pcalc_failure_message = value
                                self.pcalc_failure_message.value_namespace = name_space
                                self.pcalc_failure_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "record-route-messsage"):
                                self.record_route_messsage = value
                                self.record_route_messsage.value_namespace = name_space
                                self.record_route_messsage.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimize-attempts-message"):
                                self.reoptimize_attempts_message = value
                                self.reoptimize_attempts_message.value_namespace = name_space
                                self.reoptimize_attempts_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimized-message"):
                                self.reoptimized_message = value
                                self.reoptimized_message.value_namespace = name_space
                                self.reoptimized_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reroute-messsage"):
                                self.reroute_messsage = value
                                self.reroute_messsage.value_namespace = name_space
                                self.reroute_messsage.value_namespace_prefix = name_space_prefix
                            if(value_path == "state-message"):
                                self.state_message = value
                                self.state_message.value_namespace = name_space
                                self.state_message.value_namespace_prefix = name_space_prefix


                    class Bandwidth(Entity):
                        """
                        Tunnel bandwidth requirement
                        
                        .. attribute:: bandwidth
                        
                        	The value of the bandwidth reserved by this tunnel in kbps
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**mandatory**\: True
                        
                        	**units**\: kbit/s
                        
                        .. attribute:: class_or_pool_type
                        
                        	Class type for the bandwidth allocation
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        .. attribute:: dste_type
                        
                        	DSTE\-standard flag
                        	**type**\:   :py:class:`MplsTeBandwidthDste <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeBandwidthDste>`
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Bandwidth, self).__init__()

                            self.yang_name = "bandwidth"
                            self.yang_parent_name = "tunnel-attributes"
                            self.is_presence_container = True

                            self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                            self.class_or_pool_type = YLeaf(YType.uint32, "class-or-pool-type")

                            self.dste_type = YLeaf(YType.enumeration, "dste-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth",
                                            "class_or_pool_type",
                                            "dste_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Bandwidth, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Bandwidth, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bandwidth.is_set or
                                self.class_or_pool_type.is_set or
                                self.dste_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth.yfilter != YFilter.not_set or
                                self.class_or_pool_type.yfilter != YFilter.not_set or
                                self.dste_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bandwidth" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth.get_name_leafdata())
                            if (self.class_or_pool_type.is_set or self.class_or_pool_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.class_or_pool_type.get_name_leafdata())
                            if (self.dste_type.is_set or self.dste_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dste_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth" or name == "class-or-pool-type" or name == "dste-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth"):
                                self.bandwidth = value
                                self.bandwidth.value_namespace = name_space
                                self.bandwidth.value_namespace_prefix = name_space_prefix
                            if(value_path == "class-or-pool-type"):
                                self.class_or_pool_type = value
                                self.class_or_pool_type.value_namespace = name_space
                                self.class_or_pool_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "dste-type"):
                                self.dste_type = value
                                self.dste_type.value_namespace = name_space
                                self.dste_type.value_namespace_prefix = name_space_prefix


                    class Autoroute(Entity):
                        """
                        Parameters for IGP routing over tunnel
                        
                        .. attribute:: autoroute_announce
                        
                        	Announce tunnel to IGP
                        	**type**\:   :py:class:`AutorouteAnnounce <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce>`
                        
                        .. attribute:: destination
                        
                        	Deprecated\: do NOT use
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: destination_xr
                        
                        	Tunnel Autoroute Destination(s)
                        	**type**\:   :py:class:`DestinationXr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute, self).__init__()

                            self.yang_name = "autoroute"
                            self.yang_parent_name = "tunnel-attributes"

                            self.destination = YLeaf(YType.empty, "destination")

                            self.autoroute_announce = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce()
                            self.autoroute_announce.parent = self
                            self._children_name_map["autoroute_announce"] = "autoroute-announce"
                            self._children_yang_names.add("autoroute-announce")

                            self.destination_xr = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr()
                            self.destination_xr.parent = self
                            self._children_name_map["destination_xr"] = "destination-xr"
                            self._children_yang_names.add("destination-xr")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("destination") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute, self).__setattr__(name, value)


                        class AutorouteAnnounce(Entity):
                            """
                            Announce tunnel to IGP
                            
                            .. attribute:: enable
                            
                            	Enable autoroute announce
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: exclude_traffic
                            
                            	Exclude traffic on autorouted tunnel
                            	**type**\:   :py:class:`ExcludeTraffic <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.ExcludeTraffic>`
                            
                            .. attribute:: include_ipv6
                            
                            	Specify that the tunnel should be an IPv6 autoroute announce also
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: metric
                            
                            	Specify MPLS tunnel metric
                            	**type**\:   :py:class:`Metric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.Metric>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce, self).__init__()

                                self.yang_name = "autoroute-announce"
                                self.yang_parent_name = "autoroute"

                                self.enable = YLeaf(YType.empty, "enable")

                                self.include_ipv6 = YLeaf(YType.empty, "include-ipv6")

                                self.exclude_traffic = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.ExcludeTraffic()
                                self.exclude_traffic.parent = self
                                self._children_name_map["exclude_traffic"] = "exclude-traffic"
                                self._children_yang_names.add("exclude-traffic")

                                self.metric = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.Metric()
                                self.metric.parent = self
                                self._children_name_map["metric"] = "metric"
                                self._children_yang_names.add("metric")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable",
                                                "include_ipv6") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce, self).__setattr__(name, value)


                            class ExcludeTraffic(Entity):
                                """
                                Exclude traffic on autorouted tunnel
                                
                                .. attribute:: segment_routing
                                
                                	Exclude tunnel in IGP for SR prefixes
                                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                                
                                

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.ExcludeTraffic, self).__init__()

                                    self.yang_name = "exclude-traffic"
                                    self.yang_parent_name = "autoroute-announce"

                                    self.segment_routing = YLeaf(YType.empty, "segment-routing")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("segment_routing") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.ExcludeTraffic, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.ExcludeTraffic, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.segment_routing.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.segment_routing.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "exclude-traffic" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.segment_routing.is_set or self.segment_routing.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.segment_routing.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "segment-routing"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "segment-routing"):
                                        self.segment_routing = value
                                        self.segment_routing.value_namespace = name_space
                                        self.segment_routing.value_namespace_prefix = name_space_prefix


                            class Metric(Entity):
                                """
                                Specify MPLS tunnel metric
                                
                                .. attribute:: absolute_metric
                                
                                	The absolute metric value
                                	**type**\:  int
                                
                                	**range:** 1..2147483647
                                
                                .. attribute:: constant_metric
                                
                                	The constant metric value
                                	**type**\:  int
                                
                                	**range:** 1..2147483647
                                
                                .. attribute:: metric_type
                                
                                	Autoroute tunnel metric type
                                	**type**\:   :py:class:`MplsTeAutorouteMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeAutorouteMetric>`
                                
                                .. attribute:: relative_metric
                                
                                	The value of the adjustment
                                	**type**\:  int
                                
                                	**range:** \-10..10
                                
                                

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.Metric, self).__init__()

                                    self.yang_name = "metric"
                                    self.yang_parent_name = "autoroute-announce"

                                    self.absolute_metric = YLeaf(YType.uint32, "absolute-metric")

                                    self.constant_metric = YLeaf(YType.uint32, "constant-metric")

                                    self.metric_type = YLeaf(YType.enumeration, "metric-type")

                                    self.relative_metric = YLeaf(YType.int32, "relative-metric")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("absolute_metric",
                                                    "constant_metric",
                                                    "metric_type",
                                                    "relative_metric") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.Metric, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.Metric, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.absolute_metric.is_set or
                                        self.constant_metric.is_set or
                                        self.metric_type.is_set or
                                        self.relative_metric.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.absolute_metric.yfilter != YFilter.not_set or
                                        self.constant_metric.yfilter != YFilter.not_set or
                                        self.metric_type.yfilter != YFilter.not_set or
                                        self.relative_metric.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "metric" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.absolute_metric.is_set or self.absolute_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.absolute_metric.get_name_leafdata())
                                    if (self.constant_metric.is_set or self.constant_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.constant_metric.get_name_leafdata())
                                    if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.metric_type.get_name_leafdata())
                                    if (self.relative_metric.is_set or self.relative_metric.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.relative_metric.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "absolute-metric" or name == "constant-metric" or name == "metric-type" or name == "relative-metric"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "absolute-metric"):
                                        self.absolute_metric = value
                                        self.absolute_metric.value_namespace = name_space
                                        self.absolute_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "constant-metric"):
                                        self.constant_metric = value
                                        self.constant_metric.value_namespace = name_space
                                        self.constant_metric.value_namespace_prefix = name_space_prefix
                                    if(value_path == "metric-type"):
                                        self.metric_type = value
                                        self.metric_type.value_namespace = name_space
                                        self.metric_type.value_namespace_prefix = name_space_prefix
                                    if(value_path == "relative-metric"):
                                        self.relative_metric = value
                                        self.relative_metric.value_namespace = name_space
                                        self.relative_metric.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    self.include_ipv6.is_set or
                                    (self.exclude_traffic is not None and self.exclude_traffic.has_data()) or
                                    (self.metric is not None and self.metric.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    self.include_ipv6.yfilter != YFilter.not_set or
                                    (self.exclude_traffic is not None and self.exclude_traffic.has_operation()) or
                                    (self.metric is not None and self.metric.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "autoroute-announce" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())
                                if (self.include_ipv6.is_set or self.include_ipv6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.include_ipv6.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "exclude-traffic"):
                                    if (self.exclude_traffic is None):
                                        self.exclude_traffic = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.ExcludeTraffic()
                                        self.exclude_traffic.parent = self
                                        self._children_name_map["exclude_traffic"] = "exclude-traffic"
                                    return self.exclude_traffic

                                if (child_yang_name == "metric"):
                                    if (self.metric is None):
                                        self.metric = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce.Metric()
                                        self.metric.parent = self
                                        self._children_name_map["metric"] = "metric"
                                    return self.metric

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "exclude-traffic" or name == "metric" or name == "enable" or name == "include-ipv6"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix
                                if(value_path == "include-ipv6"):
                                    self.include_ipv6 = value
                                    self.include_ipv6.value_namespace = name_space
                                    self.include_ipv6.value_namespace_prefix = name_space_prefix


                        class DestinationXr(Entity):
                            """
                            Tunnel Autoroute Destination(s)
                            
                            .. attribute:: destination
                            
                            	Destination address to add in RIB
                            	**type**\: list of    :py:class:`Destination <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr.Destination>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr, self).__init__()

                                self.yang_name = "destination-xr"
                                self.yang_parent_name = "autoroute"

                                self.destination = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr, self).__setattr__(name, value)


                            class Destination(Entity):
                                """
                                Destination address to add in RIB
                                
                                .. attribute:: destination_address  <key>
                                
                                	IP address of destination
                                	**type**\:  str
                                
                                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                
                                

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr.Destination, self).__init__()

                                    self.yang_name = "destination"
                                    self.yang_parent_name = "destination-xr"

                                    self.destination_address = YLeaf(YType.str, "destination-address")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("destination_address") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr.Destination, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr.Destination, self).__setattr__(name, value)

                                def has_data(self):
                                    return self.destination_address.is_set

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.destination_address.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "destination" + "[destination-address='" + self.destination_address.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.destination_address.is_set or self.destination_address.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.destination_address.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "destination-address"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "destination-address"):
                                        self.destination_address = value
                                        self.destination_address.value_namespace = name_space
                                        self.destination_address.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.destination:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.destination:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "destination-xr" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "destination"):
                                    for c in self.destination:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr.Destination()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.destination.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "destination"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                self.destination.is_set or
                                (self.autoroute_announce is not None and self.autoroute_announce.has_data()) or
                                (self.destination_xr is not None and self.destination_xr.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.destination.yfilter != YFilter.not_set or
                                (self.autoroute_announce is not None and self.autoroute_announce.has_operation()) or
                                (self.destination_xr is not None and self.destination_xr.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "autoroute" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.destination.is_set or self.destination.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.destination.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "autoroute-announce"):
                                if (self.autoroute_announce is None):
                                    self.autoroute_announce = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.AutorouteAnnounce()
                                    self.autoroute_announce.parent = self
                                    self._children_name_map["autoroute_announce"] = "autoroute-announce"
                                return self.autoroute_announce

                            if (child_yang_name == "destination-xr"):
                                if (self.destination_xr is None):
                                    self.destination_xr = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute.DestinationXr()
                                    self.destination_xr.parent = self
                                    self._children_name_map["destination_xr"] = "destination-xr"
                                return self.destination_xr

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "autoroute-announce" or name == "destination-xr" or name == "destination"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "destination"):
                                self.destination = value
                                self.destination.value_namespace = name_space
                                self.destination.value_namespace_prefix = name_space_prefix


                    class NewStyleAffinityAffinityTypes(Entity):
                        """
                        Tunnel new style affinity attributes table
                        
                        .. attribute:: new_style_affinity_affinity_type
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes, self).__init__()

                            self.yang_name = "new-style-affinity-affinity-types"
                            self.yang_parent_name = "tunnel-attributes"

                            self.new_style_affinity_affinity_type = YList(self)
                            self.new_style_affinity_affinity_type_affinity1 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10 = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)


                        class NewStyleAffinityAffinityType(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)

                            def has_data(self):
                                return self.affinity_type.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type" + "[affinity-type='" + self.affinity_type.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity10  <key>
                            
                            	The name of the tenth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                                self.affinity10 = YLeaf(YType.str, "affinity10")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9",
                                                "affinity10") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set or
                                    self.affinity10.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set or
                                    self.affinity10.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + "[affinity10='" + self.affinity10.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())
                                if (self.affinity10.is_set or self.affinity10.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity10.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9" or name == "affinity10"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity10"):
                                    self.affinity10 = value
                                    self.affinity10.value_namespace = name_space
                                    self.affinity10.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "new-style-affinity-affinity-types" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "new-style-affinity-affinity-type"):
                                for c in self.new_style_affinity_affinity_type:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1"):
                                for c in self.new_style_affinity_affinity_type_affinity1:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "new-style-affinity-affinity-type" or name == "new-style-affinity-affinity-type-affinity1" or name == "new-style-affinity-affinity-type-affinity1-affinity2" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class FastReroute(Entity):
                        """
                        Specify MPLS tunnel can be fast\-rerouted
                        
                        .. attribute:: bandwidth_protection
                        
                        	Bandwidth Protection
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        .. attribute:: node_protection
                        
                        	Node Protection
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.FastReroute, self).__init__()

                            self.yang_name = "fast-reroute"
                            self.yang_parent_name = "tunnel-attributes"
                            self.is_presence_container = True

                            self.bandwidth_protection = YLeaf(YType.uint32, "bandwidth-protection")

                            self.node_protection = YLeaf(YType.uint32, "node-protection")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth_protection",
                                            "node_protection") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.FastReroute, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.FastReroute, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bandwidth_protection.is_set or
                                self.node_protection.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth_protection.yfilter != YFilter.not_set or
                                self.node_protection.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "fast-reroute" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth_protection.is_set or self.bandwidth_protection.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth_protection.get_name_leafdata())
                            if (self.node_protection.is_set or self.node_protection.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.node_protection.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth-protection" or name == "node-protection"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth-protection"):
                                self.bandwidth_protection = value
                                self.bandwidth_protection.value_namespace = name_space
                                self.bandwidth_protection.value_namespace_prefix = name_space_prefix
                            if(value_path == "node-protection"):
                                self.node_protection = value
                                self.node_protection.value_namespace = name_space
                                self.node_protection.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.destination.is_set or
                            self.forward_class.is_set or
                            self.load_share.is_set or
                            self.path_selection_metric.is_set or
                            self.record_route.is_set or
                            self.shutdown.is_set or
                            self.soft_preemption.is_set or
                            (self.auto_bandwidth is not None and self.auto_bandwidth.has_data()) or
                            (self.autoroute is not None and self.autoroute.has_data()) or
                            (self.logging is not None and self.logging.has_data()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_data()) or
                            (self.path_setups is not None and self.path_setups.has_data()) or
                            (self.tunnel_path_selection is not None and self.tunnel_path_selection.has_data()) or
                            (self.bandwidth is not None) or
                            (self.fast_reroute is not None) or
                            (self.priority is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.destination.yfilter != YFilter.not_set or
                            self.forward_class.yfilter != YFilter.not_set or
                            self.load_share.yfilter != YFilter.not_set or
                            self.path_selection_metric.yfilter != YFilter.not_set or
                            self.record_route.yfilter != YFilter.not_set or
                            self.shutdown.yfilter != YFilter.not_set or
                            self.soft_preemption.yfilter != YFilter.not_set or
                            (self.auto_bandwidth is not None and self.auto_bandwidth.has_operation()) or
                            (self.autoroute is not None and self.autoroute.has_operation()) or
                            (self.bandwidth is not None and self.bandwidth.has_operation()) or
                            (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                            (self.logging is not None and self.logging.has_operation()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_operation()) or
                            (self.path_setups is not None and self.path_setups.has_operation()) or
                            (self.priority is not None and self.priority.has_operation()) or
                            (self.tunnel_path_selection is not None and self.tunnel_path_selection.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel-attributes" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.destination.is_set or self.destination.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.destination.get_name_leafdata())
                        if (self.forward_class.is_set or self.forward_class.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.forward_class.get_name_leafdata())
                        if (self.load_share.is_set or self.load_share.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.load_share.get_name_leafdata())
                        if (self.path_selection_metric.is_set or self.path_selection_metric.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.path_selection_metric.get_name_leafdata())
                        if (self.record_route.is_set or self.record_route.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.record_route.get_name_leafdata())
                        if (self.shutdown.is_set or self.shutdown.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.shutdown.get_name_leafdata())
                        if (self.soft_preemption.is_set or self.soft_preemption.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.soft_preemption.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "auto-bandwidth"):
                            if (self.auto_bandwidth is None):
                                self.auto_bandwidth = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.AutoBandwidth()
                                self.auto_bandwidth.parent = self
                                self._children_name_map["auto_bandwidth"] = "auto-bandwidth"
                            return self.auto_bandwidth

                        if (child_yang_name == "autoroute"):
                            if (self.autoroute is None):
                                self.autoroute = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Autoroute()
                                self.autoroute.parent = self
                                self._children_name_map["autoroute"] = "autoroute"
                            return self.autoroute

                        if (child_yang_name == "bandwidth"):
                            if (self.bandwidth is None):
                                self.bandwidth = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Bandwidth()
                                self.bandwidth.parent = self
                                self._children_name_map["bandwidth"] = "bandwidth"
                            return self.bandwidth

                        if (child_yang_name == "fast-reroute"):
                            if (self.fast_reroute is None):
                                self.fast_reroute = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.FastReroute()
                                self.fast_reroute.parent = self
                                self._children_name_map["fast_reroute"] = "fast-reroute"
                            return self.fast_reroute

                        if (child_yang_name == "logging"):
                            if (self.logging is None):
                                self.logging = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Logging()
                                self.logging.parent = self
                                self._children_name_map["logging"] = "logging"
                            return self.logging

                        if (child_yang_name == "new-style-affinity-affinity-types"):
                            if (self.new_style_affinity_affinity_types is None):
                                self.new_style_affinity_affinity_types = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.NewStyleAffinityAffinityTypes()
                                self.new_style_affinity_affinity_types.parent = self
                                self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                            return self.new_style_affinity_affinity_types

                        if (child_yang_name == "path-setups"):
                            if (self.path_setups is None):
                                self.path_setups = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.PathSetups()
                                self.path_setups.parent = self
                                self._children_name_map["path_setups"] = "path-setups"
                            return self.path_setups

                        if (child_yang_name == "priority"):
                            if (self.priority is None):
                                self.priority = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.Priority()
                                self.priority.parent = self
                                self._children_name_map["priority"] = "priority"
                            return self.priority

                        if (child_yang_name == "tunnel-path-selection"):
                            if (self.tunnel_path_selection is None):
                                self.tunnel_path_selection = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes.TunnelPathSelection()
                                self.tunnel_path_selection.parent = self
                                self._children_name_map["tunnel_path_selection"] = "tunnel-path-selection"
                            return self.tunnel_path_selection

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "auto-bandwidth" or name == "autoroute" or name == "bandwidth" or name == "fast-reroute" or name == "logging" or name == "new-style-affinity-affinity-types" or name == "path-setups" or name == "priority" or name == "tunnel-path-selection" or name == "destination" or name == "forward-class" or name == "load-share" or name == "path-selection-metric" or name == "record-route" or name == "shutdown" or name == "soft-preemption"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "destination"):
                            self.destination = value
                            self.destination.value_namespace = name_space
                            self.destination.value_namespace_prefix = name_space_prefix
                        if(value_path == "forward-class"):
                            self.forward_class = value
                            self.forward_class.value_namespace = name_space
                            self.forward_class.value_namespace_prefix = name_space_prefix
                        if(value_path == "load-share"):
                            self.load_share = value
                            self.load_share.value_namespace = name_space
                            self.load_share.value_namespace_prefix = name_space_prefix
                        if(value_path == "path-selection-metric"):
                            self.path_selection_metric = value
                            self.path_selection_metric.value_namespace = name_space
                            self.path_selection_metric.value_namespace_prefix = name_space_prefix
                        if(value_path == "record-route"):
                            self.record_route = value
                            self.record_route.value_namespace = name_space
                            self.record_route.value_namespace_prefix = name_space_prefix
                        if(value_path == "shutdown"):
                            self.shutdown = value
                            self.shutdown.value_namespace = name_space
                            self.shutdown.value_namespace_prefix = name_space_prefix
                        if(value_path == "soft-preemption"):
                            self.soft_preemption = value
                            self.soft_preemption.value_namespace = name_space
                            self.soft_preemption.value_namespace_prefix = name_space_prefix


                class TunnelId(Entity):
                    """
                    Set the tunnel ID
                    
                    .. attribute:: tunnel_id
                    
                    	Tunnel ID
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: tunnel_id_type
                    
                    	Tunnel ID Type
                    	**type**\:   :py:class:`MplsTeTunnelId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelId>`
                    
                    	**mandatory**\: True
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelId, self).__init__()

                        self.yang_name = "tunnel-id"
                        self.yang_parent_name = "tunnel"
                        self.is_presence_container = True

                        self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                        self.tunnel_id_type = YLeaf(YType.enumeration, "tunnel-id-type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("tunnel_id",
                                        "tunnel_id_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelId, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelId, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.tunnel_id.is_set or
                            self.tunnel_id_type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.tunnel_id.yfilter != YFilter.not_set or
                            self.tunnel_id_type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel-id" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())
                        if (self.tunnel_id_type.is_set or self.tunnel_id_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "tunnel-id" or name == "tunnel-id-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "tunnel-id"):
                            self.tunnel_id = value
                            self.tunnel_id.value_namespace = name_space
                            self.tunnel_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-id-type"):
                            self.tunnel_id_type = value
                            self.tunnel_id_type.value_namespace = name_space
                            self.tunnel_id_type.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.tunnel_name.is_set or
                        self.tunnel_type.is_set or
                        self.enable.is_set or
                        (self.tunnel_attributes is not None and self.tunnel_attributes.has_data()) or
                        (self.tunnel_id is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.tunnel_name.yfilter != YFilter.not_set or
                        self.tunnel_type.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        (self.tunnel_attributes is not None and self.tunnel_attributes.has_operation()) or
                        (self.tunnel_id is not None and self.tunnel_id.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "tunnel" + "[tunnel-name='" + self.tunnel_name.get() + "']" + "[tunnel-type='" + self.tunnel_type.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/named-tunnels/tunnels/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.tunnel_name.is_set or self.tunnel_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.tunnel_name.get_name_leafdata())
                    if (self.tunnel_type.is_set or self.tunnel_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.tunnel_type.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "tunnel-attributes"):
                        if (self.tunnel_attributes is None):
                            self.tunnel_attributes = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelAttributes()
                            self.tunnel_attributes.parent = self
                            self._children_name_map["tunnel_attributes"] = "tunnel-attributes"
                        return self.tunnel_attributes

                    if (child_yang_name == "tunnel-id"):
                        if (self.tunnel_id is None):
                            self.tunnel_id = MplsTe.NamedTunnels.Tunnels.Tunnel.TunnelId()
                            self.tunnel_id.parent = self
                            self._children_name_map["tunnel_id"] = "tunnel-id"
                        return self.tunnel_id

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "tunnel-attributes" or name == "tunnel-id" or name == "tunnel-name" or name == "tunnel-type" or name == "enable"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "tunnel-name"):
                        self.tunnel_name = value
                        self.tunnel_name.value_namespace = name_space
                        self.tunnel_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "tunnel-type"):
                        self.tunnel_type = value
                        self.tunnel_type.value_namespace = name_space
                        self.tunnel_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.tunnel:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.tunnel:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnels" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/named-tunnels/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "tunnel"):
                    for c in self.tunnel:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsTe.NamedTunnels.Tunnels.Tunnel()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.tunnel.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "tunnel"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.enable.is_set or
                (self.tunnels is not None and self.tunnels.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.enable.yfilter != YFilter.not_set or
                (self.tunnels is not None and self.tunnels.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "named-tunnels" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                leaf_name_data.append(self.enable.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "tunnels"):
                if (self.tunnels is None):
                    self.tunnels = MplsTe.NamedTunnels.Tunnels()
                    self.tunnels.parent = self
                    self._children_name_map["tunnels"] = "tunnels"
                return self.tunnels

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "tunnels" or name == "enable"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "enable"):
                self.enable = value
                self.enable.value_namespace = name_space
                self.enable.value_namespace_prefix = name_space_prefix


    class GmplsUni(Entity):
        """
        GMPLS\-UNI configuration
        
        .. attribute:: controllers
        
        	GMPLS\-UNI controllers
        	**type**\:   :py:class:`Controllers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers>`
        
        .. attribute:: timers
        
        	GMPLS\-UNI timer configuration
        	**type**\:   :py:class:`Timers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Timers>`
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(MplsTe.GmplsUni, self).__init__()

            self.yang_name = "gmpls-uni"
            self.yang_parent_name = "mpls-te"

            self.controllers = MplsTe.GmplsUni.Controllers()
            self.controllers.parent = self
            self._children_name_map["controllers"] = "controllers"
            self._children_yang_names.add("controllers")

            self.timers = MplsTe.GmplsUni.Timers()
            self.timers.parent = self
            self._children_name_map["timers"] = "timers"
            self._children_yang_names.add("timers")


        class Timers(Entity):
            """
            GMPLS\-UNI timer configuration
            
            .. attribute:: path_option_timers
            
            	GMPLS\-UNI path\-option timer configuration
            	**type**\:   :py:class:`PathOptionTimers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Timers.PathOptionTimers>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GmplsUni.Timers, self).__init__()

                self.yang_name = "timers"
                self.yang_parent_name = "gmpls-uni"

                self.path_option_timers = MplsTe.GmplsUni.Timers.PathOptionTimers()
                self.path_option_timers.parent = self
                self._children_name_map["path_option_timers"] = "path-option-timers"
                self._children_yang_names.add("path-option-timers")


            class PathOptionTimers(Entity):
                """
                GMPLS\-UNI path\-option timer configuration
                
                .. attribute:: holddown
                
                	GMPLS\-UNI path\-option holddown timer configuration
                	**type**\:   :py:class:`Holddown <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Timers.PathOptionTimers.Holddown>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GmplsUni.Timers.PathOptionTimers, self).__init__()

                    self.yang_name = "path-option-timers"
                    self.yang_parent_name = "timers"

                    self.holddown = MplsTe.GmplsUni.Timers.PathOptionTimers.Holddown()
                    self.holddown.parent = self
                    self._children_name_map["holddown"] = "holddown"
                    self._children_yang_names.add("holddown")


                class Holddown(Entity):
                    """
                    GMPLS\-UNI path\-option holddown timer
                    configuration
                    
                    .. attribute:: maximum
                    
                    	Maximum holddown (seconds)
                    	**type**\:  int
                    
                    	**range:** 5..3600
                    
                    	**units**\: second
                    
                    .. attribute:: minimum
                    
                    	Minimum holddown (seconds)
                    	**type**\:  int
                    
                    	**range:** 5..3600
                    
                    	**units**\: second
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsUni.Timers.PathOptionTimers.Holddown, self).__init__()

                        self.yang_name = "holddown"
                        self.yang_parent_name = "path-option-timers"

                        self.maximum = YLeaf(YType.uint32, "maximum")

                        self.minimum = YLeaf(YType.uint32, "minimum")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("maximum",
                                        "minimum") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsUni.Timers.PathOptionTimers.Holddown, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsUni.Timers.PathOptionTimers.Holddown, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.maximum.is_set or
                            self.minimum.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.maximum.yfilter != YFilter.not_set or
                            self.minimum.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "holddown" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/timers/path-option-timers/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.maximum.is_set or self.maximum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.maximum.get_name_leafdata())
                        if (self.minimum.is_set or self.minimum.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.minimum.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "maximum" or name == "minimum"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "maximum"):
                            self.maximum = value
                            self.maximum.value_namespace = name_space
                            self.maximum.value_namespace_prefix = name_space_prefix
                        if(value_path == "minimum"):
                            self.minimum = value
                            self.minimum.value_namespace = name_space
                            self.minimum.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (self.holddown is not None and self.holddown.has_data())

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.holddown is not None and self.holddown.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "path-option-timers" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/timers/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "holddown"):
                        if (self.holddown is None):
                            self.holddown = MplsTe.GmplsUni.Timers.PathOptionTimers.Holddown()
                            self.holddown.parent = self
                            self._children_name_map["holddown"] = "holddown"
                        return self.holddown

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "holddown"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (self.path_option_timers is not None and self.path_option_timers.has_data())

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.path_option_timers is not None and self.path_option_timers.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "timers" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "path-option-timers"):
                    if (self.path_option_timers is None):
                        self.path_option_timers = MplsTe.GmplsUni.Timers.PathOptionTimers()
                        self.path_option_timers.parent = self
                        self._children_name_map["path_option_timers"] = "path-option-timers"
                    return self.path_option_timers

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "path-option-timers"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Controllers(Entity):
            """
            GMPLS\-UNI controllers
            
            .. attribute:: controller
            
            	Configure a GMPLS controller
            	**type**\: list of    :py:class:`Controller <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers.Controller>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GmplsUni.Controllers, self).__init__()

                self.yang_name = "controllers"
                self.yang_parent_name = "gmpls-uni"

                self.controller = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GmplsUni.Controllers, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GmplsUni.Controllers, self).__setattr__(name, value)


            class Controller(Entity):
                """
                Configure a GMPLS controller
                
                .. attribute:: controller_name  <key>
                
                	Controller name
                	**type**\:  str
                
                	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                
                .. attribute:: announce
                
                	Announce discovered tunnel properties to system
                	**type**\:   :py:class:`Announce <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers.Controller.Announce>`
                
                .. attribute:: controller_logging
                
                	Controller logging
                	**type**\:   :py:class:`ControllerLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers.Controller.ControllerLogging>`
                
                .. attribute:: enable
                
                	Enable GMPLS\-UNI on the link
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: gmpls_unitunnel_head
                
                	GMPLS\-UNI tunnel\-head properties
                	**type**\:   :py:class:`GmplsUnitunnelHead <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GmplsUni.Controllers.Controller, self).__init__()

                    self.yang_name = "controller"
                    self.yang_parent_name = "controllers"

                    self.controller_name = YLeaf(YType.str, "controller-name")

                    self.enable = YLeaf(YType.empty, "enable")

                    self.announce = MplsTe.GmplsUni.Controllers.Controller.Announce()
                    self.announce.parent = self
                    self._children_name_map["announce"] = "announce"
                    self._children_yang_names.add("announce")

                    self.controller_logging = MplsTe.GmplsUni.Controllers.Controller.ControllerLogging()
                    self.controller_logging.parent = self
                    self._children_name_map["controller_logging"] = "controller-logging"
                    self._children_yang_names.add("controller-logging")

                    self.gmpls_unitunnel_head = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead()
                    self.gmpls_unitunnel_head.parent = self
                    self._children_name_map["gmpls_unitunnel_head"] = "gmpls-unitunnel-head"
                    self._children_yang_names.add("gmpls-unitunnel-head")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("controller_name",
                                    "enable") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GmplsUni.Controllers.Controller, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GmplsUni.Controllers.Controller, self).__setattr__(name, value)


                class Announce(Entity):
                    """
                    Announce discovered tunnel properties to
                    system
                    
                    .. attribute:: srl_gs
                    
                    	Enable announcement of discovered SRLGs
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsUni.Controllers.Controller.Announce, self).__init__()

                        self.yang_name = "announce"
                        self.yang_parent_name = "controller"

                        self.srl_gs = YLeaf(YType.empty, "srl-gs")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("srl_gs") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsUni.Controllers.Controller.Announce, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsUni.Controllers.Controller.Announce, self).__setattr__(name, value)

                    def has_data(self):
                        return self.srl_gs.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.srl_gs.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "announce" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.srl_gs.is_set or self.srl_gs.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.srl_gs.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "srl-gs"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "srl-gs"):
                            self.srl_gs = value
                            self.srl_gs.value_namespace = name_space
                            self.srl_gs.value_namespace_prefix = name_space_prefix


                class ControllerLogging(Entity):
                    """
                    Controller logging
                    
                    .. attribute:: discovered_srlg_change_logging
                    
                    	Enable logging of changes to of discovered SRLGs
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsUni.Controllers.Controller.ControllerLogging, self).__init__()

                        self.yang_name = "controller-logging"
                        self.yang_parent_name = "controller"

                        self.discovered_srlg_change_logging = YLeaf(YType.empty, "discovered-srlg-change-logging")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("discovered_srlg_change_logging") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsUni.Controllers.Controller.ControllerLogging, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsUni.Controllers.Controller.ControllerLogging, self).__setattr__(name, value)

                    def has_data(self):
                        return self.discovered_srlg_change_logging.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.discovered_srlg_change_logging.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "controller-logging" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.discovered_srlg_change_logging.is_set or self.discovered_srlg_change_logging.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.discovered_srlg_change_logging.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "discovered-srlg-change-logging"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "discovered-srlg-change-logging"):
                            self.discovered_srlg_change_logging = value
                            self.discovered_srlg_change_logging.value_namespace = name_space
                            self.discovered_srlg_change_logging.value_namespace_prefix = name_space_prefix


                class GmplsUnitunnelHead(Entity):
                    """
                    GMPLS\-UNI tunnel\-head properties
                    
                    .. attribute:: destination
                    
                    	Set the destination of the tunnel
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: enable
                    
                    	Set link as a GMPLS tunnel head
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: logging
                    
                    	Tunnel event logging
                    	**type**\:   :py:class:`Logging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Logging>`
                    
                    .. attribute:: path_options
                    
                    	Path\-option configuration
                    	**type**\:   :py:class:`PathOptions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions>`
                    
                    .. attribute:: priority
                    
                    	Tunnel Setup and Hold Priorities
                    	**type**\:   :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Priority>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: record_route
                    
                    	Record the route used by the tunnel
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: recording
                    
                    	Tunnel property recording
                    	**type**\:   :py:class:`Recording <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Recording>`
                    
                    .. attribute:: signalled_name
                    
                    	The name of the tunnel to be included in signalling messages
                    	**type**\:  str
                    
                    	**length:** 1..254
                    
                    .. attribute:: tunnel_id
                    
                    	GMPLS\-UNI head tunnel\-id
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead, self).__init__()

                        self.yang_name = "gmpls-unitunnel-head"
                        self.yang_parent_name = "controller"

                        self.destination = YLeaf(YType.str, "destination")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.record_route = YLeaf(YType.empty, "record-route")

                        self.signalled_name = YLeaf(YType.str, "signalled-name")

                        self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                        self.logging = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Logging()
                        self.logging.parent = self
                        self._children_name_map["logging"] = "logging"
                        self._children_yang_names.add("logging")

                        self.path_options = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions()
                        self.path_options.parent = self
                        self._children_name_map["path_options"] = "path-options"
                        self._children_yang_names.add("path-options")

                        self.priority = None
                        self._children_name_map["priority"] = "priority"
                        self._children_yang_names.add("priority")

                        self.recording = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Recording()
                        self.recording.parent = self
                        self._children_name_map["recording"] = "recording"
                        self._children_yang_names.add("recording")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("destination",
                                        "enable",
                                        "record_route",
                                        "signalled_name",
                                        "tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead, self).__setattr__(name, value)


                    class PathOptions(Entity):
                        """
                        Path\-option configuration
                        
                        .. attribute:: path_option
                        
                        	A Path\-option
                        	**type**\: list of    :py:class:`PathOption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions.PathOption>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions, self).__init__()

                            self.yang_name = "path-options"
                            self.yang_parent_name = "gmpls-unitunnel-head"

                            self.path_option = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions, self).__setattr__(name, value)


                        class PathOption(Entity):
                            """
                            A Path\-option
                            
                            .. attribute:: preference_level  <key>
                            
                            	Preference level for this path option
                            	**type**\:  int
                            
                            	**range:** 1..1000
                            
                            .. attribute:: dwdm_channel
                            
                            	DWDM channel number
                            	**type**\:  int
                            
                            	**range:** 1..89
                            
                            	**default value**\: 1
                            
                            .. attribute:: lockdown
                            
                            	Path option properties\: must be Lockdown
                            	**type**\:   :py:class:`MplsTePathOptionProperty <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathOptionProperty>`
                            
                            	**mandatory**\: True
                            
                            .. attribute:: path_id
                            
                            	The ID of the explicit path associated with this option
                            	**type**\:  int
                            
                            	**range:** 1..65535
                            
                            	**default value**\: 1
                            
                            .. attribute:: path_name
                            
                            	The name of the explicit path associated with this option
                            	**type**\:  str
                            
                            .. attribute:: path_type
                            
                            	The type of the path option
                            	**type**\:   :py:class:`MplsTePathOption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathOption>`
                            
                            	**mandatory**\: True
                            
                            .. attribute:: signaled_label
                            
                            	Signaled label type
                            	**type**\:   :py:class:`MplsTeSignaledLabel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeSignaledLabel>`
                            
                            	**default value**\: not-set
                            
                            .. attribute:: verbatim
                            
                            	Path option properties\: must be verbatim if set
                            	**type**\:   :py:class:`MplsTePathOptionProperty <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathOptionProperty>`
                            
                            	**default value**\: none
                            
                            .. attribute:: xro_attribute_set_name
                            
                            	The name of the XRO attribute set to be used for this path\-option
                            	**type**\:  str
                            
                            	**length:** 1..64
                            
                            .. attribute:: xro_type
                            
                            	The route\-exclusion type
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions.PathOption, self).__init__()

                                self.yang_name = "path-option"
                                self.yang_parent_name = "path-options"

                                self.preference_level = YLeaf(YType.uint32, "preference-level")

                                self.dwdm_channel = YLeaf(YType.uint32, "dwdm-channel")

                                self.lockdown = YLeaf(YType.enumeration, "lockdown")

                                self.path_id = YLeaf(YType.uint32, "path-id")

                                self.path_name = YLeaf(YType.str, "path-name")

                                self.path_type = YLeaf(YType.enumeration, "path-type")

                                self.signaled_label = YLeaf(YType.enumeration, "signaled-label")

                                self.verbatim = YLeaf(YType.enumeration, "verbatim")

                                self.xro_attribute_set_name = YLeaf(YType.str, "xro-attribute-set-name")

                                self.xro_type = YLeaf(YType.empty, "xro-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("preference_level",
                                                "dwdm_channel",
                                                "lockdown",
                                                "path_id",
                                                "path_name",
                                                "path_type",
                                                "signaled_label",
                                                "verbatim",
                                                "xro_attribute_set_name",
                                                "xro_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions.PathOption, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions.PathOption, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.preference_level.is_set or
                                    self.dwdm_channel.is_set or
                                    self.lockdown.is_set or
                                    self.path_id.is_set or
                                    self.path_name.is_set or
                                    self.path_type.is_set or
                                    self.signaled_label.is_set or
                                    self.verbatim.is_set or
                                    self.xro_attribute_set_name.is_set or
                                    self.xro_type.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.preference_level.yfilter != YFilter.not_set or
                                    self.dwdm_channel.yfilter != YFilter.not_set or
                                    self.lockdown.yfilter != YFilter.not_set or
                                    self.path_id.yfilter != YFilter.not_set or
                                    self.path_name.yfilter != YFilter.not_set or
                                    self.path_type.yfilter != YFilter.not_set or
                                    self.signaled_label.yfilter != YFilter.not_set or
                                    self.verbatim.yfilter != YFilter.not_set or
                                    self.xro_attribute_set_name.yfilter != YFilter.not_set or
                                    self.xro_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "path-option" + "[preference-level='" + self.preference_level.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.preference_level.is_set or self.preference_level.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.preference_level.get_name_leafdata())
                                if (self.dwdm_channel.is_set or self.dwdm_channel.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dwdm_channel.get_name_leafdata())
                                if (self.lockdown.is_set or self.lockdown.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.lockdown.get_name_leafdata())
                                if (self.path_id.is_set or self.path_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_id.get_name_leafdata())
                                if (self.path_name.is_set or self.path_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_name.get_name_leafdata())
                                if (self.path_type.is_set or self.path_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_type.get_name_leafdata())
                                if (self.signaled_label.is_set or self.signaled_label.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.signaled_label.get_name_leafdata())
                                if (self.verbatim.is_set or self.verbatim.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.verbatim.get_name_leafdata())
                                if (self.xro_attribute_set_name.is_set or self.xro_attribute_set_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.xro_attribute_set_name.get_name_leafdata())
                                if (self.xro_type.is_set or self.xro_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.xro_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "preference-level" or name == "dwdm-channel" or name == "lockdown" or name == "path-id" or name == "path-name" or name == "path-type" or name == "signaled-label" or name == "verbatim" or name == "xro-attribute-set-name" or name == "xro-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "preference-level"):
                                    self.preference_level = value
                                    self.preference_level.value_namespace = name_space
                                    self.preference_level.value_namespace_prefix = name_space_prefix
                                if(value_path == "dwdm-channel"):
                                    self.dwdm_channel = value
                                    self.dwdm_channel.value_namespace = name_space
                                    self.dwdm_channel.value_namespace_prefix = name_space_prefix
                                if(value_path == "lockdown"):
                                    self.lockdown = value
                                    self.lockdown.value_namespace = name_space
                                    self.lockdown.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-id"):
                                    self.path_id = value
                                    self.path_id.value_namespace = name_space
                                    self.path_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-name"):
                                    self.path_name = value
                                    self.path_name.value_namespace = name_space
                                    self.path_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-type"):
                                    self.path_type = value
                                    self.path_type.value_namespace = name_space
                                    self.path_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "signaled-label"):
                                    self.signaled_label = value
                                    self.signaled_label.value_namespace = name_space
                                    self.signaled_label.value_namespace_prefix = name_space_prefix
                                if(value_path == "verbatim"):
                                    self.verbatim = value
                                    self.verbatim.value_namespace = name_space
                                    self.verbatim.value_namespace_prefix = name_space_prefix
                                if(value_path == "xro-attribute-set-name"):
                                    self.xro_attribute_set_name = value
                                    self.xro_attribute_set_name.value_namespace = name_space
                                    self.xro_attribute_set_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "xro-type"):
                                    self.xro_type = value
                                    self.xro_type.value_namespace = name_space
                                    self.xro_type.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.path_option:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.path_option:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-options" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "path-option"):
                                for c in self.path_option:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions.PathOption()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.path_option.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "path-option"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class Recording(Entity):
                        """
                        Tunnel property recording
                        
                        .. attribute:: srlg
                        
                        	Enable SRLG\-recording during signaling
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Recording, self).__init__()

                            self.yang_name = "recording"
                            self.yang_parent_name = "gmpls-unitunnel-head"

                            self.srlg = YLeaf(YType.empty, "srlg")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("srlg") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Recording, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Recording, self).__setattr__(name, value)

                        def has_data(self):
                            return self.srlg.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.srlg.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "recording" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.srlg.is_set or self.srlg.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.srlg.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "srlg"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "srlg"):
                                self.srlg = value
                                self.srlg.value_namespace = name_space
                                self.srlg.value_namespace_prefix = name_space_prefix


                    class Logging(Entity):
                        """
                        Tunnel event logging
                        
                        .. attribute:: state_message
                        
                        	Log tunnel state messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Logging, self).__init__()

                            self.yang_name = "logging"
                            self.yang_parent_name = "gmpls-unitunnel-head"

                            self.state_message = YLeaf(YType.empty, "state-message")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("state_message") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Logging, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Logging, self).__setattr__(name, value)

                        def has_data(self):
                            return self.state_message.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.state_message.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "logging" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.state_message.is_set or self.state_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.state_message.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "state-message"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "state-message"):
                                self.state_message = value
                                self.state_message.value_namespace = name_space
                                self.state_message.value_namespace_prefix = name_space_prefix


                    class Priority(Entity):
                        """
                        Tunnel Setup and Hold Priorities
                        
                        .. attribute:: hold_priority
                        
                        	Hold Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        .. attribute:: setup_priority
                        
                        	Setup Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Priority, self).__init__()

                            self.yang_name = "priority"
                            self.yang_parent_name = "gmpls-unitunnel-head"
                            self.is_presence_container = True

                            self.hold_priority = YLeaf(YType.uint32, "hold-priority")

                            self.setup_priority = YLeaf(YType.uint32, "setup-priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hold_priority",
                                            "setup_priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Priority, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Priority, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.hold_priority.is_set or
                                self.setup_priority.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hold_priority.yfilter != YFilter.not_set or
                                self.setup_priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "priority" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hold_priority.get_name_leafdata())
                            if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.setup_priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hold-priority" or name == "setup-priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hold-priority"):
                                self.hold_priority = value
                                self.hold_priority.value_namespace = name_space
                                self.hold_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "setup-priority"):
                                self.setup_priority = value
                                self.setup_priority.value_namespace = name_space
                                self.setup_priority.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.destination.is_set or
                            self.enable.is_set or
                            self.record_route.is_set or
                            self.signalled_name.is_set or
                            self.tunnel_id.is_set or
                            (self.logging is not None and self.logging.has_data()) or
                            (self.path_options is not None and self.path_options.has_data()) or
                            (self.recording is not None and self.recording.has_data()) or
                            (self.priority is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.destination.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.record_route.yfilter != YFilter.not_set or
                            self.signalled_name.yfilter != YFilter.not_set or
                            self.tunnel_id.yfilter != YFilter.not_set or
                            (self.logging is not None and self.logging.has_operation()) or
                            (self.path_options is not None and self.path_options.has_operation()) or
                            (self.priority is not None and self.priority.has_operation()) or
                            (self.recording is not None and self.recording.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "gmpls-unitunnel-head" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.destination.is_set or self.destination.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.destination.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.record_route.is_set or self.record_route.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.record_route.get_name_leafdata())
                        if (self.signalled_name.is_set or self.signalled_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.signalled_name.get_name_leafdata())
                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "logging"):
                            if (self.logging is None):
                                self.logging = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Logging()
                                self.logging.parent = self
                                self._children_name_map["logging"] = "logging"
                            return self.logging

                        if (child_yang_name == "path-options"):
                            if (self.path_options is None):
                                self.path_options = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.PathOptions()
                                self.path_options.parent = self
                                self._children_name_map["path_options"] = "path-options"
                            return self.path_options

                        if (child_yang_name == "priority"):
                            if (self.priority is None):
                                self.priority = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Priority()
                                self.priority.parent = self
                                self._children_name_map["priority"] = "priority"
                            return self.priority

                        if (child_yang_name == "recording"):
                            if (self.recording is None):
                                self.recording = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead.Recording()
                                self.recording.parent = self
                                self._children_name_map["recording"] = "recording"
                            return self.recording

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "logging" or name == "path-options" or name == "priority" or name == "recording" or name == "destination" or name == "enable" or name == "record-route" or name == "signalled-name" or name == "tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "destination"):
                            self.destination = value
                            self.destination.value_namespace = name_space
                            self.destination.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "record-route"):
                            self.record_route = value
                            self.record_route.value_namespace = name_space
                            self.record_route.value_namespace_prefix = name_space_prefix
                        if(value_path == "signalled-name"):
                            self.signalled_name = value
                            self.signalled_name.value_namespace = name_space
                            self.signalled_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-id"):
                            self.tunnel_id = value
                            self.tunnel_id.value_namespace = name_space
                            self.tunnel_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.controller_name.is_set or
                        self.enable.is_set or
                        (self.announce is not None and self.announce.has_data()) or
                        (self.controller_logging is not None and self.controller_logging.has_data()) or
                        (self.gmpls_unitunnel_head is not None and self.gmpls_unitunnel_head.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.controller_name.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        (self.announce is not None and self.announce.has_operation()) or
                        (self.controller_logging is not None and self.controller_logging.has_operation()) or
                        (self.gmpls_unitunnel_head is not None and self.gmpls_unitunnel_head.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "controller" + "[controller-name='" + self.controller_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/controllers/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.controller_name.is_set or self.controller_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.controller_name.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "announce"):
                        if (self.announce is None):
                            self.announce = MplsTe.GmplsUni.Controllers.Controller.Announce()
                            self.announce.parent = self
                            self._children_name_map["announce"] = "announce"
                        return self.announce

                    if (child_yang_name == "controller-logging"):
                        if (self.controller_logging is None):
                            self.controller_logging = MplsTe.GmplsUni.Controllers.Controller.ControllerLogging()
                            self.controller_logging.parent = self
                            self._children_name_map["controller_logging"] = "controller-logging"
                        return self.controller_logging

                    if (child_yang_name == "gmpls-unitunnel-head"):
                        if (self.gmpls_unitunnel_head is None):
                            self.gmpls_unitunnel_head = MplsTe.GmplsUni.Controllers.Controller.GmplsUnitunnelHead()
                            self.gmpls_unitunnel_head.parent = self
                            self._children_name_map["gmpls_unitunnel_head"] = "gmpls-unitunnel-head"
                        return self.gmpls_unitunnel_head

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "announce" or name == "controller-logging" or name == "gmpls-unitunnel-head" or name == "controller-name" or name == "enable"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "controller-name"):
                        self.controller_name = value
                        self.controller_name.value_namespace = name_space
                        self.controller_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.controller:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.controller:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "controllers" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "controller"):
                    for c in self.controller:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsTe.GmplsUni.Controllers.Controller()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.controller.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "controller"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                (self.controllers is not None and self.controllers.has_data()) or
                (self.timers is not None and self.timers.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                (self.controllers is not None and self.controllers.has_operation()) or
                (self.timers is not None and self.timers.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "gmpls-uni" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "controllers"):
                if (self.controllers is None):
                    self.controllers = MplsTe.GmplsUni.Controllers()
                    self.controllers.parent = self
                    self._children_name_map["controllers"] = "controllers"
                return self.controllers

            if (child_yang_name == "timers"):
                if (self.timers is None):
                    self.timers = MplsTe.GmplsUni.Timers()
                    self.timers.parent = self
                    self._children_name_map["timers"] = "timers"
                return self.timers

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "controllers" or name == "timers"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class GlobalAttributes(Entity):
        """
        Configure MPLS TE global attributes
        
        .. attribute:: advertise_explicit_nulls
        
        	Enable explicit\-null advertising to PHOP
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: affinity_mappings
        
        	Affinity Mapping Table configuration
        	**type**\:   :py:class:`AffinityMappings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AffinityMappings>`
        
        .. attribute:: attribute_set
        
        	Attribute AttributeSets
        	**type**\:   :py:class:`AttributeSet <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet>`
        
        .. attribute:: auto_bandwidth_collect_frequency
        
        	Auto\-bandwidth global collection frequency in minutes
        	**type**\:  int
        
        	**range:** 1..10080
        
        	**units**\: minute
        
        	**default value**\: 5
        
        .. attribute:: auto_tunnel
        
        	Configure auto\-tunnels feature
        	**type**\:   :py:class:`AutoTunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel>`
        
        .. attribute:: bandwidth_accounting
        
        	Bandwidth accounting configuration data
        	**type**\:   :py:class:`BandwidthAccounting <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.BandwidthAccounting>`
        
        .. attribute:: bfd_over_lsp
        
        	BFD over MPLS TE Global Configurations
        	**type**\:   :py:class:`BfdOverLsp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.BfdOverLsp>`
        
        .. attribute:: disable_reoptimize_affinity_failure
        
        	Disable reoptimization after affinity failures
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: enable_unequal_load_balancing
        
        	Enable unequal load\-balancing over tunnels to the same destination
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: fast_reroute
        
        	Configure fast reroute attributes
        	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.FastReroute>`
        
        .. attribute:: fault_oam
        
        	Enable Fault\-OAM functionality for bidirectional tunnels
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: graceful_preemption_on_bandwidth_reduction
        
        	Enable graceful preemption when there is a bandwidth reduction
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: hardware_out_of_resource
        
        	Configure HW OOR processing in MPLS\-TE
        	**type**\:   :py:class:`HardwareOutOfResource <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.HardwareOutOfResource>`
        
        .. attribute:: link_holddown_timer
        
        	Holddown time for links which had Path Errors in seconds
        	**type**\:  int
        
        	**range:** 0..300
        
        	**units**\: second
        
        	**default value**\: 10
        
        .. attribute:: log_all
        
        	Always set to true
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: log_frr_protection
        
        	Log FRR Protection messages
        	**type**\:   :py:class:`MplsTeLogFrrProtection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeLogFrrProtection>`
        
        .. attribute:: log_head
        
        	Log all head tunnel events
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: log_issu_status
        
        	Log ISSU status messages
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: log_mid
        
        	Log all mid tunnel events
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: log_nsr_status
        
        	Log NSR status messages
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: log_preemption
        
        	Log tunnel preemption messages
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: log_tail
        
        	Log all tail tunnel events
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: loose_path_retry_period
        
        	Signalling retry for tunnels terminating outside the headend area
        	**type**\:  int
        
        	**range:** 30..600
        
        	**default value**\: 120
        
        .. attribute:: lsp_out_of_resource
        
        	Configure LSP OOR attributes in MPLS\-TE
        	**type**\:   :py:class:`LspOutOfResource <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.LspOutOfResource>`
        
        .. attribute:: maximum_tunnels
        
        	The maximum number of tunnel heads that will be allowed
        	**type**\:  int
        
        	**range:** 1..65536
        
        	**default value**\: 4096
        
        .. attribute:: mib
        
        	MPLS\-TE MIB properties
        	**type**\:   :py:class:`Mib <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Mib>`
        
        .. attribute:: path_selection
        
        	Path selection configuration
        	**type**\:   :py:class:`PathSelection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PathSelection>`
        
        .. attribute:: path_selection_ignore_overload
        
        	Deprecated \- do not use
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: pce_attributes
        
        	Configuration MPLS TE PCE attributes
        	**type**\:   :py:class:`PceAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PceAttributes>`
        
        .. attribute:: queues
        
        	Configure MPLS TE route priority
        	**type**\:   :py:class:`Queues <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Queues>`
        
        .. attribute:: reopt_delay_path_protect_switchover_timer
        
        	Seconds between path protect switchover and tunnel re\-optimization. Set to 0 to disable
        	**type**\:  int
        
        	**range:** 0..604800
        
        	**units**\: second
        
        	**default value**\: 180
        
        .. attribute:: reoptimize_delay_after_affinity_failure_timer
        
        	Delay reoptimizing current LSP after affinity failures
        	**type**\:  int
        
        	**range:** 1..604800
        
        	**units**\: second
        
        .. attribute:: reoptimize_delay_after_frr_timer
        
        	Reoptimization Delay After FRR Value (seconds)
        	**type**\:  int
        
        	**range:** 0..120
        
        	**units**\: second
        
        .. attribute:: reoptimize_delay_cleanup_timer
        
        	Reoptimization Delay Cleanup Value (seconds)
        	**type**\:  int
        
        	**range:** 0..300
        
        	**units**\: second
        
        .. attribute:: reoptimize_delay_install_timer
        
        	Reoptimization Delay Install Value (seconds)
        	**type**\:  int
        
        	**range:** 0..3600
        
        	**units**\: second
        
        .. attribute:: reoptimize_link_up
        
        	Enable reoptimization based on link\-up events
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: reoptimize_load_balancing
        
        	Load balance bandwidth during reoptimization
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: reoptimize_timer_frequency
        
        	Reoptimize timers period in seconds
        	**type**\:  int
        
        	**range:** 0..604800
        
        	**units**\: second
        
        	**default value**\: 3600
        
        .. attribute:: secondary_router_ids
        
        	Configure MPLS TE Secondary Router ID
        	**type**\:   :py:class:`SecondaryRouterIds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.SecondaryRouterIds>`
        
        .. attribute:: soft_preemption
        
        	Soft preemption configuration data
        	**type**\:   :py:class:`SoftPreemption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.SoftPreemption>`
        
        .. attribute:: srlg
        
        	Configure SRLG values and MPLS\-TE properties
        	**type**\:   :py:class:`Srlg <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Srlg>`
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(MplsTe.GlobalAttributes, self).__init__()

            self.yang_name = "global-attributes"
            self.yang_parent_name = "mpls-te"

            self.advertise_explicit_nulls = YLeaf(YType.empty, "advertise-explicit-nulls")

            self.auto_bandwidth_collect_frequency = YLeaf(YType.uint32, "auto-bandwidth-collect-frequency")

            self.disable_reoptimize_affinity_failure = YLeaf(YType.empty, "disable-reoptimize-affinity-failure")

            self.enable_unequal_load_balancing = YLeaf(YType.empty, "enable-unequal-load-balancing")

            self.fault_oam = YLeaf(YType.empty, "fault-oam")

            self.graceful_preemption_on_bandwidth_reduction = YLeaf(YType.empty, "graceful-preemption-on-bandwidth-reduction")

            self.link_holddown_timer = YLeaf(YType.uint32, "link-holddown-timer")

            self.log_all = YLeaf(YType.empty, "log-all")

            self.log_frr_protection = YLeaf(YType.enumeration, "log-frr-protection")

            self.log_head = YLeaf(YType.empty, "log-head")

            self.log_issu_status = YLeaf(YType.empty, "log-issu-status")

            self.log_mid = YLeaf(YType.empty, "log-mid")

            self.log_nsr_status = YLeaf(YType.empty, "log-nsr-status")

            self.log_preemption = YLeaf(YType.empty, "log-preemption")

            self.log_tail = YLeaf(YType.empty, "log-tail")

            self.loose_path_retry_period = YLeaf(YType.uint32, "loose-path-retry-period")

            self.maximum_tunnels = YLeaf(YType.uint32, "maximum-tunnels")

            self.path_selection_ignore_overload = YLeaf(YType.empty, "path-selection-ignore-overload")

            self.reopt_delay_path_protect_switchover_timer = YLeaf(YType.uint32, "reopt-delay-path-protect-switchover-timer")

            self.reoptimize_delay_after_affinity_failure_timer = YLeaf(YType.uint32, "reoptimize-delay-after-affinity-failure-timer")

            self.reoptimize_delay_after_frr_timer = YLeaf(YType.uint32, "reoptimize-delay-after-frr-timer")

            self.reoptimize_delay_cleanup_timer = YLeaf(YType.uint32, "reoptimize-delay-cleanup-timer")

            self.reoptimize_delay_install_timer = YLeaf(YType.uint32, "reoptimize-delay-install-timer")

            self.reoptimize_link_up = YLeaf(YType.empty, "reoptimize-link-up")

            self.reoptimize_load_balancing = YLeaf(YType.empty, "reoptimize-load-balancing")

            self.reoptimize_timer_frequency = YLeaf(YType.uint32, "reoptimize-timer-frequency")

            self.affinity_mappings = MplsTe.GlobalAttributes.AffinityMappings()
            self.affinity_mappings.parent = self
            self._children_name_map["affinity_mappings"] = "affinity-mappings"
            self._children_yang_names.add("affinity-mappings")

            self.attribute_set = MplsTe.GlobalAttributes.AttributeSet()
            self.attribute_set.parent = self
            self._children_name_map["attribute_set"] = "attribute-set"
            self._children_yang_names.add("attribute-set")

            self.auto_tunnel = MplsTe.GlobalAttributes.AutoTunnel()
            self.auto_tunnel.parent = self
            self._children_name_map["auto_tunnel"] = "auto-tunnel"
            self._children_yang_names.add("auto-tunnel")

            self.bandwidth_accounting = MplsTe.GlobalAttributes.BandwidthAccounting()
            self.bandwidth_accounting.parent = self
            self._children_name_map["bandwidth_accounting"] = "bandwidth-accounting"
            self._children_yang_names.add("bandwidth-accounting")

            self.bfd_over_lsp = MplsTe.GlobalAttributes.BfdOverLsp()
            self.bfd_over_lsp.parent = self
            self._children_name_map["bfd_over_lsp"] = "bfd-over-lsp"
            self._children_yang_names.add("bfd-over-lsp")

            self.fast_reroute = MplsTe.GlobalAttributes.FastReroute()
            self.fast_reroute.parent = self
            self._children_name_map["fast_reroute"] = "fast-reroute"
            self._children_yang_names.add("fast-reroute")

            self.hardware_out_of_resource = MplsTe.GlobalAttributes.HardwareOutOfResource()
            self.hardware_out_of_resource.parent = self
            self._children_name_map["hardware_out_of_resource"] = "hardware-out-of-resource"
            self._children_yang_names.add("hardware-out-of-resource")

            self.lsp_out_of_resource = MplsTe.GlobalAttributes.LspOutOfResource()
            self.lsp_out_of_resource.parent = self
            self._children_name_map["lsp_out_of_resource"] = "lsp-out-of-resource"
            self._children_yang_names.add("lsp-out-of-resource")

            self.mib = MplsTe.GlobalAttributes.Mib()
            self.mib.parent = self
            self._children_name_map["mib"] = "mib"
            self._children_yang_names.add("mib")

            self.path_selection = MplsTe.GlobalAttributes.PathSelection()
            self.path_selection.parent = self
            self._children_name_map["path_selection"] = "path-selection"
            self._children_yang_names.add("path-selection")

            self.pce_attributes = MplsTe.GlobalAttributes.PceAttributes()
            self.pce_attributes.parent = self
            self._children_name_map["pce_attributes"] = "pce-attributes"
            self._children_yang_names.add("pce-attributes")

            self.queues = MplsTe.GlobalAttributes.Queues()
            self.queues.parent = self
            self._children_name_map["queues"] = "queues"
            self._children_yang_names.add("queues")

            self.secondary_router_ids = MplsTe.GlobalAttributes.SecondaryRouterIds()
            self.secondary_router_ids.parent = self
            self._children_name_map["secondary_router_ids"] = "secondary-router-ids"
            self._children_yang_names.add("secondary-router-ids")

            self.soft_preemption = MplsTe.GlobalAttributes.SoftPreemption()
            self.soft_preemption.parent = self
            self._children_name_map["soft_preemption"] = "soft-preemption"
            self._children_yang_names.add("soft-preemption")

            self.srlg = MplsTe.GlobalAttributes.Srlg()
            self.srlg.parent = self
            self._children_name_map["srlg"] = "srlg"
            self._children_yang_names.add("srlg")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("advertise_explicit_nulls",
                            "auto_bandwidth_collect_frequency",
                            "disable_reoptimize_affinity_failure",
                            "enable_unequal_load_balancing",
                            "fault_oam",
                            "graceful_preemption_on_bandwidth_reduction",
                            "link_holddown_timer",
                            "log_all",
                            "log_frr_protection",
                            "log_head",
                            "log_issu_status",
                            "log_mid",
                            "log_nsr_status",
                            "log_preemption",
                            "log_tail",
                            "loose_path_retry_period",
                            "maximum_tunnels",
                            "path_selection_ignore_overload",
                            "reopt_delay_path_protect_switchover_timer",
                            "reoptimize_delay_after_affinity_failure_timer",
                            "reoptimize_delay_after_frr_timer",
                            "reoptimize_delay_cleanup_timer",
                            "reoptimize_delay_install_timer",
                            "reoptimize_link_up",
                            "reoptimize_load_balancing",
                            "reoptimize_timer_frequency") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(MplsTe.GlobalAttributes, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(MplsTe.GlobalAttributes, self).__setattr__(name, value)


        class AutoTunnel(Entity):
            """
            Configure auto\-tunnels feature
            
            .. attribute:: backup
            
            	Configure auto\-tunnel backup feature
            	**type**\:   :py:class:`Backup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Backup>`
            
            .. attribute:: mesh
            
            	Configure auto\-tunnel mesh feature
            	**type**\:   :py:class:`Mesh <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Mesh>`
            
            .. attribute:: p2mp_auto_tunnel
            
            	Configure P2MP auto\-tunnel feature
            	**type**\:   :py:class:`P2MpAutoTunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel>`
            
            .. attribute:: p2p_auto_tunnel
            
            	Configure P2P auto\-tunnel feature
            	**type**\:   :py:class:`P2PAutoTunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel>`
            
            .. attribute:: pcc
            
            	Configure auto\-tunnel PCC (Path Computation Client) feature
            	**type**\:   :py:class:`Pcc <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Pcc>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.AutoTunnel, self).__init__()

                self.yang_name = "auto-tunnel"
                self.yang_parent_name = "global-attributes"

                self.backup = MplsTe.GlobalAttributes.AutoTunnel.Backup()
                self.backup.parent = self
                self._children_name_map["backup"] = "backup"
                self._children_yang_names.add("backup")

                self.mesh = MplsTe.GlobalAttributes.AutoTunnel.Mesh()
                self.mesh.parent = self
                self._children_name_map["mesh"] = "mesh"
                self._children_yang_names.add("mesh")

                self.p2mp_auto_tunnel = MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel()
                self.p2mp_auto_tunnel.parent = self
                self._children_name_map["p2mp_auto_tunnel"] = "p2mp-auto-tunnel"
                self._children_yang_names.add("p2mp-auto-tunnel")

                self.p2p_auto_tunnel = MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel()
                self.p2p_auto_tunnel.parent = self
                self._children_name_map["p2p_auto_tunnel"] = "p2p-auto-tunnel"
                self._children_yang_names.add("p2p-auto-tunnel")

                self.pcc = MplsTe.GlobalAttributes.AutoTunnel.Pcc()
                self.pcc.parent = self
                self._children_name_map["pcc"] = "pcc"
                self._children_yang_names.add("pcc")


            class Pcc(Entity):
                """
                Configure auto\-tunnel PCC (Path Computation
                Client) feature
                
                .. attribute:: tunnel_range
                
                	Configure tunnel ID range for auto\-tunnel features
                	**type**\:   :py:class:`TunnelRange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Pcc.TunnelRange>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AutoTunnel.Pcc, self).__init__()

                    self.yang_name = "pcc"
                    self.yang_parent_name = "auto-tunnel"

                    self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.Pcc.TunnelRange()
                    self.tunnel_range.parent = self
                    self._children_name_map["tunnel_range"] = "tunnel-range"
                    self._children_yang_names.add("tunnel-range")


                class TunnelRange(Entity):
                    """
                    Configure tunnel ID range for auto\-tunnel
                    features
                    
                    .. attribute:: max_tunnel_id
                    
                    	Maximum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: min_tunnel_id
                    
                    	Minimum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AutoTunnel.Pcc.TunnelRange, self).__init__()

                        self.yang_name = "tunnel-range"
                        self.yang_parent_name = "pcc"

                        self.max_tunnel_id = YLeaf(YType.uint32, "max-tunnel-id")

                        self.min_tunnel_id = YLeaf(YType.uint32, "min-tunnel-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("max_tunnel_id",
                                        "min_tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AutoTunnel.Pcc.TunnelRange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AutoTunnel.Pcc.TunnelRange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.max_tunnel_id.is_set or
                            self.min_tunnel_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.max_tunnel_id.yfilter != YFilter.not_set or
                            self.min_tunnel_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel-range" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/pcc/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.max_tunnel_id.is_set or self.max_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_tunnel_id.get_name_leafdata())
                        if (self.min_tunnel_id.is_set or self.min_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.min_tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "max-tunnel-id" or name == "min-tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "max-tunnel-id"):
                            self.max_tunnel_id = value
                            self.max_tunnel_id.value_namespace = name_space
                            self.max_tunnel_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "min-tunnel-id"):
                            self.min_tunnel_id = value
                            self.min_tunnel_id.value_namespace = name_space
                            self.min_tunnel_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (self.tunnel_range is not None and self.tunnel_range.has_data())

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.tunnel_range is not None and self.tunnel_range.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "pcc" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "tunnel-range"):
                        if (self.tunnel_range is None):
                            self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.Pcc.TunnelRange()
                            self.tunnel_range.parent = self
                            self._children_name_map["tunnel_range"] = "tunnel-range"
                        return self.tunnel_range

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "tunnel-range"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class P2PAutoTunnel(Entity):
                """
                Configure P2P auto\-tunnel feature
                
                .. attribute:: tunnel_range
                
                	Configure tunnel ID range for auto\-tunnel features
                	**type**\:   :py:class:`TunnelRange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel.TunnelRange>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel, self).__init__()

                    self.yang_name = "p2p-auto-tunnel"
                    self.yang_parent_name = "auto-tunnel"

                    self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel.TunnelRange()
                    self.tunnel_range.parent = self
                    self._children_name_map["tunnel_range"] = "tunnel-range"
                    self._children_yang_names.add("tunnel-range")


                class TunnelRange(Entity):
                    """
                    Configure tunnel ID range for auto\-tunnel
                    features
                    
                    .. attribute:: max_tunnel_id
                    
                    	Maximum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: min_tunnel_id
                    
                    	Minimum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel.TunnelRange, self).__init__()

                        self.yang_name = "tunnel-range"
                        self.yang_parent_name = "p2p-auto-tunnel"

                        self.max_tunnel_id = YLeaf(YType.uint32, "max-tunnel-id")

                        self.min_tunnel_id = YLeaf(YType.uint32, "min-tunnel-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("max_tunnel_id",
                                        "min_tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel.TunnelRange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel.TunnelRange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.max_tunnel_id.is_set or
                            self.min_tunnel_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.max_tunnel_id.yfilter != YFilter.not_set or
                            self.min_tunnel_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel-range" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/p2p-auto-tunnel/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.max_tunnel_id.is_set or self.max_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_tunnel_id.get_name_leafdata())
                        if (self.min_tunnel_id.is_set or self.min_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.min_tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "max-tunnel-id" or name == "min-tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "max-tunnel-id"):
                            self.max_tunnel_id = value
                            self.max_tunnel_id.value_namespace = name_space
                            self.max_tunnel_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "min-tunnel-id"):
                            self.min_tunnel_id = value
                            self.min_tunnel_id.value_namespace = name_space
                            self.min_tunnel_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (self.tunnel_range is not None and self.tunnel_range.has_data())

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.tunnel_range is not None and self.tunnel_range.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "p2p-auto-tunnel" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "tunnel-range"):
                        if (self.tunnel_range is None):
                            self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel.TunnelRange()
                            self.tunnel_range.parent = self
                            self._children_name_map["tunnel_range"] = "tunnel-range"
                        return self.tunnel_range

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "tunnel-range"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Backup(Entity):
                """
                Configure auto\-tunnel backup feature
                
                .. attribute:: affinity_ignore
                
                	Ignore affinity during CSPF for auto backup tunnels
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: timers
                
                	Configure auto\-tunnel backup timers value
                	**type**\:   :py:class:`Timers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers>`
                
                .. attribute:: tunnel_range
                
                	Configure tunnel ID range for auto\-tunnel features
                	**type**\:   :py:class:`TunnelRange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Backup.TunnelRange>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AutoTunnel.Backup, self).__init__()

                    self.yang_name = "backup"
                    self.yang_parent_name = "auto-tunnel"

                    self.affinity_ignore = YLeaf(YType.empty, "affinity-ignore")

                    self.timers = MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers()
                    self.timers.parent = self
                    self._children_name_map["timers"] = "timers"
                    self._children_yang_names.add("timers")

                    self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.Backup.TunnelRange()
                    self.tunnel_range.parent = self
                    self._children_name_map["tunnel_range"] = "tunnel-range"
                    self._children_yang_names.add("tunnel-range")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("affinity_ignore") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.AutoTunnel.Backup, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.AutoTunnel.Backup, self).__setattr__(name, value)


                class Timers(Entity):
                    """
                    Configure auto\-tunnel backup timers value
                    
                    .. attribute:: removal
                    
                    	Configure auto\-tunnel backup removal timers value
                    	**type**\:   :py:class:`Removal <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers.Removal>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers, self).__init__()

                        self.yang_name = "timers"
                        self.yang_parent_name = "backup"

                        self.removal = MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers.Removal()
                        self.removal.parent = self
                        self._children_name_map["removal"] = "removal"
                        self._children_yang_names.add("removal")


                    class Removal(Entity):
                        """
                        Configure auto\-tunnel backup removal timers
                        value
                        
                        .. attribute:: unused
                        
                        	Auto\-tunnel backup unused timeout in minutes (0=never timeout)
                        	**type**\:  int
                        
                        	**range:** 0..10080
                        
                        	**units**\: minute
                        
                        	**default value**\: 3600
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers.Removal, self).__init__()

                            self.yang_name = "removal"
                            self.yang_parent_name = "timers"

                            self.unused = YLeaf(YType.uint32, "unused")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("unused") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers.Removal, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers.Removal, self).__setattr__(name, value)

                        def has_data(self):
                            return self.unused.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.unused.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "removal" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/backup/timers/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.unused.is_set or self.unused.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unused.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "unused"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "unused"):
                                self.unused = value
                                self.unused.value_namespace = name_space
                                self.unused.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.removal is not None and self.removal.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.removal is not None and self.removal.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "timers" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/backup/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "removal"):
                            if (self.removal is None):
                                self.removal = MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers.Removal()
                                self.removal.parent = self
                                self._children_name_map["removal"] = "removal"
                            return self.removal

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "removal"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class TunnelRange(Entity):
                    """
                    Configure tunnel ID range for auto\-tunnel
                    features
                    
                    .. attribute:: max_tunnel_id
                    
                    	Maximum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: min_tunnel_id
                    
                    	Minimum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AutoTunnel.Backup.TunnelRange, self).__init__()

                        self.yang_name = "tunnel-range"
                        self.yang_parent_name = "backup"

                        self.max_tunnel_id = YLeaf(YType.uint32, "max-tunnel-id")

                        self.min_tunnel_id = YLeaf(YType.uint32, "min-tunnel-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("max_tunnel_id",
                                        "min_tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AutoTunnel.Backup.TunnelRange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AutoTunnel.Backup.TunnelRange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.max_tunnel_id.is_set or
                            self.min_tunnel_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.max_tunnel_id.yfilter != YFilter.not_set or
                            self.min_tunnel_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel-range" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/backup/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.max_tunnel_id.is_set or self.max_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_tunnel_id.get_name_leafdata())
                        if (self.min_tunnel_id.is_set or self.min_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.min_tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "max-tunnel-id" or name == "min-tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "max-tunnel-id"):
                            self.max_tunnel_id = value
                            self.max_tunnel_id.value_namespace = name_space
                            self.max_tunnel_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "min-tunnel-id"):
                            self.min_tunnel_id = value
                            self.min_tunnel_id.value_namespace = name_space
                            self.min_tunnel_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.affinity_ignore.is_set or
                        (self.timers is not None and self.timers.has_data()) or
                        (self.tunnel_range is not None and self.tunnel_range.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.affinity_ignore.yfilter != YFilter.not_set or
                        (self.timers is not None and self.timers.has_operation()) or
                        (self.tunnel_range is not None and self.tunnel_range.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "backup" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.affinity_ignore.is_set or self.affinity_ignore.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.affinity_ignore.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "timers"):
                        if (self.timers is None):
                            self.timers = MplsTe.GlobalAttributes.AutoTunnel.Backup.Timers()
                            self.timers.parent = self
                            self._children_name_map["timers"] = "timers"
                        return self.timers

                    if (child_yang_name == "tunnel-range"):
                        if (self.tunnel_range is None):
                            self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.Backup.TunnelRange()
                            self.tunnel_range.parent = self
                            self._children_name_map["tunnel_range"] = "tunnel-range"
                        return self.tunnel_range

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "timers" or name == "tunnel-range" or name == "affinity-ignore"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "affinity-ignore"):
                        self.affinity_ignore = value
                        self.affinity_ignore.value_namespace = name_space
                        self.affinity_ignore.value_namespace_prefix = name_space_prefix


            class Mesh(Entity):
                """
                Configure auto\-tunnel mesh feature
                
                .. attribute:: mesh_groups
                
                	Configure auto\-tunnel mesh group
                	**type**\:   :py:class:`MeshGroups <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups>`
                
                .. attribute:: timers
                
                	Configure auto\-tunnel backup timers value
                	**type**\:   :py:class:`Timers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers>`
                
                .. attribute:: tunnel_range
                
                	Configure tunnel ID range for auto\-tunnel features
                	**type**\:   :py:class:`TunnelRange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Mesh.TunnelRange>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AutoTunnel.Mesh, self).__init__()

                    self.yang_name = "mesh"
                    self.yang_parent_name = "auto-tunnel"

                    self.mesh_groups = MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups()
                    self.mesh_groups.parent = self
                    self._children_name_map["mesh_groups"] = "mesh-groups"
                    self._children_yang_names.add("mesh-groups")

                    self.timers = MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers()
                    self.timers.parent = self
                    self._children_name_map["timers"] = "timers"
                    self._children_yang_names.add("timers")

                    self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.Mesh.TunnelRange()
                    self.tunnel_range.parent = self
                    self._children_name_map["tunnel_range"] = "tunnel-range"
                    self._children_yang_names.add("tunnel-range")


                class MeshGroups(Entity):
                    """
                    Configure auto\-tunnel mesh group
                    
                    .. attribute:: mesh_group
                    
                    	Auto\-mesh group identifier
                    	**type**\: list of    :py:class:`MeshGroup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups.MeshGroup>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups, self).__init__()

                        self.yang_name = "mesh-groups"
                        self.yang_parent_name = "mesh"

                        self.mesh_group = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups, self).__setattr__(name, value)


                    class MeshGroup(Entity):
                        """
                        Auto\-mesh group identifier
                        
                        .. attribute:: mesh_group_id  <key>
                        
                        	Mesh group ID
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        .. attribute:: attribute_set
                        
                        	The name of auto\-mesh attribute set to be applied to this group
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: create
                        
                        	Auto\-mesh group enable object that controls whether this group is configured or not .This object must be set before other configuration supplied for this group
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: destination_list
                        
                        	The name of prefix\-list to be applied to this destination\-list
                        	**type**\:  str
                        
                        	**length:** 1..32
                        
                        .. attribute:: disable
                        
                        	Disables mesh group
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: one_hop
                        
                        	Automatically create tunnel to all next\-hops
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups.MeshGroup, self).__init__()

                            self.yang_name = "mesh-group"
                            self.yang_parent_name = "mesh-groups"

                            self.mesh_group_id = YLeaf(YType.uint32, "mesh-group-id")

                            self.attribute_set = YLeaf(YType.str, "attribute-set")

                            self.create = YLeaf(YType.empty, "create")

                            self.destination_list = YLeaf(YType.str, "destination-list")

                            self.disable = YLeaf(YType.empty, "disable")

                            self.one_hop = YLeaf(YType.empty, "one-hop")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("mesh_group_id",
                                            "attribute_set",
                                            "create",
                                            "destination_list",
                                            "disable",
                                            "one_hop") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups.MeshGroup, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups.MeshGroup, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.mesh_group_id.is_set or
                                self.attribute_set.is_set or
                                self.create.is_set or
                                self.destination_list.is_set or
                                self.disable.is_set or
                                self.one_hop.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.mesh_group_id.yfilter != YFilter.not_set or
                                self.attribute_set.yfilter != YFilter.not_set or
                                self.create.yfilter != YFilter.not_set or
                                self.destination_list.yfilter != YFilter.not_set or
                                self.disable.yfilter != YFilter.not_set or
                                self.one_hop.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "mesh-group" + "[mesh-group-id='" + self.mesh_group_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/mesh-groups/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.mesh_group_id.is_set or self.mesh_group_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mesh_group_id.get_name_leafdata())
                            if (self.attribute_set.is_set or self.attribute_set.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.attribute_set.get_name_leafdata())
                            if (self.create.is_set or self.create.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.create.get_name_leafdata())
                            if (self.destination_list.is_set or self.destination_list.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.destination_list.get_name_leafdata())
                            if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.disable.get_name_leafdata())
                            if (self.one_hop.is_set or self.one_hop.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.one_hop.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "mesh-group-id" or name == "attribute-set" or name == "create" or name == "destination-list" or name == "disable" or name == "one-hop"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "mesh-group-id"):
                                self.mesh_group_id = value
                                self.mesh_group_id.value_namespace = name_space
                                self.mesh_group_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "attribute-set"):
                                self.attribute_set = value
                                self.attribute_set.value_namespace = name_space
                                self.attribute_set.value_namespace_prefix = name_space_prefix
                            if(value_path == "create"):
                                self.create = value
                                self.create.value_namespace = name_space
                                self.create.value_namespace_prefix = name_space_prefix
                            if(value_path == "destination-list"):
                                self.destination_list = value
                                self.destination_list.value_namespace = name_space
                                self.destination_list.value_namespace_prefix = name_space_prefix
                            if(value_path == "disable"):
                                self.disable = value
                                self.disable.value_namespace = name_space
                                self.disable.value_namespace_prefix = name_space_prefix
                            if(value_path == "one-hop"):
                                self.one_hop = value
                                self.one_hop.value_namespace = name_space
                                self.one_hop.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.mesh_group:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.mesh_group:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "mesh-groups" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "mesh-group"):
                            for c in self.mesh_group:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups.MeshGroup()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.mesh_group.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "mesh-group"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Timers(Entity):
                    """
                    Configure auto\-tunnel backup timers value
                    
                    .. attribute:: removal
                    
                    	Configure auto\-tunnel backup removal timers value
                    	**type**\:   :py:class:`Removal <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers.Removal>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers, self).__init__()

                        self.yang_name = "timers"
                        self.yang_parent_name = "mesh"

                        self.removal = MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers.Removal()
                        self.removal.parent = self
                        self._children_name_map["removal"] = "removal"
                        self._children_yang_names.add("removal")


                    class Removal(Entity):
                        """
                        Configure auto\-tunnel backup removal timers
                        value
                        
                        .. attribute:: unused
                        
                        	Auto\-tunnel backup unused timeout in minutes (0=never timeout)
                        	**type**\:  int
                        
                        	**range:** 0..10080
                        
                        	**units**\: minute
                        
                        	**default value**\: 3600
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers.Removal, self).__init__()

                            self.yang_name = "removal"
                            self.yang_parent_name = "timers"

                            self.unused = YLeaf(YType.uint32, "unused")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("unused") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers.Removal, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers.Removal, self).__setattr__(name, value)

                        def has_data(self):
                            return self.unused.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.unused.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "removal" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/timers/%s" % self.get_segment_path()
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.unused.is_set or self.unused.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.unused.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "unused"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "unused"):
                                self.unused = value
                                self.unused.value_namespace = name_space
                                self.unused.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.removal is not None and self.removal.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.removal is not None and self.removal.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "timers" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "removal"):
                            if (self.removal is None):
                                self.removal = MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers.Removal()
                                self.removal.parent = self
                                self._children_name_map["removal"] = "removal"
                            return self.removal

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "removal"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class TunnelRange(Entity):
                    """
                    Configure tunnel ID range for auto\-tunnel
                    features
                    
                    .. attribute:: max_tunnel_id
                    
                    	Maximum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: min_tunnel_id
                    
                    	Minimum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.TunnelRange, self).__init__()

                        self.yang_name = "tunnel-range"
                        self.yang_parent_name = "mesh"

                        self.max_tunnel_id = YLeaf(YType.uint32, "max-tunnel-id")

                        self.min_tunnel_id = YLeaf(YType.uint32, "min-tunnel-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("max_tunnel_id",
                                        "min_tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.TunnelRange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AutoTunnel.Mesh.TunnelRange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.max_tunnel_id.is_set or
                            self.min_tunnel_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.max_tunnel_id.yfilter != YFilter.not_set or
                            self.min_tunnel_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel-range" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.max_tunnel_id.is_set or self.max_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_tunnel_id.get_name_leafdata())
                        if (self.min_tunnel_id.is_set or self.min_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.min_tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "max-tunnel-id" or name == "min-tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "max-tunnel-id"):
                            self.max_tunnel_id = value
                            self.max_tunnel_id.value_namespace = name_space
                            self.max_tunnel_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "min-tunnel-id"):
                            self.min_tunnel_id = value
                            self.min_tunnel_id.value_namespace = name_space
                            self.min_tunnel_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        (self.mesh_groups is not None and self.mesh_groups.has_data()) or
                        (self.timers is not None and self.timers.has_data()) or
                        (self.tunnel_range is not None and self.tunnel_range.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.mesh_groups is not None and self.mesh_groups.has_operation()) or
                        (self.timers is not None and self.timers.has_operation()) or
                        (self.tunnel_range is not None and self.tunnel_range.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "mesh" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "mesh-groups"):
                        if (self.mesh_groups is None):
                            self.mesh_groups = MplsTe.GlobalAttributes.AutoTunnel.Mesh.MeshGroups()
                            self.mesh_groups.parent = self
                            self._children_name_map["mesh_groups"] = "mesh-groups"
                        return self.mesh_groups

                    if (child_yang_name == "timers"):
                        if (self.timers is None):
                            self.timers = MplsTe.GlobalAttributes.AutoTunnel.Mesh.Timers()
                            self.timers.parent = self
                            self._children_name_map["timers"] = "timers"
                        return self.timers

                    if (child_yang_name == "tunnel-range"):
                        if (self.tunnel_range is None):
                            self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.Mesh.TunnelRange()
                            self.tunnel_range.parent = self
                            self._children_name_map["tunnel_range"] = "tunnel-range"
                        return self.tunnel_range

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "mesh-groups" or name == "timers" or name == "tunnel-range"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class P2MpAutoTunnel(Entity):
                """
                Configure P2MP auto\-tunnel feature
                
                .. attribute:: tunnel_range
                
                	Configure tunnel ID range for auto\-tunnel features
                	**type**\:   :py:class:`TunnelRange <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel.TunnelRange>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel, self).__init__()

                    self.yang_name = "p2mp-auto-tunnel"
                    self.yang_parent_name = "auto-tunnel"

                    self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel.TunnelRange()
                    self.tunnel_range.parent = self
                    self._children_name_map["tunnel_range"] = "tunnel-range"
                    self._children_yang_names.add("tunnel-range")


                class TunnelRange(Entity):
                    """
                    Configure tunnel ID range for auto\-tunnel
                    features
                    
                    .. attribute:: max_tunnel_id
                    
                    	Maximum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    .. attribute:: min_tunnel_id
                    
                    	Minimum tunnel ID for auto\-tunnels
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel.TunnelRange, self).__init__()

                        self.yang_name = "tunnel-range"
                        self.yang_parent_name = "p2mp-auto-tunnel"

                        self.max_tunnel_id = YLeaf(YType.uint32, "max-tunnel-id")

                        self.min_tunnel_id = YLeaf(YType.uint32, "min-tunnel-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("max_tunnel_id",
                                        "min_tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel.TunnelRange, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel.TunnelRange, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.max_tunnel_id.is_set or
                            self.min_tunnel_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.max_tunnel_id.yfilter != YFilter.not_set or
                            self.min_tunnel_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "tunnel-range" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/p2mp-auto-tunnel/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.max_tunnel_id.is_set or self.max_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.max_tunnel_id.get_name_leafdata())
                        if (self.min_tunnel_id.is_set or self.min_tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.min_tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "max-tunnel-id" or name == "min-tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "max-tunnel-id"):
                            self.max_tunnel_id = value
                            self.max_tunnel_id.value_namespace = name_space
                            self.max_tunnel_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "min-tunnel-id"):
                            self.min_tunnel_id = value
                            self.min_tunnel_id.value_namespace = name_space
                            self.min_tunnel_id.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (self.tunnel_range is not None and self.tunnel_range.has_data())

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.tunnel_range is not None and self.tunnel_range.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "p2mp-auto-tunnel" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "tunnel-range"):
                        if (self.tunnel_range is None):
                            self.tunnel_range = MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel.TunnelRange()
                            self.tunnel_range.parent = self
                            self._children_name_map["tunnel_range"] = "tunnel-range"
                        return self.tunnel_range

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "tunnel-range"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.backup is not None and self.backup.has_data()) or
                    (self.mesh is not None and self.mesh.has_data()) or
                    (self.p2mp_auto_tunnel is not None and self.p2mp_auto_tunnel.has_data()) or
                    (self.p2p_auto_tunnel is not None and self.p2p_auto_tunnel.has_data()) or
                    (self.pcc is not None and self.pcc.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.backup is not None and self.backup.has_operation()) or
                    (self.mesh is not None and self.mesh.has_operation()) or
                    (self.p2mp_auto_tunnel is not None and self.p2mp_auto_tunnel.has_operation()) or
                    (self.p2p_auto_tunnel is not None and self.p2p_auto_tunnel.has_operation()) or
                    (self.pcc is not None and self.pcc.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "auto-tunnel" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "backup"):
                    if (self.backup is None):
                        self.backup = MplsTe.GlobalAttributes.AutoTunnel.Backup()
                        self.backup.parent = self
                        self._children_name_map["backup"] = "backup"
                    return self.backup

                if (child_yang_name == "mesh"):
                    if (self.mesh is None):
                        self.mesh = MplsTe.GlobalAttributes.AutoTunnel.Mesh()
                        self.mesh.parent = self
                        self._children_name_map["mesh"] = "mesh"
                    return self.mesh

                if (child_yang_name == "p2mp-auto-tunnel"):
                    if (self.p2mp_auto_tunnel is None):
                        self.p2mp_auto_tunnel = MplsTe.GlobalAttributes.AutoTunnel.P2MpAutoTunnel()
                        self.p2mp_auto_tunnel.parent = self
                        self._children_name_map["p2mp_auto_tunnel"] = "p2mp-auto-tunnel"
                    return self.p2mp_auto_tunnel

                if (child_yang_name == "p2p-auto-tunnel"):
                    if (self.p2p_auto_tunnel is None):
                        self.p2p_auto_tunnel = MplsTe.GlobalAttributes.AutoTunnel.P2PAutoTunnel()
                        self.p2p_auto_tunnel.parent = self
                        self._children_name_map["p2p_auto_tunnel"] = "p2p-auto-tunnel"
                    return self.p2p_auto_tunnel

                if (child_yang_name == "pcc"):
                    if (self.pcc is None):
                        self.pcc = MplsTe.GlobalAttributes.AutoTunnel.Pcc()
                        self.pcc.parent = self
                        self._children_name_map["pcc"] = "pcc"
                    return self.pcc

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "backup" or name == "mesh" or name == "p2mp-auto-tunnel" or name == "p2p-auto-tunnel" or name == "pcc"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class HardwareOutOfResource(Entity):
            """
            Configure HW OOR processing in MPLS\-TE
            
            .. attribute:: oor_green_state
            
            	Configuration for HW OOR Green State
            	**type**\:   :py:class:`OorGreenState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.HardwareOutOfResource.OorGreenState>`
            
            .. attribute:: oor_red_state
            
            	Configuration for HW OOR Red State
            	**type**\:   :py:class:`OorRedState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.HardwareOutOfResource.OorRedState>`
            
            .. attribute:: oor_yellow_state
            
            	Configuration for HW OOR Yellow State
            	**type**\:   :py:class:`OorYellowState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.HardwareOutOfResource.OorYellowState>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.HardwareOutOfResource, self).__init__()

                self.yang_name = "hardware-out-of-resource"
                self.yang_parent_name = "global-attributes"

                self.oor_green_state = MplsTe.GlobalAttributes.HardwareOutOfResource.OorGreenState()
                self.oor_green_state.parent = self
                self._children_name_map["oor_green_state"] = "oor-green-state"
                self._children_yang_names.add("oor-green-state")

                self.oor_red_state = MplsTe.GlobalAttributes.HardwareOutOfResource.OorRedState()
                self.oor_red_state.parent = self
                self._children_name_map["oor_red_state"] = "oor-red-state"
                self._children_yang_names.add("oor-red-state")

                self.oor_yellow_state = MplsTe.GlobalAttributes.HardwareOutOfResource.OorYellowState()
                self.oor_yellow_state.parent = self
                self._children_name_map["oor_yellow_state"] = "oor-yellow-state"
                self._children_yang_names.add("oor-yellow-state")


            class OorRedState(Entity):
                """
                Configuration for HW OOR Red State
                
                .. attribute:: oor_accept_lsp_min_bandwidth
                
                	Only accept LSPs with at least the specified bandwidth (in kbps)
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                	**units**\: kbit/s
                
                	**default value**\: 0
                
                .. attribute:: oor_accept_reopt_lsp
                
                	Allow the setup of reoptimized LSPs over the link in this OOR State
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: oor_available_bandwidth_percentage
                
                	Flood a specific percentage of the available bandwidth
                	**type**\:  int
                
                	**range:** 0..100
                
                	**units**\: percentage
                
                	**default value**\: 100
                
                .. attribute:: oor_metric_te_penalty
                
                	Penalty applied to the TE metric of a link in OOR state
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                	**default value**\: 0
                
                .. attribute:: oor_node_protection_disable
                
                	Disable FRR node\-protection when the link is in this OOR State
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.HardwareOutOfResource.OorRedState, self).__init__()

                    self.yang_name = "oor-red-state"
                    self.yang_parent_name = "hardware-out-of-resource"

                    self.oor_accept_lsp_min_bandwidth = YLeaf(YType.int32, "oor-accept-lsp-min-bandwidth")

                    self.oor_accept_reopt_lsp = YLeaf(YType.empty, "oor-accept-reopt-lsp")

                    self.oor_available_bandwidth_percentage = YLeaf(YType.uint32, "oor-available-bandwidth-percentage")

                    self.oor_metric_te_penalty = YLeaf(YType.int32, "oor-metric-te-penalty")

                    self.oor_node_protection_disable = YLeaf(YType.empty, "oor-node-protection-disable")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("oor_accept_lsp_min_bandwidth",
                                    "oor_accept_reopt_lsp",
                                    "oor_available_bandwidth_percentage",
                                    "oor_metric_te_penalty",
                                    "oor_node_protection_disable") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.HardwareOutOfResource.OorRedState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.HardwareOutOfResource.OorRedState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.oor_accept_lsp_min_bandwidth.is_set or
                        self.oor_accept_reopt_lsp.is_set or
                        self.oor_available_bandwidth_percentage.is_set or
                        self.oor_metric_te_penalty.is_set or
                        self.oor_node_protection_disable.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.oor_accept_lsp_min_bandwidth.yfilter != YFilter.not_set or
                        self.oor_accept_reopt_lsp.yfilter != YFilter.not_set or
                        self.oor_available_bandwidth_percentage.yfilter != YFilter.not_set or
                        self.oor_metric_te_penalty.yfilter != YFilter.not_set or
                        self.oor_node_protection_disable.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "oor-red-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/hardware-out-of-resource/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.oor_accept_lsp_min_bandwidth.is_set or self.oor_accept_lsp_min_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_accept_lsp_min_bandwidth.get_name_leafdata())
                    if (self.oor_accept_reopt_lsp.is_set or self.oor_accept_reopt_lsp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_accept_reopt_lsp.get_name_leafdata())
                    if (self.oor_available_bandwidth_percentage.is_set or self.oor_available_bandwidth_percentage.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_available_bandwidth_percentage.get_name_leafdata())
                    if (self.oor_metric_te_penalty.is_set or self.oor_metric_te_penalty.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_metric_te_penalty.get_name_leafdata())
                    if (self.oor_node_protection_disable.is_set or self.oor_node_protection_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_node_protection_disable.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "oor-accept-lsp-min-bandwidth" or name == "oor-accept-reopt-lsp" or name == "oor-available-bandwidth-percentage" or name == "oor-metric-te-penalty" or name == "oor-node-protection-disable"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "oor-accept-lsp-min-bandwidth"):
                        self.oor_accept_lsp_min_bandwidth = value
                        self.oor_accept_lsp_min_bandwidth.value_namespace = name_space
                        self.oor_accept_lsp_min_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-accept-reopt-lsp"):
                        self.oor_accept_reopt_lsp = value
                        self.oor_accept_reopt_lsp.value_namespace = name_space
                        self.oor_accept_reopt_lsp.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-available-bandwidth-percentage"):
                        self.oor_available_bandwidth_percentage = value
                        self.oor_available_bandwidth_percentage.value_namespace = name_space
                        self.oor_available_bandwidth_percentage.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-metric-te-penalty"):
                        self.oor_metric_te_penalty = value
                        self.oor_metric_te_penalty.value_namespace = name_space
                        self.oor_metric_te_penalty.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-node-protection-disable"):
                        self.oor_node_protection_disable = value
                        self.oor_node_protection_disable.value_namespace = name_space
                        self.oor_node_protection_disable.value_namespace_prefix = name_space_prefix


            class OorYellowState(Entity):
                """
                Configuration for HW OOR Yellow State
                
                .. attribute:: oor_accept_lsp_min_bandwidth
                
                	Only accept LSPs with at least the specified bandwidth (in kbps)
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                	**units**\: kbit/s
                
                	**default value**\: 0
                
                .. attribute:: oor_accept_reopt_lsp
                
                	Allow the setup of reoptimized LSPs over the link in this OOR State
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: oor_available_bandwidth_percentage
                
                	Flood a specific percentage of the available bandwidth
                	**type**\:  int
                
                	**range:** 0..100
                
                	**units**\: percentage
                
                	**default value**\: 100
                
                .. attribute:: oor_metric_te_penalty
                
                	Penalty applied to the TE metric of a link in OOR state
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                	**default value**\: 0
                
                .. attribute:: oor_node_protection_disable
                
                	Disable FRR node\-protection when the link is in this OOR State
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.HardwareOutOfResource.OorYellowState, self).__init__()

                    self.yang_name = "oor-yellow-state"
                    self.yang_parent_name = "hardware-out-of-resource"

                    self.oor_accept_lsp_min_bandwidth = YLeaf(YType.int32, "oor-accept-lsp-min-bandwidth")

                    self.oor_accept_reopt_lsp = YLeaf(YType.empty, "oor-accept-reopt-lsp")

                    self.oor_available_bandwidth_percentage = YLeaf(YType.uint32, "oor-available-bandwidth-percentage")

                    self.oor_metric_te_penalty = YLeaf(YType.int32, "oor-metric-te-penalty")

                    self.oor_node_protection_disable = YLeaf(YType.empty, "oor-node-protection-disable")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("oor_accept_lsp_min_bandwidth",
                                    "oor_accept_reopt_lsp",
                                    "oor_available_bandwidth_percentage",
                                    "oor_metric_te_penalty",
                                    "oor_node_protection_disable") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.HardwareOutOfResource.OorYellowState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.HardwareOutOfResource.OorYellowState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.oor_accept_lsp_min_bandwidth.is_set or
                        self.oor_accept_reopt_lsp.is_set or
                        self.oor_available_bandwidth_percentage.is_set or
                        self.oor_metric_te_penalty.is_set or
                        self.oor_node_protection_disable.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.oor_accept_lsp_min_bandwidth.yfilter != YFilter.not_set or
                        self.oor_accept_reopt_lsp.yfilter != YFilter.not_set or
                        self.oor_available_bandwidth_percentage.yfilter != YFilter.not_set or
                        self.oor_metric_te_penalty.yfilter != YFilter.not_set or
                        self.oor_node_protection_disable.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "oor-yellow-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/hardware-out-of-resource/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.oor_accept_lsp_min_bandwidth.is_set or self.oor_accept_lsp_min_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_accept_lsp_min_bandwidth.get_name_leafdata())
                    if (self.oor_accept_reopt_lsp.is_set or self.oor_accept_reopt_lsp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_accept_reopt_lsp.get_name_leafdata())
                    if (self.oor_available_bandwidth_percentage.is_set or self.oor_available_bandwidth_percentage.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_available_bandwidth_percentage.get_name_leafdata())
                    if (self.oor_metric_te_penalty.is_set or self.oor_metric_te_penalty.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_metric_te_penalty.get_name_leafdata())
                    if (self.oor_node_protection_disable.is_set or self.oor_node_protection_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_node_protection_disable.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "oor-accept-lsp-min-bandwidth" or name == "oor-accept-reopt-lsp" or name == "oor-available-bandwidth-percentage" or name == "oor-metric-te-penalty" or name == "oor-node-protection-disable"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "oor-accept-lsp-min-bandwidth"):
                        self.oor_accept_lsp_min_bandwidth = value
                        self.oor_accept_lsp_min_bandwidth.value_namespace = name_space
                        self.oor_accept_lsp_min_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-accept-reopt-lsp"):
                        self.oor_accept_reopt_lsp = value
                        self.oor_accept_reopt_lsp.value_namespace = name_space
                        self.oor_accept_reopt_lsp.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-available-bandwidth-percentage"):
                        self.oor_available_bandwidth_percentage = value
                        self.oor_available_bandwidth_percentage.value_namespace = name_space
                        self.oor_available_bandwidth_percentage.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-metric-te-penalty"):
                        self.oor_metric_te_penalty = value
                        self.oor_metric_te_penalty.value_namespace = name_space
                        self.oor_metric_te_penalty.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-node-protection-disable"):
                        self.oor_node_protection_disable = value
                        self.oor_node_protection_disable.value_namespace = name_space
                        self.oor_node_protection_disable.value_namespace_prefix = name_space_prefix


            class OorGreenState(Entity):
                """
                Configuration for HW OOR Green State
                
                .. attribute:: oor_accept_lsp_min_bandwidth
                
                	Only accept LSPs with at least the specified bandwidth (in kbps)
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                	**units**\: kbit/s
                
                	**default value**\: 0
                
                .. attribute:: oor_accept_reopt_lsp
                
                	Allow the setup of reoptimized LSPs over the link in this OOR State
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: oor_available_bandwidth_percentage
                
                	Flood a specific percentage of the available bandwidth
                	**type**\:  int
                
                	**range:** 0..100
                
                	**units**\: percentage
                
                	**default value**\: 100
                
                .. attribute:: oor_metric_te_penalty
                
                	Penalty applied to the TE metric of a link in OOR state
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                	**default value**\: 0
                
                .. attribute:: oor_node_protection_disable
                
                	Disable FRR node\-protection when the link is in this OOR State
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: oor_recovery_duration
                
                	Period of time (minutes) during which the action in Green state are applied. After this period, the processing in TE goes back to normal state
                	**type**\:  int
                
                	**range:** 0..10080
                
                	**units**\: minute
                
                	**default value**\: 0
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.HardwareOutOfResource.OorGreenState, self).__init__()

                    self.yang_name = "oor-green-state"
                    self.yang_parent_name = "hardware-out-of-resource"

                    self.oor_accept_lsp_min_bandwidth = YLeaf(YType.int32, "oor-accept-lsp-min-bandwidth")

                    self.oor_accept_reopt_lsp = YLeaf(YType.empty, "oor-accept-reopt-lsp")

                    self.oor_available_bandwidth_percentage = YLeaf(YType.uint32, "oor-available-bandwidth-percentage")

                    self.oor_metric_te_penalty = YLeaf(YType.int32, "oor-metric-te-penalty")

                    self.oor_node_protection_disable = YLeaf(YType.empty, "oor-node-protection-disable")

                    self.oor_recovery_duration = YLeaf(YType.uint32, "oor-recovery-duration")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("oor_accept_lsp_min_bandwidth",
                                    "oor_accept_reopt_lsp",
                                    "oor_available_bandwidth_percentage",
                                    "oor_metric_te_penalty",
                                    "oor_node_protection_disable",
                                    "oor_recovery_duration") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.HardwareOutOfResource.OorGreenState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.HardwareOutOfResource.OorGreenState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.oor_accept_lsp_min_bandwidth.is_set or
                        self.oor_accept_reopt_lsp.is_set or
                        self.oor_available_bandwidth_percentage.is_set or
                        self.oor_metric_te_penalty.is_set or
                        self.oor_node_protection_disable.is_set or
                        self.oor_recovery_duration.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.oor_accept_lsp_min_bandwidth.yfilter != YFilter.not_set or
                        self.oor_accept_reopt_lsp.yfilter != YFilter.not_set or
                        self.oor_available_bandwidth_percentage.yfilter != YFilter.not_set or
                        self.oor_metric_te_penalty.yfilter != YFilter.not_set or
                        self.oor_node_protection_disable.yfilter != YFilter.not_set or
                        self.oor_recovery_duration.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "oor-green-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/hardware-out-of-resource/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.oor_accept_lsp_min_bandwidth.is_set or self.oor_accept_lsp_min_bandwidth.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_accept_lsp_min_bandwidth.get_name_leafdata())
                    if (self.oor_accept_reopt_lsp.is_set or self.oor_accept_reopt_lsp.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_accept_reopt_lsp.get_name_leafdata())
                    if (self.oor_available_bandwidth_percentage.is_set or self.oor_available_bandwidth_percentage.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_available_bandwidth_percentage.get_name_leafdata())
                    if (self.oor_metric_te_penalty.is_set or self.oor_metric_te_penalty.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_metric_te_penalty.get_name_leafdata())
                    if (self.oor_node_protection_disable.is_set or self.oor_node_protection_disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_node_protection_disable.get_name_leafdata())
                    if (self.oor_recovery_duration.is_set or self.oor_recovery_duration.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.oor_recovery_duration.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "oor-accept-lsp-min-bandwidth" or name == "oor-accept-reopt-lsp" or name == "oor-available-bandwidth-percentage" or name == "oor-metric-te-penalty" or name == "oor-node-protection-disable" or name == "oor-recovery-duration"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "oor-accept-lsp-min-bandwidth"):
                        self.oor_accept_lsp_min_bandwidth = value
                        self.oor_accept_lsp_min_bandwidth.value_namespace = name_space
                        self.oor_accept_lsp_min_bandwidth.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-accept-reopt-lsp"):
                        self.oor_accept_reopt_lsp = value
                        self.oor_accept_reopt_lsp.value_namespace = name_space
                        self.oor_accept_reopt_lsp.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-available-bandwidth-percentage"):
                        self.oor_available_bandwidth_percentage = value
                        self.oor_available_bandwidth_percentage.value_namespace = name_space
                        self.oor_available_bandwidth_percentage.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-metric-te-penalty"):
                        self.oor_metric_te_penalty = value
                        self.oor_metric_te_penalty.value_namespace = name_space
                        self.oor_metric_te_penalty.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-node-protection-disable"):
                        self.oor_node_protection_disable = value
                        self.oor_node_protection_disable.value_namespace = name_space
                        self.oor_node_protection_disable.value_namespace_prefix = name_space_prefix
                    if(value_path == "oor-recovery-duration"):
                        self.oor_recovery_duration = value
                        self.oor_recovery_duration.value_namespace = name_space
                        self.oor_recovery_duration.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.oor_green_state is not None and self.oor_green_state.has_data()) or
                    (self.oor_red_state is not None and self.oor_red_state.has_data()) or
                    (self.oor_yellow_state is not None and self.oor_yellow_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.oor_green_state is not None and self.oor_green_state.has_operation()) or
                    (self.oor_red_state is not None and self.oor_red_state.has_operation()) or
                    (self.oor_yellow_state is not None and self.oor_yellow_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "hardware-out-of-resource" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "oor-green-state"):
                    if (self.oor_green_state is None):
                        self.oor_green_state = MplsTe.GlobalAttributes.HardwareOutOfResource.OorGreenState()
                        self.oor_green_state.parent = self
                        self._children_name_map["oor_green_state"] = "oor-green-state"
                    return self.oor_green_state

                if (child_yang_name == "oor-red-state"):
                    if (self.oor_red_state is None):
                        self.oor_red_state = MplsTe.GlobalAttributes.HardwareOutOfResource.OorRedState()
                        self.oor_red_state.parent = self
                        self._children_name_map["oor_red_state"] = "oor-red-state"
                    return self.oor_red_state

                if (child_yang_name == "oor-yellow-state"):
                    if (self.oor_yellow_state is None):
                        self.oor_yellow_state = MplsTe.GlobalAttributes.HardwareOutOfResource.OorYellowState()
                        self.oor_yellow_state.parent = self
                        self._children_name_map["oor_yellow_state"] = "oor-yellow-state"
                    return self.oor_yellow_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "oor-green-state" or name == "oor-red-state" or name == "oor-yellow-state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class SecondaryRouterIds(Entity):
            """
            Configure MPLS TE Secondary Router ID
            
            .. attribute:: secondary_router_id
            
            	Secondary Router ID
            	**type**\: list of    :py:class:`SecondaryRouterId <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.SecondaryRouterIds.SecondaryRouterId>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.SecondaryRouterIds, self).__init__()

                self.yang_name = "secondary-router-ids"
                self.yang_parent_name = "global-attributes"

                self.secondary_router_id = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GlobalAttributes.SecondaryRouterIds, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GlobalAttributes.SecondaryRouterIds, self).__setattr__(name, value)


            class SecondaryRouterId(Entity):
                """
                Secondary Router ID
                
                .. attribute:: secondary_router_id_value  <key>
                
                	Secondary TE Router ID
                	**type**\:  str
                
                	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.SecondaryRouterIds.SecondaryRouterId, self).__init__()

                    self.yang_name = "secondary-router-id"
                    self.yang_parent_name = "secondary-router-ids"

                    self.secondary_router_id_value = YLeaf(YType.str, "secondary-router-id-value")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("secondary_router_id_value") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.SecondaryRouterIds.SecondaryRouterId, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.SecondaryRouterIds.SecondaryRouterId, self).__setattr__(name, value)

                def has_data(self):
                    return self.secondary_router_id_value.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.secondary_router_id_value.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "secondary-router-id" + "[secondary-router-id-value='" + self.secondary_router_id_value.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/secondary-router-ids/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.secondary_router_id_value.is_set or self.secondary_router_id_value.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.secondary_router_id_value.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "secondary-router-id-value"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "secondary-router-id-value"):
                        self.secondary_router_id_value = value
                        self.secondary_router_id_value.value_namespace = name_space
                        self.secondary_router_id_value.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.secondary_router_id:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.secondary_router_id:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "secondary-router-ids" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "secondary-router-id"):
                    for c in self.secondary_router_id:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsTe.GlobalAttributes.SecondaryRouterIds.SecondaryRouterId()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.secondary_router_id.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "secondary-router-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Srlg(Entity):
            """
            Configure SRLG values and MPLS\-TE properties
            
            .. attribute:: default_admin_weight
            
            	Default Admin weight any SRLG value that does not have one
            	**type**\:  int
            
            	**range:** \-2147483648..2147483647
            
            	**default value**\: 1
            
            .. attribute:: enable
            
            	Enter SRLG property configuration
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: names
            
            	Configure SRLG identified by names
            	**type**\:   :py:class:`Names <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Srlg.Names>`
            
            .. attribute:: values
            
            	Configure SRLG values and MPLS\-TE properties
            	**type**\:   :py:class:`Values <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Srlg.Values>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.Srlg, self).__init__()

                self.yang_name = "srlg"
                self.yang_parent_name = "global-attributes"

                self.default_admin_weight = YLeaf(YType.int32, "default-admin-weight")

                self.enable = YLeaf(YType.empty, "enable")

                self.names = MplsTe.GlobalAttributes.Srlg.Names()
                self.names.parent = self
                self._children_name_map["names"] = "names"
                self._children_yang_names.add("names")

                self.values = MplsTe.GlobalAttributes.Srlg.Values()
                self.values.parent = self
                self._children_name_map["values"] = "values"
                self._children_yang_names.add("values")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("default_admin_weight",
                                "enable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GlobalAttributes.Srlg, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GlobalAttributes.Srlg, self).__setattr__(name, value)


            class Names(Entity):
                """
                Configure SRLG identified by names
                
                .. attribute:: name
                
                	SRLG name and its MPLS\-TE properties
                	**type**\: list of    :py:class:`Name <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Srlg.Names.Name>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.Srlg.Names, self).__init__()

                    self.yang_name = "names"
                    self.yang_parent_name = "srlg"

                    self.name = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.Srlg.Names, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.Srlg.Names, self).__setattr__(name, value)


                class Name(Entity):
                    """
                    SRLG name and its MPLS\-TE properties
                    
                    .. attribute:: srlg_name  <key>
                    
                    	SRLG membership name
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: admin_weight
                    
                    	Administrative weight for the SRLG value
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: static_srlg_members
                    
                    	Configure static SRLG members list
                    	**type**\:   :py:class:`StaticSrlgMembers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.Srlg.Names.Name, self).__init__()

                        self.yang_name = "name"
                        self.yang_parent_name = "names"

                        self.srlg_name = YLeaf(YType.str, "srlg-name")

                        self.admin_weight = YLeaf(YType.int32, "admin-weight")

                        self.static_srlg_members = MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers()
                        self.static_srlg_members.parent = self
                        self._children_name_map["static_srlg_members"] = "static-srlg-members"
                        self._children_yang_names.add("static-srlg-members")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("srlg_name",
                                        "admin_weight") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.Srlg.Names.Name, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.Srlg.Names.Name, self).__setattr__(name, value)


                    class StaticSrlgMembers(Entity):
                        """
                        Configure static SRLG members list
                        
                        .. attribute:: static_srlg_member
                        
                        	A mapping of the local static SRLG member
                        	**type**\: list of    :py:class:`StaticSrlgMember <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers.StaticSrlgMember>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers, self).__init__()

                            self.yang_name = "static-srlg-members"
                            self.yang_parent_name = "name"

                            self.static_srlg_member = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers, self).__setattr__(name, value)


                        class StaticSrlgMember(Entity):
                            """
                            A mapping of the local static SRLG member
                            
                            .. attribute:: from_address  <key>
                            
                            	From address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: to_address
                            
                            	To Addres
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            	**mandatory**\: True
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers.StaticSrlgMember, self).__init__()

                                self.yang_name = "static-srlg-member"
                                self.yang_parent_name = "static-srlg-members"

                                self.from_address = YLeaf(YType.str, "from-address")

                                self.to_address = YLeaf(YType.str, "to-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("from_address",
                                                "to_address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers.StaticSrlgMember, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers.StaticSrlgMember, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.from_address.is_set or
                                    self.to_address.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.from_address.yfilter != YFilter.not_set or
                                    self.to_address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "static-srlg-member" + "[from-address='" + self.from_address.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.from_address.is_set or self.from_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.from_address.get_name_leafdata())
                                if (self.to_address.is_set or self.to_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.to_address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "from-address" or name == "to-address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "from-address"):
                                    self.from_address = value
                                    self.from_address.value_namespace = name_space
                                    self.from_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "to-address"):
                                    self.to_address = value
                                    self.to_address.value_namespace = name_space
                                    self.to_address.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.static_srlg_member:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.static_srlg_member:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "static-srlg-members" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "static-srlg-member"):
                                for c in self.static_srlg_member:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers.StaticSrlgMember()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.static_srlg_member.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "static-srlg-member"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.srlg_name.is_set or
                            self.admin_weight.is_set or
                            (self.static_srlg_members is not None and self.static_srlg_members.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.srlg_name.yfilter != YFilter.not_set or
                            self.admin_weight.yfilter != YFilter.not_set or
                            (self.static_srlg_members is not None and self.static_srlg_members.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "name" + "[srlg-name='" + self.srlg_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/srlg/names/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.srlg_name.is_set or self.srlg_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.srlg_name.get_name_leafdata())
                        if (self.admin_weight.is_set or self.admin_weight.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.admin_weight.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "static-srlg-members"):
                            if (self.static_srlg_members is None):
                                self.static_srlg_members = MplsTe.GlobalAttributes.Srlg.Names.Name.StaticSrlgMembers()
                                self.static_srlg_members.parent = self
                                self._children_name_map["static_srlg_members"] = "static-srlg-members"
                            return self.static_srlg_members

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "static-srlg-members" or name == "srlg-name" or name == "admin-weight"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "srlg-name"):
                            self.srlg_name = value
                            self.srlg_name.value_namespace = name_space
                            self.srlg_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "admin-weight"):
                            self.admin_weight = value
                            self.admin_weight.value_namespace = name_space
                            self.admin_weight.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.name:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.name:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "names" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/srlg/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "name"):
                        for c in self.name:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.Srlg.Names.Name()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.name.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Values(Entity):
                """
                Configure SRLG values and MPLS\-TE properties
                
                .. attribute:: value
                
                	SRLG value and its MPLS\-TE properties
                	**type**\: list of    :py:class:`Value <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Srlg.Values.Value>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.Srlg.Values, self).__init__()

                    self.yang_name = "values"
                    self.yang_parent_name = "srlg"

                    self.value = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.Srlg.Values, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.Srlg.Values, self).__setattr__(name, value)


                class Value(Entity):
                    """
                    SRLG value and its MPLS\-TE properties
                    
                    .. attribute:: srlg_number  <key>
                    
                    	SRLG membership number
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    .. attribute:: admin_weight
                    
                    	Administrative weight for the SRLG value
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: ipv4_address_maps
                    
                    	Configure outgoing and remote link addresses for a given SRLG value
                    	**type**\:   :py:class:`Ipv4AddressMaps <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.Srlg.Values.Value, self).__init__()

                        self.yang_name = "value"
                        self.yang_parent_name = "values"

                        self.srlg_number = YLeaf(YType.uint32, "srlg-number")

                        self.admin_weight = YLeaf(YType.int32, "admin-weight")

                        self.ipv4_address_maps = MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps()
                        self.ipv4_address_maps.parent = self
                        self._children_name_map["ipv4_address_maps"] = "ipv4-address-maps"
                        self._children_yang_names.add("ipv4-address-maps")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("srlg_number",
                                        "admin_weight") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.Srlg.Values.Value, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.Srlg.Values.Value, self).__setattr__(name, value)


                    class Ipv4AddressMaps(Entity):
                        """
                        Configure outgoing and remote link addresses
                        for a given SRLG value
                        
                        .. attribute:: ipv4_address_map
                        
                        	A mapping of the remote and local addresses of a link to an SRLG value
                        	**type**\: list of    :py:class:`Ipv4AddressMap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps.Ipv4AddressMap>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps, self).__init__()

                            self.yang_name = "ipv4-address-maps"
                            self.yang_parent_name = "value"

                            self.ipv4_address_map = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps, self).__setattr__(name, value)


                        class Ipv4AddressMap(Entity):
                            """
                            A mapping of the remote and local addresses
                            of a link to an SRLG value
                            
                            .. attribute:: outgoing_ipv4_address  <key>
                            
                            	Outgoing v4 address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            .. attribute:: remote_ipv4_address  <key>
                            
                            	Remote v4 address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps.Ipv4AddressMap, self).__init__()

                                self.yang_name = "ipv4-address-map"
                                self.yang_parent_name = "ipv4-address-maps"

                                self.outgoing_ipv4_address = YLeaf(YType.str, "outgoing-ipv4-address")

                                self.remote_ipv4_address = YLeaf(YType.str, "remote-ipv4-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("outgoing_ipv4_address",
                                                "remote_ipv4_address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps.Ipv4AddressMap, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps.Ipv4AddressMap, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.outgoing_ipv4_address.is_set or
                                    self.remote_ipv4_address.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.outgoing_ipv4_address.yfilter != YFilter.not_set or
                                    self.remote_ipv4_address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "ipv4-address-map" + "[outgoing-ipv4-address='" + self.outgoing_ipv4_address.get() + "']" + "[remote-ipv4-address='" + self.remote_ipv4_address.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.outgoing_ipv4_address.is_set or self.outgoing_ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.outgoing_ipv4_address.get_name_leafdata())
                                if (self.remote_ipv4_address.is_set or self.remote_ipv4_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.remote_ipv4_address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "outgoing-ipv4-address" or name == "remote-ipv4-address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "outgoing-ipv4-address"):
                                    self.outgoing_ipv4_address = value
                                    self.outgoing_ipv4_address.value_namespace = name_space
                                    self.outgoing_ipv4_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "remote-ipv4-address"):
                                    self.remote_ipv4_address = value
                                    self.remote_ipv4_address.value_namespace = name_space
                                    self.remote_ipv4_address.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.ipv4_address_map:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.ipv4_address_map:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "ipv4-address-maps" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "ipv4-address-map"):
                                for c in self.ipv4_address_map:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps.Ipv4AddressMap()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.ipv4_address_map.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "ipv4-address-map"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.srlg_number.is_set or
                            self.admin_weight.is_set or
                            (self.ipv4_address_maps is not None and self.ipv4_address_maps.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.srlg_number.yfilter != YFilter.not_set or
                            self.admin_weight.yfilter != YFilter.not_set or
                            (self.ipv4_address_maps is not None and self.ipv4_address_maps.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "value" + "[srlg-number='" + self.srlg_number.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/srlg/values/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.srlg_number.is_set or self.srlg_number.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.srlg_number.get_name_leafdata())
                        if (self.admin_weight.is_set or self.admin_weight.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.admin_weight.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "ipv4-address-maps"):
                            if (self.ipv4_address_maps is None):
                                self.ipv4_address_maps = MplsTe.GlobalAttributes.Srlg.Values.Value.Ipv4AddressMaps()
                                self.ipv4_address_maps.parent = self
                                self._children_name_map["ipv4_address_maps"] = "ipv4-address-maps"
                            return self.ipv4_address_maps

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "ipv4-address-maps" or name == "srlg-number" or name == "admin-weight"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "srlg-number"):
                            self.srlg_number = value
                            self.srlg_number.value_namespace = name_space
                            self.srlg_number.value_namespace_prefix = name_space_prefix
                        if(value_path == "admin-weight"):
                            self.admin_weight = value
                            self.admin_weight.value_namespace = name_space
                            self.admin_weight.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.value:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.value:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "values" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/srlg/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "value"):
                        for c in self.value:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.Srlg.Values.Value()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.value.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "value"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.default_admin_weight.is_set or
                    self.enable.is_set or
                    (self.names is not None and self.names.has_data()) or
                    (self.values is not None and self.values.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.default_admin_weight.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    (self.names is not None and self.names.has_operation()) or
                    (self.values is not None and self.values.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "srlg" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.default_admin_weight.is_set or self.default_admin_weight.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.default_admin_weight.get_name_leafdata())
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "names"):
                    if (self.names is None):
                        self.names = MplsTe.GlobalAttributes.Srlg.Names()
                        self.names.parent = self
                        self._children_name_map["names"] = "names"
                    return self.names

                if (child_yang_name == "values"):
                    if (self.values is None):
                        self.values = MplsTe.GlobalAttributes.Srlg.Values()
                        self.values.parent = self
                        self._children_name_map["values"] = "values"
                    return self.values

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "names" or name == "values" or name == "default-admin-weight" or name == "enable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "default-admin-weight"):
                    self.default_admin_weight = value
                    self.default_admin_weight.value_namespace = name_space
                    self.default_admin_weight.value_namespace_prefix = name_space_prefix
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix


        class Queues(Entity):
            """
            Configure MPLS TE route priority
            
            .. attribute:: queue
            
            	Configure route priority queue value
            	**type**\: list of    :py:class:`Queue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.Queues.Queue>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.Queues, self).__init__()

                self.yang_name = "queues"
                self.yang_parent_name = "global-attributes"

                self.queue = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GlobalAttributes.Queues, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GlobalAttributes.Queues, self).__setattr__(name, value)


            class Queue(Entity):
                """
                Configure route priority queue value
                
                .. attribute:: role  <key>
                
                	Route Priority Tunnel Role
                	**type**\:   :py:class:`RoutePriorityRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.RoutePriorityRole>`
                
                .. attribute:: value
                
                	Route priority queue value
                	**type**\:  int
                
                	**range:** 0..12
                
                	**mandatory**\: True
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.Queues.Queue, self).__init__()

                    self.yang_name = "queue"
                    self.yang_parent_name = "queues"

                    self.role = YLeaf(YType.enumeration, "role")

                    self.value = YLeaf(YType.uint32, "value")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("role",
                                    "value") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.Queues.Queue, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.Queues.Queue, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.role.is_set or
                        self.value.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.role.yfilter != YFilter.not_set or
                        self.value.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "queue" + "[role='" + self.role.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/queues/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.role.is_set or self.role.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.role.get_name_leafdata())
                    if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.value.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "role" or name == "value"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "role"):
                        self.role = value
                        self.role.value_namespace = name_space
                        self.role.value_namespace_prefix = name_space_prefix
                    if(value_path == "value"):
                        self.value = value
                        self.value.value_namespace = name_space
                        self.value.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.queue:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.queue:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "queues" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "queue"):
                    for c in self.queue:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsTe.GlobalAttributes.Queues.Queue()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.queue.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "queue"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class Mib(Entity):
            """
            MPLS\-TE MIB properties
            
            .. attribute:: midpoint_lsp_stats_collection_disable
            
            	Disables mib midpoint LSP traffic stats collection
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.Mib, self).__init__()

                self.yang_name = "mib"
                self.yang_parent_name = "global-attributes"

                self.midpoint_lsp_stats_collection_disable = YLeaf(YType.empty, "midpoint-lsp-stats-collection-disable")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("midpoint_lsp_stats_collection_disable") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GlobalAttributes.Mib, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GlobalAttributes.Mib, self).__setattr__(name, value)

            def has_data(self):
                return self.midpoint_lsp_stats_collection_disable.is_set

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.midpoint_lsp_stats_collection_disable.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "mib" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.midpoint_lsp_stats_collection_disable.is_set or self.midpoint_lsp_stats_collection_disable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.midpoint_lsp_stats_collection_disable.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "midpoint-lsp-stats-collection-disable"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "midpoint-lsp-stats-collection-disable"):
                    self.midpoint_lsp_stats_collection_disable = value
                    self.midpoint_lsp_stats_collection_disable.value_namespace = name_space
                    self.midpoint_lsp_stats_collection_disable.value_namespace_prefix = name_space_prefix


        class AttributeSet(Entity):
            """
            Attribute AttributeSets
            
            .. attribute:: auto_backup_attributes
            
            	Auto\-backup Tunnel Attribute Table
            	**type**\:   :py:class:`AutoBackupAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes>`
            
            .. attribute:: auto_mesh_attributes
            
            	Auto\-mesh Tunnel AttributeSets Table
            	**type**\:   :py:class:`AutoMeshAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes>`
            
            .. attribute:: otn_pp_attributes
            
            	OTN Path Protection Attributes table
            	**type**\:   :py:class:`OtnPpAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes>`
            
            .. attribute:: p2mpte_attributes
            
            	P2MP\-TE Tunnel AttributeSets Table
            	**type**\:   :py:class:`P2MpteAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes>`
            
            .. attribute:: p2p_te_attributes
            
            	P2P\-TE Tunnel AttributeSets Table
            	**type**\:   :py:class:`P2PTeAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes>`
            
            .. attribute:: path_option_attributes
            
            	Path Option Attribute\-Set Table
            	**type**\:   :py:class:`PathOptionAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes>`
            
            .. attribute:: xro_attributes
            
            	XRO Tunnel Attributes table
            	**type**\:   :py:class:`XroAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.XroAttributes>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.AttributeSet, self).__init__()

                self.yang_name = "attribute-set"
                self.yang_parent_name = "global-attributes"

                self.auto_backup_attributes = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes()
                self.auto_backup_attributes.parent = self
                self._children_name_map["auto_backup_attributes"] = "auto-backup-attributes"
                self._children_yang_names.add("auto-backup-attributes")

                self.auto_mesh_attributes = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes()
                self.auto_mesh_attributes.parent = self
                self._children_name_map["auto_mesh_attributes"] = "auto-mesh-attributes"
                self._children_yang_names.add("auto-mesh-attributes")

                self.otn_pp_attributes = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes()
                self.otn_pp_attributes.parent = self
                self._children_name_map["otn_pp_attributes"] = "otn-pp-attributes"
                self._children_yang_names.add("otn-pp-attributes")

                self.p2mpte_attributes = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes()
                self.p2mpte_attributes.parent = self
                self._children_name_map["p2mpte_attributes"] = "p2mpte-attributes"
                self._children_yang_names.add("p2mpte-attributes")

                self.p2p_te_attributes = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes()
                self.p2p_te_attributes.parent = self
                self._children_name_map["p2p_te_attributes"] = "p2p-te-attributes"
                self._children_yang_names.add("p2p-te-attributes")

                self.path_option_attributes = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes()
                self.path_option_attributes.parent = self
                self._children_name_map["path_option_attributes"] = "path-option-attributes"
                self._children_yang_names.add("path-option-attributes")

                self.xro_attributes = MplsTe.GlobalAttributes.AttributeSet.XroAttributes()
                self.xro_attributes.parent = self
                self._children_name_map["xro_attributes"] = "xro-attributes"
                self._children_yang_names.add("xro-attributes")


            class PathOptionAttributes(Entity):
                """
                Path Option Attribute\-Set Table
                
                .. attribute:: path_option_attribute
                
                	Path Option Attribute
                	**type**\: list of    :py:class:`PathOptionAttribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes, self).__init__()

                    self.yang_name = "path-option-attributes"
                    self.yang_parent_name = "attribute-set"

                    self.path_option_attribute = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes, self).__setattr__(name, value)


                class PathOptionAttribute(Entity):
                    """
                    Path Option Attribute
                    
                    .. attribute:: attribute_set_name  <key>
                    
                    	Attribute Set Name
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: affinity_mask
                    
                    	Set the affinity flags and mask
                    	**type**\:   :py:class:`AffinityMask <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AffinityMask>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: att_path_option_path_selection
                    
                    	Configure path selection properties
                    	**type**\:   :py:class:`AttPathOptionPathSelection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection>`
                    
                    .. attribute:: bandwidth
                    
                    	Tunnel bandwidth requirement
                    	**type**\:   :py:class:`Bandwidth <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Bandwidth>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: bfd_reverse_path
                    
                    	Configure BFD reverse path
                    	**type**\:   :py:class:`BfdReversePath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.BfdReversePath>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: enable
                    
                    	Attribute\-set enable object that controls whether this attribute\-set is configured or not .This object must be set before other configuration supplied for this attribute\-set
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: new_style_affinity_affinity_types
                    
                    	Tunnel new style affinity attributes table
                    	**type**\:   :py:class:`NewStyleAffinityAffinityTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes>`
                    
                    .. attribute:: pce
                    
                    	Configure pce properties
                    	**type**\:   :py:class:`Pce <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute, self).__init__()

                        self.yang_name = "path-option-attribute"
                        self.yang_parent_name = "path-option-attributes"

                        self.attribute_set_name = YLeaf(YType.str, "attribute-set-name")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.affinity_mask = None
                        self._children_name_map["affinity_mask"] = "affinity-mask"
                        self._children_yang_names.add("affinity-mask")

                        self.att_path_option_path_selection = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection()
                        self.att_path_option_path_selection.parent = self
                        self._children_name_map["att_path_option_path_selection"] = "att-path-option-path-selection"
                        self._children_yang_names.add("att-path-option-path-selection")

                        self.bandwidth = None
                        self._children_name_map["bandwidth"] = "bandwidth"
                        self._children_yang_names.add("bandwidth")

                        self.bfd_reverse_path = None
                        self._children_name_map["bfd_reverse_path"] = "bfd-reverse-path"
                        self._children_yang_names.add("bfd-reverse-path")

                        self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes()
                        self.new_style_affinity_affinity_types.parent = self
                        self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                        self._children_yang_names.add("new-style-affinity-affinity-types")

                        self.pce = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce()
                        self.pce.parent = self
                        self._children_name_map["pce"] = "pce"
                        self._children_yang_names.add("pce")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("attribute_set_name",
                                        "enable") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute, self).__setattr__(name, value)


                    class BfdReversePath(Entity):
                        """
                        Configure BFD reverse path
                        
                        .. attribute:: bfd_reverse_path_type
                        
                        	BFD reverse path type
                        	**type**\:   :py:class:`BfdReversePath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.BfdReversePath>`
                        
                        .. attribute:: binding_label
                        
                        	BFD reverse path binding label
                        	**type**\:  int
                        
                        	**range:** 0..1048575
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.BfdReversePath, self).__init__()

                            self.yang_name = "bfd-reverse-path"
                            self.yang_parent_name = "path-option-attribute"
                            self.is_presence_container = True

                            self.bfd_reverse_path_type = YLeaf(YType.enumeration, "bfd-reverse-path-type")

                            self.binding_label = YLeaf(YType.uint32, "binding-label")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bfd_reverse_path_type",
                                            "binding_label") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.BfdReversePath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.BfdReversePath, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bfd_reverse_path_type.is_set or
                                self.binding_label.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bfd_reverse_path_type.yfilter != YFilter.not_set or
                                self.binding_label.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bfd-reverse-path" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bfd_reverse_path_type.is_set or self.bfd_reverse_path_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfd_reverse_path_type.get_name_leafdata())
                            if (self.binding_label.is_set or self.binding_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.binding_label.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bfd-reverse-path-type" or name == "binding-label"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bfd-reverse-path-type"):
                                self.bfd_reverse_path_type = value
                                self.bfd_reverse_path_type.value_namespace = name_space
                                self.bfd_reverse_path_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "binding-label"):
                                self.binding_label = value
                                self.binding_label.value_namespace = name_space
                                self.binding_label.value_namespace_prefix = name_space_prefix


                    class AttPathOptionPathSelection(Entity):
                        """
                        Configure path selection properties
                        
                        .. attribute:: enable
                        
                        	Enter path selection configuration
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: invalidation
                        
                        	Path invalidation configuration for this specific tunnel
                        	**type**\:   :py:class:`Invalidation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection.Invalidation>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: path_selection_cost_limit
                        
                        	Path selection cost limit configuration for this specific tunnel
                        	**type**\:  int
                        
                        	**range:** 1..4294967295
                        
                        .. attribute:: path_selection_exclude_list
                        
                        	Path selection exclude list name configuration
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection, self).__init__()

                            self.yang_name = "att-path-option-path-selection"
                            self.yang_parent_name = "path-option-attribute"

                            self.enable = YLeaf(YType.empty, "enable")

                            self.path_selection_cost_limit = YLeaf(YType.uint32, "path-selection-cost-limit")

                            self.path_selection_exclude_list = YLeaf(YType.str, "path-selection-exclude-list")

                            self.invalidation = None
                            self._children_name_map["invalidation"] = "invalidation"
                            self._children_yang_names.add("invalidation")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable",
                                            "path_selection_cost_limit",
                                            "path_selection_exclude_list") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection, self).__setattr__(name, value)


                        class Invalidation(Entity):
                            """
                            Path invalidation configuration for this
                            specific tunnel
                            
                            .. attribute:: path_invalidation_action
                            
                            	Path Invalidation Action
                            	**type**\:   :py:class:`PathInvalidationAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.PathInvalidationAction>`
                            
                            .. attribute:: path_invalidation_timeout
                            
                            	Path Invalidation Timeout
                            	**type**\:  int
                            
                            	**range:** 0..60000
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection.Invalidation, self).__init__()

                                self.yang_name = "invalidation"
                                self.yang_parent_name = "att-path-option-path-selection"
                                self.is_presence_container = True

                                self.path_invalidation_action = YLeaf(YType.enumeration, "path-invalidation-action")

                                self.path_invalidation_timeout = YLeaf(YType.uint32, "path-invalidation-timeout")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("path_invalidation_action",
                                                "path_invalidation_timeout") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection.Invalidation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection.Invalidation, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.path_invalidation_action.is_set or
                                    self.path_invalidation_timeout.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.path_invalidation_action.yfilter != YFilter.not_set or
                                    self.path_invalidation_timeout.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "invalidation" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.path_invalidation_action.is_set or self.path_invalidation_action.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_invalidation_action.get_name_leafdata())
                                if (self.path_invalidation_timeout.is_set or self.path_invalidation_timeout.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.path_invalidation_timeout.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "path-invalidation-action" or name == "path-invalidation-timeout"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "path-invalidation-action"):
                                    self.path_invalidation_action = value
                                    self.path_invalidation_action.value_namespace = name_space
                                    self.path_invalidation_action.value_namespace_prefix = name_space_prefix
                                if(value_path == "path-invalidation-timeout"):
                                    self.path_invalidation_timeout = value
                                    self.path_invalidation_timeout.value_namespace = name_space
                                    self.path_invalidation_timeout.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                self.path_selection_cost_limit.is_set or
                                self.path_selection_exclude_list.is_set or
                                (self.invalidation is not None))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.path_selection_cost_limit.yfilter != YFilter.not_set or
                                self.path_selection_exclude_list.yfilter != YFilter.not_set or
                                (self.invalidation is not None and self.invalidation.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "att-path-option-path-selection" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.path_selection_cost_limit.is_set or self.path_selection_cost_limit.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_selection_cost_limit.get_name_leafdata())
                            if (self.path_selection_exclude_list.is_set or self.path_selection_exclude_list.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_selection_exclude_list.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "invalidation"):
                                if (self.invalidation is None):
                                    self.invalidation = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection.Invalidation()
                                    self.invalidation.parent = self
                                    self._children_name_map["invalidation"] = "invalidation"
                                return self.invalidation

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "invalidation" or name == "enable" or name == "path-selection-cost-limit" or name == "path-selection-exclude-list"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-selection-cost-limit"):
                                self.path_selection_cost_limit = value
                                self.path_selection_cost_limit.value_namespace = name_space
                                self.path_selection_cost_limit.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-selection-exclude-list"):
                                self.path_selection_exclude_list = value
                                self.path_selection_exclude_list.value_namespace = name_space
                                self.path_selection_exclude_list.value_namespace_prefix = name_space_prefix


                    class Pce(Entity):
                        """
                        Configure pce properties
                        
                        .. attribute:: bidirectional
                        
                        	Bidirectional parameters
                        	**type**\:   :py:class:`Bidirectional <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.Bidirectional>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: disjoint_path
                        
                        	Disjoint path parameters
                        	**type**\:   :py:class:`DisjointPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.DisjointPath>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: enable
                        
                        	Always set to true
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce, self).__init__()

                            self.yang_name = "pce"
                            self.yang_parent_name = "path-option-attribute"

                            self.enable = YLeaf(YType.empty, "enable")

                            self.bidirectional = None
                            self._children_name_map["bidirectional"] = "bidirectional"
                            self._children_yang_names.add("bidirectional")

                            self.disjoint_path = None
                            self._children_name_map["disjoint_path"] = "disjoint-path"
                            self._children_yang_names.add("disjoint-path")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce, self).__setattr__(name, value)


                        class Bidirectional(Entity):
                            """
                            Bidirectional parameters
                            
                            .. attribute:: bd_group_id
                            
                            	Bidirectional Group ID
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            	**mandatory**\: True
                            
                            .. attribute:: bd_source_address
                            
                            	Bidirectional Source IP Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            	**mandatory**\: True
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.Bidirectional, self).__init__()

                                self.yang_name = "bidirectional"
                                self.yang_parent_name = "pce"
                                self.is_presence_container = True

                                self.bd_group_id = YLeaf(YType.uint32, "bd-group-id")

                                self.bd_source_address = YLeaf(YType.str, "bd-source-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("bd_group_id",
                                                "bd_source_address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.Bidirectional, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.Bidirectional, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.bd_group_id.is_set or
                                    self.bd_source_address.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.bd_group_id.yfilter != YFilter.not_set or
                                    self.bd_source_address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bidirectional" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.bd_group_id.is_set or self.bd_group_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_group_id.get_name_leafdata())
                                if (self.bd_source_address.is_set or self.bd_source_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_source_address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bd-group-id" or name == "bd-source-address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "bd-group-id"):
                                    self.bd_group_id = value
                                    self.bd_group_id.value_namespace = name_space
                                    self.bd_group_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "bd-source-address"):
                                    self.bd_source_address = value
                                    self.bd_source_address.value_namespace = name_space
                                    self.bd_source_address.value_namespace_prefix = name_space_prefix


                        class DisjointPath(Entity):
                            """
                            Disjoint path parameters
                            
                            .. attribute:: dp_group_id
                            
                            	Disjoint Path Group ID
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            	**mandatory**\: True
                            
                            .. attribute:: dp_source_address
                            
                            	Disjoint Path Source IP Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            	**mandatory**\: True
                            
                            .. attribute:: dp_type
                            
                            	Disjoint Path Type
                            	**type**\:  int
                            
                            	**range:** 1..3
                            
                            	**mandatory**\: True
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.DisjointPath, self).__init__()

                                self.yang_name = "disjoint-path"
                                self.yang_parent_name = "pce"
                                self.is_presence_container = True

                                self.dp_group_id = YLeaf(YType.uint32, "dp-group-id")

                                self.dp_source_address = YLeaf(YType.str, "dp-source-address")

                                self.dp_type = YLeaf(YType.uint32, "dp-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dp_group_id",
                                                "dp_source_address",
                                                "dp_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.DisjointPath, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.DisjointPath, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.dp_group_id.is_set or
                                    self.dp_source_address.is_set or
                                    self.dp_type.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dp_group_id.yfilter != YFilter.not_set or
                                    self.dp_source_address.yfilter != YFilter.not_set or
                                    self.dp_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "disjoint-path" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dp_group_id.is_set or self.dp_group_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dp_group_id.get_name_leafdata())
                                if (self.dp_source_address.is_set or self.dp_source_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dp_source_address.get_name_leafdata())
                                if (self.dp_type.is_set or self.dp_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dp_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dp-group-id" or name == "dp-source-address" or name == "dp-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dp-group-id"):
                                    self.dp_group_id = value
                                    self.dp_group_id.value_namespace = name_space
                                    self.dp_group_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "dp-source-address"):
                                    self.dp_source_address = value
                                    self.dp_source_address.value_namespace = name_space
                                    self.dp_source_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "dp-type"):
                                    self.dp_type = value
                                    self.dp_type.value_namespace = name_space
                                    self.dp_type.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                (self.bidirectional is not None) or
                                (self.disjoint_path is not None))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                (self.bidirectional is not None and self.bidirectional.has_operation()) or
                                (self.disjoint_path is not None and self.disjoint_path.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "pce" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bidirectional"):
                                if (self.bidirectional is None):
                                    self.bidirectional = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.Bidirectional()
                                    self.bidirectional.parent = self
                                    self._children_name_map["bidirectional"] = "bidirectional"
                                return self.bidirectional

                            if (child_yang_name == "disjoint-path"):
                                if (self.disjoint_path is None):
                                    self.disjoint_path = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce.DisjointPath()
                                    self.disjoint_path.parent = self
                                    self._children_name_map["disjoint_path"] = "disjoint-path"
                                return self.disjoint_path

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bidirectional" or name == "disjoint-path" or name == "enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix


                    class AffinityMask(Entity):
                        """
                        Set the affinity flags and mask
                        
                        .. attribute:: affinity
                        
                        	Affinity flags
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        .. attribute:: mask
                        
                        	Affinity mask
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AffinityMask, self).__init__()

                            self.yang_name = "affinity-mask"
                            self.yang_parent_name = "path-option-attribute"
                            self.is_presence_container = True

                            self.affinity = YLeaf(YType.str, "affinity")

                            self.mask = YLeaf(YType.str, "mask")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("affinity",
                                            "mask") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AffinityMask, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AffinityMask, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.affinity.is_set or
                                self.mask.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.affinity.yfilter != YFilter.not_set or
                                self.mask.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "affinity-mask" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.affinity.is_set or self.affinity.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.affinity.get_name_leafdata())
                            if (self.mask.is_set or self.mask.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mask.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "affinity" or name == "mask"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "affinity"):
                                self.affinity = value
                                self.affinity.value_namespace = name_space
                                self.affinity.value_namespace_prefix = name_space_prefix
                            if(value_path == "mask"):
                                self.mask = value
                                self.mask.value_namespace = name_space
                                self.mask.value_namespace_prefix = name_space_prefix


                    class Bandwidth(Entity):
                        """
                        Tunnel bandwidth requirement
                        
                        .. attribute:: bandwidth
                        
                        	The value of the bandwidth reserved by this tunnel in kbps
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**mandatory**\: True
                        
                        	**units**\: kbit/s
                        
                        .. attribute:: class_or_pool_type
                        
                        	Class type for the bandwidth allocation
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        .. attribute:: dste_type
                        
                        	DSTE\-standard flag
                        	**type**\:   :py:class:`MplsTeBandwidthDste <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeBandwidthDste>`
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Bandwidth, self).__init__()

                            self.yang_name = "bandwidth"
                            self.yang_parent_name = "path-option-attribute"
                            self.is_presence_container = True

                            self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                            self.class_or_pool_type = YLeaf(YType.uint32, "class-or-pool-type")

                            self.dste_type = YLeaf(YType.enumeration, "dste-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth",
                                            "class_or_pool_type",
                                            "dste_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Bandwidth, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Bandwidth, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bandwidth.is_set or
                                self.class_or_pool_type.is_set or
                                self.dste_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth.yfilter != YFilter.not_set or
                                self.class_or_pool_type.yfilter != YFilter.not_set or
                                self.dste_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bandwidth" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth.get_name_leafdata())
                            if (self.class_or_pool_type.is_set or self.class_or_pool_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.class_or_pool_type.get_name_leafdata())
                            if (self.dste_type.is_set or self.dste_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dste_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth" or name == "class-or-pool-type" or name == "dste-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth"):
                                self.bandwidth = value
                                self.bandwidth.value_namespace = name_space
                                self.bandwidth.value_namespace_prefix = name_space_prefix
                            if(value_path == "class-or-pool-type"):
                                self.class_or_pool_type = value
                                self.class_or_pool_type.value_namespace = name_space
                                self.class_or_pool_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "dste-type"):
                                self.dste_type = value
                                self.dste_type.value_namespace = name_space
                                self.dste_type.value_namespace_prefix = name_space_prefix


                    class NewStyleAffinityAffinityTypes(Entity):
                        """
                        Tunnel new style affinity attributes table
                        
                        .. attribute:: new_style_affinity_affinity_type
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes, self).__init__()

                            self.yang_name = "new-style-affinity-affinity-types"
                            self.yang_parent_name = "path-option-attribute"

                            self.new_style_affinity_affinity_type = YList(self)
                            self.new_style_affinity_affinity_type_affinity1 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10 = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)


                        class NewStyleAffinityAffinityType(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)

                            def has_data(self):
                                return self.affinity_type.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type" + "[affinity-type='" + self.affinity_type.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity10  <key>
                            
                            	The name of the tenth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                                self.affinity10 = YLeaf(YType.str, "affinity10")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9",
                                                "affinity10") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set or
                                    self.affinity10.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set or
                                    self.affinity10.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + "[affinity10='" + self.affinity10.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())
                                if (self.affinity10.is_set or self.affinity10.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity10.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9" or name == "affinity10"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity10"):
                                    self.affinity10 = value
                                    self.affinity10.value_namespace = name_space
                                    self.affinity10.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "new-style-affinity-affinity-types" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "new-style-affinity-affinity-type"):
                                for c in self.new_style_affinity_affinity_type:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1"):
                                for c in self.new_style_affinity_affinity_type_affinity1:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "new-style-affinity-affinity-type" or name == "new-style-affinity-affinity-type-affinity1" or name == "new-style-affinity-affinity-type-affinity1-affinity2" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.attribute_set_name.is_set or
                            self.enable.is_set or
                            (self.att_path_option_path_selection is not None and self.att_path_option_path_selection.has_data()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_data()) or
                            (self.pce is not None and self.pce.has_data()) or
                            (self.affinity_mask is not None) or
                            (self.bandwidth is not None) or
                            (self.bfd_reverse_path is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.attribute_set_name.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            (self.affinity_mask is not None and self.affinity_mask.has_operation()) or
                            (self.att_path_option_path_selection is not None and self.att_path_option_path_selection.has_operation()) or
                            (self.bandwidth is not None and self.bandwidth.has_operation()) or
                            (self.bfd_reverse_path is not None and self.bfd_reverse_path.has_operation()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_operation()) or
                            (self.pce is not None and self.pce.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "path-option-attribute" + "[attribute-set-name='" + self.attribute_set_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/path-option-attributes/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.attribute_set_name.is_set or self.attribute_set_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.attribute_set_name.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "affinity-mask"):
                            if (self.affinity_mask is None):
                                self.affinity_mask = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AffinityMask()
                                self.affinity_mask.parent = self
                                self._children_name_map["affinity_mask"] = "affinity-mask"
                            return self.affinity_mask

                        if (child_yang_name == "att-path-option-path-selection"):
                            if (self.att_path_option_path_selection is None):
                                self.att_path_option_path_selection = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.AttPathOptionPathSelection()
                                self.att_path_option_path_selection.parent = self
                                self._children_name_map["att_path_option_path_selection"] = "att-path-option-path-selection"
                            return self.att_path_option_path_selection

                        if (child_yang_name == "bandwidth"):
                            if (self.bandwidth is None):
                                self.bandwidth = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Bandwidth()
                                self.bandwidth.parent = self
                                self._children_name_map["bandwidth"] = "bandwidth"
                            return self.bandwidth

                        if (child_yang_name == "bfd-reverse-path"):
                            if (self.bfd_reverse_path is None):
                                self.bfd_reverse_path = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.BfdReversePath()
                                self.bfd_reverse_path.parent = self
                                self._children_name_map["bfd_reverse_path"] = "bfd-reverse-path"
                            return self.bfd_reverse_path

                        if (child_yang_name == "new-style-affinity-affinity-types"):
                            if (self.new_style_affinity_affinity_types is None):
                                self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.NewStyleAffinityAffinityTypes()
                                self.new_style_affinity_affinity_types.parent = self
                                self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                            return self.new_style_affinity_affinity_types

                        if (child_yang_name == "pce"):
                            if (self.pce is None):
                                self.pce = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute.Pce()
                                self.pce.parent = self
                                self._children_name_map["pce"] = "pce"
                            return self.pce

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "affinity-mask" or name == "att-path-option-path-selection" or name == "bandwidth" or name == "bfd-reverse-path" or name == "new-style-affinity-affinity-types" or name == "pce" or name == "attribute-set-name" or name == "enable"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "attribute-set-name"):
                            self.attribute_set_name = value
                            self.attribute_set_name.value_namespace = name_space
                            self.attribute_set_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.path_option_attribute:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.path_option_attribute:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "path-option-attributes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "path-option-attribute"):
                        for c in self.path_option_attribute:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes.PathOptionAttribute()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.path_option_attribute.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "path-option-attribute"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class P2MpteAttributes(Entity):
                """
                P2MP\-TE Tunnel AttributeSets Table
                
                .. attribute:: p2mpte_attribute
                
                	P2MP\-TE Tunnel Attribute
                	**type**\: list of    :py:class:`P2MpteAttribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes, self).__init__()

                    self.yang_name = "p2mpte-attributes"
                    self.yang_parent_name = "attribute-set"

                    self.p2mpte_attribute = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes, self).__setattr__(name, value)


                class P2MpteAttribute(Entity):
                    """
                    P2MP\-TE Tunnel Attribute
                    
                    .. attribute:: attribute_set_name  <key>
                    
                    	Attribute Set Name
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: affinity_mask
                    
                    	Set the affinity flags and mask
                    	**type**\:   :py:class:`AffinityMask <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.AffinityMask>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: bandwidth
                    
                    	Tunnel bandwidth requirement
                    	**type**\:   :py:class:`Bandwidth <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Bandwidth>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: enable
                    
                    	Attribute\-set enable object that controls whether this attribute\-set is configured or not .This object must be set before other configuration supplied for this attribute\-set
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: fast_reroute
                    
                    	Specify MPLS tunnel can be fast\-rerouted
                    	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.FastReroute>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: interface_bandwidth
                    
                    	The bandwidth of the interface in kbps
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: kbit/s
                    
                    .. attribute:: logging
                    
                    	Log tunnel LSP messages
                    	**type**\:   :py:class:`Logging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Logging>`
                    
                    .. attribute:: new_style_affinity_affinity_types
                    
                    	Tunnel new style affinity attributes table
                    	**type**\:   :py:class:`NewStyleAffinityAffinityTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes>`
                    
                    .. attribute:: path_selection
                    
                    	Configure path selection properties
                    	**type**\:   :py:class:`PathSelection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.PathSelection>`
                    
                    .. attribute:: priority
                    
                    	Tunnel Setup and Hold Priorities
                    	**type**\:   :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Priority>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: record_route
                    
                    	Record the route used by the tunnel
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute, self).__init__()

                        self.yang_name = "p2mpte-attribute"
                        self.yang_parent_name = "p2mpte-attributes"

                        self.attribute_set_name = YLeaf(YType.str, "attribute-set-name")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.interface_bandwidth = YLeaf(YType.uint32, "interface-bandwidth")

                        self.record_route = YLeaf(YType.empty, "record-route")

                        self.affinity_mask = None
                        self._children_name_map["affinity_mask"] = "affinity-mask"
                        self._children_yang_names.add("affinity-mask")

                        self.bandwidth = None
                        self._children_name_map["bandwidth"] = "bandwidth"
                        self._children_yang_names.add("bandwidth")

                        self.fast_reroute = None
                        self._children_name_map["fast_reroute"] = "fast-reroute"
                        self._children_yang_names.add("fast-reroute")

                        self.logging = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Logging()
                        self.logging.parent = self
                        self._children_name_map["logging"] = "logging"
                        self._children_yang_names.add("logging")

                        self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes()
                        self.new_style_affinity_affinity_types.parent = self
                        self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                        self._children_yang_names.add("new-style-affinity-affinity-types")

                        self.path_selection = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.PathSelection()
                        self.path_selection.parent = self
                        self._children_name_map["path_selection"] = "path-selection"
                        self._children_yang_names.add("path-selection")

                        self.priority = None
                        self._children_name_map["priority"] = "priority"
                        self._children_yang_names.add("priority")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("attribute_set_name",
                                        "enable",
                                        "interface_bandwidth",
                                        "record_route") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute, self).__setattr__(name, value)


                    class Priority(Entity):
                        """
                        Tunnel Setup and Hold Priorities
                        
                        .. attribute:: hold_priority
                        
                        	Hold Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        .. attribute:: setup_priority
                        
                        	Setup Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Priority, self).__init__()

                            self.yang_name = "priority"
                            self.yang_parent_name = "p2mpte-attribute"
                            self.is_presence_container = True

                            self.hold_priority = YLeaf(YType.uint32, "hold-priority")

                            self.setup_priority = YLeaf(YType.uint32, "setup-priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hold_priority",
                                            "setup_priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Priority, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Priority, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.hold_priority.is_set or
                                self.setup_priority.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hold_priority.yfilter != YFilter.not_set or
                                self.setup_priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "priority" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hold_priority.get_name_leafdata())
                            if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.setup_priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hold-priority" or name == "setup-priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hold-priority"):
                                self.hold_priority = value
                                self.hold_priority.value_namespace = name_space
                                self.hold_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "setup-priority"):
                                self.setup_priority = value
                                self.setup_priority.value_namespace = name_space
                                self.setup_priority.value_namespace_prefix = name_space_prefix


                    class AffinityMask(Entity):
                        """
                        Set the affinity flags and mask
                        
                        .. attribute:: affinity
                        
                        	Affinity flags
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        .. attribute:: mask
                        
                        	Affinity mask
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.AffinityMask, self).__init__()

                            self.yang_name = "affinity-mask"
                            self.yang_parent_name = "p2mpte-attribute"
                            self.is_presence_container = True

                            self.affinity = YLeaf(YType.str, "affinity")

                            self.mask = YLeaf(YType.str, "mask")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("affinity",
                                            "mask") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.AffinityMask, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.AffinityMask, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.affinity.is_set or
                                self.mask.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.affinity.yfilter != YFilter.not_set or
                                self.mask.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "affinity-mask" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.affinity.is_set or self.affinity.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.affinity.get_name_leafdata())
                            if (self.mask.is_set or self.mask.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mask.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "affinity" or name == "mask"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "affinity"):
                                self.affinity = value
                                self.affinity.value_namespace = name_space
                                self.affinity.value_namespace_prefix = name_space_prefix
                            if(value_path == "mask"):
                                self.mask = value
                                self.mask.value_namespace = name_space
                                self.mask.value_namespace_prefix = name_space_prefix


                    class Bandwidth(Entity):
                        """
                        Tunnel bandwidth requirement
                        
                        .. attribute:: bandwidth
                        
                        	The value of the bandwidth reserved by this tunnel in kbps
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**mandatory**\: True
                        
                        	**units**\: kbit/s
                        
                        .. attribute:: class_or_pool_type
                        
                        	Class type for the bandwidth allocation
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        .. attribute:: dste_type
                        
                        	DSTE\-standard flag
                        	**type**\:   :py:class:`MplsTeBandwidthDste <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeBandwidthDste>`
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Bandwidth, self).__init__()

                            self.yang_name = "bandwidth"
                            self.yang_parent_name = "p2mpte-attribute"
                            self.is_presence_container = True

                            self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                            self.class_or_pool_type = YLeaf(YType.uint32, "class-or-pool-type")

                            self.dste_type = YLeaf(YType.enumeration, "dste-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth",
                                            "class_or_pool_type",
                                            "dste_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Bandwidth, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Bandwidth, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bandwidth.is_set or
                                self.class_or_pool_type.is_set or
                                self.dste_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth.yfilter != YFilter.not_set or
                                self.class_or_pool_type.yfilter != YFilter.not_set or
                                self.dste_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bandwidth" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth.get_name_leafdata())
                            if (self.class_or_pool_type.is_set or self.class_or_pool_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.class_or_pool_type.get_name_leafdata())
                            if (self.dste_type.is_set or self.dste_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dste_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth" or name == "class-or-pool-type" or name == "dste-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth"):
                                self.bandwidth = value
                                self.bandwidth.value_namespace = name_space
                                self.bandwidth.value_namespace_prefix = name_space_prefix
                            if(value_path == "class-or-pool-type"):
                                self.class_or_pool_type = value
                                self.class_or_pool_type.value_namespace = name_space
                                self.class_or_pool_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "dste-type"):
                                self.dste_type = value
                                self.dste_type.value_namespace = name_space
                                self.dste_type.value_namespace_prefix = name_space_prefix


                    class PathSelection(Entity):
                        """
                        Configure path selection properties
                        
                        .. attribute:: enable
                        
                        	Enable path selection
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.PathSelection, self).__init__()

                            self.yang_name = "path-selection"
                            self.yang_parent_name = "p2mpte-attribute"

                            self.enable = YLeaf(YType.empty, "enable")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.PathSelection, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.PathSelection, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enable.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-selection" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix


                    class NewStyleAffinityAffinityTypes(Entity):
                        """
                        Tunnel new style affinity attributes table
                        
                        .. attribute:: new_style_affinity_affinity_type
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes, self).__init__()

                            self.yang_name = "new-style-affinity-affinity-types"
                            self.yang_parent_name = "p2mpte-attribute"

                            self.new_style_affinity_affinity_type = YList(self)
                            self.new_style_affinity_affinity_type_affinity1 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10 = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)


                        class NewStyleAffinityAffinityType(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)

                            def has_data(self):
                                return self.affinity_type.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type" + "[affinity-type='" + self.affinity_type.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity10  <key>
                            
                            	The name of the tenth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                                self.affinity10 = YLeaf(YType.str, "affinity10")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9",
                                                "affinity10") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set or
                                    self.affinity10.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set or
                                    self.affinity10.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + "[affinity10='" + self.affinity10.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())
                                if (self.affinity10.is_set or self.affinity10.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity10.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9" or name == "affinity10"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity10"):
                                    self.affinity10 = value
                                    self.affinity10.value_namespace = name_space
                                    self.affinity10.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "new-style-affinity-affinity-types" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "new-style-affinity-affinity-type"):
                                for c in self.new_style_affinity_affinity_type:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1"):
                                for c in self.new_style_affinity_affinity_type_affinity1:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "new-style-affinity-affinity-type" or name == "new-style-affinity-affinity-type-affinity1" or name == "new-style-affinity-affinity-type-affinity1-affinity2" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class FastReroute(Entity):
                        """
                        Specify MPLS tunnel can be fast\-rerouted
                        
                        .. attribute:: bandwidth_protection
                        
                        	Bandwidth Protection
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        .. attribute:: node_protection
                        
                        	Node Protection
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.FastReroute, self).__init__()

                            self.yang_name = "fast-reroute"
                            self.yang_parent_name = "p2mpte-attribute"
                            self.is_presence_container = True

                            self.bandwidth_protection = YLeaf(YType.uint32, "bandwidth-protection")

                            self.node_protection = YLeaf(YType.uint32, "node-protection")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth_protection",
                                            "node_protection") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.FastReroute, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.FastReroute, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bandwidth_protection.is_set or
                                self.node_protection.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth_protection.yfilter != YFilter.not_set or
                                self.node_protection.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "fast-reroute" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth_protection.is_set or self.bandwidth_protection.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth_protection.get_name_leafdata())
                            if (self.node_protection.is_set or self.node_protection.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.node_protection.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth-protection" or name == "node-protection"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth-protection"):
                                self.bandwidth_protection = value
                                self.bandwidth_protection.value_namespace = name_space
                                self.bandwidth_protection.value_namespace_prefix = name_space_prefix
                            if(value_path == "node-protection"):
                                self.node_protection = value
                                self.node_protection.value_namespace = name_space
                                self.node_protection.value_namespace_prefix = name_space_prefix


                    class Logging(Entity):
                        """
                        Log tunnel LSP messages
                        
                        .. attribute:: all
                        
                        	Log all events for a tunnel
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: bandwidth_change_message
                        
                        	Log tunnel bandwidth change messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: insufficient_bw_message
                        
                        	Log tunnel messages for insufficient bandwidth
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: pcalc_failure_message
                        
                        	Enable logging for path\-calculation failures
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimize_attempts_message
                        
                        	Log tunnel reoptimization attempts messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimized_message
                        
                        	Log tunnel reoptimized messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reroute_messsage
                        
                        	Log tunnel rereoute messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: state_message
                        
                        	Log tunnel state messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: sub_lsp_state_message
                        
                        	Log all tunnel sub\-LSP state messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Logging, self).__init__()

                            self.yang_name = "logging"
                            self.yang_parent_name = "p2mpte-attribute"

                            self.all = YLeaf(YType.empty, "all")

                            self.bandwidth_change_message = YLeaf(YType.empty, "bandwidth-change-message")

                            self.insufficient_bw_message = YLeaf(YType.empty, "insufficient-bw-message")

                            self.pcalc_failure_message = YLeaf(YType.empty, "pcalc-failure-message")

                            self.reoptimize_attempts_message = YLeaf(YType.empty, "reoptimize-attempts-message")

                            self.reoptimized_message = YLeaf(YType.empty, "reoptimized-message")

                            self.reroute_messsage = YLeaf(YType.empty, "reroute-messsage")

                            self.state_message = YLeaf(YType.empty, "state-message")

                            self.sub_lsp_state_message = YLeaf(YType.empty, "sub-lsp-state-message")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("all",
                                            "bandwidth_change_message",
                                            "insufficient_bw_message",
                                            "pcalc_failure_message",
                                            "reoptimize_attempts_message",
                                            "reoptimized_message",
                                            "reroute_messsage",
                                            "state_message",
                                            "sub_lsp_state_message") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Logging, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Logging, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.all.is_set or
                                self.bandwidth_change_message.is_set or
                                self.insufficient_bw_message.is_set or
                                self.pcalc_failure_message.is_set or
                                self.reoptimize_attempts_message.is_set or
                                self.reoptimized_message.is_set or
                                self.reroute_messsage.is_set or
                                self.state_message.is_set or
                                self.sub_lsp_state_message.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.all.yfilter != YFilter.not_set or
                                self.bandwidth_change_message.yfilter != YFilter.not_set or
                                self.insufficient_bw_message.yfilter != YFilter.not_set or
                                self.pcalc_failure_message.yfilter != YFilter.not_set or
                                self.reoptimize_attempts_message.yfilter != YFilter.not_set or
                                self.reoptimized_message.yfilter != YFilter.not_set or
                                self.reroute_messsage.yfilter != YFilter.not_set or
                                self.state_message.yfilter != YFilter.not_set or
                                self.sub_lsp_state_message.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "logging" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.all.is_set or self.all.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.all.get_name_leafdata())
                            if (self.bandwidth_change_message.is_set or self.bandwidth_change_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth_change_message.get_name_leafdata())
                            if (self.insufficient_bw_message.is_set or self.insufficient_bw_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.insufficient_bw_message.get_name_leafdata())
                            if (self.pcalc_failure_message.is_set or self.pcalc_failure_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pcalc_failure_message.get_name_leafdata())
                            if (self.reoptimize_attempts_message.is_set or self.reoptimize_attempts_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimize_attempts_message.get_name_leafdata())
                            if (self.reoptimized_message.is_set or self.reoptimized_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimized_message.get_name_leafdata())
                            if (self.reroute_messsage.is_set or self.reroute_messsage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reroute_messsage.get_name_leafdata())
                            if (self.state_message.is_set or self.state_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.state_message.get_name_leafdata())
                            if (self.sub_lsp_state_message.is_set or self.sub_lsp_state_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.sub_lsp_state_message.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "all" or name == "bandwidth-change-message" or name == "insufficient-bw-message" or name == "pcalc-failure-message" or name == "reoptimize-attempts-message" or name == "reoptimized-message" or name == "reroute-messsage" or name == "state-message" or name == "sub-lsp-state-message"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "all"):
                                self.all = value
                                self.all.value_namespace = name_space
                                self.all.value_namespace_prefix = name_space_prefix
                            if(value_path == "bandwidth-change-message"):
                                self.bandwidth_change_message = value
                                self.bandwidth_change_message.value_namespace = name_space
                                self.bandwidth_change_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "insufficient-bw-message"):
                                self.insufficient_bw_message = value
                                self.insufficient_bw_message.value_namespace = name_space
                                self.insufficient_bw_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "pcalc-failure-message"):
                                self.pcalc_failure_message = value
                                self.pcalc_failure_message.value_namespace = name_space
                                self.pcalc_failure_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimize-attempts-message"):
                                self.reoptimize_attempts_message = value
                                self.reoptimize_attempts_message.value_namespace = name_space
                                self.reoptimize_attempts_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimized-message"):
                                self.reoptimized_message = value
                                self.reoptimized_message.value_namespace = name_space
                                self.reoptimized_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reroute-messsage"):
                                self.reroute_messsage = value
                                self.reroute_messsage.value_namespace = name_space
                                self.reroute_messsage.value_namespace_prefix = name_space_prefix
                            if(value_path == "state-message"):
                                self.state_message = value
                                self.state_message.value_namespace = name_space
                                self.state_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "sub-lsp-state-message"):
                                self.sub_lsp_state_message = value
                                self.sub_lsp_state_message.value_namespace = name_space
                                self.sub_lsp_state_message.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.attribute_set_name.is_set or
                            self.enable.is_set or
                            self.interface_bandwidth.is_set or
                            self.record_route.is_set or
                            (self.logging is not None and self.logging.has_data()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_data()) or
                            (self.path_selection is not None and self.path_selection.has_data()) or
                            (self.affinity_mask is not None) or
                            (self.bandwidth is not None) or
                            (self.fast_reroute is not None) or
                            (self.priority is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.attribute_set_name.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.interface_bandwidth.yfilter != YFilter.not_set or
                            self.record_route.yfilter != YFilter.not_set or
                            (self.affinity_mask is not None and self.affinity_mask.has_operation()) or
                            (self.bandwidth is not None and self.bandwidth.has_operation()) or
                            (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                            (self.logging is not None and self.logging.has_operation()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_operation()) or
                            (self.path_selection is not None and self.path_selection.has_operation()) or
                            (self.priority is not None and self.priority.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "p2mpte-attribute" + "[attribute-set-name='" + self.attribute_set_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/p2mpte-attributes/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.attribute_set_name.is_set or self.attribute_set_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.attribute_set_name.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.interface_bandwidth.is_set or self.interface_bandwidth.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_bandwidth.get_name_leafdata())
                        if (self.record_route.is_set or self.record_route.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.record_route.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "affinity-mask"):
                            if (self.affinity_mask is None):
                                self.affinity_mask = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.AffinityMask()
                                self.affinity_mask.parent = self
                                self._children_name_map["affinity_mask"] = "affinity-mask"
                            return self.affinity_mask

                        if (child_yang_name == "bandwidth"):
                            if (self.bandwidth is None):
                                self.bandwidth = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Bandwidth()
                                self.bandwidth.parent = self
                                self._children_name_map["bandwidth"] = "bandwidth"
                            return self.bandwidth

                        if (child_yang_name == "fast-reroute"):
                            if (self.fast_reroute is None):
                                self.fast_reroute = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.FastReroute()
                                self.fast_reroute.parent = self
                                self._children_name_map["fast_reroute"] = "fast-reroute"
                            return self.fast_reroute

                        if (child_yang_name == "logging"):
                            if (self.logging is None):
                                self.logging = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Logging()
                                self.logging.parent = self
                                self._children_name_map["logging"] = "logging"
                            return self.logging

                        if (child_yang_name == "new-style-affinity-affinity-types"):
                            if (self.new_style_affinity_affinity_types is None):
                                self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.NewStyleAffinityAffinityTypes()
                                self.new_style_affinity_affinity_types.parent = self
                                self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                            return self.new_style_affinity_affinity_types

                        if (child_yang_name == "path-selection"):
                            if (self.path_selection is None):
                                self.path_selection = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.PathSelection()
                                self.path_selection.parent = self
                                self._children_name_map["path_selection"] = "path-selection"
                            return self.path_selection

                        if (child_yang_name == "priority"):
                            if (self.priority is None):
                                self.priority = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute.Priority()
                                self.priority.parent = self
                                self._children_name_map["priority"] = "priority"
                            return self.priority

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "affinity-mask" or name == "bandwidth" or name == "fast-reroute" or name == "logging" or name == "new-style-affinity-affinity-types" or name == "path-selection" or name == "priority" or name == "attribute-set-name" or name == "enable" or name == "interface-bandwidth" or name == "record-route"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "attribute-set-name"):
                            self.attribute_set_name = value
                            self.attribute_set_name.value_namespace = name_space
                            self.attribute_set_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-bandwidth"):
                            self.interface_bandwidth = value
                            self.interface_bandwidth.value_namespace = name_space
                            self.interface_bandwidth.value_namespace_prefix = name_space_prefix
                        if(value_path == "record-route"):
                            self.record_route = value
                            self.record_route.value_namespace = name_space
                            self.record_route.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.p2mpte_attribute:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.p2mpte_attribute:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "p2mpte-attributes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "p2mpte-attribute"):
                        for c in self.p2mpte_attribute:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes.P2MpteAttribute()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.p2mpte_attribute.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "p2mpte-attribute"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class P2PTeAttributes(Entity):
                """
                P2P\-TE Tunnel AttributeSets Table
                
                .. attribute:: p2p_te_attribute
                
                	P2P\-TE Tunnel Attribute
                	**type**\: list of    :py:class:`P2PTeAttribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes, self).__init__()

                    self.yang_name = "p2p-te-attributes"
                    self.yang_parent_name = "attribute-set"

                    self.p2p_te_attribute = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes, self).__setattr__(name, value)


                class P2PTeAttribute(Entity):
                    """
                    P2P\-TE Tunnel Attribute
                    
                    .. attribute:: attribute_set_name  <key>
                    
                    	Attribute Set Name
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: affinity_mask
                    
                    	Set the affinity flags and mask
                    	**type**\:   :py:class:`AffinityMask <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.AffinityMask>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: enable
                    
                    	Attribute\-set enable object that controls whether this attribute\-set is configured or not .This object must be set before other configuration supplied for this attribute\-set
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: logging
                    
                    	Log tunnel LSP messages
                    	**type**\:   :py:class:`Logging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Logging>`
                    
                    .. attribute:: new_style_affinity_affinity_types
                    
                    	Tunnel new style affinity attributes table
                    	**type**\:   :py:class:`NewStyleAffinityAffinityTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes>`
                    
                    .. attribute:: path_selection
                    
                    	Configure path selection properties
                    	**type**\:   :py:class:`PathSelection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection>`
                    
                    .. attribute:: pce
                    
                    	Configure pce properties
                    	**type**\:   :py:class:`Pce <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute, self).__init__()

                        self.yang_name = "p2p-te-attribute"
                        self.yang_parent_name = "p2p-te-attributes"

                        self.attribute_set_name = YLeaf(YType.str, "attribute-set-name")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.affinity_mask = None
                        self._children_name_map["affinity_mask"] = "affinity-mask"
                        self._children_yang_names.add("affinity-mask")

                        self.logging = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Logging()
                        self.logging.parent = self
                        self._children_name_map["logging"] = "logging"
                        self._children_yang_names.add("logging")

                        self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes()
                        self.new_style_affinity_affinity_types.parent = self
                        self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                        self._children_yang_names.add("new-style-affinity-affinity-types")

                        self.path_selection = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection()
                        self.path_selection.parent = self
                        self._children_name_map["path_selection"] = "path-selection"
                        self._children_yang_names.add("path-selection")

                        self.pce = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce()
                        self.pce.parent = self
                        self._children_name_map["pce"] = "pce"
                        self._children_yang_names.add("pce")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("attribute_set_name",
                                        "enable") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute, self).__setattr__(name, value)


                    class PathSelection(Entity):
                        """
                        Configure path selection properties
                        
                        .. attribute:: enable
                        
                        	Enter path selection configuration
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: invalidation
                        
                        	Path selection invalidation configuration
                        	**type**\:   :py:class:`Invalidation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.Invalidation>`
                        
                        .. attribute:: path_selection_metric
                        
                        	Path selection metric to use in path calculation
                        	**type**\:   :py:class:`MplsTePathSelectionMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionMetric>`
                        
                        .. attribute:: path_selection_segment_routing_adjacency_protection
                        
                        	Segment routing adjacency protection type to use in path calculation
                        	**type**\:   :py:class:`MplsTePathSelectionSegmentRoutingAdjacencyProtection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionSegmentRoutingAdjacencyProtection>`
                        
                        .. attribute:: segment_routing_prepend
                        
                        	Path selection segment routing prepend configuration
                        	**type**\:   :py:class:`SegmentRoutingPrepend <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection, self).__init__()

                            self.yang_name = "path-selection"
                            self.yang_parent_name = "p2p-te-attribute"

                            self.enable = YLeaf(YType.empty, "enable")

                            self.path_selection_metric = YLeaf(YType.enumeration, "path-selection-metric")

                            self.path_selection_segment_routing_adjacency_protection = YLeaf(YType.enumeration, "path-selection-segment-routing-adjacency-protection")

                            self.invalidation = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.Invalidation()
                            self.invalidation.parent = self
                            self._children_name_map["invalidation"] = "invalidation"
                            self._children_yang_names.add("invalidation")

                            self.segment_routing_prepend = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend()
                            self.segment_routing_prepend.parent = self
                            self._children_name_map["segment_routing_prepend"] = "segment-routing-prepend"
                            self._children_yang_names.add("segment-routing-prepend")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable",
                                            "path_selection_metric",
                                            "path_selection_segment_routing_adjacency_protection") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection, self).__setattr__(name, value)


                        class SegmentRoutingPrepend(Entity):
                            """
                            Path selection segment routing prepend
                            configuration
                            
                            .. attribute:: enable
                            
                            	Enter path selection segment routing prepend submode
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: indexes
                            
                            	Segment routing prepend index table
                            	**type**\:   :py:class:`Indexes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend, self).__init__()

                                self.yang_name = "segment-routing-prepend"
                                self.yang_parent_name = "path-selection"

                                self.enable = YLeaf(YType.empty, "enable")

                                self.indexes = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes()
                                self.indexes.parent = self
                                self._children_name_map["indexes"] = "indexes"
                                self._children_yang_names.add("indexes")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend, self).__setattr__(name, value)


                            class Indexes(Entity):
                                """
                                Segment routing prepend index table
                                
                                .. attribute:: index
                                
                                	Prepend index information
                                	**type**\: list of    :py:class:`Index <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes.Index>`
                                
                                

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes, self).__init__()

                                    self.yang_name = "indexes"
                                    self.yang_parent_name = "segment-routing-prepend"

                                    self.index = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes, self).__setattr__(name, value)


                                class Index(Entity):
                                    """
                                    Prepend index information
                                    
                                    .. attribute:: index_number  <key>
                                    
                                    	Index number
                                    	**type**\:  int
                                    
                                    	**range:** 1..10
                                    
                                    .. attribute:: mpls_label
                                    
                                    	MPLS Label
                                    	**type**\:  int
                                    
                                    	**range:** \-2147483648..2147483647
                                    
                                    	**default value**\: 1048577
                                    
                                    .. attribute:: prepend_type
                                    
                                    	Prepend type
                                    	**type**\:   :py:class:`SrPrepend <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.SrPrepend>`
                                    
                                    	**default value**\: none-type
                                    
                                    

                                    """

                                    _prefix = 'mpls-te-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes.Index, self).__init__()

                                        self.yang_name = "index"
                                        self.yang_parent_name = "indexes"

                                        self.index_number = YLeaf(YType.uint32, "index-number")

                                        self.mpls_label = YLeaf(YType.int32, "mpls-label")

                                        self.prepend_type = YLeaf(YType.enumeration, "prepend-type")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("index_number",
                                                        "mpls_label",
                                                        "prepend_type") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes.Index, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes.Index, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.index_number.is_set or
                                            self.mpls_label.is_set or
                                            self.prepend_type.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.index_number.yfilter != YFilter.not_set or
                                            self.mpls_label.yfilter != YFilter.not_set or
                                            self.prepend_type.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "index" + "[index-number='" + self.index_number.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.index_number.is_set or self.index_number.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.index_number.get_name_leafdata())
                                        if (self.mpls_label.is_set or self.mpls_label.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.mpls_label.get_name_leafdata())
                                        if (self.prepend_type.is_set or self.prepend_type.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.prepend_type.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "index-number" or name == "mpls-label" or name == "prepend-type"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "index-number"):
                                            self.index_number = value
                                            self.index_number.value_namespace = name_space
                                            self.index_number.value_namespace_prefix = name_space_prefix
                                        if(value_path == "mpls-label"):
                                            self.mpls_label = value
                                            self.mpls_label.value_namespace = name_space
                                            self.mpls_label.value_namespace_prefix = name_space_prefix
                                        if(value_path == "prepend-type"):
                                            self.prepend_type = value
                                            self.prepend_type.value_namespace = name_space
                                            self.prepend_type.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.index:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.index:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "indexes" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "index"):
                                        for c in self.index:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes.Index()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.index.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "index"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (
                                    self.enable.is_set or
                                    (self.indexes is not None and self.indexes.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    (self.indexes is not None and self.indexes.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "segment-routing-prepend" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "indexes"):
                                    if (self.indexes is None):
                                        self.indexes = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend.Indexes()
                                        self.indexes.parent = self
                                        self._children_name_map["indexes"] = "indexes"
                                    return self.indexes

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "indexes" or name == "enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix


                        class Invalidation(Entity):
                            """
                            Path selection invalidation configuration
                            
                            .. attribute:: invalidation_timer
                            
                            	Path selection invalidation timer value (milliseconds)
                            	**type**\:  int
                            
                            	**range:** 0..60000
                            
                            	**units**\: millisecond
                            
                            .. attribute:: invalidation_timer_expire_type
                            
                            	Path selection invalidation timer expire type
                            	**type**\:   :py:class:`MplsTePathSelectionInvalidationTimerExpire <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionInvalidationTimerExpire>`
                            
                            	**default value**\: tunnel-action-tear
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.Invalidation, self).__init__()

                                self.yang_name = "invalidation"
                                self.yang_parent_name = "path-selection"

                                self.invalidation_timer = YLeaf(YType.uint32, "invalidation-timer")

                                self.invalidation_timer_expire_type = YLeaf(YType.enumeration, "invalidation-timer-expire-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("invalidation_timer",
                                                "invalidation_timer_expire_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.Invalidation, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.Invalidation, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.invalidation_timer.is_set or
                                    self.invalidation_timer_expire_type.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.invalidation_timer.yfilter != YFilter.not_set or
                                    self.invalidation_timer_expire_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "invalidation" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.invalidation_timer.is_set or self.invalidation_timer.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.invalidation_timer.get_name_leafdata())
                                if (self.invalidation_timer_expire_type.is_set or self.invalidation_timer_expire_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.invalidation_timer_expire_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "invalidation-timer" or name == "invalidation-timer-expire-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "invalidation-timer"):
                                    self.invalidation_timer = value
                                    self.invalidation_timer.value_namespace = name_space
                                    self.invalidation_timer.value_namespace_prefix = name_space_prefix
                                if(value_path == "invalidation-timer-expire-type"):
                                    self.invalidation_timer_expire_type = value
                                    self.invalidation_timer_expire_type.value_namespace = name_space
                                    self.invalidation_timer_expire_type.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                self.path_selection_metric.is_set or
                                self.path_selection_segment_routing_adjacency_protection.is_set or
                                (self.invalidation is not None and self.invalidation.has_data()) or
                                (self.segment_routing_prepend is not None and self.segment_routing_prepend.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.path_selection_metric.yfilter != YFilter.not_set or
                                self.path_selection_segment_routing_adjacency_protection.yfilter != YFilter.not_set or
                                (self.invalidation is not None and self.invalidation.has_operation()) or
                                (self.segment_routing_prepend is not None and self.segment_routing_prepend.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-selection" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.path_selection_metric.is_set or self.path_selection_metric.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_selection_metric.get_name_leafdata())
                            if (self.path_selection_segment_routing_adjacency_protection.is_set or self.path_selection_segment_routing_adjacency_protection.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_selection_segment_routing_adjacency_protection.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "invalidation"):
                                if (self.invalidation is None):
                                    self.invalidation = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.Invalidation()
                                    self.invalidation.parent = self
                                    self._children_name_map["invalidation"] = "invalidation"
                                return self.invalidation

                            if (child_yang_name == "segment-routing-prepend"):
                                if (self.segment_routing_prepend is None):
                                    self.segment_routing_prepend = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection.SegmentRoutingPrepend()
                                    self.segment_routing_prepend.parent = self
                                    self._children_name_map["segment_routing_prepend"] = "segment-routing-prepend"
                                return self.segment_routing_prepend

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "invalidation" or name == "segment-routing-prepend" or name == "enable" or name == "path-selection-metric" or name == "path-selection-segment-routing-adjacency-protection"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-selection-metric"):
                                self.path_selection_metric = value
                                self.path_selection_metric.value_namespace = name_space
                                self.path_selection_metric.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-selection-segment-routing-adjacency-protection"):
                                self.path_selection_segment_routing_adjacency_protection = value
                                self.path_selection_segment_routing_adjacency_protection.value_namespace = name_space
                                self.path_selection_segment_routing_adjacency_protection.value_namespace_prefix = name_space_prefix


                    class Pce(Entity):
                        """
                        Configure pce properties
                        
                        .. attribute:: bidirectional
                        
                        	Bidirectional parameters
                        	**type**\:   :py:class:`Bidirectional <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.Bidirectional>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: disjoint_path
                        
                        	Disjoint path parameters
                        	**type**\:   :py:class:`DisjointPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.DisjointPath>`
                        
                        	**presence node**\: True
                        
                        .. attribute:: enable
                        
                        	Always set to true
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce, self).__init__()

                            self.yang_name = "pce"
                            self.yang_parent_name = "p2p-te-attribute"

                            self.enable = YLeaf(YType.empty, "enable")

                            self.bidirectional = None
                            self._children_name_map["bidirectional"] = "bidirectional"
                            self._children_yang_names.add("bidirectional")

                            self.disjoint_path = None
                            self._children_name_map["disjoint_path"] = "disjoint-path"
                            self._children_yang_names.add("disjoint-path")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce, self).__setattr__(name, value)


                        class Bidirectional(Entity):
                            """
                            Bidirectional parameters
                            
                            .. attribute:: bd_group_id
                            
                            	Bidirectional Group ID
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            	**mandatory**\: True
                            
                            .. attribute:: bd_source_address
                            
                            	Bidirectional Source IP Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            	**mandatory**\: True
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.Bidirectional, self).__init__()

                                self.yang_name = "bidirectional"
                                self.yang_parent_name = "pce"
                                self.is_presence_container = True

                                self.bd_group_id = YLeaf(YType.uint32, "bd-group-id")

                                self.bd_source_address = YLeaf(YType.str, "bd-source-address")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("bd_group_id",
                                                "bd_source_address") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.Bidirectional, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.Bidirectional, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.bd_group_id.is_set or
                                    self.bd_source_address.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.bd_group_id.yfilter != YFilter.not_set or
                                    self.bd_source_address.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "bidirectional" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.bd_group_id.is_set or self.bd_group_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_group_id.get_name_leafdata())
                                if (self.bd_source_address.is_set or self.bd_source_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.bd_source_address.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "bd-group-id" or name == "bd-source-address"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "bd-group-id"):
                                    self.bd_group_id = value
                                    self.bd_group_id.value_namespace = name_space
                                    self.bd_group_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "bd-source-address"):
                                    self.bd_source_address = value
                                    self.bd_source_address.value_namespace = name_space
                                    self.bd_source_address.value_namespace_prefix = name_space_prefix


                        class DisjointPath(Entity):
                            """
                            Disjoint path parameters
                            
                            .. attribute:: dp_group_id
                            
                            	Disjoint Path Group ID
                            	**type**\:  int
                            
                            	**range:** 1..4294967295
                            
                            	**mandatory**\: True
                            
                            .. attribute:: dp_source_address
                            
                            	Disjoint Path Source IP Address
                            	**type**\:  str
                            
                            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                            
                            	**mandatory**\: True
                            
                            .. attribute:: dp_type
                            
                            	Disjoint Path Type
                            	**type**\:  int
                            
                            	**range:** 1..3
                            
                            	**mandatory**\: True
                            
                            

                            This class is a :ref:`presence class<presence-class>`

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.DisjointPath, self).__init__()

                                self.yang_name = "disjoint-path"
                                self.yang_parent_name = "pce"
                                self.is_presence_container = True

                                self.dp_group_id = YLeaf(YType.uint32, "dp-group-id")

                                self.dp_source_address = YLeaf(YType.str, "dp-source-address")

                                self.dp_type = YLeaf(YType.uint32, "dp-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("dp_group_id",
                                                "dp_source_address",
                                                "dp_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.DisjointPath, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.DisjointPath, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.dp_group_id.is_set or
                                    self.dp_source_address.is_set or
                                    self.dp_type.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.dp_group_id.yfilter != YFilter.not_set or
                                    self.dp_source_address.yfilter != YFilter.not_set or
                                    self.dp_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "disjoint-path" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.dp_group_id.is_set or self.dp_group_id.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dp_group_id.get_name_leafdata())
                                if (self.dp_source_address.is_set or self.dp_source_address.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dp_source_address.get_name_leafdata())
                                if (self.dp_type.is_set or self.dp_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.dp_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "dp-group-id" or name == "dp-source-address" or name == "dp-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "dp-group-id"):
                                    self.dp_group_id = value
                                    self.dp_group_id.value_namespace = name_space
                                    self.dp_group_id.value_namespace_prefix = name_space_prefix
                                if(value_path == "dp-source-address"):
                                    self.dp_source_address = value
                                    self.dp_source_address.value_namespace = name_space
                                    self.dp_source_address.value_namespace_prefix = name_space_prefix
                                if(value_path == "dp-type"):
                                    self.dp_type = value
                                    self.dp_type.value_namespace = name_space
                                    self.dp_type.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.enable.is_set or
                                (self.bidirectional is not None) or
                                (self.disjoint_path is not None))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                (self.bidirectional is not None and self.bidirectional.has_operation()) or
                                (self.disjoint_path is not None and self.disjoint_path.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "pce" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "bidirectional"):
                                if (self.bidirectional is None):
                                    self.bidirectional = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.Bidirectional()
                                    self.bidirectional.parent = self
                                    self._children_name_map["bidirectional"] = "bidirectional"
                                return self.bidirectional

                            if (child_yang_name == "disjoint-path"):
                                if (self.disjoint_path is None):
                                    self.disjoint_path = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce.DisjointPath()
                                    self.disjoint_path.parent = self
                                    self._children_name_map["disjoint_path"] = "disjoint-path"
                                return self.disjoint_path

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bidirectional" or name == "disjoint-path" or name == "enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix


                    class AffinityMask(Entity):
                        """
                        Set the affinity flags and mask
                        
                        .. attribute:: affinity
                        
                        	Affinity flags
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        .. attribute:: mask
                        
                        	Affinity mask
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.AffinityMask, self).__init__()

                            self.yang_name = "affinity-mask"
                            self.yang_parent_name = "p2p-te-attribute"
                            self.is_presence_container = True

                            self.affinity = YLeaf(YType.str, "affinity")

                            self.mask = YLeaf(YType.str, "mask")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("affinity",
                                            "mask") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.AffinityMask, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.AffinityMask, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.affinity.is_set or
                                self.mask.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.affinity.yfilter != YFilter.not_set or
                                self.mask.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "affinity-mask" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.affinity.is_set or self.affinity.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.affinity.get_name_leafdata())
                            if (self.mask.is_set or self.mask.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mask.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "affinity" or name == "mask"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "affinity"):
                                self.affinity = value
                                self.affinity.value_namespace = name_space
                                self.affinity.value_namespace_prefix = name_space_prefix
                            if(value_path == "mask"):
                                self.mask = value
                                self.mask.value_namespace = name_space
                                self.mask.value_namespace_prefix = name_space_prefix


                    class Logging(Entity):
                        """
                        Log tunnel LSP messages
                        
                        .. attribute:: all
                        
                        	Log all events for a tunnel
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: bandwidth_change_message
                        
                        	Log tunnel messages for bandwidth change
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: bfd_state_message
                        
                        	Enable BFD session state change alarm
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: insufficient_bw_message
                        
                        	Log tunnel messages for insufficient bandwidth
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: lsp_switch_over_change_message
                        
                        	Log tunnel messages for bandwidth change
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: pcalc_failure_message
                        
                        	Enable logging for path\-calculation failures
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: record_route_messsage
                        
                        	Log tunnel record\-route messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimize_attempts_message
                        
                        	Log tunnel reoptimization attempts messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimized_message
                        
                        	Log tunnel reoptimized messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reroute_messsage
                        
                        	Log tunnel rereoute messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: state_message
                        
                        	Log tunnel state messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Logging, self).__init__()

                            self.yang_name = "logging"
                            self.yang_parent_name = "p2p-te-attribute"

                            self.all = YLeaf(YType.empty, "all")

                            self.bandwidth_change_message = YLeaf(YType.empty, "bandwidth-change-message")

                            self.bfd_state_message = YLeaf(YType.empty, "bfd-state-message")

                            self.insufficient_bw_message = YLeaf(YType.empty, "insufficient-bw-message")

                            self.lsp_switch_over_change_message = YLeaf(YType.empty, "lsp-switch-over-change-message")

                            self.pcalc_failure_message = YLeaf(YType.empty, "pcalc-failure-message")

                            self.record_route_messsage = YLeaf(YType.empty, "record-route-messsage")

                            self.reoptimize_attempts_message = YLeaf(YType.empty, "reoptimize-attempts-message")

                            self.reoptimized_message = YLeaf(YType.empty, "reoptimized-message")

                            self.reroute_messsage = YLeaf(YType.empty, "reroute-messsage")

                            self.state_message = YLeaf(YType.empty, "state-message")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("all",
                                            "bandwidth_change_message",
                                            "bfd_state_message",
                                            "insufficient_bw_message",
                                            "lsp_switch_over_change_message",
                                            "pcalc_failure_message",
                                            "record_route_messsage",
                                            "reoptimize_attempts_message",
                                            "reoptimized_message",
                                            "reroute_messsage",
                                            "state_message") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Logging, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Logging, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.all.is_set or
                                self.bandwidth_change_message.is_set or
                                self.bfd_state_message.is_set or
                                self.insufficient_bw_message.is_set or
                                self.lsp_switch_over_change_message.is_set or
                                self.pcalc_failure_message.is_set or
                                self.record_route_messsage.is_set or
                                self.reoptimize_attempts_message.is_set or
                                self.reoptimized_message.is_set or
                                self.reroute_messsage.is_set or
                                self.state_message.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.all.yfilter != YFilter.not_set or
                                self.bandwidth_change_message.yfilter != YFilter.not_set or
                                self.bfd_state_message.yfilter != YFilter.not_set or
                                self.insufficient_bw_message.yfilter != YFilter.not_set or
                                self.lsp_switch_over_change_message.yfilter != YFilter.not_set or
                                self.pcalc_failure_message.yfilter != YFilter.not_set or
                                self.record_route_messsage.yfilter != YFilter.not_set or
                                self.reoptimize_attempts_message.yfilter != YFilter.not_set or
                                self.reoptimized_message.yfilter != YFilter.not_set or
                                self.reroute_messsage.yfilter != YFilter.not_set or
                                self.state_message.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "logging" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.all.is_set or self.all.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.all.get_name_leafdata())
                            if (self.bandwidth_change_message.is_set or self.bandwidth_change_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth_change_message.get_name_leafdata())
                            if (self.bfd_state_message.is_set or self.bfd_state_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bfd_state_message.get_name_leafdata())
                            if (self.insufficient_bw_message.is_set or self.insufficient_bw_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.insufficient_bw_message.get_name_leafdata())
                            if (self.lsp_switch_over_change_message.is_set or self.lsp_switch_over_change_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lsp_switch_over_change_message.get_name_leafdata())
                            if (self.pcalc_failure_message.is_set or self.pcalc_failure_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pcalc_failure_message.get_name_leafdata())
                            if (self.record_route_messsage.is_set or self.record_route_messsage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.record_route_messsage.get_name_leafdata())
                            if (self.reoptimize_attempts_message.is_set or self.reoptimize_attempts_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimize_attempts_message.get_name_leafdata())
                            if (self.reoptimized_message.is_set or self.reoptimized_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimized_message.get_name_leafdata())
                            if (self.reroute_messsage.is_set or self.reroute_messsage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reroute_messsage.get_name_leafdata())
                            if (self.state_message.is_set or self.state_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.state_message.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "all" or name == "bandwidth-change-message" or name == "bfd-state-message" or name == "insufficient-bw-message" or name == "lsp-switch-over-change-message" or name == "pcalc-failure-message" or name == "record-route-messsage" or name == "reoptimize-attempts-message" or name == "reoptimized-message" or name == "reroute-messsage" or name == "state-message"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "all"):
                                self.all = value
                                self.all.value_namespace = name_space
                                self.all.value_namespace_prefix = name_space_prefix
                            if(value_path == "bandwidth-change-message"):
                                self.bandwidth_change_message = value
                                self.bandwidth_change_message.value_namespace = name_space
                                self.bandwidth_change_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "bfd-state-message"):
                                self.bfd_state_message = value
                                self.bfd_state_message.value_namespace = name_space
                                self.bfd_state_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "insufficient-bw-message"):
                                self.insufficient_bw_message = value
                                self.insufficient_bw_message.value_namespace = name_space
                                self.insufficient_bw_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "lsp-switch-over-change-message"):
                                self.lsp_switch_over_change_message = value
                                self.lsp_switch_over_change_message.value_namespace = name_space
                                self.lsp_switch_over_change_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "pcalc-failure-message"):
                                self.pcalc_failure_message = value
                                self.pcalc_failure_message.value_namespace = name_space
                                self.pcalc_failure_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "record-route-messsage"):
                                self.record_route_messsage = value
                                self.record_route_messsage.value_namespace = name_space
                                self.record_route_messsage.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimize-attempts-message"):
                                self.reoptimize_attempts_message = value
                                self.reoptimize_attempts_message.value_namespace = name_space
                                self.reoptimize_attempts_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimized-message"):
                                self.reoptimized_message = value
                                self.reoptimized_message.value_namespace = name_space
                                self.reoptimized_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reroute-messsage"):
                                self.reroute_messsage = value
                                self.reroute_messsage.value_namespace = name_space
                                self.reroute_messsage.value_namespace_prefix = name_space_prefix
                            if(value_path == "state-message"):
                                self.state_message = value
                                self.state_message.value_namespace = name_space
                                self.state_message.value_namespace_prefix = name_space_prefix


                    class NewStyleAffinityAffinityTypes(Entity):
                        """
                        Tunnel new style affinity attributes table
                        
                        .. attribute:: new_style_affinity_affinity_type
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes, self).__init__()

                            self.yang_name = "new-style-affinity-affinity-types"
                            self.yang_parent_name = "p2p-te-attribute"

                            self.new_style_affinity_affinity_type = YList(self)
                            self.new_style_affinity_affinity_type_affinity1 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10 = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)


                        class NewStyleAffinityAffinityType(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)

                            def has_data(self):
                                return self.affinity_type.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type" + "[affinity-type='" + self.affinity_type.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity10  <key>
                            
                            	The name of the tenth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                                self.affinity10 = YLeaf(YType.str, "affinity10")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9",
                                                "affinity10") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set or
                                    self.affinity10.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set or
                                    self.affinity10.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + "[affinity10='" + self.affinity10.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())
                                if (self.affinity10.is_set or self.affinity10.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity10.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9" or name == "affinity10"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity10"):
                                    self.affinity10 = value
                                    self.affinity10.value_namespace = name_space
                                    self.affinity10.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "new-style-affinity-affinity-types" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "new-style-affinity-affinity-type"):
                                for c in self.new_style_affinity_affinity_type:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1"):
                                for c in self.new_style_affinity_affinity_type_affinity1:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "new-style-affinity-affinity-type" or name == "new-style-affinity-affinity-type-affinity1" or name == "new-style-affinity-affinity-type-affinity1-affinity2" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.attribute_set_name.is_set or
                            self.enable.is_set or
                            (self.logging is not None and self.logging.has_data()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_data()) or
                            (self.path_selection is not None and self.path_selection.has_data()) or
                            (self.pce is not None and self.pce.has_data()) or
                            (self.affinity_mask is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.attribute_set_name.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            (self.affinity_mask is not None and self.affinity_mask.has_operation()) or
                            (self.logging is not None and self.logging.has_operation()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_operation()) or
                            (self.path_selection is not None and self.path_selection.has_operation()) or
                            (self.pce is not None and self.pce.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "p2p-te-attribute" + "[attribute-set-name='" + self.attribute_set_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/p2p-te-attributes/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.attribute_set_name.is_set or self.attribute_set_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.attribute_set_name.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "affinity-mask"):
                            if (self.affinity_mask is None):
                                self.affinity_mask = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.AffinityMask()
                                self.affinity_mask.parent = self
                                self._children_name_map["affinity_mask"] = "affinity-mask"
                            return self.affinity_mask

                        if (child_yang_name == "logging"):
                            if (self.logging is None):
                                self.logging = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Logging()
                                self.logging.parent = self
                                self._children_name_map["logging"] = "logging"
                            return self.logging

                        if (child_yang_name == "new-style-affinity-affinity-types"):
                            if (self.new_style_affinity_affinity_types is None):
                                self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.NewStyleAffinityAffinityTypes()
                                self.new_style_affinity_affinity_types.parent = self
                                self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                            return self.new_style_affinity_affinity_types

                        if (child_yang_name == "path-selection"):
                            if (self.path_selection is None):
                                self.path_selection = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.PathSelection()
                                self.path_selection.parent = self
                                self._children_name_map["path_selection"] = "path-selection"
                            return self.path_selection

                        if (child_yang_name == "pce"):
                            if (self.pce is None):
                                self.pce = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute.Pce()
                                self.pce.parent = self
                                self._children_name_map["pce"] = "pce"
                            return self.pce

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "affinity-mask" or name == "logging" or name == "new-style-affinity-affinity-types" or name == "path-selection" or name == "pce" or name == "attribute-set-name" or name == "enable"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "attribute-set-name"):
                            self.attribute_set_name = value
                            self.attribute_set_name.value_namespace = name_space
                            self.attribute_set_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.p2p_te_attribute:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.p2p_te_attribute:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "p2p-te-attributes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "p2p-te-attribute"):
                        for c in self.p2p_te_attribute:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes.P2PTeAttribute()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.p2p_te_attribute.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "p2p-te-attribute"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AutoBackupAttributes(Entity):
                """
                Auto\-backup Tunnel Attribute Table
                
                .. attribute:: auto_backup_attribute
                
                	Auto\-backup Tunnel Attribute
                	**type**\: list of    :py:class:`AutoBackupAttribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes, self).__init__()

                    self.yang_name = "auto-backup-attributes"
                    self.yang_parent_name = "attribute-set"

                    self.auto_backup_attribute = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes, self).__setattr__(name, value)


                class AutoBackupAttribute(Entity):
                    """
                    Auto\-backup Tunnel Attribute
                    
                    .. attribute:: attribute_set_name  <key>
                    
                    	Attribute Set Name
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: affinity_mask
                    
                    	Set the affinity flags and mask
                    	**type**\:   :py:class:`AffinityMask <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AffinityMask>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: auto_backup_logging
                    
                    	Log tunnel LSP messages
                    	**type**\:   :py:class:`AutoBackupLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AutoBackupLogging>`
                    
                    .. attribute:: enable
                    
                    	Attribute\-set enable object that controls whether this attribute\-set is configured or not .This object must be set before other configuration supplied for this attribute\-set
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: new_style_affinity_affinity_types
                    
                    	Tunnel new style affinity attributes table
                    	**type**\:   :py:class:`NewStyleAffinityAffinityTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes>`
                    
                    .. attribute:: path_selection
                    
                    	Configure path selection properties
                    	**type**\:   :py:class:`PathSelection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PathSelection>`
                    
                    .. attribute:: policy_classes
                    
                    	Policy classes for PBTS
                    	**type**\:   :py:class:`PolicyClasses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PolicyClasses>`
                    
                    .. attribute:: priority
                    
                    	Tunnel Setup and Hold Priorities
                    	**type**\:   :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.Priority>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: record_route
                    
                    	Record the route used by the tunnel
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: signalled_name
                    
                    	Signalled name
                    	**type**\:   :py:class:`SignalledName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.SignalledName>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute, self).__init__()

                        self.yang_name = "auto-backup-attribute"
                        self.yang_parent_name = "auto-backup-attributes"

                        self.attribute_set_name = YLeaf(YType.str, "attribute-set-name")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.record_route = YLeaf(YType.empty, "record-route")

                        self.affinity_mask = None
                        self._children_name_map["affinity_mask"] = "affinity-mask"
                        self._children_yang_names.add("affinity-mask")

                        self.auto_backup_logging = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AutoBackupLogging()
                        self.auto_backup_logging.parent = self
                        self._children_name_map["auto_backup_logging"] = "auto-backup-logging"
                        self._children_yang_names.add("auto-backup-logging")

                        self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes()
                        self.new_style_affinity_affinity_types.parent = self
                        self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                        self._children_yang_names.add("new-style-affinity-affinity-types")

                        self.path_selection = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PathSelection()
                        self.path_selection.parent = self
                        self._children_name_map["path_selection"] = "path-selection"
                        self._children_yang_names.add("path-selection")

                        self.policy_classes = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PolicyClasses()
                        self.policy_classes.parent = self
                        self._children_name_map["policy_classes"] = "policy-classes"
                        self._children_yang_names.add("policy-classes")

                        self.priority = None
                        self._children_name_map["priority"] = "priority"
                        self._children_yang_names.add("priority")

                        self.signalled_name = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.SignalledName()
                        self.signalled_name.parent = self
                        self._children_name_map["signalled_name"] = "signalled-name"
                        self._children_yang_names.add("signalled-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("attribute_set_name",
                                        "enable",
                                        "record_route") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute, self).__setattr__(name, value)


                    class SignalledName(Entity):
                        """
                        Signalled name
                        
                        .. attribute:: mp_address
                        
                        	Set if merge\-point address is to be appended
                        	**type**\:  bool
                        
                        .. attribute:: name
                        
                        	Signalled name
                        	**type**\:  str
                        
                        .. attribute:: protected_interface_type
                        
                        	Protected\-interface address or name
                        	**type**\:   :py:class:`MplsTeSigNameOption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeSigNameOption>`
                        
                        .. attribute:: source_type
                        
                        	Source address or name
                        	**type**\:   :py:class:`MplsTeSigNameOption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeSigNameOption>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.SignalledName, self).__init__()

                            self.yang_name = "signalled-name"
                            self.yang_parent_name = "auto-backup-attribute"

                            self.mp_address = YLeaf(YType.boolean, "mp-address")

                            self.name = YLeaf(YType.str, "name")

                            self.protected_interface_type = YLeaf(YType.enumeration, "protected-interface-type")

                            self.source_type = YLeaf(YType.enumeration, "source-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("mp_address",
                                            "name",
                                            "protected_interface_type",
                                            "source_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.SignalledName, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.SignalledName, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.mp_address.is_set or
                                self.name.is_set or
                                self.protected_interface_type.is_set or
                                self.source_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.mp_address.yfilter != YFilter.not_set or
                                self.name.yfilter != YFilter.not_set or
                                self.protected_interface_type.yfilter != YFilter.not_set or
                                self.source_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "signalled-name" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.mp_address.is_set or self.mp_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mp_address.get_name_leafdata())
                            if (self.name.is_set or self.name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.name.get_name_leafdata())
                            if (self.protected_interface_type.is_set or self.protected_interface_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protected_interface_type.get_name_leafdata())
                            if (self.source_type.is_set or self.source_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.source_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "mp-address" or name == "name" or name == "protected-interface-type" or name == "source-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "mp-address"):
                                self.mp_address = value
                                self.mp_address.value_namespace = name_space
                                self.mp_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "name"):
                                self.name = value
                                self.name.value_namespace = name_space
                                self.name.value_namespace_prefix = name_space_prefix
                            if(value_path == "protected-interface-type"):
                                self.protected_interface_type = value
                                self.protected_interface_type.value_namespace = name_space
                                self.protected_interface_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "source-type"):
                                self.source_type = value
                                self.source_type.value_namespace = name_space
                                self.source_type.value_namespace_prefix = name_space_prefix


                    class AutoBackupLogging(Entity):
                        """
                        Log tunnel LSP messages
                        
                        .. attribute:: bandwidth_change_message
                        
                        	Log tunnel messages for bandwidth change
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimize_attempts_message
                        
                        	Log tunnel reoptimization attempts messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimized_message
                        
                        	Log tunnel reoptimized messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: state_message
                        
                        	Log tunnel state messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AutoBackupLogging, self).__init__()

                            self.yang_name = "auto-backup-logging"
                            self.yang_parent_name = "auto-backup-attribute"

                            self.bandwidth_change_message = YLeaf(YType.empty, "bandwidth-change-message")

                            self.reoptimize_attempts_message = YLeaf(YType.empty, "reoptimize-attempts-message")

                            self.reoptimized_message = YLeaf(YType.empty, "reoptimized-message")

                            self.state_message = YLeaf(YType.empty, "state-message")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth_change_message",
                                            "reoptimize_attempts_message",
                                            "reoptimized_message",
                                            "state_message") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AutoBackupLogging, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AutoBackupLogging, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bandwidth_change_message.is_set or
                                self.reoptimize_attempts_message.is_set or
                                self.reoptimized_message.is_set or
                                self.state_message.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth_change_message.yfilter != YFilter.not_set or
                                self.reoptimize_attempts_message.yfilter != YFilter.not_set or
                                self.reoptimized_message.yfilter != YFilter.not_set or
                                self.state_message.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "auto-backup-logging" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth_change_message.is_set or self.bandwidth_change_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth_change_message.get_name_leafdata())
                            if (self.reoptimize_attempts_message.is_set or self.reoptimize_attempts_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimize_attempts_message.get_name_leafdata())
                            if (self.reoptimized_message.is_set or self.reoptimized_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimized_message.get_name_leafdata())
                            if (self.state_message.is_set or self.state_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.state_message.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth-change-message" or name == "reoptimize-attempts-message" or name == "reoptimized-message" or name == "state-message"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth-change-message"):
                                self.bandwidth_change_message = value
                                self.bandwidth_change_message.value_namespace = name_space
                                self.bandwidth_change_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimize-attempts-message"):
                                self.reoptimize_attempts_message = value
                                self.reoptimize_attempts_message.value_namespace = name_space
                                self.reoptimize_attempts_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimized-message"):
                                self.reoptimized_message = value
                                self.reoptimized_message.value_namespace = name_space
                                self.reoptimized_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "state-message"):
                                self.state_message = value
                                self.state_message.value_namespace = name_space
                                self.state_message.value_namespace_prefix = name_space_prefix


                    class Priority(Entity):
                        """
                        Tunnel Setup and Hold Priorities
                        
                        .. attribute:: hold_priority
                        
                        	Hold Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        .. attribute:: setup_priority
                        
                        	Setup Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.Priority, self).__init__()

                            self.yang_name = "priority"
                            self.yang_parent_name = "auto-backup-attribute"
                            self.is_presence_container = True

                            self.hold_priority = YLeaf(YType.uint32, "hold-priority")

                            self.setup_priority = YLeaf(YType.uint32, "setup-priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hold_priority",
                                            "setup_priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.Priority, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.Priority, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.hold_priority.is_set or
                                self.setup_priority.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hold_priority.yfilter != YFilter.not_set or
                                self.setup_priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "priority" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hold_priority.get_name_leafdata())
                            if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.setup_priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hold-priority" or name == "setup-priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hold-priority"):
                                self.hold_priority = value
                                self.hold_priority.value_namespace = name_space
                                self.hold_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "setup-priority"):
                                self.setup_priority = value
                                self.setup_priority.value_namespace = name_space
                                self.setup_priority.value_namespace_prefix = name_space_prefix


                    class AffinityMask(Entity):
                        """
                        Set the affinity flags and mask
                        
                        .. attribute:: affinity
                        
                        	Affinity flags
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        .. attribute:: mask
                        
                        	Affinity mask
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AffinityMask, self).__init__()

                            self.yang_name = "affinity-mask"
                            self.yang_parent_name = "auto-backup-attribute"
                            self.is_presence_container = True

                            self.affinity = YLeaf(YType.str, "affinity")

                            self.mask = YLeaf(YType.str, "mask")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("affinity",
                                            "mask") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AffinityMask, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AffinityMask, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.affinity.is_set or
                                self.mask.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.affinity.yfilter != YFilter.not_set or
                                self.mask.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "affinity-mask" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.affinity.is_set or self.affinity.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.affinity.get_name_leafdata())
                            if (self.mask.is_set or self.mask.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mask.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "affinity" or name == "mask"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "affinity"):
                                self.affinity = value
                                self.affinity.value_namespace = name_space
                                self.affinity.value_namespace_prefix = name_space_prefix
                            if(value_path == "mask"):
                                self.mask = value
                                self.mask.value_namespace = name_space
                                self.mask.value_namespace_prefix = name_space_prefix


                    class PathSelection(Entity):
                        """
                        Configure path selection properties
                        
                        .. attribute:: enable
                        
                        	Enable path selection
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PathSelection, self).__init__()

                            self.yang_name = "path-selection"
                            self.yang_parent_name = "auto-backup-attribute"

                            self.enable = YLeaf(YType.empty, "enable")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PathSelection, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PathSelection, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enable.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-selection" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix


                    class PolicyClasses(Entity):
                        """
                        Policy classes for PBTS
                        
                        .. attribute:: policy_class
                        
                        	Array of Policy class
                        	**type**\:  list of int
                        
                        	**range:** 1..8
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PolicyClasses, self).__init__()

                            self.yang_name = "policy-classes"
                            self.yang_parent_name = "auto-backup-attribute"

                            self.policy_class = YLeafList(YType.uint32, "policy-class")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("policy_class") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PolicyClasses, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PolicyClasses, self).__setattr__(name, value)

                        def has_data(self):
                            for leaf in self.policy_class.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return False

                        def has_operation(self):
                            for leaf in self.policy_class.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.policy_class.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "policy-classes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            leaf_name_data.extend(self.policy_class.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "policy-class"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "policy-class"):
                                self.policy_class.append(value)


                    class NewStyleAffinityAffinityTypes(Entity):
                        """
                        Tunnel new style affinity attributes table
                        
                        .. attribute:: new_style_affinity_affinity_type
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes, self).__init__()

                            self.yang_name = "new-style-affinity-affinity-types"
                            self.yang_parent_name = "auto-backup-attribute"

                            self.new_style_affinity_affinity_type = YList(self)
                            self.new_style_affinity_affinity_type_affinity1 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10 = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)


                        class NewStyleAffinityAffinityType(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)

                            def has_data(self):
                                return self.affinity_type.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type" + "[affinity-type='" + self.affinity_type.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity10  <key>
                            
                            	The name of the tenth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                                self.affinity10 = YLeaf(YType.str, "affinity10")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9",
                                                "affinity10") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set or
                                    self.affinity10.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set or
                                    self.affinity10.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + "[affinity10='" + self.affinity10.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())
                                if (self.affinity10.is_set or self.affinity10.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity10.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9" or name == "affinity10"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity10"):
                                    self.affinity10 = value
                                    self.affinity10.value_namespace = name_space
                                    self.affinity10.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "new-style-affinity-affinity-types" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "new-style-affinity-affinity-type"):
                                for c in self.new_style_affinity_affinity_type:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1"):
                                for c in self.new_style_affinity_affinity_type_affinity1:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "new-style-affinity-affinity-type" or name == "new-style-affinity-affinity-type-affinity1" or name == "new-style-affinity-affinity-type-affinity1-affinity2" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.attribute_set_name.is_set or
                            self.enable.is_set or
                            self.record_route.is_set or
                            (self.auto_backup_logging is not None and self.auto_backup_logging.has_data()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_data()) or
                            (self.path_selection is not None and self.path_selection.has_data()) or
                            (self.policy_classes is not None and self.policy_classes.has_data()) or
                            (self.signalled_name is not None and self.signalled_name.has_data()) or
                            (self.affinity_mask is not None) or
                            (self.priority is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.attribute_set_name.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.record_route.yfilter != YFilter.not_set or
                            (self.affinity_mask is not None and self.affinity_mask.has_operation()) or
                            (self.auto_backup_logging is not None and self.auto_backup_logging.has_operation()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_operation()) or
                            (self.path_selection is not None and self.path_selection.has_operation()) or
                            (self.policy_classes is not None and self.policy_classes.has_operation()) or
                            (self.priority is not None and self.priority.has_operation()) or
                            (self.signalled_name is not None and self.signalled_name.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "auto-backup-attribute" + "[attribute-set-name='" + self.attribute_set_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/auto-backup-attributes/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.attribute_set_name.is_set or self.attribute_set_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.attribute_set_name.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.record_route.is_set or self.record_route.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.record_route.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "affinity-mask"):
                            if (self.affinity_mask is None):
                                self.affinity_mask = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AffinityMask()
                                self.affinity_mask.parent = self
                                self._children_name_map["affinity_mask"] = "affinity-mask"
                            return self.affinity_mask

                        if (child_yang_name == "auto-backup-logging"):
                            if (self.auto_backup_logging is None):
                                self.auto_backup_logging = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.AutoBackupLogging()
                                self.auto_backup_logging.parent = self
                                self._children_name_map["auto_backup_logging"] = "auto-backup-logging"
                            return self.auto_backup_logging

                        if (child_yang_name == "new-style-affinity-affinity-types"):
                            if (self.new_style_affinity_affinity_types is None):
                                self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.NewStyleAffinityAffinityTypes()
                                self.new_style_affinity_affinity_types.parent = self
                                self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                            return self.new_style_affinity_affinity_types

                        if (child_yang_name == "path-selection"):
                            if (self.path_selection is None):
                                self.path_selection = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PathSelection()
                                self.path_selection.parent = self
                                self._children_name_map["path_selection"] = "path-selection"
                            return self.path_selection

                        if (child_yang_name == "policy-classes"):
                            if (self.policy_classes is None):
                                self.policy_classes = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.PolicyClasses()
                                self.policy_classes.parent = self
                                self._children_name_map["policy_classes"] = "policy-classes"
                            return self.policy_classes

                        if (child_yang_name == "priority"):
                            if (self.priority is None):
                                self.priority = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.Priority()
                                self.priority.parent = self
                                self._children_name_map["priority"] = "priority"
                            return self.priority

                        if (child_yang_name == "signalled-name"):
                            if (self.signalled_name is None):
                                self.signalled_name = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute.SignalledName()
                                self.signalled_name.parent = self
                                self._children_name_map["signalled_name"] = "signalled-name"
                            return self.signalled_name

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "affinity-mask" or name == "auto-backup-logging" or name == "new-style-affinity-affinity-types" or name == "path-selection" or name == "policy-classes" or name == "priority" or name == "signalled-name" or name == "attribute-set-name" or name == "enable" or name == "record-route"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "attribute-set-name"):
                            self.attribute_set_name = value
                            self.attribute_set_name.value_namespace = name_space
                            self.attribute_set_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "record-route"):
                            self.record_route = value
                            self.record_route.value_namespace = name_space
                            self.record_route.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.auto_backup_attribute:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.auto_backup_attribute:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "auto-backup-attributes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "auto-backup-attribute"):
                        for c in self.auto_backup_attribute:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes.AutoBackupAttribute()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.auto_backup_attribute.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "auto-backup-attribute"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class OtnPpAttributes(Entity):
                """
                OTN Path Protection Attributes table
                
                .. attribute:: otn_pp_attribute
                
                	OTN Path Protection Attribute
                	**type**\: list of    :py:class:`OtnPpAttribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes, self).__init__()

                    self.yang_name = "otn-pp-attributes"
                    self.yang_parent_name = "attribute-set"

                    self.otn_pp_attribute = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes, self).__setattr__(name, value)


                class OtnPpAttribute(Entity):
                    """
                    OTN Path Protection Attribute
                    
                    .. attribute:: attribute_set_name  <key>
                    
                    	Attribute Set Name
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: aps_protection_mode
                    
                    	The APS protecion mode
                    	**type**\:   :py:class:`MplsTeOtnApsProtectionMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeOtnApsProtectionMode>`
                    
                    .. attribute:: aps_protection_type
                    
                    	The APS protecion type
                    	**type**\:   :py:class:`MplsTeOtnApsProtection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeOtnApsProtection>`
                    
                    .. attribute:: aps_restoration_style
                    
                    	The APS restoration style
                    	**type**\:   :py:class:`MplsTeOtnApsRestorationStyle <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeOtnApsRestorationStyle>`
                    
                    .. attribute:: enable
                    
                    	Attribute\-set enable object that controls whether this attribute\-set is configured or not .This object must be set before other configuration supplied for this attribute\-set
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: path_selection
                    
                    	Configure path selection properties
                    	**type**\:   :py:class:`PathSelection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.PathSelection>`
                    
                    .. attribute:: revert_schedule_names
                    
                    	Specify APS revert schedule
                    	**type**\:   :py:class:`RevertScheduleNames <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames>`
                    
                    .. attribute:: sub_network_connection_mode
                    
                    	Sub\-network connection mode
                    	**type**\:   :py:class:`SubNetworkConnectionMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.SubNetworkConnectionMode>`
                    
                    .. attribute:: timers
                    
                    	Timers
                    	**type**\:   :py:class:`Timers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.Timers>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute, self).__init__()

                        self.yang_name = "otn-pp-attribute"
                        self.yang_parent_name = "otn-pp-attributes"

                        self.attribute_set_name = YLeaf(YType.str, "attribute-set-name")

                        self.aps_protection_mode = YLeaf(YType.enumeration, "aps-protection-mode")

                        self.aps_protection_type = YLeaf(YType.enumeration, "aps-protection-type")

                        self.aps_restoration_style = YLeaf(YType.enumeration, "aps-restoration-style")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.path_selection = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.PathSelection()
                        self.path_selection.parent = self
                        self._children_name_map["path_selection"] = "path-selection"
                        self._children_yang_names.add("path-selection")

                        self.revert_schedule_names = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames()
                        self.revert_schedule_names.parent = self
                        self._children_name_map["revert_schedule_names"] = "revert-schedule-names"
                        self._children_yang_names.add("revert-schedule-names")

                        self.sub_network_connection_mode = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.SubNetworkConnectionMode()
                        self.sub_network_connection_mode.parent = self
                        self._children_name_map["sub_network_connection_mode"] = "sub-network-connection-mode"
                        self._children_yang_names.add("sub-network-connection-mode")

                        self.timers = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.Timers()
                        self.timers.parent = self
                        self._children_name_map["timers"] = "timers"
                        self._children_yang_names.add("timers")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("attribute_set_name",
                                        "aps_protection_mode",
                                        "aps_protection_type",
                                        "aps_restoration_style",
                                        "enable") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute, self).__setattr__(name, value)


                    class RevertScheduleNames(Entity):
                        """
                        Specify APS revert schedule
                        
                        .. attribute:: revert_schedule_name
                        
                        	Name Identifier for revert schedule
                        	**type**\: list of    :py:class:`RevertScheduleName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames, self).__init__()

                            self.yang_name = "revert-schedule-names"
                            self.yang_parent_name = "otn-pp-attribute"

                            self.revert_schedule_name = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames, self).__setattr__(name, value)


                        class RevertScheduleName(Entity):
                            """
                            Name Identifier for revert schedule
                            
                            .. attribute:: schedule_name  <key>
                            
                            	Enter 64 characters for revert schedule name
                            	**type**\:  str
                            
                            	**length:** 1..254
                            
                            .. attribute:: revert_schedule_frequency
                            
                            	Frequency set as Once, Daily, Weekly
                            	**type**\:  int
                            
                            	**range:** 1..3
                            
                            .. attribute:: revert_schedule_max_tries
                            
                            	Revert Schedule Max tries
                            	**type**\:  int
                            
                            	**range:** 1..2016
                            
                            .. attribute:: sch_name_enable
                            
                            	Schedule name enable object
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: schedule_date
                            
                            	Set date in format hh\:mm MMM DD YYYY
                            	**type**\:   :py:class:`ScheduleDate <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDate>`
                            
                            	**presence node**\: True
                            
                            .. attribute:: schedule_duration
                            
                            	Set duration in format hh\:mm
                            	**type**\:   :py:class:`ScheduleDuration <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDuration>`
                            
                            	**presence node**\: True
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName, self).__init__()

                                self.yang_name = "revert-schedule-name"
                                self.yang_parent_name = "revert-schedule-names"

                                self.schedule_name = YLeaf(YType.str, "schedule-name")

                                self.revert_schedule_frequency = YLeaf(YType.uint32, "revert-schedule-frequency")

                                self.revert_schedule_max_tries = YLeaf(YType.uint32, "revert-schedule-max-tries")

                                self.sch_name_enable = YLeaf(YType.empty, "sch-name-enable")

                                self.schedule_date = None
                                self._children_name_map["schedule_date"] = "schedule-date"
                                self._children_yang_names.add("schedule-date")

                                self.schedule_duration = None
                                self._children_name_map["schedule_duration"] = "schedule-duration"
                                self._children_yang_names.add("schedule-duration")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("schedule_name",
                                                "revert_schedule_frequency",
                                                "revert_schedule_max_tries",
                                                "sch_name_enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName, self).__setattr__(name, value)


                            class ScheduleDuration(Entity):
                                """
                                Set duration in format hh\:mm
                                
                                .. attribute:: hour
                                
                                	Hour of day
                                	**type**\:  int
                                
                                	**range:** 0..167
                                
                                	**mandatory**\: True
                                
                                .. attribute:: minutes
                                
                                	Minute of the hour
                                	**type**\:  int
                                
                                	**range:** 0..59
                                
                                	**mandatory**\: True
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDuration, self).__init__()

                                    self.yang_name = "schedule-duration"
                                    self.yang_parent_name = "revert-schedule-name"
                                    self.is_presence_container = True

                                    self.hour = YLeaf(YType.uint32, "hour")

                                    self.minutes = YLeaf(YType.uint32, "minutes")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("hour",
                                                    "minutes") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDuration, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDuration, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.hour.is_set or
                                        self.minutes.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.hour.yfilter != YFilter.not_set or
                                        self.minutes.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "schedule-duration" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.hour.is_set or self.hour.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hour.get_name_leafdata())
                                    if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.minutes.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "hour" or name == "minutes"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "hour"):
                                        self.hour = value
                                        self.hour.value_namespace = name_space
                                        self.hour.value_namespace_prefix = name_space_prefix
                                    if(value_path == "minutes"):
                                        self.minutes = value
                                        self.minutes.value_namespace = name_space
                                        self.minutes.value_namespace_prefix = name_space_prefix


                            class ScheduleDate(Entity):
                                """
                                Set date in format hh\:mm MMM DD YYYY
                                
                                .. attribute:: day
                                
                                	Day of the month
                                	**type**\:  int
                                
                                	**range:** 1..31
                                
                                	**mandatory**\: True
                                
                                .. attribute:: hour
                                
                                	Hour of day
                                	**type**\:  int
                                
                                	**range:** 0..23
                                
                                	**mandatory**\: True
                                
                                .. attribute:: minutes
                                
                                	Minute of the hour
                                	**type**\:  int
                                
                                	**range:** 0..59
                                
                                	**mandatory**\: True
                                
                                .. attribute:: month
                                
                                	Month of the year
                                	**type**\:  int
                                
                                	**range:** 0..11
                                
                                	**mandatory**\: True
                                
                                .. attribute:: year
                                
                                	Year
                                	**type**\:  int
                                
                                	**range:** 2015..2035
                                
                                	**mandatory**\: True
                                
                                

                                This class is a :ref:`presence class<presence-class>`

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDate, self).__init__()

                                    self.yang_name = "schedule-date"
                                    self.yang_parent_name = "revert-schedule-name"
                                    self.is_presence_container = True

                                    self.day = YLeaf(YType.uint32, "day")

                                    self.hour = YLeaf(YType.uint32, "hour")

                                    self.minutes = YLeaf(YType.uint32, "minutes")

                                    self.month = YLeaf(YType.uint32, "month")

                                    self.year = YLeaf(YType.uint32, "year")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("day",
                                                    "hour",
                                                    "minutes",
                                                    "month",
                                                    "year") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDate, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDate, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.day.is_set or
                                        self.hour.is_set or
                                        self.minutes.is_set or
                                        self.month.is_set or
                                        self.year.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.day.yfilter != YFilter.not_set or
                                        self.hour.yfilter != YFilter.not_set or
                                        self.minutes.yfilter != YFilter.not_set or
                                        self.month.yfilter != YFilter.not_set or
                                        self.year.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "schedule-date" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.day.is_set or self.day.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.day.get_name_leafdata())
                                    if (self.hour.is_set or self.hour.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.hour.get_name_leafdata())
                                    if (self.minutes.is_set or self.minutes.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.minutes.get_name_leafdata())
                                    if (self.month.is_set or self.month.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.month.get_name_leafdata())
                                    if (self.year.is_set or self.year.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.year.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "day" or name == "hour" or name == "minutes" or name == "month" or name == "year"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "day"):
                                        self.day = value
                                        self.day.value_namespace = name_space
                                        self.day.value_namespace_prefix = name_space_prefix
                                    if(value_path == "hour"):
                                        self.hour = value
                                        self.hour.value_namespace = name_space
                                        self.hour.value_namespace_prefix = name_space_prefix
                                    if(value_path == "minutes"):
                                        self.minutes = value
                                        self.minutes.value_namespace = name_space
                                        self.minutes.value_namespace_prefix = name_space_prefix
                                    if(value_path == "month"):
                                        self.month = value
                                        self.month.value_namespace = name_space
                                        self.month.value_namespace_prefix = name_space_prefix
                                    if(value_path == "year"):
                                        self.year = value
                                        self.year.value_namespace = name_space
                                        self.year.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.schedule_name.is_set or
                                    self.revert_schedule_frequency.is_set or
                                    self.revert_schedule_max_tries.is_set or
                                    self.sch_name_enable.is_set or
                                    (self.schedule_date is not None) or
                                    (self.schedule_duration is not None))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.schedule_name.yfilter != YFilter.not_set or
                                    self.revert_schedule_frequency.yfilter != YFilter.not_set or
                                    self.revert_schedule_max_tries.yfilter != YFilter.not_set or
                                    self.sch_name_enable.yfilter != YFilter.not_set or
                                    (self.schedule_date is not None and self.schedule_date.has_operation()) or
                                    (self.schedule_duration is not None and self.schedule_duration.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "revert-schedule-name" + "[schedule-name='" + self.schedule_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.schedule_name.is_set or self.schedule_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.schedule_name.get_name_leafdata())
                                if (self.revert_schedule_frequency.is_set or self.revert_schedule_frequency.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.revert_schedule_frequency.get_name_leafdata())
                                if (self.revert_schedule_max_tries.is_set or self.revert_schedule_max_tries.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.revert_schedule_max_tries.get_name_leafdata())
                                if (self.sch_name_enable.is_set or self.sch_name_enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.sch_name_enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "schedule-date"):
                                    if (self.schedule_date is None):
                                        self.schedule_date = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDate()
                                        self.schedule_date.parent = self
                                        self._children_name_map["schedule_date"] = "schedule-date"
                                    return self.schedule_date

                                if (child_yang_name == "schedule-duration"):
                                    if (self.schedule_duration is None):
                                        self.schedule_duration = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName.ScheduleDuration()
                                        self.schedule_duration.parent = self
                                        self._children_name_map["schedule_duration"] = "schedule-duration"
                                    return self.schedule_duration

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "schedule-date" or name == "schedule-duration" or name == "schedule-name" or name == "revert-schedule-frequency" or name == "revert-schedule-max-tries" or name == "sch-name-enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "schedule-name"):
                                    self.schedule_name = value
                                    self.schedule_name.value_namespace = name_space
                                    self.schedule_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "revert-schedule-frequency"):
                                    self.revert_schedule_frequency = value
                                    self.revert_schedule_frequency.value_namespace = name_space
                                    self.revert_schedule_frequency.value_namespace_prefix = name_space_prefix
                                if(value_path == "revert-schedule-max-tries"):
                                    self.revert_schedule_max_tries = value
                                    self.revert_schedule_max_tries.value_namespace = name_space
                                    self.revert_schedule_max_tries.value_namespace_prefix = name_space_prefix
                                if(value_path == "sch-name-enable"):
                                    self.sch_name_enable = value
                                    self.sch_name_enable.value_namespace = name_space
                                    self.sch_name_enable.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.revert_schedule_name:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.revert_schedule_name:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "revert-schedule-names" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "revert-schedule-name"):
                                for c in self.revert_schedule_name:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames.RevertScheduleName()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.revert_schedule_name.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "revert-schedule-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class SubNetworkConnectionMode(Entity):
                        """
                        Sub\-network connection mode
                        
                        .. attribute:: connection_mode
                        
                        	The sub\-network connection mode
                        	**type**\:   :py:class:`MplsTeOtnSncMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeOtnSncMode>`
                        
                        .. attribute:: connection_monitoring_mode
                        
                        	Tandem Connection Monitoring ID for the interface
                        	**type**\:  int
                        
                        	**range:** 1..6
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.SubNetworkConnectionMode, self).__init__()

                            self.yang_name = "sub-network-connection-mode"
                            self.yang_parent_name = "otn-pp-attribute"

                            self.connection_mode = YLeaf(YType.enumeration, "connection-mode")

                            self.connection_monitoring_mode = YLeaf(YType.uint32, "connection-monitoring-mode")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("connection_mode",
                                            "connection_monitoring_mode") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.SubNetworkConnectionMode, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.SubNetworkConnectionMode, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.connection_mode.is_set or
                                self.connection_monitoring_mode.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.connection_mode.yfilter != YFilter.not_set or
                                self.connection_monitoring_mode.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "sub-network-connection-mode" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.connection_mode.is_set or self.connection_mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.connection_mode.get_name_leafdata())
                            if (self.connection_monitoring_mode.is_set or self.connection_monitoring_mode.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.connection_monitoring_mode.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "connection-mode" or name == "connection-monitoring-mode"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "connection-mode"):
                                self.connection_mode = value
                                self.connection_mode.value_namespace = name_space
                                self.connection_mode.value_namespace_prefix = name_space_prefix
                            if(value_path == "connection-monitoring-mode"):
                                self.connection_monitoring_mode = value
                                self.connection_monitoring_mode.value_namespace = name_space
                                self.connection_monitoring_mode.value_namespace_prefix = name_space_prefix


                    class Timers(Entity):
                        """
                        Timers
                        
                        .. attribute:: aps_hold_off
                        
                        	G.709 OTN path protection hold\-off timer in milliseconds
                        	**type**\:  int
                        
                        	**range:** 100..10000
                        
                        	**units**\: millisecond
                        
                        .. attribute:: aps_wait_to_restore
                        
                        	G.709 OTN path protection wait to restore timer in seconds
                        	**type**\:  int
                        
                        	**range:** 0..720
                        
                        	**units**\: second
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.Timers, self).__init__()

                            self.yang_name = "timers"
                            self.yang_parent_name = "otn-pp-attribute"

                            self.aps_hold_off = YLeaf(YType.uint32, "aps-hold-off")

                            self.aps_wait_to_restore = YLeaf(YType.uint32, "aps-wait-to-restore")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("aps_hold_off",
                                            "aps_wait_to_restore") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.Timers, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.Timers, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.aps_hold_off.is_set or
                                self.aps_wait_to_restore.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.aps_hold_off.yfilter != YFilter.not_set or
                                self.aps_wait_to_restore.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "timers" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.aps_hold_off.is_set or self.aps_hold_off.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.aps_hold_off.get_name_leafdata())
                            if (self.aps_wait_to_restore.is_set or self.aps_wait_to_restore.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.aps_wait_to_restore.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "aps-hold-off" or name == "aps-wait-to-restore"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "aps-hold-off"):
                                self.aps_hold_off = value
                                self.aps_hold_off.value_namespace = name_space
                                self.aps_hold_off.value_namespace_prefix = name_space_prefix
                            if(value_path == "aps-wait-to-restore"):
                                self.aps_wait_to_restore = value
                                self.aps_wait_to_restore.value_namespace = name_space
                                self.aps_wait_to_restore.value_namespace_prefix = name_space_prefix


                    class PathSelection(Entity):
                        """
                        Configure path selection properties
                        
                        .. attribute:: enable
                        
                        	Enable path selection
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.PathSelection, self).__init__()

                            self.yang_name = "path-selection"
                            self.yang_parent_name = "otn-pp-attribute"

                            self.enable = YLeaf(YType.empty, "enable")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.PathSelection, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.PathSelection, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enable.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-selection" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.attribute_set_name.is_set or
                            self.aps_protection_mode.is_set or
                            self.aps_protection_type.is_set or
                            self.aps_restoration_style.is_set or
                            self.enable.is_set or
                            (self.path_selection is not None and self.path_selection.has_data()) or
                            (self.revert_schedule_names is not None and self.revert_schedule_names.has_data()) or
                            (self.sub_network_connection_mode is not None and self.sub_network_connection_mode.has_data()) or
                            (self.timers is not None and self.timers.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.attribute_set_name.yfilter != YFilter.not_set or
                            self.aps_protection_mode.yfilter != YFilter.not_set or
                            self.aps_protection_type.yfilter != YFilter.not_set or
                            self.aps_restoration_style.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            (self.path_selection is not None and self.path_selection.has_operation()) or
                            (self.revert_schedule_names is not None and self.revert_schedule_names.has_operation()) or
                            (self.sub_network_connection_mode is not None and self.sub_network_connection_mode.has_operation()) or
                            (self.timers is not None and self.timers.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "otn-pp-attribute" + "[attribute-set-name='" + self.attribute_set_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/otn-pp-attributes/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.attribute_set_name.is_set or self.attribute_set_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.attribute_set_name.get_name_leafdata())
                        if (self.aps_protection_mode.is_set or self.aps_protection_mode.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.aps_protection_mode.get_name_leafdata())
                        if (self.aps_protection_type.is_set or self.aps_protection_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.aps_protection_type.get_name_leafdata())
                        if (self.aps_restoration_style.is_set or self.aps_restoration_style.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.aps_restoration_style.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "path-selection"):
                            if (self.path_selection is None):
                                self.path_selection = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.PathSelection()
                                self.path_selection.parent = self
                                self._children_name_map["path_selection"] = "path-selection"
                            return self.path_selection

                        if (child_yang_name == "revert-schedule-names"):
                            if (self.revert_schedule_names is None):
                                self.revert_schedule_names = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.RevertScheduleNames()
                                self.revert_schedule_names.parent = self
                                self._children_name_map["revert_schedule_names"] = "revert-schedule-names"
                            return self.revert_schedule_names

                        if (child_yang_name == "sub-network-connection-mode"):
                            if (self.sub_network_connection_mode is None):
                                self.sub_network_connection_mode = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.SubNetworkConnectionMode()
                                self.sub_network_connection_mode.parent = self
                                self._children_name_map["sub_network_connection_mode"] = "sub-network-connection-mode"
                            return self.sub_network_connection_mode

                        if (child_yang_name == "timers"):
                            if (self.timers is None):
                                self.timers = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute.Timers()
                                self.timers.parent = self
                                self._children_name_map["timers"] = "timers"
                            return self.timers

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "path-selection" or name == "revert-schedule-names" or name == "sub-network-connection-mode" or name == "timers" or name == "attribute-set-name" or name == "aps-protection-mode" or name == "aps-protection-type" or name == "aps-restoration-style" or name == "enable"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "attribute-set-name"):
                            self.attribute_set_name = value
                            self.attribute_set_name.value_namespace = name_space
                            self.attribute_set_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "aps-protection-mode"):
                            self.aps_protection_mode = value
                            self.aps_protection_mode.value_namespace = name_space
                            self.aps_protection_mode.value_namespace_prefix = name_space_prefix
                        if(value_path == "aps-protection-type"):
                            self.aps_protection_type = value
                            self.aps_protection_type.value_namespace = name_space
                            self.aps_protection_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "aps-restoration-style"):
                            self.aps_restoration_style = value
                            self.aps_restoration_style.value_namespace = name_space
                            self.aps_restoration_style.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.otn_pp_attribute:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.otn_pp_attribute:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "otn-pp-attributes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "otn-pp-attribute"):
                        for c in self.otn_pp_attribute:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes.OtnPpAttribute()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.otn_pp_attribute.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "otn-pp-attribute"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class AutoMeshAttributes(Entity):
                """
                Auto\-mesh Tunnel AttributeSets Table
                
                .. attribute:: auto_mesh_attribute
                
                	Auto\-mesh Tunnel Attribute
                	**type**\: list of    :py:class:`AutoMeshAttribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes, self).__init__()

                    self.yang_name = "auto-mesh-attributes"
                    self.yang_parent_name = "attribute-set"

                    self.auto_mesh_attribute = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes, self).__setattr__(name, value)


                class AutoMeshAttribute(Entity):
                    """
                    Auto\-mesh Tunnel Attribute
                    
                    .. attribute:: attribute_set_name  <key>
                    
                    	Attribute Set Name
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: affinity_mask
                    
                    	Set the affinity flags and mask
                    	**type**\:   :py:class:`AffinityMask <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AffinityMask>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: auto_mesh_logging
                    
                    	Log tunnel LSP messages
                    	**type**\:   :py:class:`AutoMeshLogging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AutoMeshLogging>`
                    
                    .. attribute:: autoroute_announce
                    
                    	Enable autoroute announce
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: bandwidth
                    
                    	Tunnel bandwidth requirement
                    	**type**\:   :py:class:`Bandwidth <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Bandwidth>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: collection_only
                    
                    	Enable bandwidth collection only, no auto\-bw adjustment
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: enable
                    
                    	Attribute\-set enable object that controls whether this attribute\-set is configured or not .This object must be set before other configuration supplied for this attribute\-set
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: fast_reroute
                    
                    	Specify MPLS tunnel can be fast\-rerouted
                    	**type**\:   :py:class:`FastReroute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.FastReroute>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: forward_class
                    
                    	Forward class value
                    	**type**\:  int
                    
                    	**range:** 1..7
                    
                    .. attribute:: interface_bandwidth
                    
                    	The bandwidth of the interface in kbps
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: kbit/s
                    
                    .. attribute:: load_share
                    
                    	Tunnel loadsharing metric
                    	**type**\:  int
                    
                    	**range:** 1..4294967295
                    
                    .. attribute:: new_style_affinity_affinity_types
                    
                    	Tunnel new style affinity attributes table
                    	**type**\:   :py:class:`NewStyleAffinityAffinityTypes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes>`
                    
                    .. attribute:: path_selection
                    
                    	Configure path selection properties
                    	**type**\:   :py:class:`PathSelection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PathSelection>`
                    
                    .. attribute:: policy_classes
                    
                    	Policy classes for PBTS
                    	**type**\:   :py:class:`PolicyClasses <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PolicyClasses>`
                    
                    .. attribute:: priority
                    
                    	Tunnel Setup and Hold Priorities
                    	**type**\:   :py:class:`Priority <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Priority>`
                    
                    	**presence node**\: True
                    
                    .. attribute:: record_route
                    
                    	Record the route used by the tunnel
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: soft_preemption
                    
                    	Enable the soft\-preemption feature on the tunnel
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute, self).__init__()

                        self.yang_name = "auto-mesh-attribute"
                        self.yang_parent_name = "auto-mesh-attributes"

                        self.attribute_set_name = YLeaf(YType.str, "attribute-set-name")

                        self.autoroute_announce = YLeaf(YType.empty, "autoroute-announce")

                        self.collection_only = YLeaf(YType.empty, "collection-only")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.forward_class = YLeaf(YType.uint32, "forward-class")

                        self.interface_bandwidth = YLeaf(YType.uint32, "interface-bandwidth")

                        self.load_share = YLeaf(YType.uint32, "load-share")

                        self.record_route = YLeaf(YType.empty, "record-route")

                        self.soft_preemption = YLeaf(YType.empty, "soft-preemption")

                        self.affinity_mask = None
                        self._children_name_map["affinity_mask"] = "affinity-mask"
                        self._children_yang_names.add("affinity-mask")

                        self.auto_mesh_logging = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AutoMeshLogging()
                        self.auto_mesh_logging.parent = self
                        self._children_name_map["auto_mesh_logging"] = "auto-mesh-logging"
                        self._children_yang_names.add("auto-mesh-logging")

                        self.bandwidth = None
                        self._children_name_map["bandwidth"] = "bandwidth"
                        self._children_yang_names.add("bandwidth")

                        self.fast_reroute = None
                        self._children_name_map["fast_reroute"] = "fast-reroute"
                        self._children_yang_names.add("fast-reroute")

                        self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes()
                        self.new_style_affinity_affinity_types.parent = self
                        self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                        self._children_yang_names.add("new-style-affinity-affinity-types")

                        self.path_selection = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PathSelection()
                        self.path_selection.parent = self
                        self._children_name_map["path_selection"] = "path-selection"
                        self._children_yang_names.add("path-selection")

                        self.policy_classes = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PolicyClasses()
                        self.policy_classes.parent = self
                        self._children_name_map["policy_classes"] = "policy-classes"
                        self._children_yang_names.add("policy-classes")

                        self.priority = None
                        self._children_name_map["priority"] = "priority"
                        self._children_yang_names.add("priority")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("attribute_set_name",
                                        "autoroute_announce",
                                        "collection_only",
                                        "enable",
                                        "forward_class",
                                        "interface_bandwidth",
                                        "load_share",
                                        "record_route",
                                        "soft_preemption") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute, self).__setattr__(name, value)


                    class AutoMeshLogging(Entity):
                        """
                        Log tunnel LSP messages
                        
                        .. attribute:: bandwidth_change_message
                        
                        	Log tunnel messages for bandwidth change
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: insufficient_bw_message
                        
                        	Log tunnel messages for insufficient bandwidth
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: pcalc_failure_message
                        
                        	Enable logging for path\-calculation failures
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimize_attempts_message
                        
                        	Log tunnel reoptimization attempts messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reoptimized_message
                        
                        	Log tunnel reoptimized messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: reroute_messsage
                        
                        	Log tunnel rereoute messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: state_message
                        
                        	Log tunnel state messages
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AutoMeshLogging, self).__init__()

                            self.yang_name = "auto-mesh-logging"
                            self.yang_parent_name = "auto-mesh-attribute"

                            self.bandwidth_change_message = YLeaf(YType.empty, "bandwidth-change-message")

                            self.insufficient_bw_message = YLeaf(YType.empty, "insufficient-bw-message")

                            self.pcalc_failure_message = YLeaf(YType.empty, "pcalc-failure-message")

                            self.reoptimize_attempts_message = YLeaf(YType.empty, "reoptimize-attempts-message")

                            self.reoptimized_message = YLeaf(YType.empty, "reoptimized-message")

                            self.reroute_messsage = YLeaf(YType.empty, "reroute-messsage")

                            self.state_message = YLeaf(YType.empty, "state-message")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth_change_message",
                                            "insufficient_bw_message",
                                            "pcalc_failure_message",
                                            "reoptimize_attempts_message",
                                            "reoptimized_message",
                                            "reroute_messsage",
                                            "state_message") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AutoMeshLogging, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AutoMeshLogging, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bandwidth_change_message.is_set or
                                self.insufficient_bw_message.is_set or
                                self.pcalc_failure_message.is_set or
                                self.reoptimize_attempts_message.is_set or
                                self.reoptimized_message.is_set or
                                self.reroute_messsage.is_set or
                                self.state_message.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth_change_message.yfilter != YFilter.not_set or
                                self.insufficient_bw_message.yfilter != YFilter.not_set or
                                self.pcalc_failure_message.yfilter != YFilter.not_set or
                                self.reoptimize_attempts_message.yfilter != YFilter.not_set or
                                self.reoptimized_message.yfilter != YFilter.not_set or
                                self.reroute_messsage.yfilter != YFilter.not_set or
                                self.state_message.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "auto-mesh-logging" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth_change_message.is_set or self.bandwidth_change_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth_change_message.get_name_leafdata())
                            if (self.insufficient_bw_message.is_set or self.insufficient_bw_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.insufficient_bw_message.get_name_leafdata())
                            if (self.pcalc_failure_message.is_set or self.pcalc_failure_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.pcalc_failure_message.get_name_leafdata())
                            if (self.reoptimize_attempts_message.is_set or self.reoptimize_attempts_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimize_attempts_message.get_name_leafdata())
                            if (self.reoptimized_message.is_set or self.reoptimized_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reoptimized_message.get_name_leafdata())
                            if (self.reroute_messsage.is_set or self.reroute_messsage.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.reroute_messsage.get_name_leafdata())
                            if (self.state_message.is_set or self.state_message.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.state_message.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth-change-message" or name == "insufficient-bw-message" or name == "pcalc-failure-message" or name == "reoptimize-attempts-message" or name == "reoptimized-message" or name == "reroute-messsage" or name == "state-message"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth-change-message"):
                                self.bandwidth_change_message = value
                                self.bandwidth_change_message.value_namespace = name_space
                                self.bandwidth_change_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "insufficient-bw-message"):
                                self.insufficient_bw_message = value
                                self.insufficient_bw_message.value_namespace = name_space
                                self.insufficient_bw_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "pcalc-failure-message"):
                                self.pcalc_failure_message = value
                                self.pcalc_failure_message.value_namespace = name_space
                                self.pcalc_failure_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimize-attempts-message"):
                                self.reoptimize_attempts_message = value
                                self.reoptimize_attempts_message.value_namespace = name_space
                                self.reoptimize_attempts_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reoptimized-message"):
                                self.reoptimized_message = value
                                self.reoptimized_message.value_namespace = name_space
                                self.reoptimized_message.value_namespace_prefix = name_space_prefix
                            if(value_path == "reroute-messsage"):
                                self.reroute_messsage = value
                                self.reroute_messsage.value_namespace = name_space
                                self.reroute_messsage.value_namespace_prefix = name_space_prefix
                            if(value_path == "state-message"):
                                self.state_message = value
                                self.state_message.value_namespace = name_space
                                self.state_message.value_namespace_prefix = name_space_prefix


                    class Priority(Entity):
                        """
                        Tunnel Setup and Hold Priorities
                        
                        .. attribute:: hold_priority
                        
                        	Hold Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        .. attribute:: setup_priority
                        
                        	Setup Priority
                        	**type**\:  int
                        
                        	**range:** 0..7
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Priority, self).__init__()

                            self.yang_name = "priority"
                            self.yang_parent_name = "auto-mesh-attribute"
                            self.is_presence_container = True

                            self.hold_priority = YLeaf(YType.uint32, "hold-priority")

                            self.setup_priority = YLeaf(YType.uint32, "setup-priority")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("hold_priority",
                                            "setup_priority") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Priority, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Priority, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.hold_priority.is_set or
                                self.setup_priority.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.hold_priority.yfilter != YFilter.not_set or
                                self.setup_priority.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "priority" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.hold_priority.is_set or self.hold_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.hold_priority.get_name_leafdata())
                            if (self.setup_priority.is_set or self.setup_priority.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.setup_priority.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "hold-priority" or name == "setup-priority"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "hold-priority"):
                                self.hold_priority = value
                                self.hold_priority.value_namespace = name_space
                                self.hold_priority.value_namespace_prefix = name_space_prefix
                            if(value_path == "setup-priority"):
                                self.setup_priority = value
                                self.setup_priority.value_namespace = name_space
                                self.setup_priority.value_namespace_prefix = name_space_prefix


                    class AffinityMask(Entity):
                        """
                        Set the affinity flags and mask
                        
                        .. attribute:: affinity
                        
                        	Affinity flags
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        .. attribute:: mask
                        
                        	Affinity mask
                        	**type**\:  str
                        
                        	**pattern:** [0\-9a\-fA\-F]{1,8}
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AffinityMask, self).__init__()

                            self.yang_name = "affinity-mask"
                            self.yang_parent_name = "auto-mesh-attribute"
                            self.is_presence_container = True

                            self.affinity = YLeaf(YType.str, "affinity")

                            self.mask = YLeaf(YType.str, "mask")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("affinity",
                                            "mask") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AffinityMask, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AffinityMask, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.affinity.is_set or
                                self.mask.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.affinity.yfilter != YFilter.not_set or
                                self.mask.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "affinity-mask" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.affinity.is_set or self.affinity.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.affinity.get_name_leafdata())
                            if (self.mask.is_set or self.mask.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.mask.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "affinity" or name == "mask"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "affinity"):
                                self.affinity = value
                                self.affinity.value_namespace = name_space
                                self.affinity.value_namespace_prefix = name_space_prefix
                            if(value_path == "mask"):
                                self.mask = value
                                self.mask.value_namespace = name_space
                                self.mask.value_namespace_prefix = name_space_prefix


                    class Bandwidth(Entity):
                        """
                        Tunnel bandwidth requirement
                        
                        .. attribute:: bandwidth
                        
                        	The value of the bandwidth reserved by this tunnel in kbps
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        	**mandatory**\: True
                        
                        	**units**\: kbit/s
                        
                        .. attribute:: class_or_pool_type
                        
                        	Class type for the bandwidth allocation
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        .. attribute:: dste_type
                        
                        	DSTE\-standard flag
                        	**type**\:   :py:class:`MplsTeBandwidthDste <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeBandwidthDste>`
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Bandwidth, self).__init__()

                            self.yang_name = "bandwidth"
                            self.yang_parent_name = "auto-mesh-attribute"
                            self.is_presence_container = True

                            self.bandwidth = YLeaf(YType.uint32, "bandwidth")

                            self.class_or_pool_type = YLeaf(YType.uint32, "class-or-pool-type")

                            self.dste_type = YLeaf(YType.enumeration, "dste-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth",
                                            "class_or_pool_type",
                                            "dste_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Bandwidth, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Bandwidth, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bandwidth.is_set or
                                self.class_or_pool_type.is_set or
                                self.dste_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth.yfilter != YFilter.not_set or
                                self.class_or_pool_type.yfilter != YFilter.not_set or
                                self.dste_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "bandwidth" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth.is_set or self.bandwidth.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth.get_name_leafdata())
                            if (self.class_or_pool_type.is_set or self.class_or_pool_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.class_or_pool_type.get_name_leafdata())
                            if (self.dste_type.is_set or self.dste_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.dste_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth" or name == "class-or-pool-type" or name == "dste-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth"):
                                self.bandwidth = value
                                self.bandwidth.value_namespace = name_space
                                self.bandwidth.value_namespace_prefix = name_space_prefix
                            if(value_path == "class-or-pool-type"):
                                self.class_or_pool_type = value
                                self.class_or_pool_type.value_namespace = name_space
                                self.class_or_pool_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "dste-type"):
                                self.dste_type = value
                                self.dste_type.value_namespace = name_space
                                self.dste_type.value_namespace_prefix = name_space_prefix


                    class PathSelection(Entity):
                        """
                        Configure path selection properties
                        
                        .. attribute:: enable
                        
                        	Enable path selection
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PathSelection, self).__init__()

                            self.yang_name = "path-selection"
                            self.yang_parent_name = "auto-mesh-attribute"

                            self.enable = YLeaf(YType.empty, "enable")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PathSelection, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PathSelection, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enable.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-selection" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix


                    class PolicyClasses(Entity):
                        """
                        Policy classes for PBTS
                        
                        .. attribute:: policy_class
                        
                        	Array of Policy class
                        	**type**\:  list of int
                        
                        	**range:** 1..8
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PolicyClasses, self).__init__()

                            self.yang_name = "policy-classes"
                            self.yang_parent_name = "auto-mesh-attribute"

                            self.policy_class = YLeafList(YType.uint32, "policy-class")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("policy_class") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PolicyClasses, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PolicyClasses, self).__setattr__(name, value)

                        def has_data(self):
                            for leaf in self.policy_class.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return False

                        def has_operation(self):
                            for leaf in self.policy_class.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.policy_class.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "policy-classes" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            leaf_name_data.extend(self.policy_class.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "policy-class"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "policy-class"):
                                self.policy_class.append(value)


                    class NewStyleAffinityAffinityTypes(Entity):
                        """
                        Tunnel new style affinity attributes table
                        
                        .. attribute:: new_style_affinity_affinity_type
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityType <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>`
                        
                        .. attribute:: new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10
                        
                        	Tunnel new style affinity attribute
                        	**type**\: list of    :py:class:`NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10 <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes, self).__init__()

                            self.yang_name = "new-style-affinity-affinity-types"
                            self.yang_parent_name = "auto-mesh-attribute"

                            self.new_style_affinity_affinity_type = YList(self)
                            self.new_style_affinity_affinity_type_affinity1 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9 = YList(self)
                            self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10 = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes, self).__setattr__(name, value)


                        class NewStyleAffinityAffinityType(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType, self).__setattr__(name, value)

                            def has_data(self):
                                return self.affinity_type.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type" + "[affinity-type='" + self.affinity_type.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix


                        class NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10(Entity):
                            """
                            Tunnel new style affinity attribute
                            
                            .. attribute:: affinity_type  <key>
                            
                            	The type of the affinity entry
                            	**type**\:   :py:class:`MplsTeTunnelAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeTunnelAffinity>`
                            
                            .. attribute:: affinity1  <key>
                            
                            	The name of the first affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity2  <key>
                            
                            	The name of the second affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity3  <key>
                            
                            	The name of the third affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity4  <key>
                            
                            	The name of the fourth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity5  <key>
                            
                            	The name of the fifth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity6  <key>
                            
                            	The name of the sixth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity7  <key>
                            
                            	The name of the seventh affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity8  <key>
                            
                            	The name of the eighth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity9  <key>
                            
                            	The name of the nineth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            .. attribute:: affinity10  <key>
                            
                            	The name of the tenth affinity
                            	**type**\:  str
                            
                            	**pattern:** [\\w\\\-\\.\:,\_@#%$\\+=\\\|;]+
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__init__()

                                self.yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"
                                self.yang_parent_name = "new-style-affinity-affinity-types"

                                self.affinity_type = YLeaf(YType.enumeration, "affinity-type")

                                self.affinity1 = YLeaf(YType.str, "affinity1")

                                self.affinity2 = YLeaf(YType.str, "affinity2")

                                self.affinity3 = YLeaf(YType.str, "affinity3")

                                self.affinity4 = YLeaf(YType.str, "affinity4")

                                self.affinity5 = YLeaf(YType.str, "affinity5")

                                self.affinity6 = YLeaf(YType.str, "affinity6")

                                self.affinity7 = YLeaf(YType.str, "affinity7")

                                self.affinity8 = YLeaf(YType.str, "affinity8")

                                self.affinity9 = YLeaf(YType.str, "affinity9")

                                self.affinity10 = YLeaf(YType.str, "affinity10")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("affinity_type",
                                                "affinity1",
                                                "affinity2",
                                                "affinity3",
                                                "affinity4",
                                                "affinity5",
                                                "affinity6",
                                                "affinity7",
                                                "affinity8",
                                                "affinity9",
                                                "affinity10") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10, self).__setattr__(name, value)

                            def has_data(self):
                                return (
                                    self.affinity_type.is_set or
                                    self.affinity1.is_set or
                                    self.affinity2.is_set or
                                    self.affinity3.is_set or
                                    self.affinity4.is_set or
                                    self.affinity5.is_set or
                                    self.affinity6.is_set or
                                    self.affinity7.is_set or
                                    self.affinity8.is_set or
                                    self.affinity9.is_set or
                                    self.affinity10.is_set)

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.affinity_type.yfilter != YFilter.not_set or
                                    self.affinity1.yfilter != YFilter.not_set or
                                    self.affinity2.yfilter != YFilter.not_set or
                                    self.affinity3.yfilter != YFilter.not_set or
                                    self.affinity4.yfilter != YFilter.not_set or
                                    self.affinity5.yfilter != YFilter.not_set or
                                    self.affinity6.yfilter != YFilter.not_set or
                                    self.affinity7.yfilter != YFilter.not_set or
                                    self.affinity8.yfilter != YFilter.not_set or
                                    self.affinity9.yfilter != YFilter.not_set or
                                    self.affinity10.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" + "[affinity-type='" + self.affinity_type.get() + "']" + "[affinity1='" + self.affinity1.get() + "']" + "[affinity2='" + self.affinity2.get() + "']" + "[affinity3='" + self.affinity3.get() + "']" + "[affinity4='" + self.affinity4.get() + "']" + "[affinity5='" + self.affinity5.get() + "']" + "[affinity6='" + self.affinity6.get() + "']" + "[affinity7='" + self.affinity7.get() + "']" + "[affinity8='" + self.affinity8.get() + "']" + "[affinity9='" + self.affinity9.get() + "']" + "[affinity10='" + self.affinity10.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.affinity_type.is_set or self.affinity_type.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity_type.get_name_leafdata())
                                if (self.affinity1.is_set or self.affinity1.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity1.get_name_leafdata())
                                if (self.affinity2.is_set or self.affinity2.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity2.get_name_leafdata())
                                if (self.affinity3.is_set or self.affinity3.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity3.get_name_leafdata())
                                if (self.affinity4.is_set or self.affinity4.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity4.get_name_leafdata())
                                if (self.affinity5.is_set or self.affinity5.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity5.get_name_leafdata())
                                if (self.affinity6.is_set or self.affinity6.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity6.get_name_leafdata())
                                if (self.affinity7.is_set or self.affinity7.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity7.get_name_leafdata())
                                if (self.affinity8.is_set or self.affinity8.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity8.get_name_leafdata())
                                if (self.affinity9.is_set or self.affinity9.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity9.get_name_leafdata())
                                if (self.affinity10.is_set or self.affinity10.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.affinity10.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "affinity-type" or name == "affinity1" or name == "affinity2" or name == "affinity3" or name == "affinity4" or name == "affinity5" or name == "affinity6" or name == "affinity7" or name == "affinity8" or name == "affinity9" or name == "affinity10"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "affinity-type"):
                                    self.affinity_type = value
                                    self.affinity_type.value_namespace = name_space
                                    self.affinity_type.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity1"):
                                    self.affinity1 = value
                                    self.affinity1.value_namespace = name_space
                                    self.affinity1.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity2"):
                                    self.affinity2 = value
                                    self.affinity2.value_namespace = name_space
                                    self.affinity2.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity3"):
                                    self.affinity3 = value
                                    self.affinity3.value_namespace = name_space
                                    self.affinity3.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity4"):
                                    self.affinity4 = value
                                    self.affinity4.value_namespace = name_space
                                    self.affinity4.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity5"):
                                    self.affinity5 = value
                                    self.affinity5.value_namespace = name_space
                                    self.affinity5.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity6"):
                                    self.affinity6 = value
                                    self.affinity6.value_namespace = name_space
                                    self.affinity6.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity7"):
                                    self.affinity7 = value
                                    self.affinity7.value_namespace = name_space
                                    self.affinity7.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity8"):
                                    self.affinity8 = value
                                    self.affinity8.value_namespace = name_space
                                    self.affinity8.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity9"):
                                    self.affinity9 = value
                                    self.affinity9.value_namespace = name_space
                                    self.affinity9.value_namespace_prefix = name_space_prefix
                                if(value_path == "affinity10"):
                                    self.affinity10 = value
                                    self.affinity10.value_namespace = name_space
                                    self.affinity10.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_data()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.new_style_affinity_affinity_type:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                if (c.has_operation()):
                                    return True
                            for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "new-style-affinity-affinity-types" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "new-style-affinity-affinity-type"):
                                for c in self.new_style_affinity_affinity_type:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityType()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1"):
                                for c in self.new_style_affinity_affinity_type_affinity1:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.append(c)
                                return c

                            if (child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                for c in self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes.NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "new-style-affinity-affinity-type" or name == "new-style-affinity-affinity-type-affinity1" or name == "new-style-affinity-affinity-type-affinity1-affinity2" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" or name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class FastReroute(Entity):
                        """
                        Specify MPLS tunnel can be fast\-rerouted
                        
                        .. attribute:: bandwidth_protection
                        
                        	Bandwidth Protection
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        .. attribute:: node_protection
                        
                        	Node Protection
                        	**type**\:  int
                        
                        	**range:** 0..1
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.FastReroute, self).__init__()

                            self.yang_name = "fast-reroute"
                            self.yang_parent_name = "auto-mesh-attribute"
                            self.is_presence_container = True

                            self.bandwidth_protection = YLeaf(YType.uint32, "bandwidth-protection")

                            self.node_protection = YLeaf(YType.uint32, "node-protection")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("bandwidth_protection",
                                            "node_protection") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.FastReroute, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.FastReroute, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.bandwidth_protection.is_set or
                                self.node_protection.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.bandwidth_protection.yfilter != YFilter.not_set or
                                self.node_protection.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "fast-reroute" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.bandwidth_protection.is_set or self.bandwidth_protection.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.bandwidth_protection.get_name_leafdata())
                            if (self.node_protection.is_set or self.node_protection.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.node_protection.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "bandwidth-protection" or name == "node-protection"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "bandwidth-protection"):
                                self.bandwidth_protection = value
                                self.bandwidth_protection.value_namespace = name_space
                                self.bandwidth_protection.value_namespace_prefix = name_space_prefix
                            if(value_path == "node-protection"):
                                self.node_protection = value
                                self.node_protection.value_namespace = name_space
                                self.node_protection.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.attribute_set_name.is_set or
                            self.autoroute_announce.is_set or
                            self.collection_only.is_set or
                            self.enable.is_set or
                            self.forward_class.is_set or
                            self.interface_bandwidth.is_set or
                            self.load_share.is_set or
                            self.record_route.is_set or
                            self.soft_preemption.is_set or
                            (self.auto_mesh_logging is not None and self.auto_mesh_logging.has_data()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_data()) or
                            (self.path_selection is not None and self.path_selection.has_data()) or
                            (self.policy_classes is not None and self.policy_classes.has_data()) or
                            (self.affinity_mask is not None) or
                            (self.bandwidth is not None) or
                            (self.fast_reroute is not None) or
                            (self.priority is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.attribute_set_name.yfilter != YFilter.not_set or
                            self.autoroute_announce.yfilter != YFilter.not_set or
                            self.collection_only.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.forward_class.yfilter != YFilter.not_set or
                            self.interface_bandwidth.yfilter != YFilter.not_set or
                            self.load_share.yfilter != YFilter.not_set or
                            self.record_route.yfilter != YFilter.not_set or
                            self.soft_preemption.yfilter != YFilter.not_set or
                            (self.affinity_mask is not None and self.affinity_mask.has_operation()) or
                            (self.auto_mesh_logging is not None and self.auto_mesh_logging.has_operation()) or
                            (self.bandwidth is not None and self.bandwidth.has_operation()) or
                            (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                            (self.new_style_affinity_affinity_types is not None and self.new_style_affinity_affinity_types.has_operation()) or
                            (self.path_selection is not None and self.path_selection.has_operation()) or
                            (self.policy_classes is not None and self.policy_classes.has_operation()) or
                            (self.priority is not None and self.priority.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "auto-mesh-attribute" + "[attribute-set-name='" + self.attribute_set_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/auto-mesh-attributes/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.attribute_set_name.is_set or self.attribute_set_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.attribute_set_name.get_name_leafdata())
                        if (self.autoroute_announce.is_set or self.autoroute_announce.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.autoroute_announce.get_name_leafdata())
                        if (self.collection_only.is_set or self.collection_only.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.collection_only.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.forward_class.is_set or self.forward_class.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.forward_class.get_name_leafdata())
                        if (self.interface_bandwidth.is_set or self.interface_bandwidth.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_bandwidth.get_name_leafdata())
                        if (self.load_share.is_set or self.load_share.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.load_share.get_name_leafdata())
                        if (self.record_route.is_set or self.record_route.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.record_route.get_name_leafdata())
                        if (self.soft_preemption.is_set or self.soft_preemption.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.soft_preemption.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "affinity-mask"):
                            if (self.affinity_mask is None):
                                self.affinity_mask = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AffinityMask()
                                self.affinity_mask.parent = self
                                self._children_name_map["affinity_mask"] = "affinity-mask"
                            return self.affinity_mask

                        if (child_yang_name == "auto-mesh-logging"):
                            if (self.auto_mesh_logging is None):
                                self.auto_mesh_logging = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.AutoMeshLogging()
                                self.auto_mesh_logging.parent = self
                                self._children_name_map["auto_mesh_logging"] = "auto-mesh-logging"
                            return self.auto_mesh_logging

                        if (child_yang_name == "bandwidth"):
                            if (self.bandwidth is None):
                                self.bandwidth = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Bandwidth()
                                self.bandwidth.parent = self
                                self._children_name_map["bandwidth"] = "bandwidth"
                            return self.bandwidth

                        if (child_yang_name == "fast-reroute"):
                            if (self.fast_reroute is None):
                                self.fast_reroute = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.FastReroute()
                                self.fast_reroute.parent = self
                                self._children_name_map["fast_reroute"] = "fast-reroute"
                            return self.fast_reroute

                        if (child_yang_name == "new-style-affinity-affinity-types"):
                            if (self.new_style_affinity_affinity_types is None):
                                self.new_style_affinity_affinity_types = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.NewStyleAffinityAffinityTypes()
                                self.new_style_affinity_affinity_types.parent = self
                                self._children_name_map["new_style_affinity_affinity_types"] = "new-style-affinity-affinity-types"
                            return self.new_style_affinity_affinity_types

                        if (child_yang_name == "path-selection"):
                            if (self.path_selection is None):
                                self.path_selection = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PathSelection()
                                self.path_selection.parent = self
                                self._children_name_map["path_selection"] = "path-selection"
                            return self.path_selection

                        if (child_yang_name == "policy-classes"):
                            if (self.policy_classes is None):
                                self.policy_classes = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.PolicyClasses()
                                self.policy_classes.parent = self
                                self._children_name_map["policy_classes"] = "policy-classes"
                            return self.policy_classes

                        if (child_yang_name == "priority"):
                            if (self.priority is None):
                                self.priority = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute.Priority()
                                self.priority.parent = self
                                self._children_name_map["priority"] = "priority"
                            return self.priority

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "affinity-mask" or name == "auto-mesh-logging" or name == "bandwidth" or name == "fast-reroute" or name == "new-style-affinity-affinity-types" or name == "path-selection" or name == "policy-classes" or name == "priority" or name == "attribute-set-name" or name == "autoroute-announce" or name == "collection-only" or name == "enable" or name == "forward-class" or name == "interface-bandwidth" or name == "load-share" or name == "record-route" or name == "soft-preemption"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "attribute-set-name"):
                            self.attribute_set_name = value
                            self.attribute_set_name.value_namespace = name_space
                            self.attribute_set_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "autoroute-announce"):
                            self.autoroute_announce = value
                            self.autoroute_announce.value_namespace = name_space
                            self.autoroute_announce.value_namespace_prefix = name_space_prefix
                        if(value_path == "collection-only"):
                            self.collection_only = value
                            self.collection_only.value_namespace = name_space
                            self.collection_only.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "forward-class"):
                            self.forward_class = value
                            self.forward_class.value_namespace = name_space
                            self.forward_class.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-bandwidth"):
                            self.interface_bandwidth = value
                            self.interface_bandwidth.value_namespace = name_space
                            self.interface_bandwidth.value_namespace_prefix = name_space_prefix
                        if(value_path == "load-share"):
                            self.load_share = value
                            self.load_share.value_namespace = name_space
                            self.load_share.value_namespace_prefix = name_space_prefix
                        if(value_path == "record-route"):
                            self.record_route = value
                            self.record_route.value_namespace = name_space
                            self.record_route.value_namespace_prefix = name_space_prefix
                        if(value_path == "soft-preemption"):
                            self.soft_preemption = value
                            self.soft_preemption.value_namespace = name_space
                            self.soft_preemption.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.auto_mesh_attribute:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.auto_mesh_attribute:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "auto-mesh-attributes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "auto-mesh-attribute"):
                        for c in self.auto_mesh_attribute:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes.AutoMeshAttribute()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.auto_mesh_attribute.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "auto-mesh-attribute"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class XroAttributes(Entity):
                """
                XRO Tunnel Attributes table
                
                .. attribute:: xro_attribute
                
                	XRO Attribute
                	**type**\: list of    :py:class:`XroAttribute <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes, self).__init__()

                    self.yang_name = "xro-attributes"
                    self.yang_parent_name = "attribute-set"

                    self.xro_attribute = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes, self).__setattr__(name, value)


                class XroAttribute(Entity):
                    """
                    XRO Attribute
                    
                    .. attribute:: attribute_set_name  <key>
                    
                    	Attribute Set Name
                    	**type**\:  str
                    
                    	**length:** 1..64
                    
                    .. attribute:: enable
                    
                    	Attribute\-set enable object that controls whether this attribute\-set is configured or not .This object must be set before other configuration supplied for this attribute\-set
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: path_diversity
                    
                    	Path diversity
                    	**type**\:   :py:class:`PathDiversity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity>`
                    
                    .. attribute:: path_selection
                    
                    	Configure path selection properties
                    	**type**\:   :py:class:`PathSelection <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathSelection>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute, self).__init__()

                        self.yang_name = "xro-attribute"
                        self.yang_parent_name = "xro-attributes"

                        self.attribute_set_name = YLeaf(YType.str, "attribute-set-name")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.path_diversity = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity()
                        self.path_diversity.parent = self
                        self._children_name_map["path_diversity"] = "path-diversity"
                        self._children_yang_names.add("path-diversity")

                        self.path_selection = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathSelection()
                        self.path_selection.parent = self
                        self._children_name_map["path_selection"] = "path-selection"
                        self._children_yang_names.add("path-selection")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("attribute_set_name",
                                        "enable") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute, self).__setattr__(name, value)


                    class PathDiversity(Entity):
                        """
                        Path diversity
                        
                        .. attribute:: lsp
                        
                        	LSP\-based path diversity
                        	**type**\:   :py:class:`Lsp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp>`
                        
                        .. attribute:: srlgs
                        
                        	SRLG\-based path diversity
                        	**type**\:   :py:class:`Srlgs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity, self).__init__()

                            self.yang_name = "path-diversity"
                            self.yang_parent_name = "xro-attribute"

                            self.lsp = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp()
                            self.lsp.parent = self
                            self._children_name_map["lsp"] = "lsp"
                            self._children_yang_names.add("lsp")

                            self.srlgs = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs()
                            self.srlgs.parent = self
                            self._children_name_map["srlgs"] = "srlgs"
                            self._children_yang_names.add("srlgs")


                        class Srlgs(Entity):
                            """
                            SRLG\-based path diversity
                            
                            .. attribute:: srlg
                            
                            	SRLG\-based path\-diversity element
                            	**type**\: list of    :py:class:`Srlg <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs.Srlg>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs, self).__init__()

                                self.yang_name = "srlgs"
                                self.yang_parent_name = "path-diversity"

                                self.srlg = YList(self)

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in () and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs, self).__setattr__(name, value)


                            class Srlg(Entity):
                                """
                                SRLG\-based path\-diversity element
                                
                                .. attribute:: srlg  <key>
                                
                                	SRLG
                                	**type**\:  int
                                
                                	**range:** 0..4294967295
                                
                                .. attribute:: conformance
                                
                                	The diversity conformance requirements
                                	**type**\:   :py:class:`MplsTePathDiversityConformance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathDiversityConformance>`
                                
                                	**mandatory**\: True
                                
                                

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs.Srlg, self).__init__()

                                    self.yang_name = "srlg"
                                    self.yang_parent_name = "srlgs"

                                    self.srlg = YLeaf(YType.uint32, "srlg")

                                    self.conformance = YLeaf(YType.enumeration, "conformance")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("srlg",
                                                    "conformance") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs.Srlg, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs.Srlg, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.srlg.is_set or
                                        self.conformance.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.srlg.yfilter != YFilter.not_set or
                                        self.conformance.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "srlg" + "[srlg='" + self.srlg.get() + "']" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.srlg.is_set or self.srlg.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.srlg.get_name_leafdata())
                                    if (self.conformance.is_set or self.conformance.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.conformance.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "srlg" or name == "conformance"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "srlg"):
                                        self.srlg = value
                                        self.srlg.value_namespace = name_space
                                        self.srlg.value_namespace_prefix = name_space_prefix
                                    if(value_path == "conformance"):
                                        self.conformance = value
                                        self.conformance.value_namespace = name_space
                                        self.conformance.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                for c in self.srlg:
                                    if (c.has_data()):
                                        return True
                                return False

                            def has_operation(self):
                                for c in self.srlg:
                                    if (c.has_operation()):
                                        return True
                                return self.yfilter != YFilter.not_set

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "srlgs" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "srlg"):
                                    for c in self.srlg:
                                        segment = c.get_segment_path()
                                        if (segment_path == segment):
                                            return c
                                    c = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs.Srlg()
                                    c.parent = self
                                    local_reference_key = "ydk::seg::%s" % segment_path
                                    self._local_refs[local_reference_key] = c
                                    self.srlg.append(c)
                                    return c

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "srlg"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass


                        class Lsp(Entity):
                            """
                            LSP\-based path diversity
                            
                            .. attribute:: fecs
                            
                            	FEC LSP\-based path diversity
                            	**type**\:   :py:class:`Fecs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp, self).__init__()

                                self.yang_name = "lsp"
                                self.yang_parent_name = "path-diversity"

                                self.fecs = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs()
                                self.fecs.parent = self
                                self._children_name_map["fecs"] = "fecs"
                                self._children_yang_names.add("fecs")


                            class Fecs(Entity):
                                """
                                FEC LSP\-based path diversity
                                
                                .. attribute:: fec
                                
                                	LSP\-based path\-diversity, referenced by FEC
                                	**type**\: list of    :py:class:`Fec <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs.Fec>`
                                
                                

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs, self).__init__()

                                    self.yang_name = "fecs"
                                    self.yang_parent_name = "lsp"

                                    self.fec = YList(self)

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in () and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs, self).__setattr__(name, value)


                                class Fec(Entity):
                                    """
                                    LSP\-based path\-diversity, referenced by
                                    FEC
                                    
                                    .. attribute:: source  <key>
                                    
                                    	Source address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: destination  <key>
                                    
                                    	Destination address
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: tunnel_id  <key>
                                    
                                    	Tunnel id
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: extended_tunnel_id  <key>
                                    
                                    	Extended tunnel\-id
                                    	**type**\:  str
                                    
                                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                                    
                                    .. attribute:: lsp_id  <key>
                                    
                                    	LSP id
                                    	**type**\:  int
                                    
                                    	**range:** 0..65535
                                    
                                    .. attribute:: conformance
                                    
                                    	The diversity conformance requirements
                                    	**type**\:   :py:class:`MplsTePathDiversityConformance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathDiversityConformance>`
                                    
                                    	**mandatory**\: True
                                    
                                    

                                    """

                                    _prefix = 'mpls-te-cfg'
                                    _revision = '2015-11-09'

                                    def __init__(self):
                                        super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs.Fec, self).__init__()

                                        self.yang_name = "fec"
                                        self.yang_parent_name = "fecs"

                                        self.source = YLeaf(YType.str, "source")

                                        self.destination = YLeaf(YType.str, "destination")

                                        self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                                        self.extended_tunnel_id = YLeaf(YType.str, "extended-tunnel-id")

                                        self.lsp_id = YLeaf(YType.uint32, "lsp-id")

                                        self.conformance = YLeaf(YType.enumeration, "conformance")

                                    def __setattr__(self, name, value):
                                        self._check_monkey_patching_error(name, value)
                                        with _handle_type_error():
                                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                    "Please use list append or extend method."
                                                                    .format(value))
                                            if isinstance(value, Enum.YLeaf):
                                                value = value.name
                                            if name in ("source",
                                                        "destination",
                                                        "tunnel_id",
                                                        "extended_tunnel_id",
                                                        "lsp_id",
                                                        "conformance") and name in self.__dict__:
                                                if isinstance(value, YLeaf):
                                                    self.__dict__[name].set(value.get())
                                                elif isinstance(value, YLeafList):
                                                    super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs.Fec, self).__setattr__(name, value)
                                                else:
                                                    self.__dict__[name].set(value)
                                            else:
                                                if hasattr(value, "parent") and name != "parent":
                                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                        value.parent = self
                                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                                        value.parent = self
                                                super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs.Fec, self).__setattr__(name, value)

                                    def has_data(self):
                                        return (
                                            self.source.is_set or
                                            self.destination.is_set or
                                            self.tunnel_id.is_set or
                                            self.extended_tunnel_id.is_set or
                                            self.lsp_id.is_set or
                                            self.conformance.is_set)

                                    def has_operation(self):
                                        return (
                                            self.yfilter != YFilter.not_set or
                                            self.source.yfilter != YFilter.not_set or
                                            self.destination.yfilter != YFilter.not_set or
                                            self.tunnel_id.yfilter != YFilter.not_set or
                                            self.extended_tunnel_id.yfilter != YFilter.not_set or
                                            self.lsp_id.yfilter != YFilter.not_set or
                                            self.conformance.yfilter != YFilter.not_set)

                                    def get_segment_path(self):
                                        path_buffer = ""
                                        path_buffer = "fec" + "[source='" + self.source.get() + "']" + "[destination='" + self.destination.get() + "']" + "[tunnel-id='" + self.tunnel_id.get() + "']" + "[extended-tunnel-id='" + self.extended_tunnel_id.get() + "']" + "[lsp-id='" + self.lsp_id.get() + "']" + path_buffer

                                        return path_buffer

                                    def get_entity_path(self, ancestor):
                                        path_buffer = ""
                                        if (ancestor is None):
                                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                        else:
                                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                        leaf_name_data = LeafDataList()
                                        if (self.source.is_set or self.source.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.source.get_name_leafdata())
                                        if (self.destination.is_set or self.destination.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.destination.get_name_leafdata())
                                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())
                                        if (self.extended_tunnel_id.is_set or self.extended_tunnel_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.extended_tunnel_id.get_name_leafdata())
                                        if (self.lsp_id.is_set or self.lsp_id.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.lsp_id.get_name_leafdata())
                                        if (self.conformance.is_set or self.conformance.yfilter != YFilter.not_set):
                                            leaf_name_data.append(self.conformance.get_name_leafdata())

                                        entity_path = EntityPath(path_buffer, leaf_name_data)
                                        return entity_path

                                    def get_child_by_name(self, child_yang_name, segment_path):
                                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                        if child is not None:
                                            return child

                                        return None

                                    def has_leaf_or_child_of_name(self, name):
                                        if(name == "source" or name == "destination" or name == "tunnel-id" or name == "extended-tunnel-id" or name == "lsp-id" or name == "conformance"):
                                            return True
                                        return False

                                    def set_value(self, value_path, value, name_space, name_space_prefix):
                                        if(value_path == "source"):
                                            self.source = value
                                            self.source.value_namespace = name_space
                                            self.source.value_namespace_prefix = name_space_prefix
                                        if(value_path == "destination"):
                                            self.destination = value
                                            self.destination.value_namespace = name_space
                                            self.destination.value_namespace_prefix = name_space_prefix
                                        if(value_path == "tunnel-id"):
                                            self.tunnel_id = value
                                            self.tunnel_id.value_namespace = name_space
                                            self.tunnel_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "extended-tunnel-id"):
                                            self.extended_tunnel_id = value
                                            self.extended_tunnel_id.value_namespace = name_space
                                            self.extended_tunnel_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "lsp-id"):
                                            self.lsp_id = value
                                            self.lsp_id.value_namespace = name_space
                                            self.lsp_id.value_namespace_prefix = name_space_prefix
                                        if(value_path == "conformance"):
                                            self.conformance = value
                                            self.conformance.value_namespace = name_space
                                            self.conformance.value_namespace_prefix = name_space_prefix

                                def has_data(self):
                                    for c in self.fec:
                                        if (c.has_data()):
                                            return True
                                    return False

                                def has_operation(self):
                                    for c in self.fec:
                                        if (c.has_operation()):
                                            return True
                                    return self.yfilter != YFilter.not_set

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "fecs" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    if (child_yang_name == "fec"):
                                        for c in self.fec:
                                            segment = c.get_segment_path()
                                            if (segment_path == segment):
                                                return c
                                        c = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs.Fec()
                                        c.parent = self
                                        local_reference_key = "ydk::seg::%s" % segment_path
                                        self._local_refs[local_reference_key] = c
                                        self.fec.append(c)
                                        return c

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "fec"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    pass

                            def has_data(self):
                                return (self.fecs is not None and self.fecs.has_data())

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    (self.fecs is not None and self.fecs.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "lsp" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "fecs"):
                                    if (self.fecs is None):
                                        self.fecs = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp.Fecs()
                                        self.fecs.parent = self
                                        self._children_name_map["fecs"] = "fecs"
                                    return self.fecs

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "fecs"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                pass

                        def has_data(self):
                            return (
                                (self.lsp is not None and self.lsp.has_data()) or
                                (self.srlgs is not None and self.srlgs.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                (self.lsp is not None and self.lsp.has_operation()) or
                                (self.srlgs is not None and self.srlgs.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-diversity" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "lsp"):
                                if (self.lsp is None):
                                    self.lsp = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Lsp()
                                    self.lsp.parent = self
                                    self._children_name_map["lsp"] = "lsp"
                                return self.lsp

                            if (child_yang_name == "srlgs"):
                                if (self.srlgs is None):
                                    self.srlgs = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity.Srlgs()
                                    self.srlgs.parent = self
                                    self._children_name_map["srlgs"] = "srlgs"
                                return self.srlgs

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "lsp" or name == "srlgs"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass


                    class PathSelection(Entity):
                        """
                        Configure path selection properties
                        
                        .. attribute:: enable
                        
                        	Enable path selection
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathSelection, self).__init__()

                            self.yang_name = "path-selection"
                            self.yang_parent_name = "xro-attribute"

                            self.enable = YLeaf(YType.empty, "enable")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("enable") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathSelection, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathSelection, self).__setattr__(name, value)

                        def has_data(self):
                            return self.enable.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-selection" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "enable"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.attribute_set_name.is_set or
                            self.enable.is_set or
                            (self.path_diversity is not None and self.path_diversity.has_data()) or
                            (self.path_selection is not None and self.path_selection.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.attribute_set_name.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            (self.path_diversity is not None and self.path_diversity.has_operation()) or
                            (self.path_selection is not None and self.path_selection.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "xro-attribute" + "[attribute-set-name='" + self.attribute_set_name.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/xro-attributes/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.attribute_set_name.is_set or self.attribute_set_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.attribute_set_name.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "path-diversity"):
                            if (self.path_diversity is None):
                                self.path_diversity = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathDiversity()
                                self.path_diversity.parent = self
                                self._children_name_map["path_diversity"] = "path-diversity"
                            return self.path_diversity

                        if (child_yang_name == "path-selection"):
                            if (self.path_selection is None):
                                self.path_selection = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute.PathSelection()
                                self.path_selection.parent = self
                                self._children_name_map["path_selection"] = "path-selection"
                            return self.path_selection

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "path-diversity" or name == "path-selection" or name == "attribute-set-name" or name == "enable"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "attribute-set-name"):
                            self.attribute_set_name = value
                            self.attribute_set_name.value_namespace = name_space
                            self.attribute_set_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.xro_attribute:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.xro_attribute:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "xro-attributes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "xro-attribute"):
                        for c in self.xro_attribute:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.AttributeSet.XroAttributes.XroAttribute()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.xro_attribute.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "xro-attribute"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    (self.auto_backup_attributes is not None and self.auto_backup_attributes.has_data()) or
                    (self.auto_mesh_attributes is not None and self.auto_mesh_attributes.has_data()) or
                    (self.otn_pp_attributes is not None and self.otn_pp_attributes.has_data()) or
                    (self.p2mpte_attributes is not None and self.p2mpte_attributes.has_data()) or
                    (self.p2p_te_attributes is not None and self.p2p_te_attributes.has_data()) or
                    (self.path_option_attributes is not None and self.path_option_attributes.has_data()) or
                    (self.xro_attributes is not None and self.xro_attributes.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.auto_backup_attributes is not None and self.auto_backup_attributes.has_operation()) or
                    (self.auto_mesh_attributes is not None and self.auto_mesh_attributes.has_operation()) or
                    (self.otn_pp_attributes is not None and self.otn_pp_attributes.has_operation()) or
                    (self.p2mpte_attributes is not None and self.p2mpte_attributes.has_operation()) or
                    (self.p2p_te_attributes is not None and self.p2p_te_attributes.has_operation()) or
                    (self.path_option_attributes is not None and self.path_option_attributes.has_operation()) or
                    (self.xro_attributes is not None and self.xro_attributes.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "attribute-set" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "auto-backup-attributes"):
                    if (self.auto_backup_attributes is None):
                        self.auto_backup_attributes = MplsTe.GlobalAttributes.AttributeSet.AutoBackupAttributes()
                        self.auto_backup_attributes.parent = self
                        self._children_name_map["auto_backup_attributes"] = "auto-backup-attributes"
                    return self.auto_backup_attributes

                if (child_yang_name == "auto-mesh-attributes"):
                    if (self.auto_mesh_attributes is None):
                        self.auto_mesh_attributes = MplsTe.GlobalAttributes.AttributeSet.AutoMeshAttributes()
                        self.auto_mesh_attributes.parent = self
                        self._children_name_map["auto_mesh_attributes"] = "auto-mesh-attributes"
                    return self.auto_mesh_attributes

                if (child_yang_name == "otn-pp-attributes"):
                    if (self.otn_pp_attributes is None):
                        self.otn_pp_attributes = MplsTe.GlobalAttributes.AttributeSet.OtnPpAttributes()
                        self.otn_pp_attributes.parent = self
                        self._children_name_map["otn_pp_attributes"] = "otn-pp-attributes"
                    return self.otn_pp_attributes

                if (child_yang_name == "p2mpte-attributes"):
                    if (self.p2mpte_attributes is None):
                        self.p2mpte_attributes = MplsTe.GlobalAttributes.AttributeSet.P2MpteAttributes()
                        self.p2mpte_attributes.parent = self
                        self._children_name_map["p2mpte_attributes"] = "p2mpte-attributes"
                    return self.p2mpte_attributes

                if (child_yang_name == "p2p-te-attributes"):
                    if (self.p2p_te_attributes is None):
                        self.p2p_te_attributes = MplsTe.GlobalAttributes.AttributeSet.P2PTeAttributes()
                        self.p2p_te_attributes.parent = self
                        self._children_name_map["p2p_te_attributes"] = "p2p-te-attributes"
                    return self.p2p_te_attributes

                if (child_yang_name == "path-option-attributes"):
                    if (self.path_option_attributes is None):
                        self.path_option_attributes = MplsTe.GlobalAttributes.AttributeSet.PathOptionAttributes()
                        self.path_option_attributes.parent = self
                        self._children_name_map["path_option_attributes"] = "path-option-attributes"
                    return self.path_option_attributes

                if (child_yang_name == "xro-attributes"):
                    if (self.xro_attributes is None):
                        self.xro_attributes = MplsTe.GlobalAttributes.AttributeSet.XroAttributes()
                        self.xro_attributes.parent = self
                        self._children_name_map["xro_attributes"] = "xro-attributes"
                    return self.xro_attributes

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "auto-backup-attributes" or name == "auto-mesh-attributes" or name == "otn-pp-attributes" or name == "p2mpte-attributes" or name == "p2p-te-attributes" or name == "path-option-attributes" or name == "xro-attributes"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class BfdOverLsp(Entity):
            """
            BFD over MPLS TE Global Configurations
            
            .. attribute:: head
            
            	BFD over LSP Head Global Configurations
            	**type**\:   :py:class:`Head <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.BfdOverLsp.Head>`
            
            .. attribute:: tail
            
            	BFD over LSP Tail Global Configurations
            	**type**\:   :py:class:`Tail <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.BfdOverLsp.Tail>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.BfdOverLsp, self).__init__()

                self.yang_name = "bfd-over-lsp"
                self.yang_parent_name = "global-attributes"

                self.head = MplsTe.GlobalAttributes.BfdOverLsp.Head()
                self.head.parent = self
                self._children_name_map["head"] = "head"
                self._children_yang_names.add("head")

                self.tail = MplsTe.GlobalAttributes.BfdOverLsp.Tail()
                self.tail.parent = self
                self._children_name_map["tail"] = "tail"
                self._children_yang_names.add("tail")


            class Tail(Entity):
                """
                BFD over LSP Tail Global Configurations
                
                .. attribute:: minimum_interval
                
                	Specify BFD over LSP tail minimum interval
                	**type**\:  int
                
                	**range:** 50..30000
                
                .. attribute:: multiplier
                
                	Specify BFD over LSP tail multiplier
                	**type**\:  int
                
                	**range:** 3..10
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.BfdOverLsp.Tail, self).__init__()

                    self.yang_name = "tail"
                    self.yang_parent_name = "bfd-over-lsp"

                    self.minimum_interval = YLeaf(YType.uint32, "minimum-interval")

                    self.multiplier = YLeaf(YType.uint32, "multiplier")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("minimum_interval",
                                    "multiplier") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.BfdOverLsp.Tail, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.BfdOverLsp.Tail, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.minimum_interval.is_set or
                        self.multiplier.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.minimum_interval.yfilter != YFilter.not_set or
                        self.multiplier.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "tail" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/bfd-over-lsp/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.minimum_interval.is_set or self.minimum_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.minimum_interval.get_name_leafdata())
                    if (self.multiplier.is_set or self.multiplier.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.multiplier.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "minimum-interval" or name == "multiplier"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "minimum-interval"):
                        self.minimum_interval = value
                        self.minimum_interval.value_namespace = name_space
                        self.minimum_interval.value_namespace_prefix = name_space_prefix
                    if(value_path == "multiplier"):
                        self.multiplier = value
                        self.multiplier.value_namespace = name_space
                        self.multiplier.value_namespace_prefix = name_space_prefix


            class Head(Entity):
                """
                BFD over LSP Head Global Configurations
                
                .. attribute:: down_action
                
                	Specify BFD session down action
                	**type**\:   :py:class:`MplsTeBfdSessionDownAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeBfdSessionDownAction>`
                
                .. attribute:: reopt_timeout
                
                	BFD session down reopt timeout
                	**type**\:  int
                
                	**range:** 120..4294967295
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.BfdOverLsp.Head, self).__init__()

                    self.yang_name = "head"
                    self.yang_parent_name = "bfd-over-lsp"

                    self.down_action = YLeaf(YType.enumeration, "down-action")

                    self.reopt_timeout = YLeaf(YType.uint32, "reopt-timeout")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_action",
                                    "reopt_timeout") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.BfdOverLsp.Head, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.BfdOverLsp.Head, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_action.is_set or
                        self.reopt_timeout.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_action.yfilter != YFilter.not_set or
                        self.reopt_timeout.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "head" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/bfd-over-lsp/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_action.is_set or self.down_action.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_action.get_name_leafdata())
                    if (self.reopt_timeout.is_set or self.reopt_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.reopt_timeout.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-action" or name == "reopt-timeout"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-action"):
                        self.down_action = value
                        self.down_action.value_namespace = name_space
                        self.down_action.value_namespace_prefix = name_space_prefix
                    if(value_path == "reopt-timeout"):
                        self.reopt_timeout = value
                        self.reopt_timeout.value_namespace = name_space
                        self.reopt_timeout.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.head is not None and self.head.has_data()) or
                    (self.tail is not None and self.tail.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.head is not None and self.head.has_operation()) or
                    (self.tail is not None and self.tail.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "bfd-over-lsp" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "head"):
                    if (self.head is None):
                        self.head = MplsTe.GlobalAttributes.BfdOverLsp.Head()
                        self.head.parent = self
                        self._children_name_map["head"] = "head"
                    return self.head

                if (child_yang_name == "tail"):
                    if (self.tail is None):
                        self.tail = MplsTe.GlobalAttributes.BfdOverLsp.Tail()
                        self.tail.parent = self
                        self._children_name_map["tail"] = "tail"
                    return self.tail

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "head" or name == "tail"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class BandwidthAccounting(Entity):
            """
            Bandwidth accounting configuration data
            
            .. attribute:: account_flooding_threshold
            
            	This object sets the flooding threshold as percentage of total link bandwidth for bandwidth accounting. Default to 10%, 10%
            	**type**\:   :py:class:`AccountFloodingThreshold <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.BandwidthAccounting.AccountFloodingThreshold>`
            
            .. attribute:: adjustment_factor
            
            	This object sets the percentage adjustment factor for the non RSVP\-TE bandwidth accounting.  Default is 100%
            	**type**\:  int
            
            	**range:** 0..200
            
            	**units**\: percentage
            
            	**default value**\: 100
            
            .. attribute:: application
            
            	Bandwidth accounting application configuration data
            	**type**\:   :py:class:`Application <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.BandwidthAccounting.Application>`
            
            .. attribute:: collection_type_rsvp_te
            
            	This object enables the bandwidth accounting RSVP\-TE sample collection
            	**type**\:  bool
            
            	**default value**\: false
            
            .. attribute:: enable
            
            	This object controls whether BW accounting is enabled. This object must be set before setting any other objects  under the BandwidthAccounting class
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: sampling_interval
            
            	This object sets the sampling interval in seconds for bandwidth accounting. Default to 60 seconds
            	**type**\:  int
            
            	**range:** 30..600
            
            	**units**\: second
            
            	**default value**\: 60
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.BandwidthAccounting, self).__init__()

                self.yang_name = "bandwidth-accounting"
                self.yang_parent_name = "global-attributes"

                self.adjustment_factor = YLeaf(YType.uint32, "adjustment-factor")

                self.collection_type_rsvp_te = YLeaf(YType.boolean, "collection-type-rsvp-te")

                self.enable = YLeaf(YType.empty, "enable")

                self.sampling_interval = YLeaf(YType.uint32, "sampling-interval")

                self.account_flooding_threshold = MplsTe.GlobalAttributes.BandwidthAccounting.AccountFloodingThreshold()
                self.account_flooding_threshold.parent = self
                self._children_name_map["account_flooding_threshold"] = "account-flooding-threshold"
                self._children_yang_names.add("account-flooding-threshold")

                self.application = MplsTe.GlobalAttributes.BandwidthAccounting.Application()
                self.application.parent = self
                self._children_name_map["application"] = "application"
                self._children_yang_names.add("application")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("adjustment_factor",
                                "collection_type_rsvp_te",
                                "enable",
                                "sampling_interval") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GlobalAttributes.BandwidthAccounting, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GlobalAttributes.BandwidthAccounting, self).__setattr__(name, value)


            class Application(Entity):
                """
                Bandwidth accounting application configuration
                data
                
                .. attribute:: application_enforced
                
                	This object enables the application
                	**type**\:  bool
                
                	**default value**\: false
                
                .. attribute:: application_interval
                
                	This object sets the application interval in seconds for bandwidth accounting. Default to 180 seconds
                	**type**\:  int
                
                	**range:** 90..1800
                
                	**units**\: second
                
                	**default value**\: 180
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.BandwidthAccounting.Application, self).__init__()

                    self.yang_name = "application"
                    self.yang_parent_name = "bandwidth-accounting"

                    self.application_enforced = YLeaf(YType.boolean, "application-enforced")

                    self.application_interval = YLeaf(YType.uint32, "application-interval")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("application_enforced",
                                    "application_interval") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.BandwidthAccounting.Application, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.BandwidthAccounting.Application, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.application_enforced.is_set or
                        self.application_interval.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.application_enforced.yfilter != YFilter.not_set or
                        self.application_interval.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "application" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/bandwidth-accounting/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.application_enforced.is_set or self.application_enforced.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.application_enforced.get_name_leafdata())
                    if (self.application_interval.is_set or self.application_interval.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.application_interval.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "application-enforced" or name == "application-interval"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "application-enforced"):
                        self.application_enforced = value
                        self.application_enforced.value_namespace = name_space
                        self.application_enforced.value_namespace_prefix = name_space_prefix
                    if(value_path == "application-interval"):
                        self.application_interval = value
                        self.application_interval.value_namespace = name_space
                        self.application_interval.value_namespace_prefix = name_space_prefix


            class AccountFloodingThreshold(Entity):
                """
                This object sets the flooding threshold as
                percentage of total link bandwidth for
                bandwidth accounting. Default to 10%, 10%
                
                .. attribute:: down_threshold
                
                	Downward flooding Threshold in percentages of total bandwidth
                	**type**\:  int
                
                	**range:** 0..100
                
                	**units**\: percentage
                
                	**default value**\: 10
                
                .. attribute:: up_threshold
                
                	Upward flooding Threshold in percentages of total bandwidth
                	**type**\:  int
                
                	**range:** 0..100
                
                	**units**\: percentage
                
                	**default value**\: 10
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.BandwidthAccounting.AccountFloodingThreshold, self).__init__()

                    self.yang_name = "account-flooding-threshold"
                    self.yang_parent_name = "bandwidth-accounting"

                    self.down_threshold = YLeaf(YType.uint32, "down-threshold")

                    self.up_threshold = YLeaf(YType.uint32, "up-threshold")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("down_threshold",
                                    "up_threshold") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.BandwidthAccounting.AccountFloodingThreshold, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.BandwidthAccounting.AccountFloodingThreshold, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.down_threshold.is_set or
                        self.up_threshold.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.down_threshold.yfilter != YFilter.not_set or
                        self.up_threshold.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "account-flooding-threshold" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/bandwidth-accounting/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.down_threshold.is_set or self.down_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.down_threshold.get_name_leafdata())
                    if (self.up_threshold.is_set or self.up_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.up_threshold.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "down-threshold" or name == "up-threshold"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "down-threshold"):
                        self.down_threshold = value
                        self.down_threshold.value_namespace = name_space
                        self.down_threshold.value_namespace_prefix = name_space_prefix
                    if(value_path == "up-threshold"):
                        self.up_threshold = value
                        self.up_threshold.value_namespace = name_space
                        self.up_threshold.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.adjustment_factor.is_set or
                    self.collection_type_rsvp_te.is_set or
                    self.enable.is_set or
                    self.sampling_interval.is_set or
                    (self.account_flooding_threshold is not None and self.account_flooding_threshold.has_data()) or
                    (self.application is not None and self.application.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.adjustment_factor.yfilter != YFilter.not_set or
                    self.collection_type_rsvp_te.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.sampling_interval.yfilter != YFilter.not_set or
                    (self.account_flooding_threshold is not None and self.account_flooding_threshold.has_operation()) or
                    (self.application is not None and self.application.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "bandwidth-accounting" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.adjustment_factor.is_set or self.adjustment_factor.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.adjustment_factor.get_name_leafdata())
                if (self.collection_type_rsvp_te.is_set or self.collection_type_rsvp_te.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.collection_type_rsvp_te.get_name_leafdata())
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.sampling_interval.is_set or self.sampling_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.sampling_interval.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "account-flooding-threshold"):
                    if (self.account_flooding_threshold is None):
                        self.account_flooding_threshold = MplsTe.GlobalAttributes.BandwidthAccounting.AccountFloodingThreshold()
                        self.account_flooding_threshold.parent = self
                        self._children_name_map["account_flooding_threshold"] = "account-flooding-threshold"
                    return self.account_flooding_threshold

                if (child_yang_name == "application"):
                    if (self.application is None):
                        self.application = MplsTe.GlobalAttributes.BandwidthAccounting.Application()
                        self.application.parent = self
                        self._children_name_map["application"] = "application"
                    return self.application

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "account-flooding-threshold" or name == "application" or name == "adjustment-factor" or name == "collection-type-rsvp-te" or name == "enable" or name == "sampling-interval"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "adjustment-factor"):
                    self.adjustment_factor = value
                    self.adjustment_factor.value_namespace = name_space
                    self.adjustment_factor.value_namespace_prefix = name_space_prefix
                if(value_path == "collection-type-rsvp-te"):
                    self.collection_type_rsvp_te = value
                    self.collection_type_rsvp_te.value_namespace = name_space
                    self.collection_type_rsvp_te.value_namespace_prefix = name_space_prefix
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "sampling-interval"):
                    self.sampling_interval = value
                    self.sampling_interval.value_namespace = name_space
                    self.sampling_interval.value_namespace_prefix = name_space_prefix


        class PceAttributes(Entity):
            """
            Configuration MPLS TE PCE attributes
            
            .. attribute:: address
            
            	Address of this PCE
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: deadtimer
            
            	Deadtimer interval in seconds
            	**type**\:  int
            
            	**range:** 0..255
            
            	**units**\: second
            
            	**default value**\: 120
            
            .. attribute:: keepalive
            
            	Keepalive interval in seconds
            	**type**\:  int
            
            	**range:** 0..255
            
            	**units**\: second
            
            	**default value**\: 30
            
            .. attribute:: keepalive_tolerance
            
            	Keepalive interval tolerance in seconds
            	**type**\:  int
            
            	**range:** 0..255
            
            	**units**\: second
            
            	**default value**\: 10
            
            .. attribute:: keychain
            
            	Keychain based authentication
            	**type**\:  str
            
            	**length:** 1..32
            
            .. attribute:: logging
            
            	Configure PCE (Path Computation Element) logging feature
            	**type**\:   :py:class:`Logging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PceAttributes.Logging>`
            
            .. attribute:: password
            
            	MD5 password
            	**type**\:  str
            
            	**pattern:** (!.+)\|([^!].+)
            
            .. attribute:: pce_stateful
            
            	PCE Stateful
            	**type**\:   :py:class:`PceStateful <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PceAttributes.PceStateful>`
            
            .. attribute:: peer_source_addr
            
            	PCE Peer Source Address
            	**type**\:  str
            
            	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
            
            .. attribute:: peers
            
            	Configure PCE peers
            	**type**\:   :py:class:`Peers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PceAttributes.Peers>`
            
            .. attribute:: precedence
            
            	Precedence order
            	**type**\:  int
            
            	**range:** 0..255
            
            .. attribute:: reoptimize_period
            
            	PCE reoptimization period for PCE\-based paths
            	**type**\:  int
            
            	**range:** 60..604800
            
            	**units**\: second
            
            	**default value**\: 60
            
            .. attribute:: request_timeout
            
            	Request timeout value in seconds
            	**type**\:  int
            
            	**range:** 5..100
            
            	**units**\: second
            
            	**default value**\: 10
            
            .. attribute:: segment_routing
            
            	PCE segment routing capability
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: speaker_entity_id
            
            	PCE speaker entity identifier
            	**type**\:  str
            
            	**length:** 1..256
            
            .. attribute:: timer
            
            	Configure PCE (Path Computation Element) timers
            	**type**\:   :py:class:`Timer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PceAttributes.Timer>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.PceAttributes, self).__init__()

                self.yang_name = "pce-attributes"
                self.yang_parent_name = "global-attributes"

                self.address = YLeaf(YType.str, "address")

                self.deadtimer = YLeaf(YType.uint32, "deadtimer")

                self.keepalive = YLeaf(YType.uint32, "keepalive")

                self.keepalive_tolerance = YLeaf(YType.uint32, "keepalive-tolerance")

                self.keychain = YLeaf(YType.str, "keychain")

                self.password = YLeaf(YType.str, "password")

                self.peer_source_addr = YLeaf(YType.str, "peer-source-addr")

                self.precedence = YLeaf(YType.uint32, "precedence")

                self.reoptimize_period = YLeaf(YType.uint32, "reoptimize-period")

                self.request_timeout = YLeaf(YType.uint32, "request-timeout")

                self.segment_routing = YLeaf(YType.empty, "segment-routing")

                self.speaker_entity_id = YLeaf(YType.str, "speaker-entity-id")

                self.logging = MplsTe.GlobalAttributes.PceAttributes.Logging()
                self.logging.parent = self
                self._children_name_map["logging"] = "logging"
                self._children_yang_names.add("logging")

                self.pce_stateful = MplsTe.GlobalAttributes.PceAttributes.PceStateful()
                self.pce_stateful.parent = self
                self._children_name_map["pce_stateful"] = "pce-stateful"
                self._children_yang_names.add("pce-stateful")

                self.peers = MplsTe.GlobalAttributes.PceAttributes.Peers()
                self.peers.parent = self
                self._children_name_map["peers"] = "peers"
                self._children_yang_names.add("peers")

                self.timer = MplsTe.GlobalAttributes.PceAttributes.Timer()
                self.timer.parent = self
                self._children_name_map["timer"] = "timer"
                self._children_yang_names.add("timer")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("address",
                                "deadtimer",
                                "keepalive",
                                "keepalive_tolerance",
                                "keychain",
                                "password",
                                "peer_source_addr",
                                "precedence",
                                "reoptimize_period",
                                "request_timeout",
                                "segment_routing",
                                "speaker_entity_id") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GlobalAttributes.PceAttributes, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GlobalAttributes.PceAttributes, self).__setattr__(name, value)


            class PceStateful(Entity):
                """
                PCE Stateful
                
                .. attribute:: cisco_extension
                
                	Enable processing of PCEP Cisco extension
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: delegation
                
                	Delegate all statically configured tunnels
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: enable
                
                	PCE stateful capability
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: fast_repair
                
                	Enable reoptimization by PCC after path failures
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: instantiation
                
                	PCE stateful instantiation capability
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: report
                
                	Report all statically configured tunnels
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: stateful_timers
                
                	Configure Stateful PCE (Path Computation Element) timers
                	**type**\:   :py:class:`StatefulTimers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PceAttributes.PceStateful.StatefulTimers>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.PceAttributes.PceStateful, self).__init__()

                    self.yang_name = "pce-stateful"
                    self.yang_parent_name = "pce-attributes"

                    self.cisco_extension = YLeaf(YType.empty, "cisco-extension")

                    self.delegation = YLeaf(YType.empty, "delegation")

                    self.enable = YLeaf(YType.empty, "enable")

                    self.fast_repair = YLeaf(YType.empty, "fast-repair")

                    self.instantiation = YLeaf(YType.empty, "instantiation")

                    self.report = YLeaf(YType.empty, "report")

                    self.stateful_timers = MplsTe.GlobalAttributes.PceAttributes.PceStateful.StatefulTimers()
                    self.stateful_timers.parent = self
                    self._children_name_map["stateful_timers"] = "stateful-timers"
                    self._children_yang_names.add("stateful-timers")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("cisco_extension",
                                    "delegation",
                                    "enable",
                                    "fast_repair",
                                    "instantiation",
                                    "report") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.PceAttributes.PceStateful, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.PceAttributes.PceStateful, self).__setattr__(name, value)


                class StatefulTimers(Entity):
                    """
                    Configure Stateful PCE (Path Computation
                    Element) timers
                    
                    .. attribute:: redelegation_timeout
                    
                    	Timer for static tunnel redelegation in seconds, default is 180 seconds
                    	**type**\:  int
                    
                    	**range:** 0..3600
                    
                    	**units**\: second
                    
                    	**default value**\: 180
                    
                    .. attribute:: state_timeout
                    
                    	State timeout for LSPs without delegation in seconds, zero means immediate removal, default is 180 seconds
                    	**type**\:  int
                    
                    	**range:** 0..3600
                    
                    	**units**\: second
                    
                    	**default value**\: 180
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.PceAttributes.PceStateful.StatefulTimers, self).__init__()

                        self.yang_name = "stateful-timers"
                        self.yang_parent_name = "pce-stateful"

                        self.redelegation_timeout = YLeaf(YType.uint32, "redelegation-timeout")

                        self.state_timeout = YLeaf(YType.uint32, "state-timeout")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("redelegation_timeout",
                                        "state_timeout") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.PceAttributes.PceStateful.StatefulTimers, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.PceAttributes.PceStateful.StatefulTimers, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.redelegation_timeout.is_set or
                            self.state_timeout.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.redelegation_timeout.yfilter != YFilter.not_set or
                            self.state_timeout.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "stateful-timers" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/pce-stateful/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.redelegation_timeout.is_set or self.redelegation_timeout.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.redelegation_timeout.get_name_leafdata())
                        if (self.state_timeout.is_set or self.state_timeout.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.state_timeout.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "redelegation-timeout" or name == "state-timeout"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "redelegation-timeout"):
                            self.redelegation_timeout = value
                            self.redelegation_timeout.value_namespace = name_space
                            self.redelegation_timeout.value_namespace_prefix = name_space_prefix
                        if(value_path == "state-timeout"):
                            self.state_timeout = value
                            self.state_timeout.value_namespace = name_space
                            self.state_timeout.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.cisco_extension.is_set or
                        self.delegation.is_set or
                        self.enable.is_set or
                        self.fast_repair.is_set or
                        self.instantiation.is_set or
                        self.report.is_set or
                        (self.stateful_timers is not None and self.stateful_timers.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.cisco_extension.yfilter != YFilter.not_set or
                        self.delegation.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        self.fast_repair.yfilter != YFilter.not_set or
                        self.instantiation.yfilter != YFilter.not_set or
                        self.report.yfilter != YFilter.not_set or
                        (self.stateful_timers is not None and self.stateful_timers.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "pce-stateful" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.cisco_extension.is_set or self.cisco_extension.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.cisco_extension.get_name_leafdata())
                    if (self.delegation.is_set or self.delegation.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.delegation.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())
                    if (self.fast_repair.is_set or self.fast_repair.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fast_repair.get_name_leafdata())
                    if (self.instantiation.is_set or self.instantiation.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.instantiation.get_name_leafdata())
                    if (self.report.is_set or self.report.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.report.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "stateful-timers"):
                        if (self.stateful_timers is None):
                            self.stateful_timers = MplsTe.GlobalAttributes.PceAttributes.PceStateful.StatefulTimers()
                            self.stateful_timers.parent = self
                            self._children_name_map["stateful_timers"] = "stateful-timers"
                        return self.stateful_timers

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "stateful-timers" or name == "cisco-extension" or name == "delegation" or name == "enable" or name == "fast-repair" or name == "instantiation" or name == "report"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "cisco-extension"):
                        self.cisco_extension = value
                        self.cisco_extension.value_namespace = name_space
                        self.cisco_extension.value_namespace_prefix = name_space_prefix
                    if(value_path == "delegation"):
                        self.delegation = value
                        self.delegation.value_namespace = name_space
                        self.delegation.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "fast-repair"):
                        self.fast_repair = value
                        self.fast_repair.value_namespace = name_space
                        self.fast_repair.value_namespace_prefix = name_space_prefix
                    if(value_path == "instantiation"):
                        self.instantiation = value
                        self.instantiation.value_namespace = name_space
                        self.instantiation.value_namespace_prefix = name_space_prefix
                    if(value_path == "report"):
                        self.report = value
                        self.report.value_namespace = name_space
                        self.report.value_namespace_prefix = name_space_prefix


            class Timer(Entity):
                """
                Configure PCE (Path Computation Element)
                timers
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.PceAttributes.Timer, self).__init__()

                    self.yang_name = "timer"
                    self.yang_parent_name = "pce-attributes"

                def has_data(self):
                    return False

                def has_operation(self):
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "timer" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Peers(Entity):
                """
                Configure PCE peers
                
                .. attribute:: peer
                
                	PCE peer
                	**type**\: list of    :py:class:`Peer <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PceAttributes.Peers.Peer>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.PceAttributes.Peers, self).__init__()

                    self.yang_name = "peers"
                    self.yang_parent_name = "pce-attributes"

                    self.peer = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.PceAttributes.Peers, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.PceAttributes.Peers, self).__setattr__(name, value)


                class Peer(Entity):
                    """
                    PCE peer
                    
                    .. attribute:: pce_peer_address  <key>
                    
                    	Address of PCE Peer
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: enable
                    
                    	Enabled PCE peer (default source address uses local)
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: keychain
                    
                    	Keychain based authentication
                    	**type**\:  str
                    
                    	**length:** 1..32
                    
                    .. attribute:: password
                    
                    	MD5 password
                    	**type**\:  str
                    
                    	**pattern:** (!.+)\|([^!].+)
                    
                    .. attribute:: precedence
                    
                    	Precedence order
                    	**type**\:  int
                    
                    	**range:** 0..255
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.PceAttributes.Peers.Peer, self).__init__()

                        self.yang_name = "peer"
                        self.yang_parent_name = "peers"

                        self.pce_peer_address = YLeaf(YType.str, "pce-peer-address")

                        self.enable = YLeaf(YType.empty, "enable")

                        self.keychain = YLeaf(YType.str, "keychain")

                        self.password = YLeaf(YType.str, "password")

                        self.precedence = YLeaf(YType.uint32, "precedence")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("pce_peer_address",
                                        "enable",
                                        "keychain",
                                        "password",
                                        "precedence") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.PceAttributes.Peers.Peer, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.PceAttributes.Peers.Peer, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.pce_peer_address.is_set or
                            self.enable.is_set or
                            self.keychain.is_set or
                            self.password.is_set or
                            self.precedence.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.pce_peer_address.yfilter != YFilter.not_set or
                            self.enable.yfilter != YFilter.not_set or
                            self.keychain.yfilter != YFilter.not_set or
                            self.password.yfilter != YFilter.not_set or
                            self.precedence.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "peer" + "[pce-peer-address='" + self.pce_peer_address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/peers/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.pce_peer_address.is_set or self.pce_peer_address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.pce_peer_address.get_name_leafdata())
                        if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.enable.get_name_leafdata())
                        if (self.keychain.is_set or self.keychain.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.keychain.get_name_leafdata())
                        if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.password.get_name_leafdata())
                        if (self.precedence.is_set or self.precedence.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.precedence.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "pce-peer-address" or name == "enable" or name == "keychain" or name == "password" or name == "precedence"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "pce-peer-address"):
                            self.pce_peer_address = value
                            self.pce_peer_address.value_namespace = name_space
                            self.pce_peer_address.value_namespace_prefix = name_space_prefix
                        if(value_path == "enable"):
                            self.enable = value
                            self.enable.value_namespace = name_space
                            self.enable.value_namespace_prefix = name_space_prefix
                        if(value_path == "keychain"):
                            self.keychain = value
                            self.keychain.value_namespace = name_space
                            self.keychain.value_namespace_prefix = name_space_prefix
                        if(value_path == "password"):
                            self.password = value
                            self.password.value_namespace = name_space
                            self.password.value_namespace_prefix = name_space_prefix
                        if(value_path == "precedence"):
                            self.precedence = value
                            self.precedence.value_namespace = name_space
                            self.precedence.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.peer:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.peer:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "peers" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "peer"):
                        for c in self.peer:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.PceAttributes.Peers.Peer()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.peer.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "peer"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Logging(Entity):
                """
                Configure PCE (Path Computation Element)
                logging feature
                
                .. attribute:: events
                
                	Configure logging events
                	**type**\:   :py:class:`Events <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PceAttributes.Logging.Events>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.PceAttributes.Logging, self).__init__()

                    self.yang_name = "logging"
                    self.yang_parent_name = "pce-attributes"

                    self.events = MplsTe.GlobalAttributes.PceAttributes.Logging.Events()
                    self.events.parent = self
                    self._children_name_map["events"] = "events"
                    self._children_yang_names.add("events")


                class Events(Entity):
                    """
                    Configure logging events
                    
                    .. attribute:: peer_status
                    
                    	Peer status changes logging
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.PceAttributes.Logging.Events, self).__init__()

                        self.yang_name = "events"
                        self.yang_parent_name = "logging"

                        self.peer_status = YLeaf(YType.empty, "peer-status")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("peer_status") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.PceAttributes.Logging.Events, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.PceAttributes.Logging.Events, self).__setattr__(name, value)

                    def has_data(self):
                        return self.peer_status.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.peer_status.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "events" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/logging/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.peer_status.is_set or self.peer_status.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.peer_status.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "peer-status"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "peer-status"):
                            self.peer_status = value
                            self.peer_status.value_namespace = name_space
                            self.peer_status.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (self.events is not None and self.events.has_data())

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.events is not None and self.events.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "logging" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "events"):
                        if (self.events is None):
                            self.events = MplsTe.GlobalAttributes.PceAttributes.Logging.Events()
                            self.events.parent = self
                            self._children_name_map["events"] = "events"
                        return self.events

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "events"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.address.is_set or
                    self.deadtimer.is_set or
                    self.keepalive.is_set or
                    self.keepalive_tolerance.is_set or
                    self.keychain.is_set or
                    self.password.is_set or
                    self.peer_source_addr.is_set or
                    self.precedence.is_set or
                    self.reoptimize_period.is_set or
                    self.request_timeout.is_set or
                    self.segment_routing.is_set or
                    self.speaker_entity_id.is_set or
                    (self.logging is not None and self.logging.has_data()) or
                    (self.pce_stateful is not None and self.pce_stateful.has_data()) or
                    (self.peers is not None and self.peers.has_data()) or
                    (self.timer is not None and self.timer.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.address.yfilter != YFilter.not_set or
                    self.deadtimer.yfilter != YFilter.not_set or
                    self.keepalive.yfilter != YFilter.not_set or
                    self.keepalive_tolerance.yfilter != YFilter.not_set or
                    self.keychain.yfilter != YFilter.not_set or
                    self.password.yfilter != YFilter.not_set or
                    self.peer_source_addr.yfilter != YFilter.not_set or
                    self.precedence.yfilter != YFilter.not_set or
                    self.reoptimize_period.yfilter != YFilter.not_set or
                    self.request_timeout.yfilter != YFilter.not_set or
                    self.segment_routing.yfilter != YFilter.not_set or
                    self.speaker_entity_id.yfilter != YFilter.not_set or
                    (self.logging is not None and self.logging.has_operation()) or
                    (self.pce_stateful is not None and self.pce_stateful.has_operation()) or
                    (self.peers is not None and self.peers.has_operation()) or
                    (self.timer is not None and self.timer.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "pce-attributes" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.address.get_name_leafdata())
                if (self.deadtimer.is_set or self.deadtimer.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.deadtimer.get_name_leafdata())
                if (self.keepalive.is_set or self.keepalive.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.keepalive.get_name_leafdata())
                if (self.keepalive_tolerance.is_set or self.keepalive_tolerance.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.keepalive_tolerance.get_name_leafdata())
                if (self.keychain.is_set or self.keychain.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.keychain.get_name_leafdata())
                if (self.password.is_set or self.password.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.password.get_name_leafdata())
                if (self.peer_source_addr.is_set or self.peer_source_addr.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.peer_source_addr.get_name_leafdata())
                if (self.precedence.is_set or self.precedence.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.precedence.get_name_leafdata())
                if (self.reoptimize_period.is_set or self.reoptimize_period.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.reoptimize_period.get_name_leafdata())
                if (self.request_timeout.is_set or self.request_timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.request_timeout.get_name_leafdata())
                if (self.segment_routing.is_set or self.segment_routing.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.segment_routing.get_name_leafdata())
                if (self.speaker_entity_id.is_set or self.speaker_entity_id.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.speaker_entity_id.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "logging"):
                    if (self.logging is None):
                        self.logging = MplsTe.GlobalAttributes.PceAttributes.Logging()
                        self.logging.parent = self
                        self._children_name_map["logging"] = "logging"
                    return self.logging

                if (child_yang_name == "pce-stateful"):
                    if (self.pce_stateful is None):
                        self.pce_stateful = MplsTe.GlobalAttributes.PceAttributes.PceStateful()
                        self.pce_stateful.parent = self
                        self._children_name_map["pce_stateful"] = "pce-stateful"
                    return self.pce_stateful

                if (child_yang_name == "peers"):
                    if (self.peers is None):
                        self.peers = MplsTe.GlobalAttributes.PceAttributes.Peers()
                        self.peers.parent = self
                        self._children_name_map["peers"] = "peers"
                    return self.peers

                if (child_yang_name == "timer"):
                    if (self.timer is None):
                        self.timer = MplsTe.GlobalAttributes.PceAttributes.Timer()
                        self.timer.parent = self
                        self._children_name_map["timer"] = "timer"
                    return self.timer

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "logging" or name == "pce-stateful" or name == "peers" or name == "timer" or name == "address" or name == "deadtimer" or name == "keepalive" or name == "keepalive-tolerance" or name == "keychain" or name == "password" or name == "peer-source-addr" or name == "precedence" or name == "reoptimize-period" or name == "request-timeout" or name == "segment-routing" or name == "speaker-entity-id"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "address"):
                    self.address = value
                    self.address.value_namespace = name_space
                    self.address.value_namespace_prefix = name_space_prefix
                if(value_path == "deadtimer"):
                    self.deadtimer = value
                    self.deadtimer.value_namespace = name_space
                    self.deadtimer.value_namespace_prefix = name_space_prefix
                if(value_path == "keepalive"):
                    self.keepalive = value
                    self.keepalive.value_namespace = name_space
                    self.keepalive.value_namespace_prefix = name_space_prefix
                if(value_path == "keepalive-tolerance"):
                    self.keepalive_tolerance = value
                    self.keepalive_tolerance.value_namespace = name_space
                    self.keepalive_tolerance.value_namespace_prefix = name_space_prefix
                if(value_path == "keychain"):
                    self.keychain = value
                    self.keychain.value_namespace = name_space
                    self.keychain.value_namespace_prefix = name_space_prefix
                if(value_path == "password"):
                    self.password = value
                    self.password.value_namespace = name_space
                    self.password.value_namespace_prefix = name_space_prefix
                if(value_path == "peer-source-addr"):
                    self.peer_source_addr = value
                    self.peer_source_addr.value_namespace = name_space
                    self.peer_source_addr.value_namespace_prefix = name_space_prefix
                if(value_path == "precedence"):
                    self.precedence = value
                    self.precedence.value_namespace = name_space
                    self.precedence.value_namespace_prefix = name_space_prefix
                if(value_path == "reoptimize-period"):
                    self.reoptimize_period = value
                    self.reoptimize_period.value_namespace = name_space
                    self.reoptimize_period.value_namespace_prefix = name_space_prefix
                if(value_path == "request-timeout"):
                    self.request_timeout = value
                    self.request_timeout.value_namespace = name_space
                    self.request_timeout.value_namespace_prefix = name_space_prefix
                if(value_path == "segment-routing"):
                    self.segment_routing = value
                    self.segment_routing.value_namespace = name_space
                    self.segment_routing.value_namespace_prefix = name_space_prefix
                if(value_path == "speaker-entity-id"):
                    self.speaker_entity_id = value
                    self.speaker_entity_id.value_namespace = name_space
                    self.speaker_entity_id.value_namespace_prefix = name_space_prefix


        class LspOutOfResource(Entity):
            """
            Configure LSP OOR attributes in MPLS\-TE
            
            .. attribute:: lsp_oor_red_state
            
            	Configuration for LSP OOR Red/Major State
            	**type**\:   :py:class:`LspOorRedState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.LspOutOfResource.LspOorRedState>`
            
            .. attribute:: lsp_oor_yellow_state
            
            	Configuration for LSP OOR Yellow/Minor State
            	**type**\:   :py:class:`LspOorYellowState <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.LspOutOfResource.LspOorYellowState>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.LspOutOfResource, self).__init__()

                self.yang_name = "lsp-out-of-resource"
                self.yang_parent_name = "global-attributes"

                self.lsp_oor_red_state = MplsTe.GlobalAttributes.LspOutOfResource.LspOorRedState()
                self.lsp_oor_red_state.parent = self
                self._children_name_map["lsp_oor_red_state"] = "lsp-oor-red-state"
                self._children_yang_names.add("lsp-oor-red-state")

                self.lsp_oor_yellow_state = MplsTe.GlobalAttributes.LspOutOfResource.LspOorYellowState()
                self.lsp_oor_yellow_state.parent = self
                self._children_name_map["lsp_oor_yellow_state"] = "lsp-oor-yellow-state"
                self._children_yang_names.add("lsp-oor-yellow-state")


            class LspOorRedState(Entity):
                """
                Configuration for LSP OOR Red/Major State
                
                .. attribute:: all_transit_lsp_threshold
                
                	Threshold for all transit LSPs
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: unprotected_transit_lsp_threshold
                
                	Threshold for unprotected transit LSPs
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.LspOutOfResource.LspOorRedState, self).__init__()

                    self.yang_name = "lsp-oor-red-state"
                    self.yang_parent_name = "lsp-out-of-resource"

                    self.all_transit_lsp_threshold = YLeaf(YType.int32, "all-transit-lsp-threshold")

                    self.unprotected_transit_lsp_threshold = YLeaf(YType.int32, "unprotected-transit-lsp-threshold")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("all_transit_lsp_threshold",
                                    "unprotected_transit_lsp_threshold") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.LspOutOfResource.LspOorRedState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.LspOutOfResource.LspOorRedState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.all_transit_lsp_threshold.is_set or
                        self.unprotected_transit_lsp_threshold.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.all_transit_lsp_threshold.yfilter != YFilter.not_set or
                        self.unprotected_transit_lsp_threshold.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-oor-red-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/lsp-out-of-resource/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.all_transit_lsp_threshold.is_set or self.all_transit_lsp_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.all_transit_lsp_threshold.get_name_leafdata())
                    if (self.unprotected_transit_lsp_threshold.is_set or self.unprotected_transit_lsp_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unprotected_transit_lsp_threshold.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "all-transit-lsp-threshold" or name == "unprotected-transit-lsp-threshold"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "all-transit-lsp-threshold"):
                        self.all_transit_lsp_threshold = value
                        self.all_transit_lsp_threshold.value_namespace = name_space
                        self.all_transit_lsp_threshold.value_namespace_prefix = name_space_prefix
                    if(value_path == "unprotected-transit-lsp-threshold"):
                        self.unprotected_transit_lsp_threshold = value
                        self.unprotected_transit_lsp_threshold.value_namespace = name_space
                        self.unprotected_transit_lsp_threshold.value_namespace_prefix = name_space_prefix


            class LspOorYellowState(Entity):
                """
                Configuration for LSP OOR Yellow/Minor State
                
                .. attribute:: all_transit_lsp_threshold
                
                	Threshold for all transit LSPs
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: unprotected_transit_lsp_threshold
                
                	Threshold for unprotected transit LSPs
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.LspOutOfResource.LspOorYellowState, self).__init__()

                    self.yang_name = "lsp-oor-yellow-state"
                    self.yang_parent_name = "lsp-out-of-resource"

                    self.all_transit_lsp_threshold = YLeaf(YType.int32, "all-transit-lsp-threshold")

                    self.unprotected_transit_lsp_threshold = YLeaf(YType.int32, "unprotected-transit-lsp-threshold")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("all_transit_lsp_threshold",
                                    "unprotected_transit_lsp_threshold") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.LspOutOfResource.LspOorYellowState, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.LspOutOfResource.LspOorYellowState, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.all_transit_lsp_threshold.is_set or
                        self.unprotected_transit_lsp_threshold.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.all_transit_lsp_threshold.yfilter != YFilter.not_set or
                        self.unprotected_transit_lsp_threshold.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lsp-oor-yellow-state" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/lsp-out-of-resource/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.all_transit_lsp_threshold.is_set or self.all_transit_lsp_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.all_transit_lsp_threshold.get_name_leafdata())
                    if (self.unprotected_transit_lsp_threshold.is_set or self.unprotected_transit_lsp_threshold.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.unprotected_transit_lsp_threshold.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "all-transit-lsp-threshold" or name == "unprotected-transit-lsp-threshold"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "all-transit-lsp-threshold"):
                        self.all_transit_lsp_threshold = value
                        self.all_transit_lsp_threshold.value_namespace = name_space
                        self.all_transit_lsp_threshold.value_namespace_prefix = name_space_prefix
                    if(value_path == "unprotected-transit-lsp-threshold"):
                        self.unprotected_transit_lsp_threshold = value
                        self.unprotected_transit_lsp_threshold.value_namespace = name_space
                        self.unprotected_transit_lsp_threshold.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    (self.lsp_oor_red_state is not None and self.lsp_oor_red_state.has_data()) or
                    (self.lsp_oor_yellow_state is not None and self.lsp_oor_yellow_state.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.lsp_oor_red_state is not None and self.lsp_oor_red_state.has_operation()) or
                    (self.lsp_oor_yellow_state is not None and self.lsp_oor_yellow_state.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "lsp-out-of-resource" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "lsp-oor-red-state"):
                    if (self.lsp_oor_red_state is None):
                        self.lsp_oor_red_state = MplsTe.GlobalAttributes.LspOutOfResource.LspOorRedState()
                        self.lsp_oor_red_state.parent = self
                        self._children_name_map["lsp_oor_red_state"] = "lsp-oor-red-state"
                    return self.lsp_oor_red_state

                if (child_yang_name == "lsp-oor-yellow-state"):
                    if (self.lsp_oor_yellow_state is None):
                        self.lsp_oor_yellow_state = MplsTe.GlobalAttributes.LspOutOfResource.LspOorYellowState()
                        self.lsp_oor_yellow_state.parent = self
                        self._children_name_map["lsp_oor_yellow_state"] = "lsp-oor-yellow-state"
                    return self.lsp_oor_yellow_state

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "lsp-oor-red-state" or name == "lsp-oor-yellow-state"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class SoftPreemption(Entity):
            """
            Soft preemption configuration data
            
            .. attribute:: enable
            
            	This object controls whether soft preemption is enabled. This object must be set before setting any other objects under the SoftPreemption class
            	**type**\:  bool
            
            .. attribute:: frr_rewrite
            
            	This object controls whether FRR rewrite during soft preemption is enabled
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: timeout
            
            	This object sets the timeout in seconds before hard preemption is triggered
            	**type**\:  int
            
            	**range:** 1..300
            
            	**units**\: second
            
            	**default value**\: 60
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.SoftPreemption, self).__init__()

                self.yang_name = "soft-preemption"
                self.yang_parent_name = "global-attributes"

                self.enable = YLeaf(YType.boolean, "enable")

                self.frr_rewrite = YLeaf(YType.empty, "frr-rewrite")

                self.timeout = YLeaf(YType.uint32, "timeout")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable",
                                "frr_rewrite",
                                "timeout") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GlobalAttributes.SoftPreemption, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GlobalAttributes.SoftPreemption, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.enable.is_set or
                    self.frr_rewrite.is_set or
                    self.timeout.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable.yfilter != YFilter.not_set or
                    self.frr_rewrite.yfilter != YFilter.not_set or
                    self.timeout.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "soft-preemption" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable.get_name_leafdata())
                if (self.frr_rewrite.is_set or self.frr_rewrite.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.frr_rewrite.get_name_leafdata())
                if (self.timeout.is_set or self.timeout.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.timeout.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "enable" or name == "frr-rewrite" or name == "timeout"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable"):
                    self.enable = value
                    self.enable.value_namespace = name_space
                    self.enable.value_namespace_prefix = name_space_prefix
                if(value_path == "frr-rewrite"):
                    self.frr_rewrite = value
                    self.frr_rewrite.value_namespace = name_space
                    self.frr_rewrite.value_namespace_prefix = name_space_prefix
                if(value_path == "timeout"):
                    self.timeout = value
                    self.timeout.value_namespace = name_space
                    self.timeout.value_namespace_prefix = name_space_prefix


        class FastReroute(Entity):
            """
            Configure fast reroute attributes
            
            .. attribute:: timers
            
            	Configure fast reroute timers
            	**type**\:   :py:class:`Timers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.FastReroute.Timers>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.FastReroute, self).__init__()

                self.yang_name = "fast-reroute"
                self.yang_parent_name = "global-attributes"

                self.timers = MplsTe.GlobalAttributes.FastReroute.Timers()
                self.timers.parent = self
                self._children_name_map["timers"] = "timers"
                self._children_yang_names.add("timers")


            class Timers(Entity):
                """
                Configure fast reroute timers
                
                .. attribute:: hold_backup
                
                	Seconds before backup declared UP (0 disables hold\-timer)
                	**type**\:  int
                
                	**range:** 0..604800
                
                	**units**\: second
                
                .. attribute:: promotion
                
                	The value of the promotion timer in seconds
                	**type**\:  int
                
                	**range:** 0..604800
                
                	**units**\: second
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.FastReroute.Timers, self).__init__()

                    self.yang_name = "timers"
                    self.yang_parent_name = "fast-reroute"

                    self.hold_backup = YLeaf(YType.uint32, "hold-backup")

                    self.promotion = YLeaf(YType.uint32, "promotion")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("hold_backup",
                                    "promotion") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.FastReroute.Timers, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.FastReroute.Timers, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.hold_backup.is_set or
                        self.promotion.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.hold_backup.yfilter != YFilter.not_set or
                        self.promotion.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "timers" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/fast-reroute/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.hold_backup.is_set or self.hold_backup.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.hold_backup.get_name_leafdata())
                    if (self.promotion.is_set or self.promotion.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.promotion.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "hold-backup" or name == "promotion"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "hold-backup"):
                        self.hold_backup = value
                        self.hold_backup.value_namespace = name_space
                        self.hold_backup.value_namespace_prefix = name_space_prefix
                    if(value_path == "promotion"):
                        self.promotion = value
                        self.promotion.value_namespace = name_space
                        self.promotion.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (self.timers is not None and self.timers.has_data())

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    (self.timers is not None and self.timers.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "fast-reroute" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "timers"):
                    if (self.timers is None):
                        self.timers = MplsTe.GlobalAttributes.FastReroute.Timers()
                        self.timers.parent = self
                        self._children_name_map["timers"] = "timers"
                    return self.timers

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "timers"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class PathSelection(Entity):
            """
            Path selection configuration
            
            .. attribute:: cost_limit
            
            	Path selection cost limit configuration for all tunnels
            	**type**\:  int
            
            	**range:** 1..4294967295
            
            .. attribute:: ignore_overload_role
            
            	Path selection to ignore overload node during CSPF
            	**type**\:   :py:class:`IgnoreOverloadRole <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PathSelection.IgnoreOverloadRole>`
            
            .. attribute:: invalidation
            
            	Path invalidation configuration for all tunnels
            	**type**\:   :py:class:`Invalidation <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PathSelection.Invalidation>`
            
            .. attribute:: loose_affinities
            
            	Path selection Loose ERO Affinity Class configuration
            	**type**\:   :py:class:`LooseAffinities <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PathSelection.LooseAffinities>`
            
            .. attribute:: loose_domain_match
            
            	Use only the IGP instance of the incoming interface
            	**type**\:  bool
            
            .. attribute:: loose_metrics
            
            	Path selection Loose ERO Metric Class configuration
            	**type**\:   :py:class:`LooseMetrics <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PathSelection.LooseMetrics>`
            
            .. attribute:: metric
            
            	Metric to use in path calculation
            	**type**\:   :py:class:`MplsTePathSelectionMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionMetric>`
            
            .. attribute:: tiebreaker
            
            	CSPF tiebreaker to use in path calculation
            	**type**\:   :py:class:`MplsTePathSelectionTiebreaker <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionTiebreaker>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.PathSelection, self).__init__()

                self.yang_name = "path-selection"
                self.yang_parent_name = "global-attributes"

                self.cost_limit = YLeaf(YType.uint32, "cost-limit")

                self.loose_domain_match = YLeaf(YType.boolean, "loose-domain-match")

                self.metric = YLeaf(YType.enumeration, "metric")

                self.tiebreaker = YLeaf(YType.enumeration, "tiebreaker")

                self.ignore_overload_role = MplsTe.GlobalAttributes.PathSelection.IgnoreOverloadRole()
                self.ignore_overload_role.parent = self
                self._children_name_map["ignore_overload_role"] = "ignore-overload-role"
                self._children_yang_names.add("ignore-overload-role")

                self.invalidation = MplsTe.GlobalAttributes.PathSelection.Invalidation()
                self.invalidation.parent = self
                self._children_name_map["invalidation"] = "invalidation"
                self._children_yang_names.add("invalidation")

                self.loose_affinities = MplsTe.GlobalAttributes.PathSelection.LooseAffinities()
                self.loose_affinities.parent = self
                self._children_name_map["loose_affinities"] = "loose-affinities"
                self._children_yang_names.add("loose-affinities")

                self.loose_metrics = MplsTe.GlobalAttributes.PathSelection.LooseMetrics()
                self.loose_metrics.parent = self
                self._children_name_map["loose_metrics"] = "loose-metrics"
                self._children_yang_names.add("loose-metrics")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("cost_limit",
                                "loose_domain_match",
                                "metric",
                                "tiebreaker") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GlobalAttributes.PathSelection, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GlobalAttributes.PathSelection, self).__setattr__(name, value)


            class LooseMetrics(Entity):
                """
                Path selection Loose ERO Metric Class
                configuration
                
                .. attribute:: loose_metric
                
                	Path selection Loose ERO Metric configuration
                	**type**\: list of    :py:class:`LooseMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PathSelection.LooseMetrics.LooseMetric>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.PathSelection.LooseMetrics, self).__init__()

                    self.yang_name = "loose-metrics"
                    self.yang_parent_name = "path-selection"

                    self.loose_metric = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.PathSelection.LooseMetrics, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.PathSelection.LooseMetrics, self).__setattr__(name, value)


                class LooseMetric(Entity):
                    """
                    Path selection Loose ERO Metric configuration
                    
                    .. attribute:: class_type  <key>
                    
                    	Path Selection class Type
                    	**type**\:  int
                    
                    	**range:** 0..7
                    
                    .. attribute:: metric_type
                    
                    	Metric to use for ERO Expansion
                    	**type**\:   :py:class:`MplsTePathSelectionMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionMetric>`
                    
                    	**mandatory**\: True
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.PathSelection.LooseMetrics.LooseMetric, self).__init__()

                        self.yang_name = "loose-metric"
                        self.yang_parent_name = "loose-metrics"

                        self.class_type = YLeaf(YType.uint32, "class-type")

                        self.metric_type = YLeaf(YType.enumeration, "metric-type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("class_type",
                                        "metric_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.PathSelection.LooseMetrics.LooseMetric, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.PathSelection.LooseMetrics.LooseMetric, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.class_type.is_set or
                            self.metric_type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.class_type.yfilter != YFilter.not_set or
                            self.metric_type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "loose-metric" + "[class-type='" + self.class_type.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/loose-metrics/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.class_type.is_set or self.class_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.class_type.get_name_leafdata())
                        if (self.metric_type.is_set or self.metric_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.metric_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "class-type" or name == "metric-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "class-type"):
                            self.class_type = value
                            self.class_type.value_namespace = name_space
                            self.class_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "metric-type"):
                            self.metric_type = value
                            self.metric_type.value_namespace = name_space
                            self.metric_type.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.loose_metric:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.loose_metric:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "loose-metrics" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "loose-metric"):
                        for c in self.loose_metric:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.PathSelection.LooseMetrics.LooseMetric()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.loose_metric.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "loose-metric"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Invalidation(Entity):
                """
                Path invalidation configuration for all
                tunnels
                
                .. attribute:: path_invalidation_action
                
                	Path Invalidation Action
                	**type**\:   :py:class:`PathInvalidationAction <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.PathInvalidationAction>`
                
                .. attribute:: path_invalidation_timeout
                
                	Path Invalidation Timeout
                	**type**\:  int
                
                	**range:** 0..60000
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.PathSelection.Invalidation, self).__init__()

                    self.yang_name = "invalidation"
                    self.yang_parent_name = "path-selection"

                    self.path_invalidation_action = YLeaf(YType.enumeration, "path-invalidation-action")

                    self.path_invalidation_timeout = YLeaf(YType.uint32, "path-invalidation-timeout")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("path_invalidation_action",
                                    "path_invalidation_timeout") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.PathSelection.Invalidation, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.PathSelection.Invalidation, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.path_invalidation_action.is_set or
                        self.path_invalidation_timeout.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.path_invalidation_action.yfilter != YFilter.not_set or
                        self.path_invalidation_timeout.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "invalidation" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.path_invalidation_action.is_set or self.path_invalidation_action.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.path_invalidation_action.get_name_leafdata())
                    if (self.path_invalidation_timeout.is_set or self.path_invalidation_timeout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.path_invalidation_timeout.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "path-invalidation-action" or name == "path-invalidation-timeout"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "path-invalidation-action"):
                        self.path_invalidation_action = value
                        self.path_invalidation_action.value_namespace = name_space
                        self.path_invalidation_action.value_namespace_prefix = name_space_prefix
                    if(value_path == "path-invalidation-timeout"):
                        self.path_invalidation_timeout = value
                        self.path_invalidation_timeout.value_namespace = name_space
                        self.path_invalidation_timeout.value_namespace_prefix = name_space_prefix


            class IgnoreOverloadRole(Entity):
                """
                Path selection to ignore overload node during
                CSPF
                
                .. attribute:: head
                
                	Set if the OL\-bit is to be applied to tunnel heads
                	**type**\:  bool
                
                .. attribute:: mid
                
                	Set if the OL\-bit is to be applied to tunnel midpoints
                	**type**\:  bool
                
                .. attribute:: tail
                
                	Set if the OL\-bit is to be applied to tunnel tails
                	**type**\:  bool
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.PathSelection.IgnoreOverloadRole, self).__init__()

                    self.yang_name = "ignore-overload-role"
                    self.yang_parent_name = "path-selection"

                    self.head = YLeaf(YType.boolean, "head")

                    self.mid = YLeaf(YType.boolean, "mid")

                    self.tail = YLeaf(YType.boolean, "tail")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("head",
                                    "mid",
                                    "tail") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.PathSelection.IgnoreOverloadRole, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.PathSelection.IgnoreOverloadRole, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.head.is_set or
                        self.mid.is_set or
                        self.tail.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.head.yfilter != YFilter.not_set or
                        self.mid.yfilter != YFilter.not_set or
                        self.tail.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "ignore-overload-role" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.head.is_set or self.head.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.head.get_name_leafdata())
                    if (self.mid.is_set or self.mid.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.mid.get_name_leafdata())
                    if (self.tail.is_set or self.tail.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.tail.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "head" or name == "mid" or name == "tail"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "head"):
                        self.head = value
                        self.head.value_namespace = name_space
                        self.head.value_namespace_prefix = name_space_prefix
                    if(value_path == "mid"):
                        self.mid = value
                        self.mid.value_namespace = name_space
                        self.mid.value_namespace_prefix = name_space_prefix
                    if(value_path == "tail"):
                        self.tail = value
                        self.tail.value_namespace = name_space
                        self.tail.value_namespace_prefix = name_space_prefix


            class LooseAffinities(Entity):
                """
                Path selection Loose ERO Affinity Class
                configuration
                
                .. attribute:: loose_affinity
                
                	Path selection Loose ERO Affinity configuration
                	**type**\: list of    :py:class:`LooseAffinity <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.PathSelection.LooseAffinities.LooseAffinity>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.PathSelection.LooseAffinities, self).__init__()

                    self.yang_name = "loose-affinities"
                    self.yang_parent_name = "path-selection"

                    self.loose_affinity = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in () and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.PathSelection.LooseAffinities, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.PathSelection.LooseAffinities, self).__setattr__(name, value)


                class LooseAffinity(Entity):
                    """
                    Path selection Loose ERO Affinity
                    configuration
                    
                    .. attribute:: class_type  <key>
                    
                    	Path Selection class Type
                    	**type**\:  int
                    
                    	**range:** 0..7
                    
                    .. attribute:: affinity
                    
                    	Affinity flags
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{1,8}
                    
                    .. attribute:: mask
                    
                    	Affinity mask
                    	**type**\:  str
                    
                    	**pattern:** [0\-9a\-fA\-F]{1,8}
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GlobalAttributes.PathSelection.LooseAffinities.LooseAffinity, self).__init__()

                        self.yang_name = "loose-affinity"
                        self.yang_parent_name = "loose-affinities"

                        self.class_type = YLeaf(YType.uint32, "class-type")

                        self.affinity = YLeaf(YType.str, "affinity")

                        self.mask = YLeaf(YType.str, "mask")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("class_type",
                                        "affinity",
                                        "mask") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GlobalAttributes.PathSelection.LooseAffinities.LooseAffinity, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GlobalAttributes.PathSelection.LooseAffinities.LooseAffinity, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.class_type.is_set or
                            self.affinity.is_set or
                            self.mask.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.class_type.yfilter != YFilter.not_set or
                            self.affinity.yfilter != YFilter.not_set or
                            self.mask.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "loose-affinity" + "[class-type='" + self.class_type.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/loose-affinities/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.class_type.is_set or self.class_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.class_type.get_name_leafdata())
                        if (self.affinity.is_set or self.affinity.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.affinity.get_name_leafdata())
                        if (self.mask.is_set or self.mask.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.mask.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "class-type" or name == "affinity" or name == "mask"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "class-type"):
                            self.class_type = value
                            self.class_type.value_namespace = name_space
                            self.class_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "affinity"):
                            self.affinity = value
                            self.affinity.value_namespace = name_space
                            self.affinity.value_namespace_prefix = name_space_prefix
                        if(value_path == "mask"):
                            self.mask = value
                            self.mask.value_namespace = name_space
                            self.mask.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.loose_affinity:
                        if (c.has_data()):
                            return True
                    return False

                def has_operation(self):
                    for c in self.loose_affinity:
                        if (c.has_operation()):
                            return True
                    return self.yfilter != YFilter.not_set

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "loose-affinities" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "loose-affinity"):
                        for c in self.loose_affinity:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GlobalAttributes.PathSelection.LooseAffinities.LooseAffinity()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.loose_affinity.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "loose-affinity"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.cost_limit.is_set or
                    self.loose_domain_match.is_set or
                    self.metric.is_set or
                    self.tiebreaker.is_set or
                    (self.ignore_overload_role is not None and self.ignore_overload_role.has_data()) or
                    (self.invalidation is not None and self.invalidation.has_data()) or
                    (self.loose_affinities is not None and self.loose_affinities.has_data()) or
                    (self.loose_metrics is not None and self.loose_metrics.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.cost_limit.yfilter != YFilter.not_set or
                    self.loose_domain_match.yfilter != YFilter.not_set or
                    self.metric.yfilter != YFilter.not_set or
                    self.tiebreaker.yfilter != YFilter.not_set or
                    (self.ignore_overload_role is not None and self.ignore_overload_role.has_operation()) or
                    (self.invalidation is not None and self.invalidation.has_operation()) or
                    (self.loose_affinities is not None and self.loose_affinities.has_operation()) or
                    (self.loose_metrics is not None and self.loose_metrics.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "path-selection" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.cost_limit.is_set or self.cost_limit.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.cost_limit.get_name_leafdata())
                if (self.loose_domain_match.is_set or self.loose_domain_match.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.loose_domain_match.get_name_leafdata())
                if (self.metric.is_set or self.metric.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.metric.get_name_leafdata())
                if (self.tiebreaker.is_set or self.tiebreaker.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.tiebreaker.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "ignore-overload-role"):
                    if (self.ignore_overload_role is None):
                        self.ignore_overload_role = MplsTe.GlobalAttributes.PathSelection.IgnoreOverloadRole()
                        self.ignore_overload_role.parent = self
                        self._children_name_map["ignore_overload_role"] = "ignore-overload-role"
                    return self.ignore_overload_role

                if (child_yang_name == "invalidation"):
                    if (self.invalidation is None):
                        self.invalidation = MplsTe.GlobalAttributes.PathSelection.Invalidation()
                        self.invalidation.parent = self
                        self._children_name_map["invalidation"] = "invalidation"
                    return self.invalidation

                if (child_yang_name == "loose-affinities"):
                    if (self.loose_affinities is None):
                        self.loose_affinities = MplsTe.GlobalAttributes.PathSelection.LooseAffinities()
                        self.loose_affinities.parent = self
                        self._children_name_map["loose_affinities"] = "loose-affinities"
                    return self.loose_affinities

                if (child_yang_name == "loose-metrics"):
                    if (self.loose_metrics is None):
                        self.loose_metrics = MplsTe.GlobalAttributes.PathSelection.LooseMetrics()
                        self.loose_metrics.parent = self
                        self._children_name_map["loose_metrics"] = "loose-metrics"
                    return self.loose_metrics

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "ignore-overload-role" or name == "invalidation" or name == "loose-affinities" or name == "loose-metrics" or name == "cost-limit" or name == "loose-domain-match" or name == "metric" or name == "tiebreaker"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "cost-limit"):
                    self.cost_limit = value
                    self.cost_limit.value_namespace = name_space
                    self.cost_limit.value_namespace_prefix = name_space_prefix
                if(value_path == "loose-domain-match"):
                    self.loose_domain_match = value
                    self.loose_domain_match.value_namespace = name_space
                    self.loose_domain_match.value_namespace_prefix = name_space_prefix
                if(value_path == "metric"):
                    self.metric = value
                    self.metric.value_namespace = name_space
                    self.metric.value_namespace_prefix = name_space_prefix
                if(value_path == "tiebreaker"):
                    self.tiebreaker = value
                    self.tiebreaker.value_namespace = name_space
                    self.tiebreaker.value_namespace_prefix = name_space_prefix


        class AffinityMappings(Entity):
            """
            Affinity Mapping Table configuration
            
            .. attribute:: affinity_mapping
            
            	Affinity Mapping configuration
            	**type**\: list of    :py:class:`AffinityMapping <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GlobalAttributes.AffinityMappings.AffinityMapping>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GlobalAttributes.AffinityMappings, self).__init__()

                self.yang_name = "affinity-mappings"
                self.yang_parent_name = "global-attributes"

                self.affinity_mapping = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GlobalAttributes.AffinityMappings, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GlobalAttributes.AffinityMappings, self).__setattr__(name, value)


            class AffinityMapping(Entity):
                """
                Affinity Mapping configuration
                
                .. attribute:: affinity_name  <key>
                
                	Affinity Name
                	**type**\:  str
                
                	**length:** 1..32
                
                .. attribute:: value
                
                	Affinity Value in Hex number or by Bit position
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: value_type
                
                	Affinity value type
                	**type**\:   :py:class:`MplsTeAffinityValue <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeAffinityValue>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GlobalAttributes.AffinityMappings.AffinityMapping, self).__init__()

                    self.yang_name = "affinity-mapping"
                    self.yang_parent_name = "affinity-mappings"

                    self.affinity_name = YLeaf(YType.str, "affinity-name")

                    self.value = YLeaf(YType.str, "value")

                    self.value_type = YLeaf(YType.enumeration, "value-type")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("affinity_name",
                                    "value",
                                    "value_type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GlobalAttributes.AffinityMappings.AffinityMapping, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GlobalAttributes.AffinityMappings.AffinityMapping, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.affinity_name.is_set or
                        self.value.is_set or
                        self.value_type.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.affinity_name.yfilter != YFilter.not_set or
                        self.value.yfilter != YFilter.not_set or
                        self.value_type.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "affinity-mapping" + "[affinity-name='" + self.affinity_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/affinity-mappings/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.affinity_name.is_set or self.affinity_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.affinity_name.get_name_leafdata())
                    if (self.value.is_set or self.value.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.value.get_name_leafdata())
                    if (self.value_type.is_set or self.value_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.value_type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "affinity-name" or name == "value" or name == "value-type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "affinity-name"):
                        self.affinity_name = value
                        self.affinity_name.value_namespace = name_space
                        self.affinity_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "value"):
                        self.value = value
                        self.value.value_namespace = name_space
                        self.value.value_namespace_prefix = name_space_prefix
                    if(value_path == "value-type"):
                        self.value_type = value
                        self.value_type.value_namespace = name_space
                        self.value_type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.affinity_mapping:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.affinity_mapping:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "affinity-mappings" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "affinity-mapping"):
                    for c in self.affinity_mapping:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsTe.GlobalAttributes.AffinityMappings.AffinityMapping()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.affinity_mapping.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "affinity-mapping"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.advertise_explicit_nulls.is_set or
                self.auto_bandwidth_collect_frequency.is_set or
                self.disable_reoptimize_affinity_failure.is_set or
                self.enable_unequal_load_balancing.is_set or
                self.fault_oam.is_set or
                self.graceful_preemption_on_bandwidth_reduction.is_set or
                self.link_holddown_timer.is_set or
                self.log_all.is_set or
                self.log_frr_protection.is_set or
                self.log_head.is_set or
                self.log_issu_status.is_set or
                self.log_mid.is_set or
                self.log_nsr_status.is_set or
                self.log_preemption.is_set or
                self.log_tail.is_set or
                self.loose_path_retry_period.is_set or
                self.maximum_tunnels.is_set or
                self.path_selection_ignore_overload.is_set or
                self.reopt_delay_path_protect_switchover_timer.is_set or
                self.reoptimize_delay_after_affinity_failure_timer.is_set or
                self.reoptimize_delay_after_frr_timer.is_set or
                self.reoptimize_delay_cleanup_timer.is_set or
                self.reoptimize_delay_install_timer.is_set or
                self.reoptimize_link_up.is_set or
                self.reoptimize_load_balancing.is_set or
                self.reoptimize_timer_frequency.is_set or
                (self.affinity_mappings is not None and self.affinity_mappings.has_data()) or
                (self.attribute_set is not None and self.attribute_set.has_data()) or
                (self.auto_tunnel is not None and self.auto_tunnel.has_data()) or
                (self.bandwidth_accounting is not None and self.bandwidth_accounting.has_data()) or
                (self.bfd_over_lsp is not None and self.bfd_over_lsp.has_data()) or
                (self.fast_reroute is not None and self.fast_reroute.has_data()) or
                (self.hardware_out_of_resource is not None and self.hardware_out_of_resource.has_data()) or
                (self.lsp_out_of_resource is not None and self.lsp_out_of_resource.has_data()) or
                (self.mib is not None and self.mib.has_data()) or
                (self.path_selection is not None and self.path_selection.has_data()) or
                (self.pce_attributes is not None and self.pce_attributes.has_data()) or
                (self.queues is not None and self.queues.has_data()) or
                (self.secondary_router_ids is not None and self.secondary_router_ids.has_data()) or
                (self.soft_preemption is not None and self.soft_preemption.has_data()) or
                (self.srlg is not None and self.srlg.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.advertise_explicit_nulls.yfilter != YFilter.not_set or
                self.auto_bandwidth_collect_frequency.yfilter != YFilter.not_set or
                self.disable_reoptimize_affinity_failure.yfilter != YFilter.not_set or
                self.enable_unequal_load_balancing.yfilter != YFilter.not_set or
                self.fault_oam.yfilter != YFilter.not_set or
                self.graceful_preemption_on_bandwidth_reduction.yfilter != YFilter.not_set or
                self.link_holddown_timer.yfilter != YFilter.not_set or
                self.log_all.yfilter != YFilter.not_set or
                self.log_frr_protection.yfilter != YFilter.not_set or
                self.log_head.yfilter != YFilter.not_set or
                self.log_issu_status.yfilter != YFilter.not_set or
                self.log_mid.yfilter != YFilter.not_set or
                self.log_nsr_status.yfilter != YFilter.not_set or
                self.log_preemption.yfilter != YFilter.not_set or
                self.log_tail.yfilter != YFilter.not_set or
                self.loose_path_retry_period.yfilter != YFilter.not_set or
                self.maximum_tunnels.yfilter != YFilter.not_set or
                self.path_selection_ignore_overload.yfilter != YFilter.not_set or
                self.reopt_delay_path_protect_switchover_timer.yfilter != YFilter.not_set or
                self.reoptimize_delay_after_affinity_failure_timer.yfilter != YFilter.not_set or
                self.reoptimize_delay_after_frr_timer.yfilter != YFilter.not_set or
                self.reoptimize_delay_cleanup_timer.yfilter != YFilter.not_set or
                self.reoptimize_delay_install_timer.yfilter != YFilter.not_set or
                self.reoptimize_link_up.yfilter != YFilter.not_set or
                self.reoptimize_load_balancing.yfilter != YFilter.not_set or
                self.reoptimize_timer_frequency.yfilter != YFilter.not_set or
                (self.affinity_mappings is not None and self.affinity_mappings.has_operation()) or
                (self.attribute_set is not None and self.attribute_set.has_operation()) or
                (self.auto_tunnel is not None and self.auto_tunnel.has_operation()) or
                (self.bandwidth_accounting is not None and self.bandwidth_accounting.has_operation()) or
                (self.bfd_over_lsp is not None and self.bfd_over_lsp.has_operation()) or
                (self.fast_reroute is not None and self.fast_reroute.has_operation()) or
                (self.hardware_out_of_resource is not None and self.hardware_out_of_resource.has_operation()) or
                (self.lsp_out_of_resource is not None and self.lsp_out_of_resource.has_operation()) or
                (self.mib is not None and self.mib.has_operation()) or
                (self.path_selection is not None and self.path_selection.has_operation()) or
                (self.pce_attributes is not None and self.pce_attributes.has_operation()) or
                (self.queues is not None and self.queues.has_operation()) or
                (self.secondary_router_ids is not None and self.secondary_router_ids.has_operation()) or
                (self.soft_preemption is not None and self.soft_preemption.has_operation()) or
                (self.srlg is not None and self.srlg.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "global-attributes" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.advertise_explicit_nulls.is_set or self.advertise_explicit_nulls.yfilter != YFilter.not_set):
                leaf_name_data.append(self.advertise_explicit_nulls.get_name_leafdata())
            if (self.auto_bandwidth_collect_frequency.is_set or self.auto_bandwidth_collect_frequency.yfilter != YFilter.not_set):
                leaf_name_data.append(self.auto_bandwidth_collect_frequency.get_name_leafdata())
            if (self.disable_reoptimize_affinity_failure.is_set or self.disable_reoptimize_affinity_failure.yfilter != YFilter.not_set):
                leaf_name_data.append(self.disable_reoptimize_affinity_failure.get_name_leafdata())
            if (self.enable_unequal_load_balancing.is_set or self.enable_unequal_load_balancing.yfilter != YFilter.not_set):
                leaf_name_data.append(self.enable_unequal_load_balancing.get_name_leafdata())
            if (self.fault_oam.is_set or self.fault_oam.yfilter != YFilter.not_set):
                leaf_name_data.append(self.fault_oam.get_name_leafdata())
            if (self.graceful_preemption_on_bandwidth_reduction.is_set or self.graceful_preemption_on_bandwidth_reduction.yfilter != YFilter.not_set):
                leaf_name_data.append(self.graceful_preemption_on_bandwidth_reduction.get_name_leafdata())
            if (self.link_holddown_timer.is_set or self.link_holddown_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.link_holddown_timer.get_name_leafdata())
            if (self.log_all.is_set or self.log_all.yfilter != YFilter.not_set):
                leaf_name_data.append(self.log_all.get_name_leafdata())
            if (self.log_frr_protection.is_set or self.log_frr_protection.yfilter != YFilter.not_set):
                leaf_name_data.append(self.log_frr_protection.get_name_leafdata())
            if (self.log_head.is_set or self.log_head.yfilter != YFilter.not_set):
                leaf_name_data.append(self.log_head.get_name_leafdata())
            if (self.log_issu_status.is_set or self.log_issu_status.yfilter != YFilter.not_set):
                leaf_name_data.append(self.log_issu_status.get_name_leafdata())
            if (self.log_mid.is_set or self.log_mid.yfilter != YFilter.not_set):
                leaf_name_data.append(self.log_mid.get_name_leafdata())
            if (self.log_nsr_status.is_set or self.log_nsr_status.yfilter != YFilter.not_set):
                leaf_name_data.append(self.log_nsr_status.get_name_leafdata())
            if (self.log_preemption.is_set or self.log_preemption.yfilter != YFilter.not_set):
                leaf_name_data.append(self.log_preemption.get_name_leafdata())
            if (self.log_tail.is_set or self.log_tail.yfilter != YFilter.not_set):
                leaf_name_data.append(self.log_tail.get_name_leafdata())
            if (self.loose_path_retry_period.is_set or self.loose_path_retry_period.yfilter != YFilter.not_set):
                leaf_name_data.append(self.loose_path_retry_period.get_name_leafdata())
            if (self.maximum_tunnels.is_set or self.maximum_tunnels.yfilter != YFilter.not_set):
                leaf_name_data.append(self.maximum_tunnels.get_name_leafdata())
            if (self.path_selection_ignore_overload.is_set or self.path_selection_ignore_overload.yfilter != YFilter.not_set):
                leaf_name_data.append(self.path_selection_ignore_overload.get_name_leafdata())
            if (self.reopt_delay_path_protect_switchover_timer.is_set or self.reopt_delay_path_protect_switchover_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reopt_delay_path_protect_switchover_timer.get_name_leafdata())
            if (self.reoptimize_delay_after_affinity_failure_timer.is_set or self.reoptimize_delay_after_affinity_failure_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reoptimize_delay_after_affinity_failure_timer.get_name_leafdata())
            if (self.reoptimize_delay_after_frr_timer.is_set or self.reoptimize_delay_after_frr_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reoptimize_delay_after_frr_timer.get_name_leafdata())
            if (self.reoptimize_delay_cleanup_timer.is_set or self.reoptimize_delay_cleanup_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reoptimize_delay_cleanup_timer.get_name_leafdata())
            if (self.reoptimize_delay_install_timer.is_set or self.reoptimize_delay_install_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reoptimize_delay_install_timer.get_name_leafdata())
            if (self.reoptimize_link_up.is_set or self.reoptimize_link_up.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reoptimize_link_up.get_name_leafdata())
            if (self.reoptimize_load_balancing.is_set or self.reoptimize_load_balancing.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reoptimize_load_balancing.get_name_leafdata())
            if (self.reoptimize_timer_frequency.is_set or self.reoptimize_timer_frequency.yfilter != YFilter.not_set):
                leaf_name_data.append(self.reoptimize_timer_frequency.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "affinity-mappings"):
                if (self.affinity_mappings is None):
                    self.affinity_mappings = MplsTe.GlobalAttributes.AffinityMappings()
                    self.affinity_mappings.parent = self
                    self._children_name_map["affinity_mappings"] = "affinity-mappings"
                return self.affinity_mappings

            if (child_yang_name == "attribute-set"):
                if (self.attribute_set is None):
                    self.attribute_set = MplsTe.GlobalAttributes.AttributeSet()
                    self.attribute_set.parent = self
                    self._children_name_map["attribute_set"] = "attribute-set"
                return self.attribute_set

            if (child_yang_name == "auto-tunnel"):
                if (self.auto_tunnel is None):
                    self.auto_tunnel = MplsTe.GlobalAttributes.AutoTunnel()
                    self.auto_tunnel.parent = self
                    self._children_name_map["auto_tunnel"] = "auto-tunnel"
                return self.auto_tunnel

            if (child_yang_name == "bandwidth-accounting"):
                if (self.bandwidth_accounting is None):
                    self.bandwidth_accounting = MplsTe.GlobalAttributes.BandwidthAccounting()
                    self.bandwidth_accounting.parent = self
                    self._children_name_map["bandwidth_accounting"] = "bandwidth-accounting"
                return self.bandwidth_accounting

            if (child_yang_name == "bfd-over-lsp"):
                if (self.bfd_over_lsp is None):
                    self.bfd_over_lsp = MplsTe.GlobalAttributes.BfdOverLsp()
                    self.bfd_over_lsp.parent = self
                    self._children_name_map["bfd_over_lsp"] = "bfd-over-lsp"
                return self.bfd_over_lsp

            if (child_yang_name == "fast-reroute"):
                if (self.fast_reroute is None):
                    self.fast_reroute = MplsTe.GlobalAttributes.FastReroute()
                    self.fast_reroute.parent = self
                    self._children_name_map["fast_reroute"] = "fast-reroute"
                return self.fast_reroute

            if (child_yang_name == "hardware-out-of-resource"):
                if (self.hardware_out_of_resource is None):
                    self.hardware_out_of_resource = MplsTe.GlobalAttributes.HardwareOutOfResource()
                    self.hardware_out_of_resource.parent = self
                    self._children_name_map["hardware_out_of_resource"] = "hardware-out-of-resource"
                return self.hardware_out_of_resource

            if (child_yang_name == "lsp-out-of-resource"):
                if (self.lsp_out_of_resource is None):
                    self.lsp_out_of_resource = MplsTe.GlobalAttributes.LspOutOfResource()
                    self.lsp_out_of_resource.parent = self
                    self._children_name_map["lsp_out_of_resource"] = "lsp-out-of-resource"
                return self.lsp_out_of_resource

            if (child_yang_name == "mib"):
                if (self.mib is None):
                    self.mib = MplsTe.GlobalAttributes.Mib()
                    self.mib.parent = self
                    self._children_name_map["mib"] = "mib"
                return self.mib

            if (child_yang_name == "path-selection"):
                if (self.path_selection is None):
                    self.path_selection = MplsTe.GlobalAttributes.PathSelection()
                    self.path_selection.parent = self
                    self._children_name_map["path_selection"] = "path-selection"
                return self.path_selection

            if (child_yang_name == "pce-attributes"):
                if (self.pce_attributes is None):
                    self.pce_attributes = MplsTe.GlobalAttributes.PceAttributes()
                    self.pce_attributes.parent = self
                    self._children_name_map["pce_attributes"] = "pce-attributes"
                return self.pce_attributes

            if (child_yang_name == "queues"):
                if (self.queues is None):
                    self.queues = MplsTe.GlobalAttributes.Queues()
                    self.queues.parent = self
                    self._children_name_map["queues"] = "queues"
                return self.queues

            if (child_yang_name == "secondary-router-ids"):
                if (self.secondary_router_ids is None):
                    self.secondary_router_ids = MplsTe.GlobalAttributes.SecondaryRouterIds()
                    self.secondary_router_ids.parent = self
                    self._children_name_map["secondary_router_ids"] = "secondary-router-ids"
                return self.secondary_router_ids

            if (child_yang_name == "soft-preemption"):
                if (self.soft_preemption is None):
                    self.soft_preemption = MplsTe.GlobalAttributes.SoftPreemption()
                    self.soft_preemption.parent = self
                    self._children_name_map["soft_preemption"] = "soft-preemption"
                return self.soft_preemption

            if (child_yang_name == "srlg"):
                if (self.srlg is None):
                    self.srlg = MplsTe.GlobalAttributes.Srlg()
                    self.srlg.parent = self
                    self._children_name_map["srlg"] = "srlg"
                return self.srlg

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "affinity-mappings" or name == "attribute-set" or name == "auto-tunnel" or name == "bandwidth-accounting" or name == "bfd-over-lsp" or name == "fast-reroute" or name == "hardware-out-of-resource" or name == "lsp-out-of-resource" or name == "mib" or name == "path-selection" or name == "pce-attributes" or name == "queues" or name == "secondary-router-ids" or name == "soft-preemption" or name == "srlg" or name == "advertise-explicit-nulls" or name == "auto-bandwidth-collect-frequency" or name == "disable-reoptimize-affinity-failure" or name == "enable-unequal-load-balancing" or name == "fault-oam" or name == "graceful-preemption-on-bandwidth-reduction" or name == "link-holddown-timer" or name == "log-all" or name == "log-frr-protection" or name == "log-head" or name == "log-issu-status" or name == "log-mid" or name == "log-nsr-status" or name == "log-preemption" or name == "log-tail" or name == "loose-path-retry-period" or name == "maximum-tunnels" or name == "path-selection-ignore-overload" or name == "reopt-delay-path-protect-switchover-timer" or name == "reoptimize-delay-after-affinity-failure-timer" or name == "reoptimize-delay-after-frr-timer" or name == "reoptimize-delay-cleanup-timer" or name == "reoptimize-delay-install-timer" or name == "reoptimize-link-up" or name == "reoptimize-load-balancing" or name == "reoptimize-timer-frequency"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "advertise-explicit-nulls"):
                self.advertise_explicit_nulls = value
                self.advertise_explicit_nulls.value_namespace = name_space
                self.advertise_explicit_nulls.value_namespace_prefix = name_space_prefix
            if(value_path == "auto-bandwidth-collect-frequency"):
                self.auto_bandwidth_collect_frequency = value
                self.auto_bandwidth_collect_frequency.value_namespace = name_space
                self.auto_bandwidth_collect_frequency.value_namespace_prefix = name_space_prefix
            if(value_path == "disable-reoptimize-affinity-failure"):
                self.disable_reoptimize_affinity_failure = value
                self.disable_reoptimize_affinity_failure.value_namespace = name_space
                self.disable_reoptimize_affinity_failure.value_namespace_prefix = name_space_prefix
            if(value_path == "enable-unequal-load-balancing"):
                self.enable_unequal_load_balancing = value
                self.enable_unequal_load_balancing.value_namespace = name_space
                self.enable_unequal_load_balancing.value_namespace_prefix = name_space_prefix
            if(value_path == "fault-oam"):
                self.fault_oam = value
                self.fault_oam.value_namespace = name_space
                self.fault_oam.value_namespace_prefix = name_space_prefix
            if(value_path == "graceful-preemption-on-bandwidth-reduction"):
                self.graceful_preemption_on_bandwidth_reduction = value
                self.graceful_preemption_on_bandwidth_reduction.value_namespace = name_space
                self.graceful_preemption_on_bandwidth_reduction.value_namespace_prefix = name_space_prefix
            if(value_path == "link-holddown-timer"):
                self.link_holddown_timer = value
                self.link_holddown_timer.value_namespace = name_space
                self.link_holddown_timer.value_namespace_prefix = name_space_prefix
            if(value_path == "log-all"):
                self.log_all = value
                self.log_all.value_namespace = name_space
                self.log_all.value_namespace_prefix = name_space_prefix
            if(value_path == "log-frr-protection"):
                self.log_frr_protection = value
                self.log_frr_protection.value_namespace = name_space
                self.log_frr_protection.value_namespace_prefix = name_space_prefix
            if(value_path == "log-head"):
                self.log_head = value
                self.log_head.value_namespace = name_space
                self.log_head.value_namespace_prefix = name_space_prefix
            if(value_path == "log-issu-status"):
                self.log_issu_status = value
                self.log_issu_status.value_namespace = name_space
                self.log_issu_status.value_namespace_prefix = name_space_prefix
            if(value_path == "log-mid"):
                self.log_mid = value
                self.log_mid.value_namespace = name_space
                self.log_mid.value_namespace_prefix = name_space_prefix
            if(value_path == "log-nsr-status"):
                self.log_nsr_status = value
                self.log_nsr_status.value_namespace = name_space
                self.log_nsr_status.value_namespace_prefix = name_space_prefix
            if(value_path == "log-preemption"):
                self.log_preemption = value
                self.log_preemption.value_namespace = name_space
                self.log_preemption.value_namespace_prefix = name_space_prefix
            if(value_path == "log-tail"):
                self.log_tail = value
                self.log_tail.value_namespace = name_space
                self.log_tail.value_namespace_prefix = name_space_prefix
            if(value_path == "loose-path-retry-period"):
                self.loose_path_retry_period = value
                self.loose_path_retry_period.value_namespace = name_space
                self.loose_path_retry_period.value_namespace_prefix = name_space_prefix
            if(value_path == "maximum-tunnels"):
                self.maximum_tunnels = value
                self.maximum_tunnels.value_namespace = name_space
                self.maximum_tunnels.value_namespace_prefix = name_space_prefix
            if(value_path == "path-selection-ignore-overload"):
                self.path_selection_ignore_overload = value
                self.path_selection_ignore_overload.value_namespace = name_space
                self.path_selection_ignore_overload.value_namespace_prefix = name_space_prefix
            if(value_path == "reopt-delay-path-protect-switchover-timer"):
                self.reopt_delay_path_protect_switchover_timer = value
                self.reopt_delay_path_protect_switchover_timer.value_namespace = name_space
                self.reopt_delay_path_protect_switchover_timer.value_namespace_prefix = name_space_prefix
            if(value_path == "reoptimize-delay-after-affinity-failure-timer"):
                self.reoptimize_delay_after_affinity_failure_timer = value
                self.reoptimize_delay_after_affinity_failure_timer.value_namespace = name_space
                self.reoptimize_delay_after_affinity_failure_timer.value_namespace_prefix = name_space_prefix
            if(value_path == "reoptimize-delay-after-frr-timer"):
                self.reoptimize_delay_after_frr_timer = value
                self.reoptimize_delay_after_frr_timer.value_namespace = name_space
                self.reoptimize_delay_after_frr_timer.value_namespace_prefix = name_space_prefix
            if(value_path == "reoptimize-delay-cleanup-timer"):
                self.reoptimize_delay_cleanup_timer = value
                self.reoptimize_delay_cleanup_timer.value_namespace = name_space
                self.reoptimize_delay_cleanup_timer.value_namespace_prefix = name_space_prefix
            if(value_path == "reoptimize-delay-install-timer"):
                self.reoptimize_delay_install_timer = value
                self.reoptimize_delay_install_timer.value_namespace = name_space
                self.reoptimize_delay_install_timer.value_namespace_prefix = name_space_prefix
            if(value_path == "reoptimize-link-up"):
                self.reoptimize_link_up = value
                self.reoptimize_link_up.value_namespace = name_space
                self.reoptimize_link_up.value_namespace_prefix = name_space_prefix
            if(value_path == "reoptimize-load-balancing"):
                self.reoptimize_load_balancing = value
                self.reoptimize_load_balancing.value_namespace = name_space
                self.reoptimize_load_balancing.value_namespace_prefix = name_space_prefix
            if(value_path == "reoptimize-timer-frequency"):
                self.reoptimize_timer_frequency = value
                self.reoptimize_timer_frequency.value_namespace = name_space
                self.reoptimize_timer_frequency.value_namespace_prefix = name_space_prefix


    class TransportProfile(Entity):
        """
        MPLS transport profile configuration data
        
        .. attribute:: alarm
        
        	Alarm management
        	**type**\:   :py:class:`Alarm <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Alarm>`
        
        .. attribute:: bfd
        
        	Configure BFD parameters
        	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Bfd>`
        
        .. attribute:: fault
        
        	Fault management
        	**type**\:   :py:class:`Fault <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Fault>`
        
        .. attribute:: global_id
        
        	Transport profile global identifier
        	**type**\:  int
        
        	**range:** 1..65535
        
        .. attribute:: midpoints
        
        	MPLS\-TP tunnel mid\-point table
        	**type**\:   :py:class:`Midpoints <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Midpoints>`
        
        .. attribute:: node_id
        
        	Node identifier in IPv4 address format
        	**type**\:  str
        
        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(MplsTe.TransportProfile, self).__init__()

            self.yang_name = "transport-profile"
            self.yang_parent_name = "mpls-te"

            self.global_id = YLeaf(YType.uint32, "global-id")

            self.node_id = YLeaf(YType.str, "node-id")

            self.alarm = MplsTe.TransportProfile.Alarm()
            self.alarm.parent = self
            self._children_name_map["alarm"] = "alarm"
            self._children_yang_names.add("alarm")

            self.bfd = MplsTe.TransportProfile.Bfd()
            self.bfd.parent = self
            self._children_name_map["bfd"] = "bfd"
            self._children_yang_names.add("bfd")

            self.fault = MplsTe.TransportProfile.Fault()
            self.fault.parent = self
            self._children_name_map["fault"] = "fault"
            self._children_yang_names.add("fault")

            self.midpoints = MplsTe.TransportProfile.Midpoints()
            self.midpoints.parent = self
            self._children_name_map["midpoints"] = "midpoints"
            self._children_yang_names.add("midpoints")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("global_id",
                            "node_id") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(MplsTe.TransportProfile, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(MplsTe.TransportProfile, self).__setattr__(name, value)


        class Fault(Entity):
            """
            Fault management
            
            .. attribute:: protection_trigger
            
            	OAM events that trigger protection switching
            	**type**\:   :py:class:`ProtectionTrigger <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Fault.ProtectionTrigger>`
            
            .. attribute:: refresh_interval
            
            	Periodic refresh interval for fault OAM messages
            	**type**\:  int
            
            	**range:** 1..20
            
            	**units**\: second
            
            	**default value**\: 20
            
            .. attribute:: wait_to_restore_interval
            
            	Waiting time before restoring working LSP
            	**type**\:  int
            
            	**range:** 0..2147483647
            
            	**units**\: second
            
            	**default value**\: 0
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.TransportProfile.Fault, self).__init__()

                self.yang_name = "fault"
                self.yang_parent_name = "transport-profile"

                self.refresh_interval = YLeaf(YType.uint32, "refresh-interval")

                self.wait_to_restore_interval = YLeaf(YType.uint32, "wait-to-restore-interval")

                self.protection_trigger = MplsTe.TransportProfile.Fault.ProtectionTrigger()
                self.protection_trigger.parent = self
                self._children_name_map["protection_trigger"] = "protection-trigger"
                self._children_yang_names.add("protection-trigger")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("refresh_interval",
                                "wait_to_restore_interval") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.TransportProfile.Fault, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.TransportProfile.Fault, self).__setattr__(name, value)


            class ProtectionTrigger(Entity):
                """
                OAM events that trigger protection switching
                
                .. attribute:: ais
                
                	Enable protection switching due to AIS event
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: ldi
                
                	Protection switching due to LDI event
                	**type**\:   :py:class:`Ldi <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Fault.ProtectionTrigger.Ldi>`
                
                .. attribute:: lkr
                
                	Protection switching due to LKR event
                	**type**\:   :py:class:`Lkr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Fault.ProtectionTrigger.Lkr>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.TransportProfile.Fault.ProtectionTrigger, self).__init__()

                    self.yang_name = "protection-trigger"
                    self.yang_parent_name = "fault"

                    self.ais = YLeaf(YType.empty, "ais")

                    self.ldi = MplsTe.TransportProfile.Fault.ProtectionTrigger.Ldi()
                    self.ldi.parent = self
                    self._children_name_map["ldi"] = "ldi"
                    self._children_yang_names.add("ldi")

                    self.lkr = MplsTe.TransportProfile.Fault.ProtectionTrigger.Lkr()
                    self.lkr.parent = self
                    self._children_name_map["lkr"] = "lkr"
                    self._children_yang_names.add("lkr")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ais") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.TransportProfile.Fault.ProtectionTrigger, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.TransportProfile.Fault.ProtectionTrigger, self).__setattr__(name, value)


                class Ldi(Entity):
                    """
                    Protection switching due to LDI event
                    
                    .. attribute:: disable
                    
                    	Disable protection switching due to LDI event
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.TransportProfile.Fault.ProtectionTrigger.Ldi, self).__init__()

                        self.yang_name = "ldi"
                        self.yang_parent_name = "protection-trigger"

                        self.disable = YLeaf(YType.empty, "disable")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("disable") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.TransportProfile.Fault.ProtectionTrigger.Ldi, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.TransportProfile.Fault.ProtectionTrigger.Ldi, self).__setattr__(name, value)

                    def has_data(self):
                        return self.disable.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.disable.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ldi" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/fault/protection-trigger/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "disable"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "disable"):
                            self.disable = value
                            self.disable.value_namespace = name_space
                            self.disable.value_namespace_prefix = name_space_prefix


                class Lkr(Entity):
                    """
                    Protection switching due to LKR event
                    
                    .. attribute:: disable
                    
                    	Disable protection switching due to LKR event
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.TransportProfile.Fault.ProtectionTrigger.Lkr, self).__init__()

                        self.yang_name = "lkr"
                        self.yang_parent_name = "protection-trigger"

                        self.disable = YLeaf(YType.empty, "disable")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("disable") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.TransportProfile.Fault.ProtectionTrigger.Lkr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.TransportProfile.Fault.ProtectionTrigger.Lkr, self).__setattr__(name, value)

                    def has_data(self):
                        return self.disable.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.disable.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "lkr" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/fault/protection-trigger/%s" % self.get_segment_path()
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.disable.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "disable"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "disable"):
                            self.disable = value
                            self.disable.value_namespace = name_space
                            self.disable.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.ais.is_set or
                        (self.ldi is not None and self.ldi.has_data()) or
                        (self.lkr is not None and self.lkr.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ais.yfilter != YFilter.not_set or
                        (self.ldi is not None and self.ldi.has_operation()) or
                        (self.lkr is not None and self.lkr.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "protection-trigger" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/fault/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ais.is_set or self.ais.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ais.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ldi"):
                        if (self.ldi is None):
                            self.ldi = MplsTe.TransportProfile.Fault.ProtectionTrigger.Ldi()
                            self.ldi.parent = self
                            self._children_name_map["ldi"] = "ldi"
                        return self.ldi

                    if (child_yang_name == "lkr"):
                        if (self.lkr is None):
                            self.lkr = MplsTe.TransportProfile.Fault.ProtectionTrigger.Lkr()
                            self.lkr.parent = self
                            self._children_name_map["lkr"] = "lkr"
                        return self.lkr

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ldi" or name == "lkr" or name == "ais"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ais"):
                        self.ais = value
                        self.ais.value_namespace = name_space
                        self.ais.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.refresh_interval.is_set or
                    self.wait_to_restore_interval.is_set or
                    (self.protection_trigger is not None and self.protection_trigger.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.refresh_interval.yfilter != YFilter.not_set or
                    self.wait_to_restore_interval.yfilter != YFilter.not_set or
                    (self.protection_trigger is not None and self.protection_trigger.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "fault" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.refresh_interval.is_set or self.refresh_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.refresh_interval.get_name_leafdata())
                if (self.wait_to_restore_interval.is_set or self.wait_to_restore_interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.wait_to_restore_interval.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "protection-trigger"):
                    if (self.protection_trigger is None):
                        self.protection_trigger = MplsTe.TransportProfile.Fault.ProtectionTrigger()
                        self.protection_trigger.parent = self
                        self._children_name_map["protection_trigger"] = "protection-trigger"
                    return self.protection_trigger

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "protection-trigger" or name == "refresh-interval" or name == "wait-to-restore-interval"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "refresh-interval"):
                    self.refresh_interval = value
                    self.refresh_interval.value_namespace = name_space
                    self.refresh_interval.value_namespace_prefix = name_space_prefix
                if(value_path == "wait-to-restore-interval"):
                    self.wait_to_restore_interval = value
                    self.wait_to_restore_interval.value_namespace = name_space
                    self.wait_to_restore_interval.value_namespace_prefix = name_space_prefix


        class Alarm(Entity):
            """
            Alarm management
            
            .. attribute:: enable_alarm
            
            	Enable Transport Profile Alarm
            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
            
            .. attribute:: soak_time
            
            	Duration of soaking alarms
            	**type**\:  int
            
            	**range:** 0..10
            
            	**units**\: second
            
            	**default value**\: 3
            
            .. attribute:: suppress_event
            
            	Suppress all tunnel/LSP alarms
            	**type**\:   :py:class:`SuppressEvent <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Alarm.SuppressEvent>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.TransportProfile.Alarm, self).__init__()

                self.yang_name = "alarm"
                self.yang_parent_name = "transport-profile"

                self.enable_alarm = YLeaf(YType.empty, "enable-alarm")

                self.soak_time = YLeaf(YType.uint32, "soak-time")

                self.suppress_event = MplsTe.TransportProfile.Alarm.SuppressEvent()
                self.suppress_event.parent = self
                self._children_name_map["suppress_event"] = "suppress-event"
                self._children_yang_names.add("suppress-event")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("enable_alarm",
                                "soak_time") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.TransportProfile.Alarm, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.TransportProfile.Alarm, self).__setattr__(name, value)


            class SuppressEvent(Entity):
                """
                Suppress all tunnel/LSP alarms
                
                .. attribute:: disable
                
                	Disable alarm suppression
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.TransportProfile.Alarm.SuppressEvent, self).__init__()

                    self.yang_name = "suppress-event"
                    self.yang_parent_name = "alarm"

                    self.disable = YLeaf(YType.empty, "disable")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("disable") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.TransportProfile.Alarm.SuppressEvent, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.TransportProfile.Alarm.SuppressEvent, self).__setattr__(name, value)

                def has_data(self):
                    return self.disable.is_set

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.disable.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "suppress-event" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/alarm/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.disable.is_set or self.disable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.disable.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "disable"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "disable"):
                        self.disable = value
                        self.disable.value_namespace = name_space
                        self.disable.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.enable_alarm.is_set or
                    self.soak_time.is_set or
                    (self.suppress_event is not None and self.suppress_event.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.enable_alarm.yfilter != YFilter.not_set or
                    self.soak_time.yfilter != YFilter.not_set or
                    (self.suppress_event is not None and self.suppress_event.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "alarm" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.enable_alarm.is_set or self.enable_alarm.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.enable_alarm.get_name_leafdata())
                if (self.soak_time.is_set or self.soak_time.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.soak_time.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "suppress-event"):
                    if (self.suppress_event is None):
                        self.suppress_event = MplsTe.TransportProfile.Alarm.SuppressEvent()
                        self.suppress_event.parent = self
                        self._children_name_map["suppress_event"] = "suppress-event"
                    return self.suppress_event

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "suppress-event" or name == "enable-alarm" or name == "soak-time"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "enable-alarm"):
                    self.enable_alarm = value
                    self.enable_alarm.value_namespace = name_space
                    self.enable_alarm.value_namespace_prefix = name_space_prefix
                if(value_path == "soak-time"):
                    self.soak_time = value
                    self.soak_time.value_namespace = name_space
                    self.soak_time.value_namespace_prefix = name_space_prefix


        class Bfd(Entity):
            """
            Configure BFD parameters
            
            .. attribute:: detection_multiplier
            
            	Detect multiplier
            	**type**\:  int
            
            	**range:** 2..10
            
            .. attribute:: detection_multiplier_standby
            
            	Detect multiplier for standby transport profile LSP
            	**type**\:  int
            
            	**range:** 2..10
            
            .. attribute:: min_interval
            
            	Hello interval, either in milli\-seconds or in micro\-seconds
            	**type**\:   :py:class:`MinInterval <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Bfd.MinInterval>`
            
            .. attribute:: min_interval_standby
            
            	Hello interval for standby transport profile LSPs, either in milli\-seconds or in micro\-seconds
            	**type**\:   :py:class:`MinIntervalStandby <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Bfd.MinIntervalStandby>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.TransportProfile.Bfd, self).__init__()

                self.yang_name = "bfd"
                self.yang_parent_name = "transport-profile"

                self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                self.detection_multiplier_standby = YLeaf(YType.uint32, "detection-multiplier-standby")

                self.min_interval = MplsTe.TransportProfile.Bfd.MinInterval()
                self.min_interval.parent = self
                self._children_name_map["min_interval"] = "min-interval"
                self._children_yang_names.add("min-interval")

                self.min_interval_standby = MplsTe.TransportProfile.Bfd.MinIntervalStandby()
                self.min_interval_standby.parent = self
                self._children_name_map["min_interval_standby"] = "min-interval-standby"
                self._children_yang_names.add("min-interval-standby")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("detection_multiplier",
                                "detection_multiplier_standby") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.TransportProfile.Bfd, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.TransportProfile.Bfd, self).__setattr__(name, value)


            class MinIntervalStandby(Entity):
                """
                Hello interval for standby transport profile
                LSPs, either in milli\-seconds or in
                micro\-seconds
                
                .. attribute:: interval_standby_ms
                
                	Hello interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 3..5000
                
                	**units**\: millisecond
                
                .. attribute:: interval_standby_us
                
                	Hello interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 3000..5000000
                
                	**units**\: microsecond
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.TransportProfile.Bfd.MinIntervalStandby, self).__init__()

                    self.yang_name = "min-interval-standby"
                    self.yang_parent_name = "bfd"

                    self.interval_standby_ms = YLeaf(YType.uint32, "interval-standby-ms")

                    self.interval_standby_us = YLeaf(YType.uint32, "interval-standby-us")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interval_standby_ms",
                                    "interval_standby_us") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.TransportProfile.Bfd.MinIntervalStandby, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.TransportProfile.Bfd.MinIntervalStandby, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interval_standby_ms.is_set or
                        self.interval_standby_us.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interval_standby_ms.yfilter != YFilter.not_set or
                        self.interval_standby_us.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "min-interval-standby" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/bfd/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interval_standby_ms.is_set or self.interval_standby_ms.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval_standby_ms.get_name_leafdata())
                    if (self.interval_standby_us.is_set or self.interval_standby_us.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval_standby_us.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interval-standby-ms" or name == "interval-standby-us"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interval-standby-ms"):
                        self.interval_standby_ms = value
                        self.interval_standby_ms.value_namespace = name_space
                        self.interval_standby_ms.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval-standby-us"):
                        self.interval_standby_us = value
                        self.interval_standby_us.value_namespace = name_space
                        self.interval_standby_us.value_namespace_prefix = name_space_prefix


            class MinInterval(Entity):
                """
                Hello interval, either in milli\-seconds or in
                micro\-seconds
                
                .. attribute:: interval_ms
                
                	Hello interval in milli\-seconds
                	**type**\:  int
                
                	**range:** 3..5000
                
                	**units**\: millisecond
                
                .. attribute:: interval_us
                
                	Hello interval in micro\-seconds
                	**type**\:  int
                
                	**range:** 3000..5000000
                
                	**units**\: microsecond
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.TransportProfile.Bfd.MinInterval, self).__init__()

                    self.yang_name = "min-interval"
                    self.yang_parent_name = "bfd"

                    self.interval_ms = YLeaf(YType.uint32, "interval-ms")

                    self.interval_us = YLeaf(YType.uint32, "interval-us")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("interval_ms",
                                    "interval_us") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.TransportProfile.Bfd.MinInterval, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.TransportProfile.Bfd.MinInterval, self).__setattr__(name, value)

                def has_data(self):
                    return (
                        self.interval_ms.is_set or
                        self.interval_us.is_set)

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.interval_ms.yfilter != YFilter.not_set or
                        self.interval_us.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "min-interval" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/bfd/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.interval_ms.is_set or self.interval_ms.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval_ms.get_name_leafdata())
                    if (self.interval_us.is_set or self.interval_us.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.interval_us.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "interval-ms" or name == "interval-us"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "interval-ms"):
                        self.interval_ms = value
                        self.interval_ms.value_namespace = name_space
                        self.interval_ms.value_namespace_prefix = name_space_prefix
                    if(value_path == "interval-us"):
                        self.interval_us = value
                        self.interval_us.value_namespace = name_space
                        self.interval_us.value_namespace_prefix = name_space_prefix

            def has_data(self):
                return (
                    self.detection_multiplier.is_set or
                    self.detection_multiplier_standby.is_set or
                    (self.min_interval is not None and self.min_interval.has_data()) or
                    (self.min_interval_standby is not None and self.min_interval_standby.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.detection_multiplier.yfilter != YFilter.not_set or
                    self.detection_multiplier_standby.yfilter != YFilter.not_set or
                    (self.min_interval is not None and self.min_interval.has_operation()) or
                    (self.min_interval_standby is not None and self.min_interval_standby.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "bfd" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                if (self.detection_multiplier_standby.is_set or self.detection_multiplier_standby.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.detection_multiplier_standby.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "min-interval"):
                    if (self.min_interval is None):
                        self.min_interval = MplsTe.TransportProfile.Bfd.MinInterval()
                        self.min_interval.parent = self
                        self._children_name_map["min_interval"] = "min-interval"
                    return self.min_interval

                if (child_yang_name == "min-interval-standby"):
                    if (self.min_interval_standby is None):
                        self.min_interval_standby = MplsTe.TransportProfile.Bfd.MinIntervalStandby()
                        self.min_interval_standby.parent = self
                        self._children_name_map["min_interval_standby"] = "min-interval-standby"
                    return self.min_interval_standby

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "min-interval" or name == "min-interval-standby" or name == "detection-multiplier" or name == "detection-multiplier-standby"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "detection-multiplier"):
                    self.detection_multiplier = value
                    self.detection_multiplier.value_namespace = name_space
                    self.detection_multiplier.value_namespace_prefix = name_space_prefix
                if(value_path == "detection-multiplier-standby"):
                    self.detection_multiplier_standby = value
                    self.detection_multiplier_standby.value_namespace = name_space
                    self.detection_multiplier_standby.value_namespace_prefix = name_space_prefix


        class Midpoints(Entity):
            """
            MPLS\-TP tunnel mid\-point table
            
            .. attribute:: midpoint
            
            	Transport profile mid\-point identifier
            	**type**\: list of    :py:class:`Midpoint <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Midpoints.Midpoint>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.TransportProfile.Midpoints, self).__init__()

                self.yang_name = "midpoints"
                self.yang_parent_name = "transport-profile"

                self.midpoint = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.TransportProfile.Midpoints, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.TransportProfile.Midpoints, self).__setattr__(name, value)


            class Midpoint(Entity):
                """
                Transport profile mid\-point identifier
                
                .. attribute:: midpoint_name  <key>
                
                	Name of mid\-point
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: destination
                
                	Node identifier, tunnel identifier and optional global identifier of the destination of the LSP
                	**type**\:   :py:class:`Destination <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Midpoints.Midpoint.Destination>`
                
                	**presence node**\: True
                
                .. attribute:: forward_lsp
                
                	Forward transport profile LSP
                	**type**\:   :py:class:`ForwardLsp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp>`
                
                .. attribute:: lsp_id
                
                	Numeric identifier
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: lsp_protect
                
                	Enable LSP protection
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: reverse_lsp
                
                	none
                	**type**\:   :py:class:`ReverseLsp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp>`
                
                .. attribute:: source
                
                	Node identifier, tunnel identifier and optional global identifier of the source of the LSP
                	**type**\:   :py:class:`Source <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Midpoints.Midpoint.Source>`
                
                	**presence node**\: True
                
                .. attribute:: tunnel_name
                
                	Tunnel Name
                	**type**\:  str
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.TransportProfile.Midpoints.Midpoint, self).__init__()

                    self.yang_name = "midpoint"
                    self.yang_parent_name = "midpoints"

                    self.midpoint_name = YLeaf(YType.str, "midpoint-name")

                    self.lsp_id = YLeaf(YType.uint32, "lsp-id")

                    self.lsp_protect = YLeaf(YType.empty, "lsp-protect")

                    self.tunnel_name = YLeaf(YType.str, "tunnel-name")

                    self.destination = None
                    self._children_name_map["destination"] = "destination"
                    self._children_yang_names.add("destination")

                    self.forward_lsp = MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp()
                    self.forward_lsp.parent = self
                    self._children_name_map["forward_lsp"] = "forward-lsp"
                    self._children_yang_names.add("forward-lsp")

                    self.reverse_lsp = MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp()
                    self.reverse_lsp.parent = self
                    self._children_name_map["reverse_lsp"] = "reverse-lsp"
                    self._children_yang_names.add("reverse-lsp")

                    self.source = None
                    self._children_name_map["source"] = "source"
                    self._children_yang_names.add("source")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("midpoint_name",
                                    "lsp_id",
                                    "lsp_protect",
                                    "tunnel_name") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.TransportProfile.Midpoints.Midpoint, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.TransportProfile.Midpoints.Midpoint, self).__setattr__(name, value)


                class Source(Entity):
                    """
                    Node identifier, tunnel identifier and
                    optional global identifier of the source of
                    the LSP
                    
                    .. attribute:: global_id
                    
                    	Global identifier in numeric value
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    .. attribute:: node_id
                    
                    	Node identifier in IPv4 address format
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: tunnel_id
                    
                    	Tunnel identifier in numeric value
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**mandatory**\: True
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.TransportProfile.Midpoints.Midpoint.Source, self).__init__()

                        self.yang_name = "source"
                        self.yang_parent_name = "midpoint"
                        self.is_presence_container = True

                        self.global_id = YLeaf(YType.uint32, "global-id")

                        self.node_id = YLeaf(YType.str, "node-id")

                        self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("global_id",
                                        "node_id",
                                        "tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.TransportProfile.Midpoints.Midpoint.Source, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.TransportProfile.Midpoints.Midpoint.Source, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.global_id.is_set or
                            self.node_id.is_set or
                            self.tunnel_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.global_id.yfilter != YFilter.not_set or
                            self.node_id.yfilter != YFilter.not_set or
                            self.tunnel_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "source" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.global_id.is_set or self.global_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.global_id.get_name_leafdata())
                        if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.node_id.get_name_leafdata())
                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "global-id" or name == "node-id" or name == "tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "global-id"):
                            self.global_id = value
                            self.global_id.value_namespace = name_space
                            self.global_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "node-id"):
                            self.node_id = value
                            self.node_id.value_namespace = name_space
                            self.node_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-id"):
                            self.tunnel_id = value
                            self.tunnel_id.value_namespace = name_space
                            self.tunnel_id.value_namespace_prefix = name_space_prefix


                class Destination(Entity):
                    """
                    Node identifier, tunnel identifier and
                    optional global identifier of the destination
                    of the LSP
                    
                    .. attribute:: global_id
                    
                    	Global identifier in numeric value
                    	**type**\:  int
                    
                    	**range:** 1..65535
                    
                    .. attribute:: node_id
                    
                    	Node identifier in IPv4 address format
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: tunnel_id
                    
                    	Tunnel identifier in numeric value
                    	**type**\:  int
                    
                    	**range:** 0..65535
                    
                    	**mandatory**\: True
                    
                    

                    This class is a :ref:`presence class<presence-class>`

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.TransportProfile.Midpoints.Midpoint.Destination, self).__init__()

                        self.yang_name = "destination"
                        self.yang_parent_name = "midpoint"
                        self.is_presence_container = True

                        self.global_id = YLeaf(YType.uint32, "global-id")

                        self.node_id = YLeaf(YType.str, "node-id")

                        self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("global_id",
                                        "node_id",
                                        "tunnel_id") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.TransportProfile.Midpoints.Midpoint.Destination, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.TransportProfile.Midpoints.Midpoint.Destination, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.global_id.is_set or
                            self.node_id.is_set or
                            self.tunnel_id.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.global_id.yfilter != YFilter.not_set or
                            self.node_id.yfilter != YFilter.not_set or
                            self.tunnel_id.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "destination" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.global_id.is_set or self.global_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.global_id.get_name_leafdata())
                        if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.node_id.get_name_leafdata())
                        if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_id.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "global-id" or name == "node-id" or name == "tunnel-id"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "global-id"):
                            self.global_id = value
                            self.global_id.value_namespace = name_space
                            self.global_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "node-id"):
                            self.node_id = value
                            self.node_id.value_namespace = name_space
                            self.node_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-id"):
                            self.tunnel_id = value
                            self.tunnel_id.value_namespace = name_space
                            self.tunnel_id.value_namespace_prefix = name_space_prefix


                class ForwardLsp(Entity):
                    """
                    Forward transport profile LSP
                    
                    .. attribute:: forward_bandwidth
                    
                    	Bandwidth of forward transport profile LSP
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: kbit/s
                    
                    .. attribute:: forward_io_map
                    
                    	Label cross\-connect of forward transport profile LSP
                    	**type**\:   :py:class:`ForwardIoMap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp.ForwardIoMap>`
                    
                    	**presence node**\: True
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp, self).__init__()

                        self.yang_name = "forward-lsp"
                        self.yang_parent_name = "midpoint"

                        self.forward_bandwidth = YLeaf(YType.uint32, "forward-bandwidth")

                        self.forward_io_map = None
                        self._children_name_map["forward_io_map"] = "forward-io-map"
                        self._children_yang_names.add("forward-io-map")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("forward_bandwidth") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp, self).__setattr__(name, value)


                    class ForwardIoMap(Entity):
                        """
                        Label cross\-connect of forward transport
                        profile LSP
                        
                        .. attribute:: in_label
                        
                        	MPLS label
                        	**type**\:  int
                        
                        	**range:** 16..4015
                        
                        .. attribute:: out_label
                        
                        	Outgoing MPLS label
                        	**type**\:  int
                        
                        	**range:** 16..1048575
                        
                        	**mandatory**\: True
                        
                        .. attribute:: out_link
                        
                        	Transport profile identifier of outgoing link
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp.ForwardIoMap, self).__init__()

                            self.yang_name = "forward-io-map"
                            self.yang_parent_name = "forward-lsp"
                            self.is_presence_container = True

                            self.in_label = YLeaf(YType.uint32, "in-label")

                            self.out_label = YLeaf(YType.uint32, "out-label")

                            self.out_link = YLeaf(YType.uint32, "out-link")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("in_label",
                                            "out_label",
                                            "out_link") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp.ForwardIoMap, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp.ForwardIoMap, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.in_label.is_set or
                                self.out_label.is_set or
                                self.out_link.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.in_label.yfilter != YFilter.not_set or
                                self.out_label.yfilter != YFilter.not_set or
                                self.out_link.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "forward-io-map" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.in_label.is_set or self.in_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_label.get_name_leafdata())
                            if (self.out_label.is_set or self.out_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_label.get_name_leafdata())
                            if (self.out_link.is_set or self.out_link.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_link.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "in-label" or name == "out-label" or name == "out-link"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "in-label"):
                                self.in_label = value
                                self.in_label.value_namespace = name_space
                                self.in_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-label"):
                                self.out_label = value
                                self.out_label.value_namespace = name_space
                                self.out_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-link"):
                                self.out_link = value
                                self.out_link.value_namespace = name_space
                                self.out_link.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.forward_bandwidth.is_set or
                            (self.forward_io_map is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.forward_bandwidth.yfilter != YFilter.not_set or
                            (self.forward_io_map is not None and self.forward_io_map.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "forward-lsp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.forward_bandwidth.is_set or self.forward_bandwidth.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.forward_bandwidth.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "forward-io-map"):
                            if (self.forward_io_map is None):
                                self.forward_io_map = MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp.ForwardIoMap()
                                self.forward_io_map.parent = self
                                self._children_name_map["forward_io_map"] = "forward-io-map"
                            return self.forward_io_map

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "forward-io-map" or name == "forward-bandwidth"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "forward-bandwidth"):
                            self.forward_bandwidth = value
                            self.forward_bandwidth.value_namespace = name_space
                            self.forward_bandwidth.value_namespace_prefix = name_space_prefix


                class ReverseLsp(Entity):
                    """
                    none
                    
                    .. attribute:: reverse_bandwidth
                    
                    	Bandwidth of reverse transport profile LSP
                    	**type**\:  int
                    
                    	**range:** 0..4294967295
                    
                    	**units**\: kbit/s
                    
                    .. attribute:: reverse_io_map
                    
                    	Label cross\-connect of reverse transport profile LSP
                    	**type**\:   :py:class:`ReverseIoMap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp.ReverseIoMap>`
                    
                    	**presence node**\: True
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp, self).__init__()

                        self.yang_name = "reverse-lsp"
                        self.yang_parent_name = "midpoint"

                        self.reverse_bandwidth = YLeaf(YType.uint32, "reverse-bandwidth")

                        self.reverse_io_map = None
                        self._children_name_map["reverse_io_map"] = "reverse-io-map"
                        self._children_yang_names.add("reverse-io-map")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("reverse_bandwidth") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp, self).__setattr__(name, value)


                    class ReverseIoMap(Entity):
                        """
                        Label cross\-connect of reverse transport
                        profile LSP
                        
                        .. attribute:: in_label
                        
                        	MPLS label
                        	**type**\:  int
                        
                        	**range:** 16..4015
                        
                        .. attribute:: out_label
                        
                        	Outgoing MPLS label
                        	**type**\:  int
                        
                        	**range:** 16..1048575
                        
                        	**mandatory**\: True
                        
                        .. attribute:: out_link
                        
                        	Transport profile identifier of outgoing link
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        	**mandatory**\: True
                        
                        

                        This class is a :ref:`presence class<presence-class>`

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp.ReverseIoMap, self).__init__()

                            self.yang_name = "reverse-io-map"
                            self.yang_parent_name = "reverse-lsp"
                            self.is_presence_container = True

                            self.in_label = YLeaf(YType.uint32, "in-label")

                            self.out_label = YLeaf(YType.uint32, "out-label")

                            self.out_link = YLeaf(YType.uint32, "out-link")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("in_label",
                                            "out_label",
                                            "out_link") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp.ReverseIoMap, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp.ReverseIoMap, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.in_label.is_set or
                                self.out_label.is_set or
                                self.out_link.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.in_label.yfilter != YFilter.not_set or
                                self.out_label.yfilter != YFilter.not_set or
                                self.out_link.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "reverse-io-map" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.in_label.is_set or self.in_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.in_label.get_name_leafdata())
                            if (self.out_label.is_set or self.out_label.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_label.get_name_leafdata())
                            if (self.out_link.is_set or self.out_link.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.out_link.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "in-label" or name == "out-label" or name == "out-link"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "in-label"):
                                self.in_label = value
                                self.in_label.value_namespace = name_space
                                self.in_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-label"):
                                self.out_label = value
                                self.out_label.value_namespace = name_space
                                self.out_label.value_namespace_prefix = name_space_prefix
                            if(value_path == "out-link"):
                                self.out_link = value
                                self.out_link.value_namespace = name_space
                                self.out_link.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (
                            self.reverse_bandwidth.is_set or
                            (self.reverse_io_map is not None))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.reverse_bandwidth.yfilter != YFilter.not_set or
                            (self.reverse_io_map is not None and self.reverse_io_map.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "reverse-lsp" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.reverse_bandwidth.is_set or self.reverse_bandwidth.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.reverse_bandwidth.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "reverse-io-map"):
                            if (self.reverse_io_map is None):
                                self.reverse_io_map = MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp.ReverseIoMap()
                                self.reverse_io_map.parent = self
                                self._children_name_map["reverse_io_map"] = "reverse-io-map"
                            return self.reverse_io_map

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "reverse-io-map" or name == "reverse-bandwidth"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "reverse-bandwidth"):
                            self.reverse_bandwidth = value
                            self.reverse_bandwidth.value_namespace = name_space
                            self.reverse_bandwidth.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.midpoint_name.is_set or
                        self.lsp_id.is_set or
                        self.lsp_protect.is_set or
                        self.tunnel_name.is_set or
                        (self.forward_lsp is not None and self.forward_lsp.has_data()) or
                        (self.reverse_lsp is not None and self.reverse_lsp.has_data()) or
                        (self.destination is not None) or
                        (self.source is not None))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.midpoint_name.yfilter != YFilter.not_set or
                        self.lsp_id.yfilter != YFilter.not_set or
                        self.lsp_protect.yfilter != YFilter.not_set or
                        self.tunnel_name.yfilter != YFilter.not_set or
                        (self.destination is not None and self.destination.has_operation()) or
                        (self.forward_lsp is not None and self.forward_lsp.has_operation()) or
                        (self.reverse_lsp is not None and self.reverse_lsp.has_operation()) or
                        (self.source is not None and self.source.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "midpoint" + "[midpoint-name='" + self.midpoint_name.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/midpoints/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.midpoint_name.is_set or self.midpoint_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.midpoint_name.get_name_leafdata())
                    if (self.lsp_id.is_set or self.lsp_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_id.get_name_leafdata())
                    if (self.lsp_protect.is_set or self.lsp_protect.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.lsp_protect.get_name_leafdata())
                    if (self.tunnel_name.is_set or self.tunnel_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.tunnel_name.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "destination"):
                        if (self.destination is None):
                            self.destination = MplsTe.TransportProfile.Midpoints.Midpoint.Destination()
                            self.destination.parent = self
                            self._children_name_map["destination"] = "destination"
                        return self.destination

                    if (child_yang_name == "forward-lsp"):
                        if (self.forward_lsp is None):
                            self.forward_lsp = MplsTe.TransportProfile.Midpoints.Midpoint.ForwardLsp()
                            self.forward_lsp.parent = self
                            self._children_name_map["forward_lsp"] = "forward-lsp"
                        return self.forward_lsp

                    if (child_yang_name == "reverse-lsp"):
                        if (self.reverse_lsp is None):
                            self.reverse_lsp = MplsTe.TransportProfile.Midpoints.Midpoint.ReverseLsp()
                            self.reverse_lsp.parent = self
                            self._children_name_map["reverse_lsp"] = "reverse-lsp"
                        return self.reverse_lsp

                    if (child_yang_name == "source"):
                        if (self.source is None):
                            self.source = MplsTe.TransportProfile.Midpoints.Midpoint.Source()
                            self.source.parent = self
                            self._children_name_map["source"] = "source"
                        return self.source

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "destination" or name == "forward-lsp" or name == "reverse-lsp" or name == "source" or name == "midpoint-name" or name == "lsp-id" or name == "lsp-protect" or name == "tunnel-name"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "midpoint-name"):
                        self.midpoint_name = value
                        self.midpoint_name.value_namespace = name_space
                        self.midpoint_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-id"):
                        self.lsp_id = value
                        self.lsp_id.value_namespace = name_space
                        self.lsp_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "lsp-protect"):
                        self.lsp_protect = value
                        self.lsp_protect.value_namespace = name_space
                        self.lsp_protect.value_namespace_prefix = name_space_prefix
                    if(value_path == "tunnel-name"):
                        self.tunnel_name = value
                        self.tunnel_name.value_namespace = name_space
                        self.tunnel_name.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.midpoint:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.midpoint:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "midpoints" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "midpoint"):
                    for c in self.midpoint:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsTe.TransportProfile.Midpoints.Midpoint()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.midpoint.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "midpoint"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.global_id.is_set or
                self.node_id.is_set or
                (self.alarm is not None and self.alarm.has_data()) or
                (self.bfd is not None and self.bfd.has_data()) or
                (self.fault is not None and self.fault.has_data()) or
                (self.midpoints is not None and self.midpoints.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.global_id.yfilter != YFilter.not_set or
                self.node_id.yfilter != YFilter.not_set or
                (self.alarm is not None and self.alarm.has_operation()) or
                (self.bfd is not None and self.bfd.has_operation()) or
                (self.fault is not None and self.fault.has_operation()) or
                (self.midpoints is not None and self.midpoints.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "transport-profile" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.global_id.is_set or self.global_id.yfilter != YFilter.not_set):
                leaf_name_data.append(self.global_id.get_name_leafdata())
            if (self.node_id.is_set or self.node_id.yfilter != YFilter.not_set):
                leaf_name_data.append(self.node_id.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "alarm"):
                if (self.alarm is None):
                    self.alarm = MplsTe.TransportProfile.Alarm()
                    self.alarm.parent = self
                    self._children_name_map["alarm"] = "alarm"
                return self.alarm

            if (child_yang_name == "bfd"):
                if (self.bfd is None):
                    self.bfd = MplsTe.TransportProfile.Bfd()
                    self.bfd.parent = self
                    self._children_name_map["bfd"] = "bfd"
                return self.bfd

            if (child_yang_name == "fault"):
                if (self.fault is None):
                    self.fault = MplsTe.TransportProfile.Fault()
                    self.fault.parent = self
                    self._children_name_map["fault"] = "fault"
                return self.fault

            if (child_yang_name == "midpoints"):
                if (self.midpoints is None):
                    self.midpoints = MplsTe.TransportProfile.Midpoints()
                    self.midpoints.parent = self
                    self._children_name_map["midpoints"] = "midpoints"
                return self.midpoints

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "alarm" or name == "bfd" or name == "fault" or name == "midpoints" or name == "global-id" or name == "node-id"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "global-id"):
                self.global_id = value
                self.global_id.value_namespace = name_space
                self.global_id.value_namespace_prefix = name_space_prefix
            if(value_path == "node-id"):
                self.node_id = value
                self.node_id.value_namespace = name_space
                self.node_id.value_namespace_prefix = name_space_prefix


    class Interfaces(Entity):
        """
        Configure MPLS TE interfaces
        
        .. attribute:: interface
        
        	Configure an MPLS TE interface
        	**type**\: list of    :py:class:`Interface <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface>`
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(MplsTe.Interfaces, self).__init__()

            self.yang_name = "interfaces"
            self.yang_parent_name = "mpls-te"

            self.interface = YList(self)

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in () and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(MplsTe.Interfaces, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(MplsTe.Interfaces, self).__setattr__(name, value)


        class Interface(Entity):
            """
            Configure an MPLS TE interface
            
            .. attribute:: interface_name  <key>
            
            	Interface name
            	**type**\:  str
            
            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
            
            .. attribute:: global_attributes
            
            	MPLS TE global interface configuration
            	**type**\:   :py:class:`GlobalAttributes <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.GlobalAttributes>`
            
            .. attribute:: lcac
            
            	LCAC specific MPLS interface configuration
            	**type**\:   :py:class:`Lcac <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac>`
            
            .. attribute:: transport_profile_link
            
            	MPLS transport profile capable link
            	**type**\:   :py:class:`TransportProfileLink <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.TransportProfileLink>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.Interfaces.Interface, self).__init__()

                self.yang_name = "interface"
                self.yang_parent_name = "interfaces"

                self.interface_name = YLeaf(YType.str, "interface-name")

                self.global_attributes = MplsTe.Interfaces.Interface.GlobalAttributes()
                self.global_attributes.parent = self
                self._children_name_map["global_attributes"] = "global-attributes"
                self._children_yang_names.add("global-attributes")

                self.lcac = MplsTe.Interfaces.Interface.Lcac()
                self.lcac.parent = self
                self._children_name_map["lcac"] = "lcac"
                self._children_yang_names.add("lcac")

                self.transport_profile_link = MplsTe.Interfaces.Interface.TransportProfileLink()
                self.transport_profile_link.parent = self
                self._children_name_map["transport_profile_link"] = "transport-profile-link"
                self._children_yang_names.add("transport-profile-link")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("interface_name") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.Interfaces.Interface, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.Interfaces.Interface, self).__setattr__(name, value)


            class TransportProfileLink(Entity):
                """
                MPLS transport profile capable link
                
                .. attribute:: links
                
                	Transport profile link table
                	**type**\:   :py:class:`Links <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.TransportProfileLink.Links>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.Interfaces.Interface.TransportProfileLink, self).__init__()

                    self.yang_name = "transport-profile-link"
                    self.yang_parent_name = "interface"

                    self.links = MplsTe.Interfaces.Interface.TransportProfileLink.Links()
                    self.links.parent = self
                    self._children_name_map["links"] = "links"
                    self._children_yang_names.add("links")


                class Links(Entity):
                    """
                    Transport profile link table
                    
                    .. attribute:: link
                    
                    	Transport profile link
                    	**type**\: list of    :py:class:`Link <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.TransportProfileLink.Links.Link>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.TransportProfileLink.Links, self).__init__()

                        self.yang_name = "links"
                        self.yang_parent_name = "transport-profile-link"

                        self.link = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.TransportProfileLink.Links, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.TransportProfileLink.Links, self).__setattr__(name, value)


                    class Link(Entity):
                        """
                        Transport profile link
                        
                        .. attribute:: link_id  <key>
                        
                        	Numeric link identifier
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        .. attribute:: next_hop_address
                        
                        	Next\-hop address in IPv4 format
                        	**type**\:  str
                        
                        	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                        
                        .. attribute:: next_hop_type
                        
                        	Next hop type
                        	**type**\:   :py:class:`LinkNextHop <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.LinkNextHop>`
                        
                        	**default value**\: ipv4-address
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.Interfaces.Interface.TransportProfileLink.Links.Link, self).__init__()

                            self.yang_name = "link"
                            self.yang_parent_name = "links"

                            self.link_id = YLeaf(YType.uint32, "link-id")

                            self.next_hop_address = YLeaf(YType.str, "next-hop-address")

                            self.next_hop_type = YLeaf(YType.enumeration, "next-hop-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("link_id",
                                            "next_hop_address",
                                            "next_hop_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.Interfaces.Interface.TransportProfileLink.Links.Link, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.Interfaces.Interface.TransportProfileLink.Links.Link, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.link_id.is_set or
                                self.next_hop_address.is_set or
                                self.next_hop_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.link_id.yfilter != YFilter.not_set or
                                self.next_hop_address.yfilter != YFilter.not_set or
                                self.next_hop_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "link" + "[link-id='" + self.link_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.link_id.is_set or self.link_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.link_id.get_name_leafdata())
                            if (self.next_hop_address.is_set or self.next_hop_address.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop_address.get_name_leafdata())
                            if (self.next_hop_type.is_set or self.next_hop_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "link-id" or name == "next-hop-address" or name == "next-hop-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "link-id"):
                                self.link_id = value
                                self.link_id.value_namespace = name_space
                                self.link_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-hop-address"):
                                self.next_hop_address = value
                                self.next_hop_address.value_namespace = name_space
                                self.next_hop_address.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-hop-type"):
                                self.next_hop_type = value
                                self.next_hop_type.value_namespace = name_space
                                self.next_hop_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.link:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.link:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "links" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "link"):
                            for c in self.link:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsTe.Interfaces.Interface.TransportProfileLink.Links.Link()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.link.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "link"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (self.links is not None and self.links.has_data())

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.links is not None and self.links.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "transport-profile-link" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "links"):
                        if (self.links is None):
                            self.links = MplsTe.Interfaces.Interface.TransportProfileLink.Links()
                            self.links.parent = self
                            self._children_name_map["links"] = "links"
                        return self.links

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "links"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass


            class Lcac(Entity):
                """
                LCAC specific MPLS interface configuration
                
                .. attribute:: admin_weight
                
                	Set administrative weight for the interface
                	**type**\:  int
                
                	**range:** \-2147483648..2147483647
                
                .. attribute:: attribute_flags
                
                	Set user defined interface attribute flags
                	**type**\:  str
                
                	**pattern:** [0\-9a\-fA\-F]{1,8}
                
                .. attribute:: attribute_name_xr
                
                	Set the interface attribute names
                	**type**\:   :py:class:`AttributeNameXr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.AttributeNameXr>`
                
                .. attribute:: attribute_names
                
                	Attribute name table
                	**type**\:   :py:class:`AttributeNames <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.AttributeNames>`
                
                .. attribute:: bfd
                
                	Enable use of Bidirectional Forwarding Detection
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: down_thresholds
                
                	Set thresholds for decreased resource availability in %
                	**type**\:   :py:class:`DownThresholds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.DownThresholds>`
                
                .. attribute:: enable
                
                	Enable MPLS\-TE on the link
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: fault_oam_lockout
                
                	Lockout protection on the interface for Flex LSP
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: flood_area
                
                	Set the IGP instance into which this interface is to be flooded (GMPLS only)
                	**type**\:   :py:class:`FloodArea <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.FloodArea>`
                
                .. attribute:: srlgs
                
                	Configure SRLG membership for the interface
                	**type**\:   :py:class:`Srlgs <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.Srlgs>`
                
                .. attribute:: switchings
                
                	Set the te\-link switching attributes
                	**type**\:   :py:class:`Switchings <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.Switchings>`
                
                .. attribute:: up_thresholds
                
                	Set thresholds for increased resource availability in %
                	**type**\:   :py:class:`UpThresholds <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.UpThresholds>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.Interfaces.Interface.Lcac, self).__init__()

                    self.yang_name = "lcac"
                    self.yang_parent_name = "interface"

                    self.admin_weight = YLeaf(YType.int32, "admin-weight")

                    self.attribute_flags = YLeaf(YType.str, "attribute-flags")

                    self.bfd = YLeaf(YType.empty, "bfd")

                    self.enable = YLeaf(YType.empty, "enable")

                    self.fault_oam_lockout = YLeaf(YType.empty, "fault-oam-lockout")

                    self.attribute_name_xr = MplsTe.Interfaces.Interface.Lcac.AttributeNameXr()
                    self.attribute_name_xr.parent = self
                    self._children_name_map["attribute_name_xr"] = "attribute-name-xr"
                    self._children_yang_names.add("attribute-name-xr")

                    self.attribute_names = MplsTe.Interfaces.Interface.Lcac.AttributeNames()
                    self.attribute_names.parent = self
                    self._children_name_map["attribute_names"] = "attribute-names"
                    self._children_yang_names.add("attribute-names")

                    self.down_thresholds = MplsTe.Interfaces.Interface.Lcac.DownThresholds()
                    self.down_thresholds.parent = self
                    self._children_name_map["down_thresholds"] = "down-thresholds"
                    self._children_yang_names.add("down-thresholds")

                    self.flood_area = MplsTe.Interfaces.Interface.Lcac.FloodArea()
                    self.flood_area.parent = self
                    self._children_name_map["flood_area"] = "flood-area"
                    self._children_yang_names.add("flood-area")

                    self.srlgs = MplsTe.Interfaces.Interface.Lcac.Srlgs()
                    self.srlgs.parent = self
                    self._children_name_map["srlgs"] = "srlgs"
                    self._children_yang_names.add("srlgs")

                    self.switchings = MplsTe.Interfaces.Interface.Lcac.Switchings()
                    self.switchings.parent = self
                    self._children_name_map["switchings"] = "switchings"
                    self._children_yang_names.add("switchings")

                    self.up_thresholds = MplsTe.Interfaces.Interface.Lcac.UpThresholds()
                    self.up_thresholds.parent = self
                    self._children_name_map["up_thresholds"] = "up-thresholds"
                    self._children_yang_names.add("up-thresholds")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("admin_weight",
                                    "attribute_flags",
                                    "bfd",
                                    "enable",
                                    "fault_oam_lockout") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.Interfaces.Interface.Lcac, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.Interfaces.Interface.Lcac, self).__setattr__(name, value)


                class Switchings(Entity):
                    """
                    Set the te\-link switching attributes
                    
                    .. attribute:: switching
                    
                    	The te\-link switching attributes
                    	**type**\: list of    :py:class:`Switching <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.Switchings.Switching>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.Lcac.Switchings, self).__init__()

                        self.yang_name = "switchings"
                        self.yang_parent_name = "lcac"

                        self.switching = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.Lcac.Switchings, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.Lcac.Switchings, self).__setattr__(name, value)


                    class Switching(Entity):
                        """
                        The te\-link switching attributes
                        
                        .. attribute:: switching_id  <key>
                        
                        	Switching index
                        	**type**\: one of the below types:
                        
                        	**type**\:   :py:class:`MplsTeSwitchingIndex <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeSwitchingIndex>`
                        
                        
                        ----
                        	**type**\:  int
                        
                        	**range:** 1..255
                        
                        
                        ----
                        .. attribute:: capability
                        
                        	Set the local switching capability
                        	**type**\:   :py:class:`MplsTeSwitchingCap <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeSwitchingCap>`
                        
                        .. attribute:: encoding
                        
                        	Set the local encoding type
                        	**type**\:   :py:class:`MplsTeSwitchingEncoding <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeSwitchingEncoding>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.Interfaces.Interface.Lcac.Switchings.Switching, self).__init__()

                            self.yang_name = "switching"
                            self.yang_parent_name = "switchings"

                            self.switching_id = YLeaf(YType.str, "switching-id")

                            self.capability = YLeaf(YType.enumeration, "capability")

                            self.encoding = YLeaf(YType.enumeration, "encoding")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("switching_id",
                                            "capability",
                                            "encoding") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.Interfaces.Interface.Lcac.Switchings.Switching, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.Interfaces.Interface.Lcac.Switchings.Switching, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.switching_id.is_set or
                                self.capability.is_set or
                                self.encoding.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.switching_id.yfilter != YFilter.not_set or
                                self.capability.yfilter != YFilter.not_set or
                                self.encoding.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "switching" + "[switching-id='" + self.switching_id.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.switching_id.is_set or self.switching_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.switching_id.get_name_leafdata())
                            if (self.capability.is_set or self.capability.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.capability.get_name_leafdata())
                            if (self.encoding.is_set or self.encoding.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.encoding.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "switching-id" or name == "capability" or name == "encoding"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "switching-id"):
                                self.switching_id = value
                                self.switching_id.value_namespace = name_space
                                self.switching_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "capability"):
                                self.capability = value
                                self.capability.value_namespace = name_space
                                self.capability.value_namespace_prefix = name_space_prefix
                            if(value_path == "encoding"):
                                self.encoding = value
                                self.encoding.value_namespace = name_space
                                self.encoding.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.switching:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.switching:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "switchings" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "switching"):
                            for c in self.switching:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsTe.Interfaces.Interface.Lcac.Switchings.Switching()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.switching.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "switching"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class FloodArea(Entity):
                    """
                    Set the IGP instance into which this
                    interface is to be flooded (GMPLS only)
                    
                    .. attribute:: area_id
                    
                    	Area ID
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: igp_type
                    
                    	IGP type
                    	**type**\:   :py:class:`MplsLcacFloodingIgp <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsLcacFloodingIgp>`
                    
                    .. attribute:: process_name
                    
                    	Process name
                    	**type**\:  str
                    
                    	**length:** 1..32
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.Lcac.FloodArea, self).__init__()

                        self.yang_name = "flood-area"
                        self.yang_parent_name = "lcac"

                        self.area_id = YLeaf(YType.int32, "area-id")

                        self.igp_type = YLeaf(YType.enumeration, "igp-type")

                        self.process_name = YLeaf(YType.str, "process-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("area_id",
                                        "igp_type",
                                        "process_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.Lcac.FloodArea, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.Lcac.FloodArea, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.area_id.is_set or
                            self.igp_type.is_set or
                            self.process_name.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.area_id.yfilter != YFilter.not_set or
                            self.igp_type.yfilter != YFilter.not_set or
                            self.process_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "flood-area" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.area_id.is_set or self.area_id.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.area_id.get_name_leafdata())
                        if (self.igp_type.is_set or self.igp_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.igp_type.get_name_leafdata())
                        if (self.process_name.is_set or self.process_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.process_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "area-id" or name == "igp-type" or name == "process-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "area-id"):
                            self.area_id = value
                            self.area_id.value_namespace = name_space
                            self.area_id.value_namespace_prefix = name_space_prefix
                        if(value_path == "igp-type"):
                            self.igp_type = value
                            self.igp_type.value_namespace = name_space
                            self.igp_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "process-name"):
                            self.process_name = value
                            self.process_name.value_namespace = name_space
                            self.process_name.value_namespace_prefix = name_space_prefix


                class AttributeNameXr(Entity):
                    """
                    Set the interface attribute names
                    
                    .. attribute:: attribute_name
                    
                    	Array of Attribute Names
                    	**type**\:  list of str
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.Lcac.AttributeNameXr, self).__init__()

                        self.yang_name = "attribute-name-xr"
                        self.yang_parent_name = "lcac"

                        self.attribute_name = YLeafList(YType.str, "attribute-name")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("attribute_name") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.Lcac.AttributeNameXr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.Lcac.AttributeNameXr, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.attribute_name.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return False

                    def has_operation(self):
                        for leaf in self.attribute_name.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.attribute_name.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "attribute-name-xr" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        leaf_name_data.extend(self.attribute_name.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "attribute-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "attribute-name"):
                            self.attribute_name.append(value)


                class AttributeNames(Entity):
                    """
                    Attribute name table
                    
                    .. attribute:: attribute_name
                    
                    	Set the interface attribute names
                    	**type**\: list of    :py:class:`AttributeName <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.AttributeNames.AttributeName>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.Lcac.AttributeNames, self).__init__()

                        self.yang_name = "attribute-names"
                        self.yang_parent_name = "lcac"

                        self.attribute_name = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.Lcac.AttributeNames, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.Lcac.AttributeNames, self).__setattr__(name, value)


                    class AttributeName(Entity):
                        """
                        Set the interface attribute names
                        
                        .. attribute:: affinity_index  <key>
                        
                        	Specify the entry index
                        	**type**\:  int
                        
                        	**range:** 1..9
                        
                        .. attribute:: value
                        
                        	Array of Attribute Names
                        	**type**\:  list of str
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.Interfaces.Interface.Lcac.AttributeNames.AttributeName, self).__init__()

                            self.yang_name = "attribute-name"
                            self.yang_parent_name = "attribute-names"

                            self.affinity_index = YLeaf(YType.uint32, "affinity-index")

                            self.value = YLeafList(YType.str, "value")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("affinity_index",
                                            "value") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.Interfaces.Interface.Lcac.AttributeNames.AttributeName, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.Interfaces.Interface.Lcac.AttributeNames.AttributeName, self).__setattr__(name, value)

                        def has_data(self):
                            for leaf in self.value.getYLeafs():
                                if (leaf.yfilter != YFilter.not_set):
                                    return True
                            return self.affinity_index.is_set

                        def has_operation(self):
                            for leaf in self.value.getYLeafs():
                                if (leaf.is_set):
                                    return True
                            return (
                                self.yfilter != YFilter.not_set or
                                self.affinity_index.yfilter != YFilter.not_set or
                                self.value.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "attribute-name" + "[affinity-index='" + self.affinity_index.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.affinity_index.is_set or self.affinity_index.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.affinity_index.get_name_leafdata())

                            leaf_name_data.extend(self.value.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "affinity-index" or name == "value"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "affinity-index"):
                                self.affinity_index = value
                                self.affinity_index.value_namespace = name_space
                                self.affinity_index.value_namespace_prefix = name_space_prefix
                            if(value_path == "value"):
                                self.value.append(value)

                    def has_data(self):
                        for c in self.attribute_name:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.attribute_name:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "attribute-names" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "attribute-name"):
                            for c in self.attribute_name:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsTe.Interfaces.Interface.Lcac.AttributeNames.AttributeName()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.attribute_name.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "attribute-name"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class Srlgs(Entity):
                    """
                    Configure SRLG membership for the interface
                    
                    .. attribute:: srlg
                    
                    	SRLG membership number
                    	**type**\: list of    :py:class:`Srlg <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.Lcac.Srlgs.Srlg>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.Lcac.Srlgs, self).__init__()

                        self.yang_name = "srlgs"
                        self.yang_parent_name = "lcac"

                        self.srlg = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.Lcac.Srlgs, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.Lcac.Srlgs, self).__setattr__(name, value)


                    class Srlg(Entity):
                        """
                        SRLG membership number
                        
                        .. attribute:: srlg_number  <key>
                        
                        	SRLG membership number
                        	**type**\:  int
                        
                        	**range:** 0..4294967295
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.Interfaces.Interface.Lcac.Srlgs.Srlg, self).__init__()

                            self.yang_name = "srlg"
                            self.yang_parent_name = "srlgs"

                            self.srlg_number = YLeaf(YType.uint32, "srlg-number")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("srlg_number") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.Interfaces.Interface.Lcac.Srlgs.Srlg, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.Interfaces.Interface.Lcac.Srlgs.Srlg, self).__setattr__(name, value)

                        def has_data(self):
                            return self.srlg_number.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.srlg_number.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "srlg" + "[srlg-number='" + self.srlg_number.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.srlg_number.is_set or self.srlg_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.srlg_number.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "srlg-number"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "srlg-number"):
                                self.srlg_number = value
                                self.srlg_number.value_namespace = name_space
                                self.srlg_number.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.srlg:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.srlg:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "srlgs" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "srlg"):
                            for c in self.srlg:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsTe.Interfaces.Interface.Lcac.Srlgs.Srlg()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.srlg.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "srlg"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class UpThresholds(Entity):
                    """
                    Set thresholds for increased resource
                    availability in %
                    
                    .. attribute:: up_threshold
                    
                    	Array of up threshold percentage
                    	**type**\:  list of int
                    
                    	**range:** 0..100
                    
                    	**units**\: percentage
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.Lcac.UpThresholds, self).__init__()

                        self.yang_name = "up-thresholds"
                        self.yang_parent_name = "lcac"

                        self.up_threshold = YLeafList(YType.uint32, "up-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("up_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.Lcac.UpThresholds, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.Lcac.UpThresholds, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.up_threshold.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return False

                    def has_operation(self):
                        for leaf in self.up_threshold.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.up_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "up-thresholds" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        leaf_name_data.extend(self.up_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "up-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "up-threshold"):
                            self.up_threshold.append(value)


                class DownThresholds(Entity):
                    """
                    Set thresholds for decreased resource
                    availability in %
                    
                    .. attribute:: down_threshold
                    
                    	Array of down threshold percentage
                    	**type**\:  list of int
                    
                    	**range:** 0..100
                    
                    	**units**\: percentage
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.Lcac.DownThresholds, self).__init__()

                        self.yang_name = "down-thresholds"
                        self.yang_parent_name = "lcac"

                        self.down_threshold = YLeafList(YType.uint32, "down-threshold")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("down_threshold") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.Lcac.DownThresholds, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.Lcac.DownThresholds, self).__setattr__(name, value)

                    def has_data(self):
                        for leaf in self.down_threshold.getYLeafs():
                            if (leaf.yfilter != YFilter.not_set):
                                return True
                        return False

                    def has_operation(self):
                        for leaf in self.down_threshold.getYLeafs():
                            if (leaf.is_set):
                                return True
                        return (
                            self.yfilter != YFilter.not_set or
                            self.down_threshold.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "down-thresholds" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        leaf_name_data.extend(self.down_threshold.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "down-threshold"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "down-threshold"):
                            self.down_threshold.append(value)

                def has_data(self):
                    return (
                        self.admin_weight.is_set or
                        self.attribute_flags.is_set or
                        self.bfd.is_set or
                        self.enable.is_set or
                        self.fault_oam_lockout.is_set or
                        (self.attribute_name_xr is not None and self.attribute_name_xr.has_data()) or
                        (self.attribute_names is not None and self.attribute_names.has_data()) or
                        (self.down_thresholds is not None and self.down_thresholds.has_data()) or
                        (self.flood_area is not None and self.flood_area.has_data()) or
                        (self.srlgs is not None and self.srlgs.has_data()) or
                        (self.switchings is not None and self.switchings.has_data()) or
                        (self.up_thresholds is not None and self.up_thresholds.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.admin_weight.yfilter != YFilter.not_set or
                        self.attribute_flags.yfilter != YFilter.not_set or
                        self.bfd.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        self.fault_oam_lockout.yfilter != YFilter.not_set or
                        (self.attribute_name_xr is not None and self.attribute_name_xr.has_operation()) or
                        (self.attribute_names is not None and self.attribute_names.has_operation()) or
                        (self.down_thresholds is not None and self.down_thresholds.has_operation()) or
                        (self.flood_area is not None and self.flood_area.has_operation()) or
                        (self.srlgs is not None and self.srlgs.has_operation()) or
                        (self.switchings is not None and self.switchings.has_operation()) or
                        (self.up_thresholds is not None and self.up_thresholds.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "lcac" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.admin_weight.is_set or self.admin_weight.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.admin_weight.get_name_leafdata())
                    if (self.attribute_flags.is_set or self.attribute_flags.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.attribute_flags.get_name_leafdata())
                    if (self.bfd.is_set or self.bfd.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.bfd.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())
                    if (self.fault_oam_lockout.is_set or self.fault_oam_lockout.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.fault_oam_lockout.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "attribute-name-xr"):
                        if (self.attribute_name_xr is None):
                            self.attribute_name_xr = MplsTe.Interfaces.Interface.Lcac.AttributeNameXr()
                            self.attribute_name_xr.parent = self
                            self._children_name_map["attribute_name_xr"] = "attribute-name-xr"
                        return self.attribute_name_xr

                    if (child_yang_name == "attribute-names"):
                        if (self.attribute_names is None):
                            self.attribute_names = MplsTe.Interfaces.Interface.Lcac.AttributeNames()
                            self.attribute_names.parent = self
                            self._children_name_map["attribute_names"] = "attribute-names"
                        return self.attribute_names

                    if (child_yang_name == "down-thresholds"):
                        if (self.down_thresholds is None):
                            self.down_thresholds = MplsTe.Interfaces.Interface.Lcac.DownThresholds()
                            self.down_thresholds.parent = self
                            self._children_name_map["down_thresholds"] = "down-thresholds"
                        return self.down_thresholds

                    if (child_yang_name == "flood-area"):
                        if (self.flood_area is None):
                            self.flood_area = MplsTe.Interfaces.Interface.Lcac.FloodArea()
                            self.flood_area.parent = self
                            self._children_name_map["flood_area"] = "flood-area"
                        return self.flood_area

                    if (child_yang_name == "srlgs"):
                        if (self.srlgs is None):
                            self.srlgs = MplsTe.Interfaces.Interface.Lcac.Srlgs()
                            self.srlgs.parent = self
                            self._children_name_map["srlgs"] = "srlgs"
                        return self.srlgs

                    if (child_yang_name == "switchings"):
                        if (self.switchings is None):
                            self.switchings = MplsTe.Interfaces.Interface.Lcac.Switchings()
                            self.switchings.parent = self
                            self._children_name_map["switchings"] = "switchings"
                        return self.switchings

                    if (child_yang_name == "up-thresholds"):
                        if (self.up_thresholds is None):
                            self.up_thresholds = MplsTe.Interfaces.Interface.Lcac.UpThresholds()
                            self.up_thresholds.parent = self
                            self._children_name_map["up_thresholds"] = "up-thresholds"
                        return self.up_thresholds

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "attribute-name-xr" or name == "attribute-names" or name == "down-thresholds" or name == "flood-area" or name == "srlgs" or name == "switchings" or name == "up-thresholds" or name == "admin-weight" or name == "attribute-flags" or name == "bfd" or name == "enable" or name == "fault-oam-lockout"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "admin-weight"):
                        self.admin_weight = value
                        self.admin_weight.value_namespace = name_space
                        self.admin_weight.value_namespace_prefix = name_space_prefix
                    if(value_path == "attribute-flags"):
                        self.attribute_flags = value
                        self.attribute_flags.value_namespace = name_space
                        self.attribute_flags.value_namespace_prefix = name_space_prefix
                    if(value_path == "bfd"):
                        self.bfd = value
                        self.bfd.value_namespace = name_space
                        self.bfd.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "fault-oam-lockout"):
                        self.fault_oam_lockout = value
                        self.fault_oam_lockout.value_namespace = name_space
                        self.fault_oam_lockout.value_namespace_prefix = name_space_prefix


            class GlobalAttributes(Entity):
                """
                MPLS TE global interface configuration
                
                .. attribute:: auto_tunnel
                
                	Auto tunnel configuration
                	**type**\:   :py:class:`AutoTunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel>`
                
                .. attribute:: backup_paths
                
                	Configure MPLS TE backup tunnels for this interface
                	**type**\:   :py:class:`BackupPaths <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths>`
                
                .. attribute:: backup_tunnels
                
                	Configure MPLS TE backup tunnels for this interface
                	**type**\:   :py:class:`BackupTunnels <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.Interfaces.Interface.GlobalAttributes, self).__init__()

                    self.yang_name = "global-attributes"
                    self.yang_parent_name = "interface"

                    self.auto_tunnel = MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel()
                    self.auto_tunnel.parent = self
                    self._children_name_map["auto_tunnel"] = "auto-tunnel"
                    self._children_yang_names.add("auto-tunnel")

                    self.backup_paths = MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths()
                    self.backup_paths.parent = self
                    self._children_name_map["backup_paths"] = "backup-paths"
                    self._children_yang_names.add("backup-paths")

                    self.backup_tunnels = MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels()
                    self.backup_tunnels.parent = self
                    self._children_name_map["backup_tunnels"] = "backup-tunnels"
                    self._children_yang_names.add("backup-tunnels")


                class BackupTunnels(Entity):
                    """
                    Configure MPLS TE backup tunnels for this
                    interface
                    
                    .. attribute:: backup_tunnel
                    
                    	Tunnel name
                    	**type**\: list of    :py:class:`BackupTunnel <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels.BackupTunnel>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels, self).__init__()

                        self.yang_name = "backup-tunnels"
                        self.yang_parent_name = "global-attributes"

                        self.backup_tunnel = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels, self).__setattr__(name, value)


                    class BackupTunnel(Entity):
                        """
                        Tunnel name
                        
                        .. attribute:: tunnel_name  <key>
                        
                        	Tunnel name
                        	**type**\:  str
                        
                        	**length:** 1..59
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels.BackupTunnel, self).__init__()

                            self.yang_name = "backup-tunnel"
                            self.yang_parent_name = "backup-tunnels"

                            self.tunnel_name = YLeaf(YType.str, "tunnel-name")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("tunnel_name") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels.BackupTunnel, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels.BackupTunnel, self).__setattr__(name, value)

                        def has_data(self):
                            return self.tunnel_name.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.tunnel_name.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "backup-tunnel" + "[tunnel-name='" + self.tunnel_name.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.tunnel_name.is_set or self.tunnel_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tunnel_name.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "tunnel-name"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "tunnel-name"):
                                self.tunnel_name = value
                                self.tunnel_name.value_namespace = name_space
                                self.tunnel_name.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.backup_tunnel:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.backup_tunnel:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "backup-tunnels" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "backup-tunnel"):
                            for c in self.backup_tunnel:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels.BackupTunnel()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.backup_tunnel.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "backup-tunnel"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class AutoTunnel(Entity):
                    """
                    Auto tunnel configuration
                    
                    .. attribute:: backup
                    
                    	Auto tunnel backup configuration
                    	**type**\:   :py:class:`Backup <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel, self).__init__()

                        self.yang_name = "auto-tunnel"
                        self.yang_parent_name = "global-attributes"

                        self.backup = MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup()
                        self.backup.parent = self
                        self._children_name_map["backup"] = "backup"
                        self._children_yang_names.add("backup")


                    class Backup(Entity):
                        """
                        Auto tunnel backup configuration
                        
                        .. attribute:: attribute_set
                        
                        	The name of attribute set to be applied to this auto backup lsp
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: enable
                        
                        	Enable auto\-tunnel backup on this TE link
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        .. attribute:: exclude
                        
                        	Auto\-tunnel backup exclusion criteria
                        	**type**\:   :py:class:`Exclude <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup.Exclude>`
                        
                        .. attribute:: next_hop_only
                        
                        	Enable NHOP\-only mode for auto\-tunnel backup on this TE link
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup, self).__init__()

                            self.yang_name = "backup"
                            self.yang_parent_name = "auto-tunnel"

                            self.attribute_set = YLeaf(YType.str, "attribute-set")

                            self.enable = YLeaf(YType.empty, "enable")

                            self.next_hop_only = YLeaf(YType.empty, "next-hop-only")

                            self.exclude = MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup.Exclude()
                            self.exclude.parent = self
                            self._children_name_map["exclude"] = "exclude"
                            self._children_yang_names.add("exclude")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("attribute_set",
                                            "enable",
                                            "next_hop_only") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup, self).__setattr__(name, value)


                        class Exclude(Entity):
                            """
                            Auto\-tunnel backup exclusion criteria
                            
                            .. attribute:: srlg_mode
                            
                            	Set exclude SRLG mode for auto\-tunnel backup on this TE link
                            	**type**\:   :py:class:`MplsTesrlgExclude <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTesrlgExclude>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup.Exclude, self).__init__()

                                self.yang_name = "exclude"
                                self.yang_parent_name = "backup"

                                self.srlg_mode = YLeaf(YType.enumeration, "srlg-mode")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("srlg_mode") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup.Exclude, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup.Exclude, self).__setattr__(name, value)

                            def has_data(self):
                                return self.srlg_mode.is_set

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.srlg_mode.yfilter != YFilter.not_set)

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "exclude" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.srlg_mode.is_set or self.srlg_mode.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.srlg_mode.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "srlg-mode"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "srlg-mode"):
                                    self.srlg_mode = value
                                    self.srlg_mode.value_namespace = name_space
                                    self.srlg_mode.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            return (
                                self.attribute_set.is_set or
                                self.enable.is_set or
                                self.next_hop_only.is_set or
                                (self.exclude is not None and self.exclude.has_data()))

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.attribute_set.yfilter != YFilter.not_set or
                                self.enable.yfilter != YFilter.not_set or
                                self.next_hop_only.yfilter != YFilter.not_set or
                                (self.exclude is not None and self.exclude.has_operation()))

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "backup" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.attribute_set.is_set or self.attribute_set.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.attribute_set.get_name_leafdata())
                            if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.enable.get_name_leafdata())
                            if (self.next_hop_only.is_set or self.next_hop_only.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.next_hop_only.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "exclude"):
                                if (self.exclude is None):
                                    self.exclude = MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup.Exclude()
                                    self.exclude.parent = self
                                    self._children_name_map["exclude"] = "exclude"
                                return self.exclude

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "exclude" or name == "attribute-set" or name == "enable" or name == "next-hop-only"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "attribute-set"):
                                self.attribute_set = value
                                self.attribute_set.value_namespace = name_space
                                self.attribute_set.value_namespace_prefix = name_space_prefix
                            if(value_path == "enable"):
                                self.enable = value
                                self.enable.value_namespace = name_space
                                self.enable.value_namespace_prefix = name_space_prefix
                            if(value_path == "next-hop-only"):
                                self.next_hop_only = value
                                self.next_hop_only.value_namespace = name_space
                                self.next_hop_only.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        return (self.backup is not None and self.backup.has_data())

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            (self.backup is not None and self.backup.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "auto-tunnel" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "backup"):
                            if (self.backup is None):
                                self.backup = MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel.Backup()
                                self.backup.parent = self
                                self._children_name_map["backup"] = "backup"
                            return self.backup

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "backup"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class BackupPaths(Entity):
                    """
                    Configure MPLS TE backup tunnels for this
                    interface
                    
                    .. attribute:: backup_path
                    
                    	Tunnel interface number
                    	**type**\: list of    :py:class:`BackupPath <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths.BackupPath>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths, self).__init__()

                        self.yang_name = "backup-paths"
                        self.yang_parent_name = "global-attributes"

                        self.backup_path = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths, self).__setattr__(name, value)


                    class BackupPath(Entity):
                        """
                        Tunnel interface number
                        
                        .. attribute:: tunnel_number  <key>
                        
                        	Tunnel interface number
                        	**type**\:  int
                        
                        	**range:** 0..65535
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths.BackupPath, self).__init__()

                            self.yang_name = "backup-path"
                            self.yang_parent_name = "backup-paths"

                            self.tunnel_number = YLeaf(YType.uint32, "tunnel-number")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("tunnel_number") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths.BackupPath, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths.BackupPath, self).__setattr__(name, value)

                        def has_data(self):
                            return self.tunnel_number.is_set

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.tunnel_number.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "backup-path" + "[tunnel-number='" + self.tunnel_number.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.tunnel_number.is_set or self.tunnel_number.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.tunnel_number.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "tunnel-number"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "tunnel-number"):
                                self.tunnel_number = value
                                self.tunnel_number.value_namespace = name_space
                                self.tunnel_number.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.backup_path:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.backup_path:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "backup-paths" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "backup-path"):
                            for c in self.backup_path:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths.BackupPath()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.backup_path.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "backup-path"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass

                def has_data(self):
                    return (
                        (self.auto_tunnel is not None and self.auto_tunnel.has_data()) or
                        (self.backup_paths is not None and self.backup_paths.has_data()) or
                        (self.backup_tunnels is not None and self.backup_tunnels.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        (self.auto_tunnel is not None and self.auto_tunnel.has_operation()) or
                        (self.backup_paths is not None and self.backup_paths.has_operation()) or
                        (self.backup_tunnels is not None and self.backup_tunnels.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "global-attributes" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "auto-tunnel"):
                        if (self.auto_tunnel is None):
                            self.auto_tunnel = MplsTe.Interfaces.Interface.GlobalAttributes.AutoTunnel()
                            self.auto_tunnel.parent = self
                            self._children_name_map["auto_tunnel"] = "auto-tunnel"
                        return self.auto_tunnel

                    if (child_yang_name == "backup-paths"):
                        if (self.backup_paths is None):
                            self.backup_paths = MplsTe.Interfaces.Interface.GlobalAttributes.BackupPaths()
                            self.backup_paths.parent = self
                            self._children_name_map["backup_paths"] = "backup-paths"
                        return self.backup_paths

                    if (child_yang_name == "backup-tunnels"):
                        if (self.backup_tunnels is None):
                            self.backup_tunnels = MplsTe.Interfaces.Interface.GlobalAttributes.BackupTunnels()
                            self.backup_tunnels.parent = self
                            self._children_name_map["backup_tunnels"] = "backup-tunnels"
                        return self.backup_tunnels

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "auto-tunnel" or name == "backup-paths" or name == "backup-tunnels"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    pass

            def has_data(self):
                return (
                    self.interface_name.is_set or
                    (self.global_attributes is not None and self.global_attributes.has_data()) or
                    (self.lcac is not None and self.lcac.has_data()) or
                    (self.transport_profile_link is not None and self.transport_profile_link.has_data()))

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.interface_name.yfilter != YFilter.not_set or
                    (self.global_attributes is not None and self.global_attributes.has_operation()) or
                    (self.lcac is not None and self.lcac.has_operation()) or
                    (self.transport_profile_link is not None and self.transport_profile_link.has_operation()))

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "interface" + "[interface-name='" + self.interface_name.get() + "']" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/interfaces/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.interface_name.is_set or self.interface_name.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interface_name.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "global-attributes"):
                    if (self.global_attributes is None):
                        self.global_attributes = MplsTe.Interfaces.Interface.GlobalAttributes()
                        self.global_attributes.parent = self
                        self._children_name_map["global_attributes"] = "global-attributes"
                    return self.global_attributes

                if (child_yang_name == "lcac"):
                    if (self.lcac is None):
                        self.lcac = MplsTe.Interfaces.Interface.Lcac()
                        self.lcac.parent = self
                        self._children_name_map["lcac"] = "lcac"
                    return self.lcac

                if (child_yang_name == "transport-profile-link"):
                    if (self.transport_profile_link is None):
                        self.transport_profile_link = MplsTe.Interfaces.Interface.TransportProfileLink()
                        self.transport_profile_link.parent = self
                        self._children_name_map["transport_profile_link"] = "transport-profile-link"
                    return self.transport_profile_link

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "global-attributes" or name == "lcac" or name == "transport-profile-link" or name == "interface-name"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "interface-name"):
                    self.interface_name = value
                    self.interface_name.value_namespace = name_space
                    self.interface_name.value_namespace_prefix = name_space_prefix

        def has_data(self):
            for c in self.interface:
                if (c.has_data()):
                    return True
            return False

        def has_operation(self):
            for c in self.interface:
                if (c.has_operation()):
                    return True
            return self.yfilter != YFilter.not_set

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "interfaces" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "interface"):
                for c in self.interface:
                    segment = c.get_segment_path()
                    if (segment_path == segment):
                        return c
                c = MplsTe.Interfaces.Interface()
                c.parent = self
                local_reference_key = "ydk::seg::%s" % segment_path
                self._local_refs[local_reference_key] = c
                self.interface.append(c)
                return c

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "interface"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            pass


    class GmplsNni(Entity):
        """
        GMPLS\-NNI configuration
        
        .. attribute:: enable_gmpls_nni
        
        	Enable MPLS Traffic Engineering GMPLS\-NNI
        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
        
        .. attribute:: path_selection_metric
        
        	Path selection configuration for all gmpls nni tunnels
        	**type**\:   :py:class:`MplsTePathSelectionMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionMetric>`
        
        .. attribute:: topology_instances
        
        	GMPLS\-NNI topology instance table
        	**type**\:   :py:class:`TopologyInstances <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances>`
        
        .. attribute:: tunnel_heads
        
        	GMPLS\-NNI tunnel\-head table
        	**type**\:   :py:class:`TunnelHeads <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TunnelHeads>`
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(MplsTe.GmplsNni, self).__init__()

            self.yang_name = "gmpls-nni"
            self.yang_parent_name = "mpls-te"

            self.enable_gmpls_nni = YLeaf(YType.empty, "enable-gmpls-nni")

            self.path_selection_metric = YLeaf(YType.enumeration, "path-selection-metric")

            self.topology_instances = MplsTe.GmplsNni.TopologyInstances()
            self.topology_instances.parent = self
            self._children_name_map["topology_instances"] = "topology-instances"
            self._children_yang_names.add("topology-instances")

            self.tunnel_heads = MplsTe.GmplsNni.TunnelHeads()
            self.tunnel_heads.parent = self
            self._children_name_map["tunnel_heads"] = "tunnel-heads"
            self._children_yang_names.add("tunnel-heads")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("enable_gmpls_nni",
                            "path_selection_metric") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(MplsTe.GmplsNni, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(MplsTe.GmplsNni, self).__setattr__(name, value)


        class TopologyInstances(Entity):
            """
            GMPLS\-NNI topology instance table
            
            .. attribute:: topology_instance
            
            	GMPLS\-NNI topology instance configuration
            	**type**\: list of    :py:class:`TopologyInstance <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances.TopologyInstance>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GmplsNni.TopologyInstances, self).__init__()

                self.yang_name = "topology-instances"
                self.yang_parent_name = "gmpls-nni"

                self.topology_instance = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GmplsNni.TopologyInstances, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GmplsNni.TopologyInstances, self).__setattr__(name, value)


            class TopologyInstance(Entity):
                """
                GMPLS\-NNI topology instance configuration
                
                .. attribute:: ospf_area_type  <key>
                
                	OSPF area format
                	**type**\:   :py:class:`OspfAreaMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.OspfAreaMode>`
                
                .. attribute:: igp_instance_name  <key>
                
                	Name of IGP instance
                	**type**\:  str
                
                	**length:** 1..40
                
                .. attribute:: igp_type  <key>
                
                	IGP type
                	**type**\:   :py:class:`MplsTeIgpProtocol <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTeIgpProtocol>`
                
                .. attribute:: ospf_int
                
                	ospf int
                	**type**\: list of    :py:class:`OspfInt <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt>`
                
                .. attribute:: ospfip_addr
                
                	ospfip addr
                	**type**\: list of    :py:class:`OspfipAddr <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance, self).__init__()

                    self.yang_name = "topology-instance"
                    self.yang_parent_name = "topology-instances"

                    self.ospf_area_type = YLeaf(YType.enumeration, "ospf-area-type")

                    self.igp_instance_name = YLeaf(YType.str, "igp-instance-name")

                    self.igp_type = YLeaf(YType.enumeration, "igp-type")

                    self.ospf_int = YList(self)
                    self.ospfip_addr = YList(self)

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("ospf_area_type",
                                    "igp_instance_name",
                                    "igp_type") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance, self).__setattr__(name, value)


                class OspfInt(Entity):
                    """
                    ospf int
                    
                    .. attribute:: igp_area  <key>
                    
                    	IGP area
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: controllers
                    
                    	GMPLS\-NNI controllers
                    	**type**\:   :py:class:`Controllers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt, self).__init__()

                        self.yang_name = "ospf-int"
                        self.yang_parent_name = "topology-instance"

                        self.igp_area = YLeaf(YType.int32, "igp-area")

                        self.controllers = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers()
                        self.controllers.parent = self
                        self._children_name_map["controllers"] = "controllers"
                        self._children_yang_names.add("controllers")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("igp_area") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt, self).__setattr__(name, value)


                    class Controllers(Entity):
                        """
                        GMPLS\-NNI controllers
                        
                        .. attribute:: controller
                        
                        	Configure a GMPLS NNI controller
                        	**type**\: list of    :py:class:`Controller <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers, self).__init__()

                            self.yang_name = "controllers"
                            self.yang_parent_name = "ospf-int"

                            self.controller = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers, self).__setattr__(name, value)


                        class Controller(Entity):
                            """
                            Configure a GMPLS NNI controller
                            
                            .. attribute:: controller_name  <key>
                            
                            	Controller name
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: admin_weight
                            
                            	Set administrative weight for the interface
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: delay
                            
                            	Set link delay for the interface
                            	**type**\:  int
                            
                            	**range:** 1..16777215
                            
                            .. attribute:: enable
                            
                            	Enable GMPLS\-NNI on the link
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: tti_mode
                            
                            	Set tandem connection monitoring for the interface
                            	**type**\:   :py:class:`TtiMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller.TtiMode>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller, self).__init__()

                                self.yang_name = "controller"
                                self.yang_parent_name = "controllers"

                                self.controller_name = YLeaf(YType.str, "controller-name")

                                self.admin_weight = YLeaf(YType.uint32, "admin-weight")

                                self.delay = YLeaf(YType.uint32, "delay")

                                self.enable = YLeaf(YType.empty, "enable")

                                self.tti_mode = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller.TtiMode()
                                self.tti_mode.parent = self
                                self._children_name_map["tti_mode"] = "tti-mode"
                                self._children_yang_names.add("tti-mode")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("controller_name",
                                                "admin_weight",
                                                "delay",
                                                "enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller, self).__setattr__(name, value)


                            class TtiMode(Entity):
                                """
                                Set tandem connection monitoring for the
                                interface
                                
                                .. attribute:: tcmid
                                
                                	Tandem Connection Monitoring ID for the interface
                                	**type**\:  int
                                
                                	**range:** 1..6
                                
                                .. attribute:: tti_mode_type
                                
                                	Type of Trail Trace Identifier
                                	**type**\:   :py:class:`GmplsttiMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.GmplsttiMode>`
                                
                                

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller.TtiMode, self).__init__()

                                    self.yang_name = "tti-mode"
                                    self.yang_parent_name = "controller"

                                    self.tcmid = YLeaf(YType.uint32, "tcmid")

                                    self.tti_mode_type = YLeaf(YType.enumeration, "tti-mode-type")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("tcmid",
                                                    "tti_mode_type") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller.TtiMode, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller.TtiMode, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.tcmid.is_set or
                                        self.tti_mode_type.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.tcmid.yfilter != YFilter.not_set or
                                        self.tti_mode_type.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "tti-mode" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.tcmid.is_set or self.tcmid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tcmid.get_name_leafdata())
                                    if (self.tti_mode_type.is_set or self.tti_mode_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tti_mode_type.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "tcmid" or name == "tti-mode-type"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "tcmid"):
                                        self.tcmid = value
                                        self.tcmid.value_namespace = name_space
                                        self.tcmid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tti-mode-type"):
                                        self.tti_mode_type = value
                                        self.tti_mode_type.value_namespace = name_space
                                        self.tti_mode_type.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.controller_name.is_set or
                                    self.admin_weight.is_set or
                                    self.delay.is_set or
                                    self.enable.is_set or
                                    (self.tti_mode is not None and self.tti_mode.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.controller_name.yfilter != YFilter.not_set or
                                    self.admin_weight.yfilter != YFilter.not_set or
                                    self.delay.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    (self.tti_mode is not None and self.tti_mode.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "controller" + "[controller-name='" + self.controller_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.controller_name.is_set or self.controller_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.controller_name.get_name_leafdata())
                                if (self.admin_weight.is_set or self.admin_weight.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.admin_weight.get_name_leafdata())
                                if (self.delay.is_set or self.delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delay.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "tti-mode"):
                                    if (self.tti_mode is None):
                                        self.tti_mode = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller.TtiMode()
                                        self.tti_mode.parent = self
                                        self._children_name_map["tti_mode"] = "tti-mode"
                                    return self.tti_mode

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "tti-mode" or name == "controller-name" or name == "admin-weight" or name == "delay" or name == "enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "controller-name"):
                                    self.controller_name = value
                                    self.controller_name.value_namespace = name_space
                                    self.controller_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "admin-weight"):
                                    self.admin_weight = value
                                    self.admin_weight.value_namespace = name_space
                                    self.admin_weight.value_namespace_prefix = name_space_prefix
                                if(value_path == "delay"):
                                    self.delay = value
                                    self.delay.value_namespace = name_space
                                    self.delay.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.controller:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.controller:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "controllers" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "controller"):
                                for c in self.controller:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers.Controller()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.controller.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "controller"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.igp_area.is_set or
                            (self.controllers is not None and self.controllers.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.igp_area.yfilter != YFilter.not_set or
                            (self.controllers is not None and self.controllers.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ospf-int" + "[igp-area='" + self.igp_area.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.igp_area.is_set or self.igp_area.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.igp_area.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "controllers"):
                            if (self.controllers is None):
                                self.controllers = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt.Controllers()
                                self.controllers.parent = self
                                self._children_name_map["controllers"] = "controllers"
                            return self.controllers

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "controllers" or name == "igp-area"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "igp-area"):
                            self.igp_area = value
                            self.igp_area.value_namespace = name_space
                            self.igp_area.value_namespace_prefix = name_space_prefix


                class OspfipAddr(Entity):
                    """
                    ospfip addr
                    
                    .. attribute:: address  <key>
                    
                    	Area ID if in IP address format
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: controllers
                    
                    	GMPLS\-NNI controllers
                    	**type**\:   :py:class:`Controllers <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr, self).__init__()

                        self.yang_name = "ospfip-addr"
                        self.yang_parent_name = "topology-instance"

                        self.address = YLeaf(YType.str, "address")

                        self.controllers = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers()
                        self.controllers.parent = self
                        self._children_name_map["controllers"] = "controllers"
                        self._children_yang_names.add("controllers")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("address") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr, self).__setattr__(name, value)


                    class Controllers(Entity):
                        """
                        GMPLS\-NNI controllers
                        
                        .. attribute:: controller
                        
                        	Configure a GMPLS NNI controller
                        	**type**\: list of    :py:class:`Controller <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller>`
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers, self).__init__()

                            self.yang_name = "controllers"
                            self.yang_parent_name = "ospfip-addr"

                            self.controller = YList(self)

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in () and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers, self).__setattr__(name, value)


                        class Controller(Entity):
                            """
                            Configure a GMPLS NNI controller
                            
                            .. attribute:: controller_name  <key>
                            
                            	Controller name
                            	**type**\:  str
                            
                            	**pattern:** (([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){3,4}\\d+\\.\\d+)\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]\*\\d+))\|(([a\-zA\-Z0\-9\_]\*\\d+/){2}([a\-zA\-Z0\-9\_]+))\|([a\-zA\-Z0\-9\_\-]\*\\d+)\|([a\-zA\-Z0\-9\_\-]\*\\d+\\.\\d+)\|(mpls)\|(dwdm)
                            
                            .. attribute:: admin_weight
                            
                            	Set administrative weight for the interface
                            	**type**\:  int
                            
                            	**range:** 0..65535
                            
                            .. attribute:: delay
                            
                            	Set link delay for the interface
                            	**type**\:  int
                            
                            	**range:** 1..16777215
                            
                            .. attribute:: enable
                            
                            	Enable GMPLS\-NNI on the link
                            	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                            
                            .. attribute:: tti_mode
                            
                            	Set tandem connection monitoring for the interface
                            	**type**\:   :py:class:`TtiMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller.TtiMode>`
                            
                            

                            """

                            _prefix = 'mpls-te-cfg'
                            _revision = '2015-11-09'

                            def __init__(self):
                                super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller, self).__init__()

                                self.yang_name = "controller"
                                self.yang_parent_name = "controllers"

                                self.controller_name = YLeaf(YType.str, "controller-name")

                                self.admin_weight = YLeaf(YType.uint32, "admin-weight")

                                self.delay = YLeaf(YType.uint32, "delay")

                                self.enable = YLeaf(YType.empty, "enable")

                                self.tti_mode = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller.TtiMode()
                                self.tti_mode.parent = self
                                self._children_name_map["tti_mode"] = "tti-mode"
                                self._children_yang_names.add("tti-mode")

                            def __setattr__(self, name, value):
                                self._check_monkey_patching_error(name, value)
                                with _handle_type_error():
                                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                            "Please use list append or extend method."
                                                            .format(value))
                                    if isinstance(value, Enum.YLeaf):
                                        value = value.name
                                    if name in ("controller_name",
                                                "admin_weight",
                                                "delay",
                                                "enable") and name in self.__dict__:
                                        if isinstance(value, YLeaf):
                                            self.__dict__[name].set(value.get())
                                        elif isinstance(value, YLeafList):
                                            super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller, self).__setattr__(name, value)
                                        else:
                                            self.__dict__[name].set(value)
                                    else:
                                        if hasattr(value, "parent") and name != "parent":
                                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                value.parent = self
                                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                                value.parent = self
                                        super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller, self).__setattr__(name, value)


                            class TtiMode(Entity):
                                """
                                Set tandem connection monitoring for the
                                interface
                                
                                .. attribute:: tcmid
                                
                                	Tandem Connection Monitoring ID for the interface
                                	**type**\:  int
                                
                                	**range:** 1..6
                                
                                .. attribute:: tti_mode_type
                                
                                	Type of Trail Trace Identifier
                                	**type**\:   :py:class:`GmplsttiMode <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.GmplsttiMode>`
                                
                                

                                """

                                _prefix = 'mpls-te-cfg'
                                _revision = '2015-11-09'

                                def __init__(self):
                                    super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller.TtiMode, self).__init__()

                                    self.yang_name = "tti-mode"
                                    self.yang_parent_name = "controller"

                                    self.tcmid = YLeaf(YType.uint32, "tcmid")

                                    self.tti_mode_type = YLeaf(YType.enumeration, "tti-mode-type")

                                def __setattr__(self, name, value):
                                    self._check_monkey_patching_error(name, value)
                                    with _handle_type_error():
                                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                                "Please use list append or extend method."
                                                                .format(value))
                                        if isinstance(value, Enum.YLeaf):
                                            value = value.name
                                        if name in ("tcmid",
                                                    "tti_mode_type") and name in self.__dict__:
                                            if isinstance(value, YLeaf):
                                                self.__dict__[name].set(value.get())
                                            elif isinstance(value, YLeafList):
                                                super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller.TtiMode, self).__setattr__(name, value)
                                            else:
                                                self.__dict__[name].set(value)
                                        else:
                                            if hasattr(value, "parent") and name != "parent":
                                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                                    value.parent = self
                                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                                    value.parent = self
                                            super(MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller.TtiMode, self).__setattr__(name, value)

                                def has_data(self):
                                    return (
                                        self.tcmid.is_set or
                                        self.tti_mode_type.is_set)

                                def has_operation(self):
                                    return (
                                        self.yfilter != YFilter.not_set or
                                        self.tcmid.yfilter != YFilter.not_set or
                                        self.tti_mode_type.yfilter != YFilter.not_set)

                                def get_segment_path(self):
                                    path_buffer = ""
                                    path_buffer = "tti-mode" + path_buffer

                                    return path_buffer

                                def get_entity_path(self, ancestor):
                                    path_buffer = ""
                                    if (ancestor is None):
                                        raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                    else:
                                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                    leaf_name_data = LeafDataList()
                                    if (self.tcmid.is_set or self.tcmid.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tcmid.get_name_leafdata())
                                    if (self.tti_mode_type.is_set or self.tti_mode_type.yfilter != YFilter.not_set):
                                        leaf_name_data.append(self.tti_mode_type.get_name_leafdata())

                                    entity_path = EntityPath(path_buffer, leaf_name_data)
                                    return entity_path

                                def get_child_by_name(self, child_yang_name, segment_path):
                                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                    if child is not None:
                                        return child

                                    return None

                                def has_leaf_or_child_of_name(self, name):
                                    if(name == "tcmid" or name == "tti-mode-type"):
                                        return True
                                    return False

                                def set_value(self, value_path, value, name_space, name_space_prefix):
                                    if(value_path == "tcmid"):
                                        self.tcmid = value
                                        self.tcmid.value_namespace = name_space
                                        self.tcmid.value_namespace_prefix = name_space_prefix
                                    if(value_path == "tti-mode-type"):
                                        self.tti_mode_type = value
                                        self.tti_mode_type.value_namespace = name_space
                                        self.tti_mode_type.value_namespace_prefix = name_space_prefix

                            def has_data(self):
                                return (
                                    self.controller_name.is_set or
                                    self.admin_weight.is_set or
                                    self.delay.is_set or
                                    self.enable.is_set or
                                    (self.tti_mode is not None and self.tti_mode.has_data()))

                            def has_operation(self):
                                return (
                                    self.yfilter != YFilter.not_set or
                                    self.controller_name.yfilter != YFilter.not_set or
                                    self.admin_weight.yfilter != YFilter.not_set or
                                    self.delay.yfilter != YFilter.not_set or
                                    self.enable.yfilter != YFilter.not_set or
                                    (self.tti_mode is not None and self.tti_mode.has_operation()))

                            def get_segment_path(self):
                                path_buffer = ""
                                path_buffer = "controller" + "[controller-name='" + self.controller_name.get() + "']" + path_buffer

                                return path_buffer

                            def get_entity_path(self, ancestor):
                                path_buffer = ""
                                if (ancestor is None):
                                    raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                                else:
                                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                                leaf_name_data = LeafDataList()
                                if (self.controller_name.is_set or self.controller_name.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.controller_name.get_name_leafdata())
                                if (self.admin_weight.is_set or self.admin_weight.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.admin_weight.get_name_leafdata())
                                if (self.delay.is_set or self.delay.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.delay.get_name_leafdata())
                                if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                                    leaf_name_data.append(self.enable.get_name_leafdata())

                                entity_path = EntityPath(path_buffer, leaf_name_data)
                                return entity_path

                            def get_child_by_name(self, child_yang_name, segment_path):
                                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                                if child is not None:
                                    return child

                                if (child_yang_name == "tti-mode"):
                                    if (self.tti_mode is None):
                                        self.tti_mode = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller.TtiMode()
                                        self.tti_mode.parent = self
                                        self._children_name_map["tti_mode"] = "tti-mode"
                                    return self.tti_mode

                                return None

                            def has_leaf_or_child_of_name(self, name):
                                if(name == "tti-mode" or name == "controller-name" or name == "admin-weight" or name == "delay" or name == "enable"):
                                    return True
                                return False

                            def set_value(self, value_path, value, name_space, name_space_prefix):
                                if(value_path == "controller-name"):
                                    self.controller_name = value
                                    self.controller_name.value_namespace = name_space
                                    self.controller_name.value_namespace_prefix = name_space_prefix
                                if(value_path == "admin-weight"):
                                    self.admin_weight = value
                                    self.admin_weight.value_namespace = name_space
                                    self.admin_weight.value_namespace_prefix = name_space_prefix
                                if(value_path == "delay"):
                                    self.delay = value
                                    self.delay.value_namespace = name_space
                                    self.delay.value_namespace_prefix = name_space_prefix
                                if(value_path == "enable"):
                                    self.enable = value
                                    self.enable.value_namespace = name_space
                                    self.enable.value_namespace_prefix = name_space_prefix

                        def has_data(self):
                            for c in self.controller:
                                if (c.has_data()):
                                    return True
                            return False

                        def has_operation(self):
                            for c in self.controller:
                                if (c.has_operation()):
                                    return True
                            return self.yfilter != YFilter.not_set

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "controllers" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            if (child_yang_name == "controller"):
                                for c in self.controller:
                                    segment = c.get_segment_path()
                                    if (segment_path == segment):
                                        return c
                                c = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers.Controller()
                                c.parent = self
                                local_reference_key = "ydk::seg::%s" % segment_path
                                self._local_refs[local_reference_key] = c
                                self.controller.append(c)
                                return c

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "controller"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            pass

                    def has_data(self):
                        return (
                            self.address.is_set or
                            (self.controllers is not None and self.controllers.has_data()))

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.address.yfilter != YFilter.not_set or
                            (self.controllers is not None and self.controllers.has_operation()))

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "ospfip-addr" + "[address='" + self.address.get() + "']" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.address.is_set or self.address.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.address.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "controllers"):
                            if (self.controllers is None):
                                self.controllers = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr.Controllers()
                                self.controllers.parent = self
                                self._children_name_map["controllers"] = "controllers"
                            return self.controllers

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "controllers" or name == "address"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "address"):
                            self.address = value
                            self.address.value_namespace = name_space
                            self.address.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    for c in self.ospf_int:
                        if (c.has_data()):
                            return True
                    for c in self.ospfip_addr:
                        if (c.has_data()):
                            return True
                    return (
                        self.ospf_area_type.is_set or
                        self.igp_instance_name.is_set or
                        self.igp_type.is_set)

                def has_operation(self):
                    for c in self.ospf_int:
                        if (c.has_operation()):
                            return True
                    for c in self.ospfip_addr:
                        if (c.has_operation()):
                            return True
                    return (
                        self.yfilter != YFilter.not_set or
                        self.ospf_area_type.yfilter != YFilter.not_set or
                        self.igp_instance_name.yfilter != YFilter.not_set or
                        self.igp_type.yfilter != YFilter.not_set)

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "topology-instance" + "[ospf-area-type='" + self.ospf_area_type.get() + "']" + "[igp-instance-name='" + self.igp_instance_name.get() + "']" + "[igp-type='" + self.igp_type.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-nni/topology-instances/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.ospf_area_type.is_set or self.ospf_area_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.ospf_area_type.get_name_leafdata())
                    if (self.igp_instance_name.is_set or self.igp_instance_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.igp_instance_name.get_name_leafdata())
                    if (self.igp_type.is_set or self.igp_type.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.igp_type.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "ospf-int"):
                        for c in self.ospf_int:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfInt()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.ospf_int.append(c)
                        return c

                    if (child_yang_name == "ospfip-addr"):
                        for c in self.ospfip_addr:
                            segment = c.get_segment_path()
                            if (segment_path == segment):
                                return c
                        c = MplsTe.GmplsNni.TopologyInstances.TopologyInstance.OspfipAddr()
                        c.parent = self
                        local_reference_key = "ydk::seg::%s" % segment_path
                        self._local_refs[local_reference_key] = c
                        self.ospfip_addr.append(c)
                        return c

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "ospf-int" or name == "ospfip-addr" or name == "ospf-area-type" or name == "igp-instance-name" or name == "igp-type"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "ospf-area-type"):
                        self.ospf_area_type = value
                        self.ospf_area_type.value_namespace = name_space
                        self.ospf_area_type.value_namespace_prefix = name_space_prefix
                    if(value_path == "igp-instance-name"):
                        self.igp_instance_name = value
                        self.igp_instance_name.value_namespace = name_space
                        self.igp_instance_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "igp-type"):
                        self.igp_type = value
                        self.igp_type.value_namespace = name_space
                        self.igp_type.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.topology_instance:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.topology_instance:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "topology-instances" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-nni/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "topology-instance"):
                    for c in self.topology_instance:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsTe.GmplsNni.TopologyInstances.TopologyInstance()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.topology_instance.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "topology-instance"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass


        class TunnelHeads(Entity):
            """
            GMPLS\-NNI tunnel\-head table
            
            .. attribute:: tunnel_head
            
            	The configuration for a GMPLS NNI tunnel head\-end
            	**type**\: list of    :py:class:`TunnelHead <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TunnelHeads.TunnelHead>`
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.GmplsNni.TunnelHeads, self).__init__()

                self.yang_name = "tunnel-heads"
                self.yang_parent_name = "gmpls-nni"

                self.tunnel_head = YList(self)

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in () and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.GmplsNni.TunnelHeads, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.GmplsNni.TunnelHeads, self).__setattr__(name, value)


            class TunnelHead(Entity):
                """
                The configuration for a GMPLS NNI tunnel
                head\-end
                
                .. attribute:: tunnel_id  <key>
                
                	Tunnel ID
                	**type**\:  int
                
                	**range:** 0..65535
                
                .. attribute:: current_lsp_shutdown
                
                	The existence of this configuration indicates the current/working LSP of tunnel is shutdown
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: destination
                
                	The existence of this configuration indicates the destination has been set for the tunnel
                	**type**\:   :py:class:`Destination <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TunnelHeads.TunnelHead.Destination>`
                
                .. attribute:: enable
                
                	The existence of this configuration indicates the a new GMPLS NNI tunnel has been enabled
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: logging
                
                	Tunnel event logging
                	**type**\:   :py:class:`Logging <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TunnelHeads.TunnelHead.Logging>`
                
                .. attribute:: path_options
                
                	GMPLS NNI path options
                	**type**\:   :py:class:`PathOptions <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions>`
                
                .. attribute:: path_protection_attribute_set_profile
                
                	The name of the path\-protection profile to be included in signalling messages
                	**type**\:  str
                
                	**length:** 1..64
                
                .. attribute:: path_selection_metric
                
                	Path selection configuration for this specific tunnel
                	**type**\:   :py:class:`MplsTePathSelectionMetric <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathSelectionMetric>`
                
                .. attribute:: payload
                
                	The existence of this configuration indicates the Payload type have been set for the tunnel
                	**type**\:   :py:class:`OtnPayload <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.OtnPayload>`
                
                .. attribute:: protection_switching
                
                	The configuration for a GMPLS NNI tunnel protection switch
                	**type**\:   :py:class:`ProtectionSwitching <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TunnelHeads.TunnelHead.ProtectionSwitching>`
                
                .. attribute:: record_route
                
                	Record the route used by the tunnel
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: restore_lsp_shutdown
                
                	The existence of this configuration indicates the restore LSP of tunnel is shutdown
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: shutdown
                
                	The existence of this configuration indicates the tunnel is shutdown
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: signalled_bandwidth
                
                	The existence of this configuration indicates the signalled bandwidth has been set for the tunnel
                	**type**\:   :py:class:`SignalledBandwidth <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TunnelHeads.TunnelHead.SignalledBandwidth>`
                
                .. attribute:: signalled_name
                
                	The name of the tunnel to be included in signalling messages
                	**type**\:  str
                
                	**length:** 1..254
                
                .. attribute:: standby_lsp_shutdown
                
                	The existence of this configuration indicates the standby/protect LSP of tunnel is shutdown
                	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                
                .. attribute:: static_uni
                
                	The existence of this configuration indicates the static UNI endpoints have been set for the tunnel
                	**type**\:   :py:class:`StaticUni <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TunnelHeads.TunnelHead.StaticUni>`
                
                

                """

                _prefix = 'mpls-te-cfg'
                _revision = '2015-11-09'

                def __init__(self):
                    super(MplsTe.GmplsNni.TunnelHeads.TunnelHead, self).__init__()

                    self.yang_name = "tunnel-head"
                    self.yang_parent_name = "tunnel-heads"

                    self.tunnel_id = YLeaf(YType.uint32, "tunnel-id")

                    self.current_lsp_shutdown = YLeaf(YType.empty, "current-lsp-shutdown")

                    self.enable = YLeaf(YType.empty, "enable")

                    self.path_protection_attribute_set_profile = YLeaf(YType.str, "path-protection-attribute-set-profile")

                    self.path_selection_metric = YLeaf(YType.enumeration, "path-selection-metric")

                    self.payload = YLeaf(YType.enumeration, "payload")

                    self.record_route = YLeaf(YType.empty, "record-route")

                    self.restore_lsp_shutdown = YLeaf(YType.empty, "restore-lsp-shutdown")

                    self.shutdown = YLeaf(YType.empty, "shutdown")

                    self.signalled_name = YLeaf(YType.str, "signalled-name")

                    self.standby_lsp_shutdown = YLeaf(YType.empty, "standby-lsp-shutdown")

                    self.destination = MplsTe.GmplsNni.TunnelHeads.TunnelHead.Destination()
                    self.destination.parent = self
                    self._children_name_map["destination"] = "destination"
                    self._children_yang_names.add("destination")

                    self.logging = MplsTe.GmplsNni.TunnelHeads.TunnelHead.Logging()
                    self.logging.parent = self
                    self._children_name_map["logging"] = "logging"
                    self._children_yang_names.add("logging")

                    self.path_options = MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions()
                    self.path_options.parent = self
                    self._children_name_map["path_options"] = "path-options"
                    self._children_yang_names.add("path-options")

                    self.protection_switching = MplsTe.GmplsNni.TunnelHeads.TunnelHead.ProtectionSwitching()
                    self.protection_switching.parent = self
                    self._children_name_map["protection_switching"] = "protection-switching"
                    self._children_yang_names.add("protection-switching")

                    self.signalled_bandwidth = MplsTe.GmplsNni.TunnelHeads.TunnelHead.SignalledBandwidth()
                    self.signalled_bandwidth.parent = self
                    self._children_name_map["signalled_bandwidth"] = "signalled-bandwidth"
                    self._children_yang_names.add("signalled-bandwidth")

                    self.static_uni = MplsTe.GmplsNni.TunnelHeads.TunnelHead.StaticUni()
                    self.static_uni.parent = self
                    self._children_name_map["static_uni"] = "static-uni"
                    self._children_yang_names.add("static-uni")

                def __setattr__(self, name, value):
                    self._check_monkey_patching_error(name, value)
                    with _handle_type_error():
                        if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                            raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                "Please use list append or extend method."
                                                .format(value))
                        if isinstance(value, Enum.YLeaf):
                            value = value.name
                        if name in ("tunnel_id",
                                    "current_lsp_shutdown",
                                    "enable",
                                    "path_protection_attribute_set_profile",
                                    "path_selection_metric",
                                    "payload",
                                    "record_route",
                                    "restore_lsp_shutdown",
                                    "shutdown",
                                    "signalled_name",
                                    "standby_lsp_shutdown") and name in self.__dict__:
                            if isinstance(value, YLeaf):
                                self.__dict__[name].set(value.get())
                            elif isinstance(value, YLeafList):
                                super(MplsTe.GmplsNni.TunnelHeads.TunnelHead, self).__setattr__(name, value)
                            else:
                                self.__dict__[name].set(value)
                        else:
                            if hasattr(value, "parent") and name != "parent":
                                if hasattr(value, "is_presence_container") and value.is_presence_container:
                                    value.parent = self
                                elif value.parent is None and value.yang_name in self._children_yang_names:
                                    value.parent = self
                            super(MplsTe.GmplsNni.TunnelHeads.TunnelHead, self).__setattr__(name, value)


                class SignalledBandwidth(Entity):
                    """
                    The existence of this configuration indicates
                    the signalled bandwidth has been set for the
                    tunnel
                    
                    .. attribute:: bitrate
                    
                    	Bitrate value in Kbps for ODUflex framing type
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    	**units**\: kbit/s
                    
                    .. attribute:: od_uflex_framing_type
                    
                    	Framing type in case of ODUflex signal type
                    	**type**\:   :py:class:`OtnSignaledBandwidthFlexFraming <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.OtnSignaledBandwidthFlexFraming>`
                    
                    .. attribute:: signalled_bandwidth_type
                    
                    	The g.709 signal type requested
                    	**type**\:   :py:class:`OtnSignaledBandwidth <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.OtnSignaledBandwidth>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.SignalledBandwidth, self).__init__()

                        self.yang_name = "signalled-bandwidth"
                        self.yang_parent_name = "tunnel-head"

                        self.bitrate = YLeaf(YType.int32, "bitrate")

                        self.od_uflex_framing_type = YLeaf(YType.enumeration, "od-uflex-framing-type")

                        self.signalled_bandwidth_type = YLeaf(YType.enumeration, "signalled-bandwidth-type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("bitrate",
                                        "od_uflex_framing_type",
                                        "signalled_bandwidth_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.SignalledBandwidth, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.SignalledBandwidth, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.bitrate.is_set or
                            self.od_uflex_framing_type.is_set or
                            self.signalled_bandwidth_type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.bitrate.yfilter != YFilter.not_set or
                            self.od_uflex_framing_type.yfilter != YFilter.not_set or
                            self.signalled_bandwidth_type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "signalled-bandwidth" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.bitrate.is_set or self.bitrate.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.bitrate.get_name_leafdata())
                        if (self.od_uflex_framing_type.is_set or self.od_uflex_framing_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.od_uflex_framing_type.get_name_leafdata())
                        if (self.signalled_bandwidth_type.is_set or self.signalled_bandwidth_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.signalled_bandwidth_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "bitrate" or name == "od-uflex-framing-type" or name == "signalled-bandwidth-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "bitrate"):
                            self.bitrate = value
                            self.bitrate.value_namespace = name_space
                            self.bitrate.value_namespace_prefix = name_space_prefix
                        if(value_path == "od-uflex-framing-type"):
                            self.od_uflex_framing_type = value
                            self.od_uflex_framing_type.value_namespace = name_space
                            self.od_uflex_framing_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "signalled-bandwidth-type"):
                            self.signalled_bandwidth_type = value
                            self.signalled_bandwidth_type.value_namespace = name_space
                            self.signalled_bandwidth_type.value_namespace_prefix = name_space_prefix


                class Destination(Entity):
                    """
                    The existence of this configuration indicates
                    the destination has been set for the tunnel
                    
                    .. attribute:: destination
                    
                    	IPV4 tunnel destination
                    	**type**\:  str
                    
                    	**pattern:** (([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])\\.){3}([0\-9]\|[1\-9][0\-9]\|1[0\-9][0\-9]\|2[0\-4][0\-9]\|25[0\-5])(%[\\p{N}\\p{L}]+)?
                    
                    .. attribute:: destination_type
                    
                    	Destination type whether it is unicast or unnumbered
                    	**type**\:   :py:class:`OtnDestination <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.OtnDestination>`
                    
                    .. attribute:: interface_if_index
                    
                    	Interface index of port
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.Destination, self).__init__()

                        self.yang_name = "destination"
                        self.yang_parent_name = "tunnel-head"

                        self.destination = YLeaf(YType.str, "destination")

                        self.destination_type = YLeaf(YType.enumeration, "destination-type")

                        self.interface_if_index = YLeaf(YType.int32, "interface-if-index")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("destination",
                                        "destination_type",
                                        "interface_if_index") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.Destination, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.Destination, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.destination.is_set or
                            self.destination_type.is_set or
                            self.interface_if_index.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.destination.yfilter != YFilter.not_set or
                            self.destination_type.yfilter != YFilter.not_set or
                            self.interface_if_index.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "destination" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.destination.is_set or self.destination.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.destination.get_name_leafdata())
                        if (self.destination_type.is_set or self.destination_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.destination_type.get_name_leafdata())
                        if (self.interface_if_index.is_set or self.interface_if_index.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.interface_if_index.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "destination" or name == "destination-type" or name == "interface-if-index"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "destination"):
                            self.destination = value
                            self.destination.value_namespace = name_space
                            self.destination.value_namespace_prefix = name_space_prefix
                        if(value_path == "destination-type"):
                            self.destination_type = value
                            self.destination_type.value_namespace = name_space
                            self.destination_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "interface-if-index"):
                            self.interface_if_index = value
                            self.interface_if_index.value_namespace = name_space
                            self.interface_if_index.value_namespace_prefix = name_space_prefix


                class ProtectionSwitching(Entity):
                    """
                    The configuration for a GMPLS NNI tunnel
                    protection switch
                    
                    .. attribute:: lockout
                    
                    	The configuration is used to prevent switch over for a particular path type in tunnel
                    	**type**\:   :py:class:`OtnProtectionSwitchLockout <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.OtnProtectionSwitchLockout>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.ProtectionSwitching, self).__init__()

                        self.yang_name = "protection-switching"
                        self.yang_parent_name = "tunnel-head"

                        self.lockout = YLeaf(YType.enumeration, "lockout")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("lockout") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.ProtectionSwitching, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.ProtectionSwitching, self).__setattr__(name, value)

                    def has_data(self):
                        return self.lockout.is_set

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.lockout.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "protection-switching" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.lockout.is_set or self.lockout.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.lockout.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "lockout"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "lockout"):
                            self.lockout = value
                            self.lockout.value_namespace = name_space
                            self.lockout.value_namespace_prefix = name_space_prefix


                class Logging(Entity):
                    """
                    Tunnel event logging
                    
                    .. attribute:: active_lsp_message
                    
                    	Log all tunnel messages for changes in Active LSP
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: homepath_state_message
                    
                    	Log all messages for changes in state of Homepath of Working LSP
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: insufficient_bw_message
                    
                    	Log tunnel messages for insufficient bandwidth
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: path_change_message
                    
                    	Log all tunnel messages for changes in path\-change
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: signalling_state_message
                    
                    	Log all tunnel sub\-LSP state messages
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: static_cross_connect_message
                    
                    	Log all tunnel messages for static cross\-connect messages
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    .. attribute:: tunnel_state_message
                    
                    	Log all tunnel messages for changes in tunnel\-state
                    	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.Logging, self).__init__()

                        self.yang_name = "logging"
                        self.yang_parent_name = "tunnel-head"

                        self.active_lsp_message = YLeaf(YType.empty, "active-lsp-message")

                        self.homepath_state_message = YLeaf(YType.empty, "homepath-state-message")

                        self.insufficient_bw_message = YLeaf(YType.empty, "insufficient-bw-message")

                        self.path_change_message = YLeaf(YType.empty, "path-change-message")

                        self.signalling_state_message = YLeaf(YType.empty, "signalling-state-message")

                        self.static_cross_connect_message = YLeaf(YType.empty, "static-cross-connect-message")

                        self.tunnel_state_message = YLeaf(YType.empty, "tunnel-state-message")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("active_lsp_message",
                                        "homepath_state_message",
                                        "insufficient_bw_message",
                                        "path_change_message",
                                        "signalling_state_message",
                                        "static_cross_connect_message",
                                        "tunnel_state_message") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.Logging, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.Logging, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.active_lsp_message.is_set or
                            self.homepath_state_message.is_set or
                            self.insufficient_bw_message.is_set or
                            self.path_change_message.is_set or
                            self.signalling_state_message.is_set or
                            self.static_cross_connect_message.is_set or
                            self.tunnel_state_message.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.active_lsp_message.yfilter != YFilter.not_set or
                            self.homepath_state_message.yfilter != YFilter.not_set or
                            self.insufficient_bw_message.yfilter != YFilter.not_set or
                            self.path_change_message.yfilter != YFilter.not_set or
                            self.signalling_state_message.yfilter != YFilter.not_set or
                            self.static_cross_connect_message.yfilter != YFilter.not_set or
                            self.tunnel_state_message.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "logging" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.active_lsp_message.is_set or self.active_lsp_message.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.active_lsp_message.get_name_leafdata())
                        if (self.homepath_state_message.is_set or self.homepath_state_message.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.homepath_state_message.get_name_leafdata())
                        if (self.insufficient_bw_message.is_set or self.insufficient_bw_message.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.insufficient_bw_message.get_name_leafdata())
                        if (self.path_change_message.is_set or self.path_change_message.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.path_change_message.get_name_leafdata())
                        if (self.signalling_state_message.is_set or self.signalling_state_message.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.signalling_state_message.get_name_leafdata())
                        if (self.static_cross_connect_message.is_set or self.static_cross_connect_message.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.static_cross_connect_message.get_name_leafdata())
                        if (self.tunnel_state_message.is_set or self.tunnel_state_message.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.tunnel_state_message.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "active-lsp-message" or name == "homepath-state-message" or name == "insufficient-bw-message" or name == "path-change-message" or name == "signalling-state-message" or name == "static-cross-connect-message" or name == "tunnel-state-message"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "active-lsp-message"):
                            self.active_lsp_message = value
                            self.active_lsp_message.value_namespace = name_space
                            self.active_lsp_message.value_namespace_prefix = name_space_prefix
                        if(value_path == "homepath-state-message"):
                            self.homepath_state_message = value
                            self.homepath_state_message.value_namespace = name_space
                            self.homepath_state_message.value_namespace_prefix = name_space_prefix
                        if(value_path == "insufficient-bw-message"):
                            self.insufficient_bw_message = value
                            self.insufficient_bw_message.value_namespace = name_space
                            self.insufficient_bw_message.value_namespace_prefix = name_space_prefix
                        if(value_path == "path-change-message"):
                            self.path_change_message = value
                            self.path_change_message.value_namespace = name_space
                            self.path_change_message.value_namespace_prefix = name_space_prefix
                        if(value_path == "signalling-state-message"):
                            self.signalling_state_message = value
                            self.signalling_state_message.value_namespace = name_space
                            self.signalling_state_message.value_namespace_prefix = name_space_prefix
                        if(value_path == "static-cross-connect-message"):
                            self.static_cross_connect_message = value
                            self.static_cross_connect_message.value_namespace = name_space
                            self.static_cross_connect_message.value_namespace_prefix = name_space_prefix
                        if(value_path == "tunnel-state-message"):
                            self.tunnel_state_message = value
                            self.tunnel_state_message.value_namespace = name_space
                            self.tunnel_state_message.value_namespace_prefix = name_space_prefix


                class PathOptions(Entity):
                    """
                    GMPLS NNI path options
                    
                    .. attribute:: path_option
                    
                    	The existence of this configuration indicates the path options have been set for the tunnel
                    	**type**\: list of    :py:class:`PathOption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions.PathOption>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions, self).__init__()

                        self.yang_name = "path-options"
                        self.yang_parent_name = "tunnel-head"

                        self.path_option = YList(self)

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in () and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions, self).__setattr__(name, value)


                    class PathOption(Entity):
                        """
                        The existence of this configuration
                        indicates the path options have been set for
                        the tunnel
                        
                        .. attribute:: preference_level  <key>
                        
                        	Preference level for this path option
                        	**type**\:  int
                        
                        	**range:** 1..1000
                        
                        .. attribute:: lockdown
                        
                        	Lockdown properties
                        	**type**\:   :py:class:`MplsTePathOptionProperty <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathOptionProperty>`
                        
                        .. attribute:: path_id
                        
                        	The ID of the IP explicit path associated with this option
                        	**type**\:  int
                        
                        	**range:** 1..65535
                        
                        .. attribute:: path_name
                        
                        	The name of the IP explicit path associated with this option
                        	**type**\:  str
                        
                        .. attribute:: path_type
                        
                        	The type of the path option
                        	**type**\:   :py:class:`MplsTePathOption <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTePathOption>`
                        
                        .. attribute:: protected_by_preference_level
                        
                        	Preference level of the protecting explicit path. 
                        	**type**\:  int
                        
                        	**range:** 1..1001
                        
                        .. attribute:: restore_by_preference_level
                        
                        	Preference level of the restore path. 
                        	**type**\:  int
                        
                        	**range:** 1..1000
                        
                        .. attribute:: xro_attribute_set_name
                        
                        	The name of the XRO attribute set to be used for this path\-option
                        	**type**\:  str
                        
                        	**length:** 1..64
                        
                        .. attribute:: xro_type
                        
                        	The route\-exclusion type
                        	**type**\:  :py:class:`Empty<ydk.types.Empty>`
                        
                        	**mandatory**\: True
                        
                        

                        """

                        _prefix = 'mpls-te-cfg'
                        _revision = '2015-11-09'

                        def __init__(self):
                            super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions.PathOption, self).__init__()

                            self.yang_name = "path-option"
                            self.yang_parent_name = "path-options"

                            self.preference_level = YLeaf(YType.uint32, "preference-level")

                            self.lockdown = YLeaf(YType.enumeration, "lockdown")

                            self.path_id = YLeaf(YType.uint32, "path-id")

                            self.path_name = YLeaf(YType.str, "path-name")

                            self.path_type = YLeaf(YType.enumeration, "path-type")

                            self.protected_by_preference_level = YLeaf(YType.uint32, "protected-by-preference-level")

                            self.restore_by_preference_level = YLeaf(YType.uint32, "restore-by-preference-level")

                            self.xro_attribute_set_name = YLeaf(YType.str, "xro-attribute-set-name")

                            self.xro_type = YLeaf(YType.empty, "xro-type")

                        def __setattr__(self, name, value):
                            self._check_monkey_patching_error(name, value)
                            with _handle_type_error():
                                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                        "Please use list append or extend method."
                                                        .format(value))
                                if isinstance(value, Enum.YLeaf):
                                    value = value.name
                                if name in ("preference_level",
                                            "lockdown",
                                            "path_id",
                                            "path_name",
                                            "path_type",
                                            "protected_by_preference_level",
                                            "restore_by_preference_level",
                                            "xro_attribute_set_name",
                                            "xro_type") and name in self.__dict__:
                                    if isinstance(value, YLeaf):
                                        self.__dict__[name].set(value.get())
                                    elif isinstance(value, YLeafList):
                                        super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions.PathOption, self).__setattr__(name, value)
                                    else:
                                        self.__dict__[name].set(value)
                                else:
                                    if hasattr(value, "parent") and name != "parent":
                                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                                            value.parent = self
                                        elif value.parent is None and value.yang_name in self._children_yang_names:
                                            value.parent = self
                                    super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions.PathOption, self).__setattr__(name, value)

                        def has_data(self):
                            return (
                                self.preference_level.is_set or
                                self.lockdown.is_set or
                                self.path_id.is_set or
                                self.path_name.is_set or
                                self.path_type.is_set or
                                self.protected_by_preference_level.is_set or
                                self.restore_by_preference_level.is_set or
                                self.xro_attribute_set_name.is_set or
                                self.xro_type.is_set)

                        def has_operation(self):
                            return (
                                self.yfilter != YFilter.not_set or
                                self.preference_level.yfilter != YFilter.not_set or
                                self.lockdown.yfilter != YFilter.not_set or
                                self.path_id.yfilter != YFilter.not_set or
                                self.path_name.yfilter != YFilter.not_set or
                                self.path_type.yfilter != YFilter.not_set or
                                self.protected_by_preference_level.yfilter != YFilter.not_set or
                                self.restore_by_preference_level.yfilter != YFilter.not_set or
                                self.xro_attribute_set_name.yfilter != YFilter.not_set or
                                self.xro_type.yfilter != YFilter.not_set)

                        def get_segment_path(self):
                            path_buffer = ""
                            path_buffer = "path-option" + "[preference-level='" + self.preference_level.get() + "']" + path_buffer

                            return path_buffer

                        def get_entity_path(self, ancestor):
                            path_buffer = ""
                            if (ancestor is None):
                                raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                            else:
                                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                            leaf_name_data = LeafDataList()
                            if (self.preference_level.is_set or self.preference_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.preference_level.get_name_leafdata())
                            if (self.lockdown.is_set or self.lockdown.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.lockdown.get_name_leafdata())
                            if (self.path_id.is_set or self.path_id.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_id.get_name_leafdata())
                            if (self.path_name.is_set or self.path_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_name.get_name_leafdata())
                            if (self.path_type.is_set or self.path_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.path_type.get_name_leafdata())
                            if (self.protected_by_preference_level.is_set or self.protected_by_preference_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.protected_by_preference_level.get_name_leafdata())
                            if (self.restore_by_preference_level.is_set or self.restore_by_preference_level.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.restore_by_preference_level.get_name_leafdata())
                            if (self.xro_attribute_set_name.is_set or self.xro_attribute_set_name.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.xro_attribute_set_name.get_name_leafdata())
                            if (self.xro_type.is_set or self.xro_type.yfilter != YFilter.not_set):
                                leaf_name_data.append(self.xro_type.get_name_leafdata())

                            entity_path = EntityPath(path_buffer, leaf_name_data)
                            return entity_path

                        def get_child_by_name(self, child_yang_name, segment_path):
                            child = self._get_child_by_seg_name([child_yang_name, segment_path])
                            if child is not None:
                                return child

                            return None

                        def has_leaf_or_child_of_name(self, name):
                            if(name == "preference-level" or name == "lockdown" or name == "path-id" or name == "path-name" or name == "path-type" or name == "protected-by-preference-level" or name == "restore-by-preference-level" or name == "xro-attribute-set-name" or name == "xro-type"):
                                return True
                            return False

                        def set_value(self, value_path, value, name_space, name_space_prefix):
                            if(value_path == "preference-level"):
                                self.preference_level = value
                                self.preference_level.value_namespace = name_space
                                self.preference_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "lockdown"):
                                self.lockdown = value
                                self.lockdown.value_namespace = name_space
                                self.lockdown.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-id"):
                                self.path_id = value
                                self.path_id.value_namespace = name_space
                                self.path_id.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-name"):
                                self.path_name = value
                                self.path_name.value_namespace = name_space
                                self.path_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "path-type"):
                                self.path_type = value
                                self.path_type.value_namespace = name_space
                                self.path_type.value_namespace_prefix = name_space_prefix
                            if(value_path == "protected-by-preference-level"):
                                self.protected_by_preference_level = value
                                self.protected_by_preference_level.value_namespace = name_space
                                self.protected_by_preference_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "restore-by-preference-level"):
                                self.restore_by_preference_level = value
                                self.restore_by_preference_level.value_namespace = name_space
                                self.restore_by_preference_level.value_namespace_prefix = name_space_prefix
                            if(value_path == "xro-attribute-set-name"):
                                self.xro_attribute_set_name = value
                                self.xro_attribute_set_name.value_namespace = name_space
                                self.xro_attribute_set_name.value_namespace_prefix = name_space_prefix
                            if(value_path == "xro-type"):
                                self.xro_type = value
                                self.xro_type.value_namespace = name_space
                                self.xro_type.value_namespace_prefix = name_space_prefix

                    def has_data(self):
                        for c in self.path_option:
                            if (c.has_data()):
                                return True
                        return False

                    def has_operation(self):
                        for c in self.path_option:
                            if (c.has_operation()):
                                return True
                        return self.yfilter != YFilter.not_set

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "path-options" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        if (child_yang_name == "path-option"):
                            for c in self.path_option:
                                segment = c.get_segment_path()
                                if (segment_path == segment):
                                    return c
                            c = MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions.PathOption()
                            c.parent = self
                            local_reference_key = "ydk::seg::%s" % segment_path
                            self._local_refs[local_reference_key] = c
                            self.path_option.append(c)
                            return c

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "path-option"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        pass


                class StaticUni(Entity):
                    """
                    The existence of this configuration indicates
                    the static UNI endpoints have been set for
                    the tunnel
                    
                    .. attribute:: egress_controller_if_index
                    
                    	Interface index of Egress controller
                    	**type**\:  int
                    
                    	**range:** \-2147483648..2147483647
                    
                    .. attribute:: egress_type
                    
                    	Egress type whether it is xconnect or terminated
                    	**type**\:   :py:class:`OtnStaticUni <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.OtnStaticUni>`
                    
                    .. attribute:: ingress_controller_name
                    
                    	Name of  ingress controller
                    	**type**\:  str
                    
                    	**length:** 1..255
                    
                    .. attribute:: ingress_type
                    
                    	Ingress type whether it is xconnect or terminated
                    	**type**\:   :py:class:`OtnStaticUni <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.OtnStaticUni>`
                    
                    

                    """

                    _prefix = 'mpls-te-cfg'
                    _revision = '2015-11-09'

                    def __init__(self):
                        super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.StaticUni, self).__init__()

                        self.yang_name = "static-uni"
                        self.yang_parent_name = "tunnel-head"

                        self.egress_controller_if_index = YLeaf(YType.int32, "egress-controller-if-index")

                        self.egress_type = YLeaf(YType.enumeration, "egress-type")

                        self.ingress_controller_name = YLeaf(YType.str, "ingress-controller-name")

                        self.ingress_type = YLeaf(YType.enumeration, "ingress-type")

                    def __setattr__(self, name, value):
                        self._check_monkey_patching_error(name, value)
                        with _handle_type_error():
                            if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                                raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                                    "Please use list append or extend method."
                                                    .format(value))
                            if isinstance(value, Enum.YLeaf):
                                value = value.name
                            if name in ("egress_controller_if_index",
                                        "egress_type",
                                        "ingress_controller_name",
                                        "ingress_type") and name in self.__dict__:
                                if isinstance(value, YLeaf):
                                    self.__dict__[name].set(value.get())
                                elif isinstance(value, YLeafList):
                                    super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.StaticUni, self).__setattr__(name, value)
                                else:
                                    self.__dict__[name].set(value)
                            else:
                                if hasattr(value, "parent") and name != "parent":
                                    if hasattr(value, "is_presence_container") and value.is_presence_container:
                                        value.parent = self
                                    elif value.parent is None and value.yang_name in self._children_yang_names:
                                        value.parent = self
                                super(MplsTe.GmplsNni.TunnelHeads.TunnelHead.StaticUni, self).__setattr__(name, value)

                    def has_data(self):
                        return (
                            self.egress_controller_if_index.is_set or
                            self.egress_type.is_set or
                            self.ingress_controller_name.is_set or
                            self.ingress_type.is_set)

                    def has_operation(self):
                        return (
                            self.yfilter != YFilter.not_set or
                            self.egress_controller_if_index.yfilter != YFilter.not_set or
                            self.egress_type.yfilter != YFilter.not_set or
                            self.ingress_controller_name.yfilter != YFilter.not_set or
                            self.ingress_type.yfilter != YFilter.not_set)

                    def get_segment_path(self):
                        path_buffer = ""
                        path_buffer = "static-uni" + path_buffer

                        return path_buffer

                    def get_entity_path(self, ancestor):
                        path_buffer = ""
                        if (ancestor is None):
                            raise YPYModelError("ancestor cannot be None as one of the ancestors is a list")
                        else:
                            path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                        leaf_name_data = LeafDataList()
                        if (self.egress_controller_if_index.is_set or self.egress_controller_if_index.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.egress_controller_if_index.get_name_leafdata())
                        if (self.egress_type.is_set or self.egress_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.egress_type.get_name_leafdata())
                        if (self.ingress_controller_name.is_set or self.ingress_controller_name.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ingress_controller_name.get_name_leafdata())
                        if (self.ingress_type.is_set or self.ingress_type.yfilter != YFilter.not_set):
                            leaf_name_data.append(self.ingress_type.get_name_leafdata())

                        entity_path = EntityPath(path_buffer, leaf_name_data)
                        return entity_path

                    def get_child_by_name(self, child_yang_name, segment_path):
                        child = self._get_child_by_seg_name([child_yang_name, segment_path])
                        if child is not None:
                            return child

                        return None

                    def has_leaf_or_child_of_name(self, name):
                        if(name == "egress-controller-if-index" or name == "egress-type" or name == "ingress-controller-name" or name == "ingress-type"):
                            return True
                        return False

                    def set_value(self, value_path, value, name_space, name_space_prefix):
                        if(value_path == "egress-controller-if-index"):
                            self.egress_controller_if_index = value
                            self.egress_controller_if_index.value_namespace = name_space
                            self.egress_controller_if_index.value_namespace_prefix = name_space_prefix
                        if(value_path == "egress-type"):
                            self.egress_type = value
                            self.egress_type.value_namespace = name_space
                            self.egress_type.value_namespace_prefix = name_space_prefix
                        if(value_path == "ingress-controller-name"):
                            self.ingress_controller_name = value
                            self.ingress_controller_name.value_namespace = name_space
                            self.ingress_controller_name.value_namespace_prefix = name_space_prefix
                        if(value_path == "ingress-type"):
                            self.ingress_type = value
                            self.ingress_type.value_namespace = name_space
                            self.ingress_type.value_namespace_prefix = name_space_prefix

                def has_data(self):
                    return (
                        self.tunnel_id.is_set or
                        self.current_lsp_shutdown.is_set or
                        self.enable.is_set or
                        self.path_protection_attribute_set_profile.is_set or
                        self.path_selection_metric.is_set or
                        self.payload.is_set or
                        self.record_route.is_set or
                        self.restore_lsp_shutdown.is_set or
                        self.shutdown.is_set or
                        self.signalled_name.is_set or
                        self.standby_lsp_shutdown.is_set or
                        (self.destination is not None and self.destination.has_data()) or
                        (self.logging is not None and self.logging.has_data()) or
                        (self.path_options is not None and self.path_options.has_data()) or
                        (self.protection_switching is not None and self.protection_switching.has_data()) or
                        (self.signalled_bandwidth is not None and self.signalled_bandwidth.has_data()) or
                        (self.static_uni is not None and self.static_uni.has_data()))

                def has_operation(self):
                    return (
                        self.yfilter != YFilter.not_set or
                        self.tunnel_id.yfilter != YFilter.not_set or
                        self.current_lsp_shutdown.yfilter != YFilter.not_set or
                        self.enable.yfilter != YFilter.not_set or
                        self.path_protection_attribute_set_profile.yfilter != YFilter.not_set or
                        self.path_selection_metric.yfilter != YFilter.not_set or
                        self.payload.yfilter != YFilter.not_set or
                        self.record_route.yfilter != YFilter.not_set or
                        self.restore_lsp_shutdown.yfilter != YFilter.not_set or
                        self.shutdown.yfilter != YFilter.not_set or
                        self.signalled_name.yfilter != YFilter.not_set or
                        self.standby_lsp_shutdown.yfilter != YFilter.not_set or
                        (self.destination is not None and self.destination.has_operation()) or
                        (self.logging is not None and self.logging.has_operation()) or
                        (self.path_options is not None and self.path_options.has_operation()) or
                        (self.protection_switching is not None and self.protection_switching.has_operation()) or
                        (self.signalled_bandwidth is not None and self.signalled_bandwidth.has_operation()) or
                        (self.static_uni is not None and self.static_uni.has_operation()))

                def get_segment_path(self):
                    path_buffer = ""
                    path_buffer = "tunnel-head" + "[tunnel-id='" + self.tunnel_id.get() + "']" + path_buffer

                    return path_buffer

                def get_entity_path(self, ancestor):
                    path_buffer = ""
                    if (ancestor is None):
                        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-nni/tunnel-heads/%s" % self.get_segment_path()
                    else:
                        path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                    leaf_name_data = LeafDataList()
                    if (self.tunnel_id.is_set or self.tunnel_id.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.tunnel_id.get_name_leafdata())
                    if (self.current_lsp_shutdown.is_set or self.current_lsp_shutdown.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.current_lsp_shutdown.get_name_leafdata())
                    if (self.enable.is_set or self.enable.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.enable.get_name_leafdata())
                    if (self.path_protection_attribute_set_profile.is_set or self.path_protection_attribute_set_profile.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.path_protection_attribute_set_profile.get_name_leafdata())
                    if (self.path_selection_metric.is_set or self.path_selection_metric.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.path_selection_metric.get_name_leafdata())
                    if (self.payload.is_set or self.payload.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.payload.get_name_leafdata())
                    if (self.record_route.is_set or self.record_route.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.record_route.get_name_leafdata())
                    if (self.restore_lsp_shutdown.is_set or self.restore_lsp_shutdown.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.restore_lsp_shutdown.get_name_leafdata())
                    if (self.shutdown.is_set or self.shutdown.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.shutdown.get_name_leafdata())
                    if (self.signalled_name.is_set or self.signalled_name.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.signalled_name.get_name_leafdata())
                    if (self.standby_lsp_shutdown.is_set or self.standby_lsp_shutdown.yfilter != YFilter.not_set):
                        leaf_name_data.append(self.standby_lsp_shutdown.get_name_leafdata())

                    entity_path = EntityPath(path_buffer, leaf_name_data)
                    return entity_path

                def get_child_by_name(self, child_yang_name, segment_path):
                    child = self._get_child_by_seg_name([child_yang_name, segment_path])
                    if child is not None:
                        return child

                    if (child_yang_name == "destination"):
                        if (self.destination is None):
                            self.destination = MplsTe.GmplsNni.TunnelHeads.TunnelHead.Destination()
                            self.destination.parent = self
                            self._children_name_map["destination"] = "destination"
                        return self.destination

                    if (child_yang_name == "logging"):
                        if (self.logging is None):
                            self.logging = MplsTe.GmplsNni.TunnelHeads.TunnelHead.Logging()
                            self.logging.parent = self
                            self._children_name_map["logging"] = "logging"
                        return self.logging

                    if (child_yang_name == "path-options"):
                        if (self.path_options is None):
                            self.path_options = MplsTe.GmplsNni.TunnelHeads.TunnelHead.PathOptions()
                            self.path_options.parent = self
                            self._children_name_map["path_options"] = "path-options"
                        return self.path_options

                    if (child_yang_name == "protection-switching"):
                        if (self.protection_switching is None):
                            self.protection_switching = MplsTe.GmplsNni.TunnelHeads.TunnelHead.ProtectionSwitching()
                            self.protection_switching.parent = self
                            self._children_name_map["protection_switching"] = "protection-switching"
                        return self.protection_switching

                    if (child_yang_name == "signalled-bandwidth"):
                        if (self.signalled_bandwidth is None):
                            self.signalled_bandwidth = MplsTe.GmplsNni.TunnelHeads.TunnelHead.SignalledBandwidth()
                            self.signalled_bandwidth.parent = self
                            self._children_name_map["signalled_bandwidth"] = "signalled-bandwidth"
                        return self.signalled_bandwidth

                    if (child_yang_name == "static-uni"):
                        if (self.static_uni is None):
                            self.static_uni = MplsTe.GmplsNni.TunnelHeads.TunnelHead.StaticUni()
                            self.static_uni.parent = self
                            self._children_name_map["static_uni"] = "static-uni"
                        return self.static_uni

                    return None

                def has_leaf_or_child_of_name(self, name):
                    if(name == "destination" or name == "logging" or name == "path-options" or name == "protection-switching" or name == "signalled-bandwidth" or name == "static-uni" or name == "tunnel-id" or name == "current-lsp-shutdown" or name == "enable" or name == "path-protection-attribute-set-profile" or name == "path-selection-metric" or name == "payload" or name == "record-route" or name == "restore-lsp-shutdown" or name == "shutdown" or name == "signalled-name" or name == "standby-lsp-shutdown"):
                        return True
                    return False

                def set_value(self, value_path, value, name_space, name_space_prefix):
                    if(value_path == "tunnel-id"):
                        self.tunnel_id = value
                        self.tunnel_id.value_namespace = name_space
                        self.tunnel_id.value_namespace_prefix = name_space_prefix
                    if(value_path == "current-lsp-shutdown"):
                        self.current_lsp_shutdown = value
                        self.current_lsp_shutdown.value_namespace = name_space
                        self.current_lsp_shutdown.value_namespace_prefix = name_space_prefix
                    if(value_path == "enable"):
                        self.enable = value
                        self.enable.value_namespace = name_space
                        self.enable.value_namespace_prefix = name_space_prefix
                    if(value_path == "path-protection-attribute-set-profile"):
                        self.path_protection_attribute_set_profile = value
                        self.path_protection_attribute_set_profile.value_namespace = name_space
                        self.path_protection_attribute_set_profile.value_namespace_prefix = name_space_prefix
                    if(value_path == "path-selection-metric"):
                        self.path_selection_metric = value
                        self.path_selection_metric.value_namespace = name_space
                        self.path_selection_metric.value_namespace_prefix = name_space_prefix
                    if(value_path == "payload"):
                        self.payload = value
                        self.payload.value_namespace = name_space
                        self.payload.value_namespace_prefix = name_space_prefix
                    if(value_path == "record-route"):
                        self.record_route = value
                        self.record_route.value_namespace = name_space
                        self.record_route.value_namespace_prefix = name_space_prefix
                    if(value_path == "restore-lsp-shutdown"):
                        self.restore_lsp_shutdown = value
                        self.restore_lsp_shutdown.value_namespace = name_space
                        self.restore_lsp_shutdown.value_namespace_prefix = name_space_prefix
                    if(value_path == "shutdown"):
                        self.shutdown = value
                        self.shutdown.value_namespace = name_space
                        self.shutdown.value_namespace_prefix = name_space_prefix
                    if(value_path == "signalled-name"):
                        self.signalled_name = value
                        self.signalled_name.value_namespace = name_space
                        self.signalled_name.value_namespace_prefix = name_space_prefix
                    if(value_path == "standby-lsp-shutdown"):
                        self.standby_lsp_shutdown = value
                        self.standby_lsp_shutdown.value_namespace = name_space
                        self.standby_lsp_shutdown.value_namespace_prefix = name_space_prefix

            def has_data(self):
                for c in self.tunnel_head:
                    if (c.has_data()):
                        return True
                return False

            def has_operation(self):
                for c in self.tunnel_head:
                    if (c.has_operation()):
                        return True
                return self.yfilter != YFilter.not_set

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "tunnel-heads" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-nni/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                if (child_yang_name == "tunnel-head"):
                    for c in self.tunnel_head:
                        segment = c.get_segment_path()
                        if (segment_path == segment):
                            return c
                    c = MplsTe.GmplsNni.TunnelHeads.TunnelHead()
                    c.parent = self
                    local_reference_key = "ydk::seg::%s" % segment_path
                    self._local_refs[local_reference_key] = c
                    self.tunnel_head.append(c)
                    return c

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "tunnel-head"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                pass

        def has_data(self):
            return (
                self.enable_gmpls_nni.is_set or
                self.path_selection_metric.is_set or
                (self.topology_instances is not None and self.topology_instances.has_data()) or
                (self.tunnel_heads is not None and self.tunnel_heads.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.enable_gmpls_nni.yfilter != YFilter.not_set or
                self.path_selection_metric.yfilter != YFilter.not_set or
                (self.topology_instances is not None and self.topology_instances.has_operation()) or
                (self.tunnel_heads is not None and self.tunnel_heads.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "gmpls-nni" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.enable_gmpls_nni.is_set or self.enable_gmpls_nni.yfilter != YFilter.not_set):
                leaf_name_data.append(self.enable_gmpls_nni.get_name_leafdata())
            if (self.path_selection_metric.is_set or self.path_selection_metric.yfilter != YFilter.not_set):
                leaf_name_data.append(self.path_selection_metric.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "topology-instances"):
                if (self.topology_instances is None):
                    self.topology_instances = MplsTe.GmplsNni.TopologyInstances()
                    self.topology_instances.parent = self
                    self._children_name_map["topology_instances"] = "topology-instances"
                return self.topology_instances

            if (child_yang_name == "tunnel-heads"):
                if (self.tunnel_heads is None):
                    self.tunnel_heads = MplsTe.GmplsNni.TunnelHeads()
                    self.tunnel_heads.parent = self
                    self._children_name_map["tunnel_heads"] = "tunnel-heads"
                return self.tunnel_heads

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "topology-instances" or name == "tunnel-heads" or name == "enable-gmpls-nni" or name == "path-selection-metric"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "enable-gmpls-nni"):
                self.enable_gmpls_nni = value
                self.enable_gmpls_nni.value_namespace = name_space
                self.enable_gmpls_nni.value_namespace_prefix = name_space_prefix
            if(value_path == "path-selection-metric"):
                self.path_selection_metric = value
                self.path_selection_metric.value_namespace = name_space
                self.path_selection_metric.value_namespace_prefix = name_space_prefix


    class Lcac(Entity):
        """
        LCAC specific MPLS global configuration
        
        .. attribute:: bandwidth_hold_timer
        
        	Bandwidth hold timer value (seconds)
        	**type**\:  int
        
        	**range:** 1..300
        
        	**units**\: second
        
        .. attribute:: bfd
        
        	BFD configuration
        	**type**\:   :py:class:`Bfd <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Lcac.Bfd>`
        
        .. attribute:: delay_preempt_bundle_capacity_timer
        
        	Bundle capacity preemption timer value (seconds)
        	**type**\:  int
        
        	**range:** 0..300
        
        	**units**\: second
        
        .. attribute:: flooding_threshold
        
        	Configure flooding threshold as percentage of total link bandwidth
        	**type**\:   :py:class:`FloodingThreshold <ydk.models.cisco_ios_xr.Cisco_IOS_XR_mpls_te_cfg.MplsTe.Lcac.FloodingThreshold>`
        
        .. attribute:: periodic_flooding_timer
        
        	Periodic flooding value (seconds)
        	**type**\:  int
        
        	**range:** 0..3600
        
        	**units**\: second
        
        

        """

        _prefix = 'mpls-te-cfg'
        _revision = '2015-11-09'

        def __init__(self):
            super(MplsTe.Lcac, self).__init__()

            self.yang_name = "lcac"
            self.yang_parent_name = "mpls-te"

            self.bandwidth_hold_timer = YLeaf(YType.uint32, "bandwidth-hold-timer")

            self.delay_preempt_bundle_capacity_timer = YLeaf(YType.uint32, "delay-preempt-bundle-capacity-timer")

            self.periodic_flooding_timer = YLeaf(YType.uint32, "periodic-flooding-timer")

            self.bfd = MplsTe.Lcac.Bfd()
            self.bfd.parent = self
            self._children_name_map["bfd"] = "bfd"
            self._children_yang_names.add("bfd")

            self.flooding_threshold = MplsTe.Lcac.FloodingThreshold()
            self.flooding_threshold.parent = self
            self._children_name_map["flooding_threshold"] = "flooding-threshold"
            self._children_yang_names.add("flooding-threshold")

        def __setattr__(self, name, value):
            self._check_monkey_patching_error(name, value)
            with _handle_type_error():
                if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                    raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                        "Please use list append or extend method."
                                        .format(value))
                if isinstance(value, Enum.YLeaf):
                    value = value.name
                if name in ("bandwidth_hold_timer",
                            "delay_preempt_bundle_capacity_timer",
                            "periodic_flooding_timer") and name in self.__dict__:
                    if isinstance(value, YLeaf):
                        self.__dict__[name].set(value.get())
                    elif isinstance(value, YLeafList):
                        super(MplsTe.Lcac, self).__setattr__(name, value)
                    else:
                        self.__dict__[name].set(value)
                else:
                    if hasattr(value, "parent") and name != "parent":
                        if hasattr(value, "is_presence_container") and value.is_presence_container:
                            value.parent = self
                        elif value.parent is None and value.yang_name in self._children_yang_names:
                            value.parent = self
                    super(MplsTe.Lcac, self).__setattr__(name, value)


        class Bfd(Entity):
            """
            BFD configuration
            
            .. attribute:: detection_multiplier
            
            	Detection multiplier for BFD sessions created by TE
            	**type**\:  int
            
            	**range:** 2..10
            
            .. attribute:: interval
            
            	Hello interval for BFD sessions created by TE
            	**type**\:  int
            
            	**range:** 15..200
            
            	**units**\: millisecond
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.Lcac.Bfd, self).__init__()

                self.yang_name = "bfd"
                self.yang_parent_name = "lcac"

                self.detection_multiplier = YLeaf(YType.uint32, "detection-multiplier")

                self.interval = YLeaf(YType.uint32, "interval")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("detection_multiplier",
                                "interval") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.Lcac.Bfd, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.Lcac.Bfd, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.detection_multiplier.is_set or
                    self.interval.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.detection_multiplier.yfilter != YFilter.not_set or
                    self.interval.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "bfd" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/lcac/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.detection_multiplier.is_set or self.detection_multiplier.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.detection_multiplier.get_name_leafdata())
                if (self.interval.is_set or self.interval.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.interval.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "detection-multiplier" or name == "interval"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "detection-multiplier"):
                    self.detection_multiplier = value
                    self.detection_multiplier.value_namespace = name_space
                    self.detection_multiplier.value_namespace_prefix = name_space_prefix
                if(value_path == "interval"):
                    self.interval = value
                    self.interval.value_namespace = name_space
                    self.interval.value_namespace_prefix = name_space_prefix


        class FloodingThreshold(Entity):
            """
            Configure flooding threshold as percentage of
            total link bandwidth.
            
            .. attribute:: down_stream
            
            	Downward flooding Threshold in percentages of total bandwidth
            	**type**\:  int
            
            	**range:** 0..100
            
            	**units**\: percentage
            
            .. attribute:: up_stream
            
            	Upward flooding Threshold in percentages of total bandwidth
            	**type**\:  int
            
            	**range:** 0..100
            
            	**units**\: percentage
            
            

            """

            _prefix = 'mpls-te-cfg'
            _revision = '2015-11-09'

            def __init__(self):
                super(MplsTe.Lcac.FloodingThreshold, self).__init__()

                self.yang_name = "flooding-threshold"
                self.yang_parent_name = "lcac"

                self.down_stream = YLeaf(YType.uint32, "down-stream")

                self.up_stream = YLeaf(YType.uint32, "up-stream")

            def __setattr__(self, name, value):
                self._check_monkey_patching_error(name, value)
                with _handle_type_error():
                    if name in self.__dict__ and isinstance(self.__dict__[name], YList):
                        raise YPYModelError("Attempt to assign value of '{}' to YList ldata. "
                                            "Please use list append or extend method."
                                            .format(value))
                    if isinstance(value, Enum.YLeaf):
                        value = value.name
                    if name in ("down_stream",
                                "up_stream") and name in self.__dict__:
                        if isinstance(value, YLeaf):
                            self.__dict__[name].set(value.get())
                        elif isinstance(value, YLeafList):
                            super(MplsTe.Lcac.FloodingThreshold, self).__setattr__(name, value)
                        else:
                            self.__dict__[name].set(value)
                    else:
                        if hasattr(value, "parent") and name != "parent":
                            if hasattr(value, "is_presence_container") and value.is_presence_container:
                                value.parent = self
                            elif value.parent is None and value.yang_name in self._children_yang_names:
                                value.parent = self
                        super(MplsTe.Lcac.FloodingThreshold, self).__setattr__(name, value)

            def has_data(self):
                return (
                    self.down_stream.is_set or
                    self.up_stream.is_set)

            def has_operation(self):
                return (
                    self.yfilter != YFilter.not_set or
                    self.down_stream.yfilter != YFilter.not_set or
                    self.up_stream.yfilter != YFilter.not_set)

            def get_segment_path(self):
                path_buffer = ""
                path_buffer = "flooding-threshold" + path_buffer

                return path_buffer

            def get_entity_path(self, ancestor):
                path_buffer = ""
                if (ancestor is None):
                    path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/lcac/%s" % self.get_segment_path()
                else:
                    path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

                leaf_name_data = LeafDataList()
                if (self.down_stream.is_set or self.down_stream.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.down_stream.get_name_leafdata())
                if (self.up_stream.is_set or self.up_stream.yfilter != YFilter.not_set):
                    leaf_name_data.append(self.up_stream.get_name_leafdata())

                entity_path = EntityPath(path_buffer, leaf_name_data)
                return entity_path

            def get_child_by_name(self, child_yang_name, segment_path):
                child = self._get_child_by_seg_name([child_yang_name, segment_path])
                if child is not None:
                    return child

                return None

            def has_leaf_or_child_of_name(self, name):
                if(name == "down-stream" or name == "up-stream"):
                    return True
                return False

            def set_value(self, value_path, value, name_space, name_space_prefix):
                if(value_path == "down-stream"):
                    self.down_stream = value
                    self.down_stream.value_namespace = name_space
                    self.down_stream.value_namespace_prefix = name_space_prefix
                if(value_path == "up-stream"):
                    self.up_stream = value
                    self.up_stream.value_namespace = name_space
                    self.up_stream.value_namespace_prefix = name_space_prefix

        def has_data(self):
            return (
                self.bandwidth_hold_timer.is_set or
                self.delay_preempt_bundle_capacity_timer.is_set or
                self.periodic_flooding_timer.is_set or
                (self.bfd is not None and self.bfd.has_data()) or
                (self.flooding_threshold is not None and self.flooding_threshold.has_data()))

        def has_operation(self):
            return (
                self.yfilter != YFilter.not_set or
                self.bandwidth_hold_timer.yfilter != YFilter.not_set or
                self.delay_preempt_bundle_capacity_timer.yfilter != YFilter.not_set or
                self.periodic_flooding_timer.yfilter != YFilter.not_set or
                (self.bfd is not None and self.bfd.has_operation()) or
                (self.flooding_threshold is not None and self.flooding_threshold.has_operation()))

        def get_segment_path(self):
            path_buffer = ""
            path_buffer = "lcac" + path_buffer

            return path_buffer

        def get_entity_path(self, ancestor):
            path_buffer = ""
            if (ancestor is None):
                path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te/%s" % self.get_segment_path()
            else:
                path_buffer = _get_relative_entity_path(self, ancestor, path_buffer)

            leaf_name_data = LeafDataList()
            if (self.bandwidth_hold_timer.is_set or self.bandwidth_hold_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.bandwidth_hold_timer.get_name_leafdata())
            if (self.delay_preempt_bundle_capacity_timer.is_set or self.delay_preempt_bundle_capacity_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.delay_preempt_bundle_capacity_timer.get_name_leafdata())
            if (self.periodic_flooding_timer.is_set or self.periodic_flooding_timer.yfilter != YFilter.not_set):
                leaf_name_data.append(self.periodic_flooding_timer.get_name_leafdata())

            entity_path = EntityPath(path_buffer, leaf_name_data)
            return entity_path

        def get_child_by_name(self, child_yang_name, segment_path):
            child = self._get_child_by_seg_name([child_yang_name, segment_path])
            if child is not None:
                return child

            if (child_yang_name == "bfd"):
                if (self.bfd is None):
                    self.bfd = MplsTe.Lcac.Bfd()
                    self.bfd.parent = self
                    self._children_name_map["bfd"] = "bfd"
                return self.bfd

            if (child_yang_name == "flooding-threshold"):
                if (self.flooding_threshold is None):
                    self.flooding_threshold = MplsTe.Lcac.FloodingThreshold()
                    self.flooding_threshold.parent = self
                    self._children_name_map["flooding_threshold"] = "flooding-threshold"
                return self.flooding_threshold

            return None

        def has_leaf_or_child_of_name(self, name):
            if(name == "bfd" or name == "flooding-threshold" or name == "bandwidth-hold-timer" or name == "delay-preempt-bundle-capacity-timer" or name == "periodic-flooding-timer"):
                return True
            return False

        def set_value(self, value_path, value, name_space, name_space_prefix):
            if(value_path == "bandwidth-hold-timer"):
                self.bandwidth_hold_timer = value
                self.bandwidth_hold_timer.value_namespace = name_space
                self.bandwidth_hold_timer.value_namespace_prefix = name_space_prefix
            if(value_path == "delay-preempt-bundle-capacity-timer"):
                self.delay_preempt_bundle_capacity_timer = value
                self.delay_preempt_bundle_capacity_timer.value_namespace = name_space
                self.delay_preempt_bundle_capacity_timer.value_namespace_prefix = name_space_prefix
            if(value_path == "periodic-flooding-timer"):
                self.periodic_flooding_timer = value
                self.periodic_flooding_timer.value_namespace = name_space
                self.periodic_flooding_timer.value_namespace_prefix = name_space_prefix

    def has_data(self):
        return (
            self.enable_traffic_engineering.is_set or
            (self.diff_serv_traffic_engineering is not None and self.diff_serv_traffic_engineering.has_data()) or
            (self.global_attributes is not None and self.global_attributes.has_data()) or
            (self.gmpls_nni is not None and self.gmpls_nni.has_data()) or
            (self.gmpls_uni is not None and self.gmpls_uni.has_data()) or
            (self.interfaces is not None and self.interfaces.has_data()) or
            (self.lcac is not None and self.lcac.has_data()) or
            (self.named_tunnels is not None and self.named_tunnels.has_data()) or
            (self.transport_profile is not None and self.transport_profile.has_data()))

    def has_operation(self):
        return (
            self.yfilter != YFilter.not_set or
            self.enable_traffic_engineering.yfilter != YFilter.not_set or
            (self.diff_serv_traffic_engineering is not None and self.diff_serv_traffic_engineering.has_operation()) or
            (self.global_attributes is not None and self.global_attributes.has_operation()) or
            (self.gmpls_nni is not None and self.gmpls_nni.has_operation()) or
            (self.gmpls_uni is not None and self.gmpls_uni.has_operation()) or
            (self.interfaces is not None and self.interfaces.has_operation()) or
            (self.lcac is not None and self.lcac.has_operation()) or
            (self.named_tunnels is not None and self.named_tunnels.has_operation()) or
            (self.transport_profile is not None and self.transport_profile.has_operation()))

    def get_segment_path(self):
        path_buffer = ""
        path_buffer = "Cisco-IOS-XR-mpls-te-cfg:mpls-te" + path_buffer

        return path_buffer

    def get_entity_path(self, ancestor):
        path_buffer = ""
        if (not ancestor is None):
            raise YPYModelError("ancestor has to be None for top-level node")

        path_buffer = self.get_segment_path()
        leaf_name_data = LeafDataList()
        if (self.enable_traffic_engineering.is_set or self.enable_traffic_engineering.yfilter != YFilter.not_set):
            leaf_name_data.append(self.enable_traffic_engineering.get_name_leafdata())

        entity_path = EntityPath(path_buffer, leaf_name_data)
        return entity_path

    def get_child_by_name(self, child_yang_name, segment_path):
        child = self._get_child_by_seg_name([child_yang_name, segment_path])
        if child is not None:
            return child

        if (child_yang_name == "diff-serv-traffic-engineering"):
            if (self.diff_serv_traffic_engineering is None):
                self.diff_serv_traffic_engineering = MplsTe.DiffServTrafficEngineering()
                self.diff_serv_traffic_engineering.parent = self
                self._children_name_map["diff_serv_traffic_engineering"] = "diff-serv-traffic-engineering"
            return self.diff_serv_traffic_engineering

        if (child_yang_name == "global-attributes"):
            if (self.global_attributes is None):
                self.global_attributes = MplsTe.GlobalAttributes()
                self.global_attributes.parent = self
                self._children_name_map["global_attributes"] = "global-attributes"
            return self.global_attributes

        if (child_yang_name == "gmpls-nni"):
            if (self.gmpls_nni is None):
                self.gmpls_nni = MplsTe.GmplsNni()
                self.gmpls_nni.parent = self
                self._children_name_map["gmpls_nni"] = "gmpls-nni"
            return self.gmpls_nni

        if (child_yang_name == "gmpls-uni"):
            if (self.gmpls_uni is None):
                self.gmpls_uni = MplsTe.GmplsUni()
                self.gmpls_uni.parent = self
                self._children_name_map["gmpls_uni"] = "gmpls-uni"
            return self.gmpls_uni

        if (child_yang_name == "interfaces"):
            if (self.interfaces is None):
                self.interfaces = MplsTe.Interfaces()
                self.interfaces.parent = self
                self._children_name_map["interfaces"] = "interfaces"
            return self.interfaces

        if (child_yang_name == "lcac"):
            if (self.lcac is None):
                self.lcac = MplsTe.Lcac()
                self.lcac.parent = self
                self._children_name_map["lcac"] = "lcac"
            return self.lcac

        if (child_yang_name == "named-tunnels"):
            if (self.named_tunnels is None):
                self.named_tunnels = MplsTe.NamedTunnels()
                self.named_tunnels.parent = self
                self._children_name_map["named_tunnels"] = "named-tunnels"
            return self.named_tunnels

        if (child_yang_name == "transport-profile"):
            if (self.transport_profile is None):
                self.transport_profile = MplsTe.TransportProfile()
                self.transport_profile.parent = self
                self._children_name_map["transport_profile"] = "transport-profile"
            return self.transport_profile

        return None

    def has_leaf_or_child_of_name(self, name):
        if(name == "diff-serv-traffic-engineering" or name == "global-attributes" or name == "gmpls-nni" or name == "gmpls-uni" or name == "interfaces" or name == "lcac" or name == "named-tunnels" or name == "transport-profile" or name == "enable-traffic-engineering"):
            return True
        return False

    def set_value(self, value_path, value, name_space, name_space_prefix):
        if(value_path == "enable-traffic-engineering"):
            self.enable_traffic_engineering = value
            self.enable_traffic_engineering.value_namespace = name_space
            self.enable_traffic_engineering.value_namespace_prefix = name_space_prefix

    def clone_ptr(self):
        self._top_entity = MplsTe()
        return self._top_entity

